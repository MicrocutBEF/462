

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_ReadAxisState
VAR_INPUT
	bExecute			:BOOL;
	iFunctionNr			:INT;
	nSlaveAddr			:INT;
	nSubIndex			:BYTE;
END_VAR
VAR_IN_OUT
	T_AxisRefIn:NCTOPLC_AXLESTRUCT;
END_VAR
VAR_OUTPUT
	Done				:BOOL;		(* successfully done *)
	dwValueOut: DWORD;
END_VAR
VAR
	fbCoEReadParameter 		: FB_EcCoESdoRead;
	abyReceive				: ARRAY[0..10] OF BYTE;
	state					:INT;
	Trigger					:R_TRIG;
	fbGetAmsNetID			 : FB_GetAxisAmsAddr;
	sEtherCATNetId 			: STRING;	(*Master Ethercat AMS Adress *)
END_VAR
(* @END_DECLARATION := '0' *)
Trigger( CLK:=bExecute );
IF Trigger.Q THEN
	CASE iFunctionNr OF
		(* Lesen der NetID und abfragen des Status füs Achse Safety Funktionen *)
		1:	state:=1;
	END_CASE;
	Done := FALSE;
END_IF;
CASE state OF
(*		get AMS Net ID of the Drive-Unit*)
(*************************************************************************************************************************)
	1:	fbGetAmsNetID(	sNetId:= '',
						iAxisId:= DWORD_TO_UINT(T_AxisRefIn.nAxisId),
						bExecute := TRUE);
		IF NOT fbGetAmsNetID.bBusy AND NOT fbGetAmsNetID.bError THEN
			fbGetAmsNetID.AxisNetId;
			sEtherCATNetId 	:= fbGetAmsNetID.AxisNetId;
			fbGetAmsNetID(	sNetId:= '',
							iAxisId:= DWORD_TO_UINT(T_AxisRefIn.nAxisId),
							bExecute := FALSE);
			state := 10;
		END_IF
(*************************************************************************************************************************)
	10:	fbCoEReadParameter.nIndex		:= 16#FA10;
		fbCoEReadParameter.nSubIndex	:=nSubIndex;
		fbCoEReadParameter.cbBufLen		:=2;
		fbCoEReadParameter.bExecute 	:= TRUE;
		state := 11;
	11: 	IF NOT fbCoEReadParameter.bBusy THEN
			fbCoEReadParameter.bExecute 	:= FALSE;
			state := 0;
			Done := TRUE;
			dwValueOut:=abyReceive[0] + (abyReceive[1] * 256);
		END_IF;
(*************************************************************************************************************************)
 END_CASE
fbCoEReadParameter(		sNetId		:= sEtherCATNetId,
						nSlaveAddr	:= nSlaveAddr,
						tTimeout		:= T#500ms,
						pDstBuf		:=ADR(abyReceive));
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_WriteObject
VAR_INPUT
	bExecute			:BOOL;
	iFunctionNr			:INT;
	nSlaveAddr			:INT;
	T_RegulatorSpindle:ST_EXCHG_PARAM_CONTRMOT;
END_VAR
VAR_IN_OUT
	T_AxisRefIn:NCTOPLC_AXLESTRUCT;
END_VAR
VAR_OUTPUT
	Done				:BOOL;		(* successfully done *)
	dwValueOut: DWORD;
END_VAR
VAR
	fbCoEWriteParameter 		: FB_EcCoESdoWrite;
	abyReceive				: ARRAY[0..10] OF BYTE;
	state					:INT;
	Trigger					:R_TRIG;
	fbGetAmsNetID			 : FB_GetAxisAmsAddr;
	sEtherCATNetId 			: STRING;	(*Master Ethercat AMS Adress *)
	ii: INT;
END_VAR
(* @END_DECLARATION := '0' *)
Trigger( CLK:=bExecute );
IF Trigger.Q THEN
	CASE iFunctionNr OF
		(* Lesen der NetID und abfragen des Status füs Achse Safety Funktionen *)
		1:	state:=1;
	END_CASE;
	Done := FALSE;
END_IF;
CASE state OF
(*		get AMS Net ID of the Drive-Unit*)
(*************************************************************************************************************************)
	1:	fbGetAmsNetID(	sNetId:= '',
						iAxisId:= DWORD_TO_UINT(T_AxisRefIn.nAxisId),
						bExecute := TRUE);
		IF NOT fbGetAmsNetID.bBusy AND NOT fbGetAmsNetID.bError THEN
			fbGetAmsNetID.AxisNetId;
			sEtherCATNetId 	:= fbGetAmsNetID.AxisNetId;
			fbGetAmsNetID(	sNetId:= '',
							iAxisId:= DWORD_TO_UINT(T_AxisRefIn.nAxisId),
							bExecute := FALSE);
			FOR ii:=0 TO 10 DO
				abyReceive[ii]:=0;
			END_FOR;
			state := 10;
		END_IF
(*************************************************************************************************************************)
	10:	fbCoEWriteParameter(bExecute 	:= FALSE);
		fbCoEWriteParameter.nIndex		:= 16#60F6;	(* Current Control Parameter Set *)
		fbCoEWriteParameter.nSubIndex	:=1;
		dwValueOut:=abyReceive[0]:=INT_TO_BYTE(T_RegulatorSpindle.iCurrentReg_PGain);
		dwValueOut:=abyReceive[1]:=INT_TO_BYTE(T_RegulatorSpindle.iCurrentReg_PGain / 256);
		fbCoEWriteParameter.pSrcBuf		:=ADR(abyReceive);
		fbCoEWriteParameter.cbBufLen		:=SIZEOF(abyReceive);
		fbCoEWriteParameter.bExecute 	:= TRUE;
		state := 11;
	11: 	IF NOT fbCoEWriteParameter.bBusy THEN
			fbCoEWriteParameter(bExecute 	:= FALSE);
			fbCoEWriteParameter.nIndex		:= 16#60F6;	(* Current Control Parameter Set *)
			fbCoEWriteParameter.nSubIndex	:=2;
			dwValueOut:=abyReceive[0]:=INT_TO_BYTE(T_RegulatorSpindle.iCurrentReg_IGain);
			dwValueOut:=abyReceive[1]:=INT_TO_BYTE(T_RegulatorSpindle.iCurrentReg_IGain / 256);
			fbCoEWriteParameter.pSrcBuf		:=ADR(abyReceive);
			fbCoEWriteParameter.cbBufLen		:=SIZEOF(abyReceive);
			fbCoEWriteParameter.bExecute 	:= TRUE;
			state := 12;
		END_IF;
	12: 	IF NOT fbCoEWriteParameter.bBusy THEN
			fbCoEWriteParameter(bExecute 	:= FALSE);
			fbCoEWriteParameter.nIndex		:= 16#60F9;	(* Velocity Control Parameter Set *)
			fbCoEWriteParameter.nSubIndex	:=1;
			dwValueOut:=abyReceive[0]:=INT_TO_BYTE(T_RegulatorSpindle.iSpeedReg_PGain);
			dwValueOut:=abyReceive[1]:=INT_TO_BYTE(T_RegulatorSpindle.iSpeedReg_PGain / 256);
			fbCoEWriteParameter.pSrcBuf		:=ADR(abyReceive);
			fbCoEWriteParameter.cbBufLen		:=SIZEOF(abyReceive);
			fbCoEWriteParameter.bExecute 	:= TRUE;
			state := 13;
		END_IF;
	13: 	IF NOT fbCoEWriteParameter.bBusy THEN
			fbCoEWriteParameter(bExecute 	:= FALSE);
			fbCoEWriteParameter.nIndex		:= 16#60F9;	(* Velocity Control Parameter Set *)
			fbCoEWriteParameter.nSubIndex	:=2;
			dwValueOut:=abyReceive[0]:=INT_TO_BYTE(T_RegulatorSpindle.iSpeedReg_IGain);
			dwValueOut:=abyReceive[1]:=INT_TO_BYTE(T_RegulatorSpindle.iSpeedReg_IGain / 256);
			fbCoEWriteParameter.pSrcBuf		:=ADR(abyReceive);
			fbCoEWriteParameter.cbBufLen		:=SIZEOF(abyReceive);
			fbCoEWriteParameter.bExecute 	:= TRUE;
			state := 14;
		END_IF;
	14: 	IF NOT fbCoEWriteParameter.bBusy THEN
			fbCoEWriteParameter(bExecute 	:= FALSE);
			fbCoEWriteParameter.nIndex		:= 16#60FB;	(* Position Control Parameter Set *)
			fbCoEWriteParameter.nSubIndex	:=1;
			dwValueOut:=abyReceive[0]:=INT_TO_BYTE(T_RegulatorSpindle.iPositionReg_PGain);
			dwValueOut:=abyReceive[1]:=INT_TO_BYTE(T_RegulatorSpindle.iPositionReg_PGain / 256);
			fbCoEWriteParameter.pSrcBuf		:=ADR(abyReceive);
			fbCoEWriteParameter.cbBufLen		:=SIZEOF(abyReceive);
			fbCoEWriteParameter.bExecute 	:= TRUE;
			state := 15;
		END_IF;
	15: 	IF NOT fbCoEWriteParameter.bBusy THEN
			fbCoEWriteParameter(bExecute 	:= FALSE);
			fbCoEWriteParameter.nIndex		:= 16#60FB;	(* Position Control Parameter Set *)
			fbCoEWriteParameter.nSubIndex	:=2;
			dwValueOut:=abyReceive[0]:=INT_TO_BYTE(T_RegulatorSpindle.iPositionReg_IGain);
			dwValueOut:=abyReceive[1]:=INT_TO_BYTE(T_RegulatorSpindle.iPositionReg_IGain / 256);
			fbCoEWriteParameter.pSrcBuf		:=ADR(abyReceive);
			fbCoEWriteParameter.cbBufLen		:=SIZEOF(abyReceive);
			fbCoEWriteParameter.bExecute 	:= TRUE;
			state := 16;
		END_IF;
	16: 	IF NOT fbCoEWriteParameter.bBusy THEN
			fbCoEWriteParameter(bExecute 	:= FALSE);
			fbCoEWriteParameter.nIndex		:= 16#60FB;	(* Position Control Parameter Set *)
			fbCoEWriteParameter.nSubIndex	:=3;
			dwValueOut:=abyReceive[0]:=INT_TO_BYTE(T_RegulatorSpindle.iPositionReg_DGain);
			dwValueOut:=abyReceive[1]:=INT_TO_BYTE(T_RegulatorSpindle.iPositionReg_DGain / 256);
			fbCoEWriteParameter.pSrcBuf		:=ADR(abyReceive);
			fbCoEWriteParameter.cbBufLen		:=SIZEOF(abyReceive);
			fbCoEWriteParameter.bExecute 	:= TRUE;
			state := 17;
		END_IF;
	17: 	IF NOT fbCoEWriteParameter.bBusy THEN
			fbCoEWriteParameter(bExecute 	:= FALSE);
			fbCoEWriteParameter.nIndex		:= 16#2F10;	(* Store Parameter *)
			fbCoEWriteParameter.nSubIndex	:=1;
			dwValueOut:=abyReceive[0]:=16#73;	(* s *)
			dwValueOut:=abyReceive[1]:=16#61;	(* a *)
			dwValueOut:=abyReceive[2]:=16#76;	(* v *)
			dwValueOut:=abyReceive[3]:=16#65;	(* e *)
			fbCoEWriteParameter.pSrcBuf		:=ADR(abyReceive);
			fbCoEWriteParameter.cbBufLen		:=4;
			fbCoEWriteParameter.bExecute 	:= TRUE;
			state := 18;
		END_IF;
	18: 	IF NOT fbCoEWriteParameter.bBusy THEN
			fbCoEWriteParameter(bExecute 	:= FALSE);
			state := 0;
			Done := TRUE;
		END_IF;
(*************************************************************************************************************************)
 END_CASE
fbCoEWriteParameter(		sNetId		:= sEtherCATNetId,
						nSlaveAddr	:= nSlaveAddr,
						tTimeout		:= T#500ms);
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_AXIS_DC
VAR_INPUT
END_VAR
VAR_IN_OUT
	T_Axis_DC : ST_DC_AXIS;
	usiStatusWord : USINT;
	usiControlWord : USINT;
	iDataOut : INT;
	iDataIn : INT;
	T_HDD:ST_HDD;
END_VAR
VAR_OUTPUT
END_VAR
VAR
(* trigger *)
	RisingEdgeResetFB:R_TRIG;
	RisingEdgeExecute:R_TRIG;
	RisingEdgePowerOn:R_TRIG;
	RisingEdgePowerOff:R_TRIG;

(* variable *)
	xConfirmResetFB:BOOL:=FALSE;
	xResetAxis:BOOL:=FALSE;
	xReadFile:BOOL:=FALSE;
	xPowerOn:BOOL:=FALSE;
	xPowerOff:BOOL:=FALSE;
	xMoveVel:BOOL:=FALSE;
	xStop:BOOL:=FALSE;
	xSendAxisParameter:BOOL:=FALSE;
	xWriteRegister: BOOL:=FALSE;
	xReadRegister: BOOL:=FALSE;

	iStepPowerOnFB:INT:=0;
	iStepPowerOffFB:INT:=0;
	iStepReadFile:INT:=0;
	iStepResetFB:INT:=0;
	iStepStopFB:INT:=0;
	iStepMoveVelFB:INT:=0;
	iStepSendAxisParameterFB:INT:=0;
	iStepWriteRegister: INT;
	iStepReadRegister: INT;
	iTmpFctNr:INT:=0;

	diTimeCounter: DINT;
	diTmpTimeCounter:DINT;
	iIncVelocity:INT;

	TONAccelerator:TON;
	lrScaleFactor:LREAL:=346.64;
	lrInitFactor:LREAL:=1500.0;
	lrVelocity:LREAL;
	xTmpPowerOn: BOOL;
	xTmpPowerOff: BOOL;
	xTmpError: BOOL;
	iTmpDataOut: INT;
	xInitAxis: BOOL;
(* timer *)
	TimerOutSendPara:TON;
	TimerFileLocked:TON;
	TimerTimeOutFunction:TON;

	sDeleteData: ARRAY[1..csiMaxAxisFileObj] OF STRING(80);
	sTmp:STRING(255);
	i:INT:=0;
	fb_ConvertParaAxis:FBConvertParaAxis;
	T_AxisDummy:ST_AXIS;

	iPtrAxisParameter:INT:=1;
	wDataToSend:WORD:=0;
	xInitAxisActiv: BOOL;
	lrActualVelocity:LREAL:=0.0;
	TONWaitStop: TON;
	xTmp: BOOL;
	RisingEdgeCheckStartFct: R_TRIG;
	xDeleteCtrl: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* reset block function *)
	RisingEdgeResetFB(CLK:=T_Axis_DC.T_CtrleDCAxis.xReset);
	IF RisingEdgeResetFB.Q THEN
	(* Init. block function *)
	(* Init. variable *)
		xResetAxis:=FALSE;
		TONAccelerator(IN:=FALSE);
		TimerTimeOutFunction(IN:=FALSE);
		TimerFileLocked(IN:=FALSE);
		TimerOutSendPara(IN:=FALSE);
		xTmpError:=FALSE;
		lrActualVelocity:=0.0;
		usiControlWord:=0;
		iDataOut:=0;
		xTmpError:=FALSE;
		xResetAxis:=xReadFile:=xTmpPowerOn:=xTmpPowerOff:=xStop:=xMoveVel:=xSendAxisParameter:=xWriteRegister:=xReadRegister:=FALSE;
	(* int. structure *)
		T_Axis_DC.T_CtrleDCAxis.iFunction:=0;
		T_Axis_DC.T_CtrleDCAxis.xDone:=FALSE;
		T_Axis_DC.T_CtrleDCAxis.xErr:=FALSE;
		T_Axis_DC.T_CtrleDCAxis.udiErrorID:=0;
		T_Axis_DC.T_CtrleDCAxis.xPower:=FALSE;
		T_Axis_DC.T_CtrleDCAxis.xReady:=FALSE;
		T_Axis_DC.T_CtrleDCAxis.xNotMoving:=TRUE;
		(* set flag done *)
		xConfirmResetFB:=TRUE;
		(* disable status flag *)
		T_Axis_DC.T_CtrleDCAxis.xDone:=FALSE;
		T_Axis_DC.T_CtrleDCAxis.xErr:=FALSE;
		T_Axis_DC.T_CtrleDCAxis.udiErrorID:=0;
		(* exit function bloc *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_Axis_DC.T_CtrleDCAxis.xDone:=TRUE;
			T_Axis_DC.T_CtrleDCAxis.xErr:=FALSE;
			T_Axis_DC.T_CtrleDCAxis.udiErrorID:=0;
			(* reset variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* return axis state *)

(* Check Timeout for Function *)
xTmp:= xStop OR xResetAxis OR xTmpPowerOn OR xTmpPowerOff OR xReadFile OR xMoveVel OR xSendAxisParameter OR xWriteRegister OR xReadRegister;
IF TimerTimeOutFunction.Q AND xTmp THEN
	xResetAxis:=xReadFile:=xTmpPowerOn:=xTmpPowerOff:=xStop:=xMoveVel:=xSendAxisParameter:=xWriteRegister:=xReadRegister:=FALSE;
	usiControlWord:=2#0;
	iDataOut:=2#0;
	T_Axis_DC.T_CtrleDCAxis.xDone:=FALSE;
	T_Axis_DC.T_CtrleDCAxis.xErr:= TRUE;
	T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#F200;	(* Function Time Out *)
	RETURN;
END_IF;

(* Timer *)
	TimerOutSendPara(IN:=TRUE, PT:=T#10S);
	TimerFileLocked(IN:=TRUE, PT:=T#10S);
	TimerTimeOutFunction(IN:=TRUE,PT:=T#10S);

(* detection start *)
	RisingEdgeExecute(CLK:=T_Axis_DC.T_CtrleDCAxis.xExecute);
	IF RisingEdgeExecute.Q THEN
		IF xStop AND (T_Axis_DC.T_CtrleDCAxis.iFunction <> 1) THEN
		(* can not execute a function when 'Stop' activ, except 'Reset' *)
			T_Axis_DC.T_CtrleDCAxis.xDone:=FALSE;
			T_Axis_DC.T_CtrleDCAxis.xErr:=TRUE;
			T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#F100;
			RETURN;
		END_IF
		CASE T_Axis_DC.T_CtrleDCAxis.iFunction OF
		(* Reset *)
		1:	T_Axis_DC.T_CtrleDCAxis.xReady:=TRUE;
			T_Axis_DC.T_CtrleDCAxis.xPower:=FALSE;
			xPowerOn:=FALSE;
			xPowerOff:=TRUE;
			xResetAxis:=TRUE;
			iTmpFctNr:=1;
			iStepResetFB:=1;
		(* Init *)
		2:	xReadFile:=TRUE;
			iStepReadFile:=1;
			iTmpFctNr:=2;
			xInitAxisActiv:=TRUE;
		(* Power ON *)
		3:	IF NOT(xPowerOn) THEN
				xPowerOn:=TRUE;
				xPowerOff:=NOT(xPowerOn);
				xTmpPowerOn:=TRUE;
				iTmpFctNr:=3;
				iStepPowerOnFB:=1;
			ELSE
				T_Axis_DC.T_CtrleDCAxis.xDone:=TRUE;
				T_Axis_DC.T_CtrleDCAxis.xErr:= FALSE;
				T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#0;
				iTmpFctNr:=3;
				iStepPowerOnFB:=1;
				RETURN;
			END_IF;
		(* Power Off *)
		4:	IF xPowerOn THEN
				xPowerOff:=TRUE;
				xPowerOn:=NOT(xPowerOff);
				xTmpPowerOff:=TRUE;
				iTmpFctNr:=4;
				iStepPowerOffFB:=1;
			ELSE
				T_Axis_DC.T_CtrleDCAxis.xDone:=TRUE;
				T_Axis_DC.T_CtrleDCAxis.xErr:= FALSE;
				T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#0;
				iTmpFctNr:=4;
				iStepPowerOffFB:=1;
				RETURN;
			END_IF;
		(* Stop *)
		5: 	xStop:=TRUE;
			iTmpFctNr:=5;
			iStepStopFB:=1;
		(* Velocity *)
		6:	xMoveVel:=TRUE;
			iTmpFctNr:=6;
			iStepMoveVelFB:=1;
		(* Send Parameter *)
		21: 	xSendAxisParameter:=TRUE;
			iStepSendAxisParameterFB:=1;
			iPtrAxisParameter:=1;
			iTmpFctNr:=21;
		(* Write Register *)
		24:	xWriteRegister:=TRUE;
			iTmpFctNr:=24;
			iStepWriteRegister:=1;
		(* Read Register *)
		25:	xReadRegister:=TRUE;
			iTmpFctNr:=25;
			iStepReadRegister:=1;
		ELSE
		(* function not implemented *)
			T_Axis_DC.T_CtrleDCAxis.xDone:=FALSE;
			T_Axis_DC.T_CtrleDCAxis.xErr:=TRUE;
			T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#F000;
			(* Exit FB *)
			RETURN;
		END_CASE
		(* Init. variable *)
		T_Axis_DC.T_CtrleDCAxis.xDone:=FALSE;
		T_Axis_DC.T_CtrleDCAxis.xErr:=FALSE;
		T_Axis_DC.T_CtrleDCAxis.udiErrorID:=0;
		(* Exit FB *)
		(*RETURN;*)
	END_IF

(* detect error *)
	xTmp:= xStop OR xResetAxis OR xTmpPowerOn OR xTmpPowerOff OR xReadFile OR xMoveVel OR xSendAxisParameter OR xWriteRegister OR xReadRegister;
	IF NOT(xTmp) THEN
		T_Axis_DC.T_CtrleDCAxis.xErr:=GETBIT32(usiStatusWord,6);
	END_IF;
	xTmp:= xStop OR xTmpPowerOn OR xTmpPowerOff OR xReadFile OR xMoveVel OR xSendAxisParameter OR xWriteRegister OR xReadRegister;
	IF xDeleteCtrl THEN
		xDeleteCtrl:=FALSE;
		usiControlWord:=2#0;
		RETURN;
	END_IF;
	RisingEdgeCheckStartFct(CLK:=xTmp);
	IF RisingEdgeCheckStartFct.Q THEN
		IF GETBIT32(usiStatusWord,6) THEN
			usiControlWord:=2#01000000;
			xDeleteCtrl:=TRUE;
			RETURN;
		END_IF;
	END_IF;

(* Reset function *)
	IF xResetAxis THEN
		xReadFile:=xTmpPowerOn:=xTmpPowerOff:=xStop:=xMoveVel:=xSendAxisParameter:=xWriteRegister:=xReadRegister:=FALSE;
		CASE iStepResetFB OF
		1:	TimerTimeOutFunction(IN:=FALSE);
			usiControlWord:=2#0;
			iDataOut:=2#0;
			lrActualVelocity:=0.0;
			iStepResetFB:=10;
		10:	IF (usiStatusWord = 16#0) THEN
				usiControlWord:=2#01000000;
				iStepResetFB:=20;
			ELSE
				usiControlWord:=2#01000000;
				iStepResetFB:=20;
			END_IF;
		20:	IF (usiStatusWord = 16#0) THEN
				usiControlWord:=2#0;
				iStepResetFB:=900;
			END_IF;
		900:	(* confirm reset *)
			IF NOT(xWriteRegister) THEN
				T_Axis_DC.T_CtrleDCAxis.xDone:=TRUE;
				T_Axis_DC.T_CtrleDCAxis.xErr:= FALSE;
				T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#0;
			END_IF;
			T_Axis_DC.T_CtrleDCAxis.xNotMoving:=TRUE;
			(* init. variable *)
			xResetAxis:=FALSE;
		END_CASE;
	END_IF;

(* Initialisation function *)
	IF xReadFile THEN
		CASE iStepReadFile OF
		(* start timeout *)
		1:	TimerTimeOutFunction(IN:=FALSE);
			TimerFileLocked(IN:=FALSE);
			T_Axis_DC.T_FileObj.sData:=sDeleteData;
			(* next step *)
			iStepReadFile:=10;
		(* start read *)
		10:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xLocked) THEN
			(* activ read axis nc parameter *)
				T_HDD.T_Ctrle.xExecute:=TRUE;
				T_HDD.T_Ctrle.xLocked :=TRUE;
				T_HDD.T_Ctrle.iFunction:=1;
				sTmp:=CONCAT(cssRootPLC,'Bore800\Axis\File\');
				sTmp:=CONCAT(sTmp, T_Axis_DC.T_Config_Gen.sDeviceFileName);
				T_HDD.T_File.sPathAndFileName:=CONCAT(sTmp,'.txt');
				(* next step *)
				iStepReadFile:=20;
			ELSE
			(* activ error if time out done, HDD not ready *)
				IF TimerFileLocked.Q THEN
					 iStepReadFile:=997;
				END_IF;
			END_IF;
		(* wait done or error *)
		20:	IF T_HDD.T_Ctrle.xDone OR T_HDD.T_Ctrle.xErr THEN
				IF T_HDD.T_Ctrle.xErr  THEN
				(* active step error *)
					iStepReadFile:=998;
					T_HDD.T_Ctrle.xLocked:=FALSE;
				ELSE
				(* next step, init convert value *)
					iStepReadFile:=30;
					(* copy data from file *)
					i:=1;
					WHILE T_HDD.T_Data.sData[i] <> '' AND i <=csiMaxAxisFileObj AND i <= csiMaxFileLine DO
						T_Axis_DC.T_FileObj.sData[i]:=T_HDD.T_Data.sData[i];
						i:=i+1;
					END_WHILE;
					(* erase last line +1 *)
					IF i < csiMaxAxisFileObj THEN T_Axis_DC.T_FileObj.sData[i+1]:=''; END_IF
				END_IF;
			END_IF;
		(* init. convert *)
		30:	fb_ConvertParaAxis(	xStart:=FALSE,
								iConversion:=1,
								T_Axis:=T_AxisDummy,
								T_Axis_DC:=T_Axis_DC);
			(* next step, convert value *)
			iStepReadFile:=40;
		(* convert value *)
		40:	fb_ConvertParaAxis(	xStart:=TRUE,
								iConversion:=1,
								sDeviceName:='MaxonDC',
								T_Axis:=T_AxisDummy,
								T_Axis_DC:=T_Axis_DC);
			IF fb_ConvertParaAxis.xDone OR fb_ConvertParaAxis.xError THEN
				IF fb_ConvertParaAxis.xError THEN
					fb_ConvertParaAxis(	xStart:=FALSE,
										iConversion:=1,
										T_Axis:=T_AxisDummy,
										T_Axis_DC:=T_Axis_DC);
					(* active step error *)
					iStepReadFile:=999;
				ELSE
					(* activ state read successfull *)
					iStepReadFile:=900;
				END_IF;
				T_HDD.T_Ctrle.xLocked:=FALSE;
			END_IF;
		(* confirm reset *)
		900:	T_Axis_DC.T_CtrleDCAxis.xDone:=TRUE;
			T_Axis_DC.T_CtrleDCAxis.xErr:= FALSE;
			T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#0;
			(* init. variable *)
			xReadFile:=FALSE;
		997:	(* Error stage *)
			T_HDD.T_Ctrle.xReset:=TRUE;
			T_Axis_DC.T_CtrleDCAxis.xDone:=FALSE;
			T_Axis_DC.T_CtrleDCAxis.xErr:= TRUE;
			T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#F300;	(* Reading Harddisk timeout *)
			xReadFile:=FALSE;
		998:	(* Error stage *)
			T_HDD.T_Ctrle.xReset:=TRUE;
			T_Axis_DC.T_CtrleDCAxis.xDone:=FALSE;
			T_Axis_DC.T_CtrleDCAxis.xErr:= TRUE;
			T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#F400;	(* File does not exist *)
			xReadFile:=FALSE;
		999:	(* Error stage *)
			T_HDD.T_Ctrle.xReset:=TRUE;
			T_Axis_DC.T_CtrleDCAxis.xDone:=FALSE;
			T_Axis_DC.T_CtrleDCAxis.xErr:= TRUE;
			T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#F500;	(* File conversion error *)
			xReadFile:=FALSE;
		END_CASE;
	END_IF;

(* Power function *)
	RisingEdgePowerOn(CLK:=xTmpPowerOn);
	RisingEdgePowerOff(CLK:=xTmpPowerOff);
	IF xTmpPowerOn THEN
		CASE iStepPowerOnFB OF
			1:	TimerTimeOutFunction(IN:=FALSE);
				xMoveVel:=FALSE;
				usiControlWord:=2#0;
				iDataOut:=0;
				lrActualVelocity:=0.0;
				iStepPowerOnFB:=10;
				T_Axis_DC.T_CtrleDCAxis.xPower:=TRUE;
			10:	usiControlWord:=2#00100000;
				iStepPowerOnFB:=20;
			20:	IF ((USINT_TO_WORD(usiStatusWord) AND 2#00010000) = 2#00010000) THEN
					iStepPowerOnFB:=900;
				END_IF;
			900:	(* confirm reset *)
			T_Axis_DC.T_CtrleDCAxis.xNotMoving:=TRUE;
			T_Axis_DC.T_CtrleDCAxis.xDone:=TRUE;
			T_Axis_DC.T_CtrleDCAxis.xErr:= FALSE;
			T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#0;
			xTmpPowerOn:=FALSE;
		END_CASE;
	END_IF;
	IF xTmpPowerOff THEN
		CASE iStepPowerOffFB OF
			1:	TimerTimeOutFunction(IN:=FALSE);
				xMoveVel:=FALSE;
				lrActualVelocity:=0.0;
				usiControlWord:=2#0;
				iDataOut:=0;
				iStepPowerOffFB:=10;
				T_Axis_DC.T_CtrleDCAxis.xPower:=FALSE;
			10:	IF (usiStatusWord = 2#0) THEN
					iStepPowerOffFB:=900;
				END_IF;
			900:	(* confirm reset *)
			T_Axis_DC.T_CtrleDCAxis.xNotMoving:=TRUE;
			T_Axis_DC.T_CtrleDCAxis.xDone:=TRUE;
			T_Axis_DC.T_CtrleDCAxis.xErr:= FALSE;
			T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#0;
			xTmpPowerOff:=FALSE;
		END_CASE;
	END_IF;


(* Stop *)
	IF xStop THEN
		CASE iStepStopFB OF
		1:	TimerTimeOutFunction(IN:=FALSE);
			TONWaitStop(IN:=FALSE);
			IF (T_Axis_DC.T_CtrleDCAxis.tDecceleration = T#0s) OR (lrActualVelocity = 0.0) THEN
				usiControlWord:=2#00100000;
				iDataOut:=0;
				iStepStopFB:=35;
			ELSE
				iStepStopFB:=20;
			END_IF;
			lrActualVelocity:=0.0;
			xMoveVel:=FALSE;
			IF (T_Axis_DC.T_CtrleDCAxis.lrVelocity >= 0) THEN lrInitFactor:=1500; END_IF;
			IF (T_Axis_DC.T_CtrleDCAxis.lrVelocity < 0) THEN lrInitFactor:=-1500; END_IF;
			lrVelocity:=(T_Axis_DC.T_CtrleDCAxis.lrVelocity * lrScaleFactor) + lrInitFactor;
			IF (lrVelocity > 32767) THEN lrVelocity:=32767; END_IF;
			IF (lrVelocity < -32768) THEN lrVelocity:=-32768; END_IF;
		20:	diTimeCounter:=REAL_TO_DINT(TIME_TO_REAL(T_Axis_DC.T_CtrleDCAxis.tDecceleration) / TIME_TO_REAL(T#10ms));
			diTmpTimeCounter:=0;
			iIncVelocity:=DINT_TO_INT(LREAL_TO_DINT(lrVelocity)/diTimeCounter);
			IF (iIncVelocity = 0) THEN
				IF (lrVelocity >= 0.0) THEN
					iIncVelocity:=-1;
				END_IF;
				IF (lrVelocity < 0.0) THEN
					iIncVelocity:=1;
				END_IF;
			ELSE
				iIncVelocity:=iIncVelocity * -1;
			END_IF;
			iStepStopFB:=30;
		30:	iDataOut:=iDataOut + iIncVelocity;
			diTmpTimeCounter:=diTmpTimeCounter + 1;
			IF (diTmpTimeCounter >= diTimeCounter) THEN
				iDataOut:=0;
				iStepStopFB:=40;
			END_IF;
			RETURN;
		35:	TONWaitStop(IN:=TRUE,PT:=T#200ms);
			IF TONWaitStop.Q THEN
				iStepStopFB:=40;
			END_IF;
		40:	usiControlWord:=2#0;
			iDataOut:=0;
			iStepStopFB:=900;
		900:	(* confirm reset *)
			T_Axis_DC.T_CtrleDCAxis.xNotMoving:=TRUE;
			T_Axis_DC.T_CtrleDCAxis.xDone:=TRUE;
			T_Axis_DC.T_CtrleDCAxis.xErr:= FALSE;
			T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#0;
			(* init. variable *)
			xStop:=FALSE;
		END_CASE;
	END_IF;

(* Velocity *)
	IF xMoveVel  THEN
		CASE iStepMoveVelFB OF
		1:	TimerTimeOutFunction(IN:=FALSE);
			usiControlWord:=2#0;
			iDataOut:=2#0;
			lrScaleFactor:=T_Axis_DC.T_Config_Gen.lrScaleFactor;
			lrInitFactor:=T_Axis_DC.T_Config_Gen.lrInitFactor;
			IF (T_Axis_DC.T_CtrleDCAxis.lrVelocity >= 0) THEN lrInitFactor:=lrInitFactor; END_IF;
			IF (T_Axis_DC.T_CtrleDCAxis.lrVelocity < 0) THEN lrInitFactor:=-lrInitFactor*-1; END_IF;
			lrVelocity:=(T_Axis_DC.T_CtrleDCAxis.lrVelocity * lrScaleFactor) + lrInitFactor;
			IF (lrVelocity > 32767) THEN lrVelocity:=32767; END_IF;
			IF (lrVelocity < -32768) THEN lrVelocity:=-32768; END_IF;
			lrActualVelocity:=lrVelocity;
			iStepMoveVelFB:=10;
		10:	IF (T_Axis_DC.T_CtrleDCAxis.tAcceleration = T#0s) THEN
				usiControlWord:=2#00100000;
				iDataOut:=LREAL_TO_INT(lrVelocity);
				iStepMoveVelFB:=900;
			ELSE
				usiControlWord:=2#00100000;
				iDataOut:=0;
				iStepMoveVelFB:=20;
			END_IF;
		20:	diTimeCounter:=REAL_TO_DINT(TIME_TO_REAL(T_Axis_DC.T_CtrleDCAxis.tAcceleration) / TIME_TO_REAL(T#10ms));
			diTmpTimeCounter:=0;
			iIncVelocity:=DINT_TO_INT(LREAL_TO_DINT(lrVelocity)/diTimeCounter);
			IF (iIncVelocity = 0) THEN
				IF (lrVelocity >= 0.0) THEN
					iIncVelocity:=1;
				END_IF;
				IF (lrVelocity < 0.0) THEN
					iIncVelocity:=-1;
				END_IF;
			END_IF;
			iStepMoveVelFB:=30;
		30:	iDataOut:=iDataOut + iIncVelocity;
			diTmpTimeCounter:=diTmpTimeCounter + 1;
			IF (diTmpTimeCounter >= diTimeCounter) THEN
				iDataOut:=LREAL_TO_INT(lrVelocity);
				iStepMoveVelFB:=900;
			END_IF;
			RETURN;
		900:	(* confirm reset *)
			xPowerOn:=TRUE;
			xPowerOff:=FALSE;
			T_Axis_DC.T_CtrleDCAxis.xPower:=TRUE;
			T_Axis_DC.T_CtrleDCAxis.xNotMoving:=FALSE;
			T_Axis_DC.T_CtrleDCAxis.xDone:=TRUE;
			T_Axis_DC.T_CtrleDCAxis.xErr:= FALSE;
			T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#0;
			(* init. variable *)
			xMoveVel:=FALSE;
		END_CASE;
	END_IF;

(* Send Parameter *)
	IF xSendAxisParameter THEN
		CASE iStepSendAxisParameterFB OF
		1:	TimerTimeOutFunction(IN:=FALSE);
			IF NOT(xWriteRegister) THEN
				IF (T_Axis_DC.T_ParamFileObj[iPtrAxisParameter].iBitValue = 16) THEN
					T_Axis_DC.T_CtrleDCAxis.iRegisterNr:=T_Axis_DC.T_ParamFileObj[iPtrAxisParameter].iRegisterNr;
					T_Axis_DC.T_CtrleDCAxis.iValueRegister:=LREAL_TO_INT(T_Axis_DC.T_ParamFileObj[iPtrAxisParameter].lrReal);
					xWriteRegister:=TRUE;
					iStepWriteRegister:=1;
					iPtrAxisParameter:=iPtrAxisParameter + 1;
				ELSE
					iStepSendAxisParameterFB:=10;
				END_IF;
			END_IF;
		10:	wDataToSend:=0;
			WHILE (T_Axis_DC.T_ParamFileObj[iPtrAxisParameter].iRegisterNr = 32) DO
				IF (T_Axis_DC.T_ParamFileObj[iPtrAxisParameter].lrReal <> 0) THEN
					wDataToSend:=wDataToSend OR REAL_TO_WORD(EXPT(2,T_Axis_DC.T_ParamFileObj[iPtrAxisParameter].iBitValue));
				END_IF;
				iPtrAxisParameter:=iPtrAxisParameter + 1;
			END_WHILE;
			iStepSendAxisParameterFB:=20;
		20:	T_Axis_DC.T_CtrleDCAxis.iRegisterNr:=32;
			T_Axis_DC.T_CtrleDCAxis.iValueRegister:=WORD_TO_INT(wDataToSend);
			xWriteRegister:=TRUE;
			iStepWriteRegister:=1;
			iStepSendAxisParameterFB:=30;
		30:	IF NOT(xWriteRegister) THEN
				iStepSendAxisParameterFB:=900;
			END_IF;
		900:	(* confirm reset *)
			T_Axis_DC.T_CtrleDCAxis.xDone:=TRUE;
			T_Axis_DC.T_CtrleDCAxis.xErr:= FALSE;
			T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#0;
			(* init. variable *)
			xSendAxisParameter:=FALSE;
		END_CASE;
	END_IF;

(* Write Register *)
	IF xWriteRegister THEN
		CASE iStepWriteRegister OF
		1:	TimerTimeOutFunction(IN:=FALSE);
			xTmpError:=FALSE;
			usiControlWord:=0;
			iDataOut:=16#0;
			iStepWriteRegister:=10;
		10:	IF (usiStatusWord = 16#0) OR (usiStatusWord = 16#20) THEN
			(* Leave Write protection for Register *)
				usiControlWord:=2#11111 + 2#11000000;
				iDataOut:=16#1235;
				iStepWriteRegister:=20;
			END_IF;
		20:	IF ((USINT_TO_BYTE(usiStatusWord) AND 2#10000000) = 2#10000000) THEN
				usiControlWord:=0;
				iDataOut:=16#0;
				iStepWriteRegister:=30;
			END_IF;
		30:	IF (usiStatusWord = 16#0) OR (usiStatusWord = 16#20) THEN
				(* send Data to write *)
				usiControlWord:=INT_TO_USINT(T_Axis_DC.T_CtrleDCAxis.iRegisterNr + 2#11000000);
				iDataOut:=T_Axis_DC.T_CtrleDCAxis.iValueRegister;
				iTmpDataOut:=iDataOut;
				iStepWriteRegister:=40;
			END_IF;
		(* wait for confirm *)
		40:	IF ((USINT_TO_BYTE(usiStatusWord) AND 2#10000000) = 2#10000000) THEN
				usiControlWord:=0;
				iDataOut:=16#0;
				iStepWriteRegister:=50;
			END_IF;
		50:	IF (usiStatusWord = 16#0) OR (usiStatusWord = 16#20) THEN
			(* check if data is writeted *)
				xReadRegister:=TRUE;
				iStepReadRegister:=1;
				iStepWriteRegister:=60;
			END_IF;
		60:	IF NOT(xReadRegister) THEN
				IF (T_Axis_DC.T_CtrleDCAxis.iValueRegister = iTmpDataOut) THEN
					iStepWriteRegister:=80;
				ELSE
					xTmpError:=TRUE;
					xResetAxis:=TRUE;
					iStepResetFB:=1;
					iStepWriteRegister:=70;
				END_IF;
			END_IF;
		70:	IF NOT(xResetAxis) THEN
				iStepWriteRegister:=80;
			END_IF;
		80:	usiControlWord:=0;
			iDataOut:=16#0;
			iStepWriteRegister:=90;
		90:	IF (usiStatusWord = 16#0) OR (usiStatusWord = 16#20) THEN
			(* Set Write protection for Register *)
				usiControlWord:=2#11111 + 2#11000000;
				iDataOut:=16#1111;
				iStepWriteRegister:=100;
			END_IF;
		100:	IF ((USINT_TO_BYTE(usiStatusWord) AND 2#10000000) = 2#10000000) THEN
				usiControlWord:=0;
				iDataOut:=16#0;
				iStepWriteRegister:=110;
			END_IF;
		110:	IF (usiStatusWord = 16#0) OR (usiStatusWord = 16#20) THEN
				IF NOT(xTmpError) THEN
					iStepWriteRegister:=900;
				ELSE
					iStepWriteRegister:=999;
				END_IF;
			END_IF;
		900:	(* confirm reset *)
			IF NOT(xInitAxis) AND NOT(xSendAxisParameter) THEN
				T_Axis_DC.T_CtrleDCAxis.xDone:=TRUE;
				T_Axis_DC.T_CtrleDCAxis.xErr:= FALSE;
				T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#0;
			END_IF;
			(* init. variable *)
			xWriteRegister:=FALSE;
		999:	(* Error stage *)
			T_Axis_DC.T_CtrleDCAxis.xDone:=FALSE;
			T_Axis_DC.T_CtrleDCAxis.xErr:= TRUE;
			T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#F600;	(* Can not set Data to Axiscontroller *)
			xWriteRegister:=FALSE;
			xInitAxis:=FALSE;
		END_CASE;
	END_IF;

(* Read Register *)
	IF xReadRegister THEN
		CASE iStepReadRegister OF
		1:	TimerTimeOutFunction(IN:=FALSE);
			xTmpError:=FALSE;
			usiControlWord:=0;
			iDataOut:=16#0;
			iStepReadRegister:=10;
		10:	IF (usiStatusWord = 16#0) OR (usiStatusWord = 16#20) THEN
			(* Leave Write protection for Register *)
				usiControlWord:=2#11111 + 2#11000000;
				iDataOut:=16#1235;
				iStepReadRegister:=20;
			END_IF;
		20:	IF ((USINT_TO_BYTE(usiStatusWord) AND 2#10000000) = 2#10000000) THEN
				usiControlWord:=0;
				iDataOut:=16#0;
				iStepReadRegister:=30;
			END_IF;
		30:	IF (usiStatusWord = 16#0) OR (usiStatusWord = 16#20) THEN
				usiControlWord:=INT_TO_USINT(T_Axis_DC.T_CtrleDCAxis.iRegisterNr + 2#10000000);
				iDataOut:=0;
				iStepReadRegister:=40;
			END_IF;
		40:	IF ((USINT_TO_WORD(usiStatusWord) AND 2#10000000) = 2#10000000) AND ((USINT_TO_WORD(usiStatusWord) AND 2#01000000) <> 2#01000000) THEN
				T_Axis_DC.T_CtrleDCAxis.iValueRegister:=iDataIn;
				iStepReadRegister:=50;
			END_IF;
			IF ((USINT_TO_WORD(usiStatusWord) AND 2#01000000) = 2#01000000) THEN
				T_Axis_DC.T_CtrleDCAxis.iValueRegister:=0;
				xTmpError:=TRUE;
				iStepReadRegister:=50;
			END_IF;
		50:	usiControlWord:=0;
			iDataOut:=16#0;
			iStepReadRegister:=60;
		60:	IF (usiStatusWord = 16#0) OR (usiStatusWord = 16#20) THEN
			(* Set Write protection for Register *)
				usiControlWord:=2#11111 + 2#11000000;
				iDataOut:=16#1111;
				iStepReadRegister:=70;
			END_IF;
		70:	IF ((USINT_TO_BYTE(usiStatusWord) AND 2#10000000) = 2#10000000) THEN
				usiControlWord:=0;
				iDataOut:=16#0;
				iStepReadRegister:=80;
			END_IF;
		80:	IF (usiStatusWord = 16#0) OR (usiStatusWord = 16#20) THEN
				IF NOT(xTmpError) THEN
					iStepReadRegister:=900;
				ELSE
					iStepReadRegister:=999;
				END_IF;
			END_IF;
		900:	(* confirm reset *)
			IF NOT(xWriteRegister) THEN
				T_Axis_DC.T_CtrleDCAxis.xDone:=TRUE;
				T_Axis_DC.T_CtrleDCAxis.xErr:= FALSE;
				T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#0;
			END_IF;
			(* init. variable *)
			xReadRegister:=FALSE;
		999:	(* Error stage *)
			T_Axis_DC.T_CtrleDCAxis.xDone:=FALSE;
			T_Axis_DC.T_CtrleDCAxis.xErr:= TRUE;
			T_Axis_DC.T_CtrleDCAxis.udiErrorID:=16#F700;	(* Can not read register from Axiscontroller *)
			(* init. variable *)
			xReadRegister:=FALSE;
			xWriteRegister:=FALSE;
		END_CASE;
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_AXIS_LIVEVALUES
VAR_INPUT
	uiActualTorque: UINT;
	IiActualTorque: INT;	(* Drehmoment von AX5xxx Servo *)
	arxDigitalInput: ARRAY[1..8] OF BOOL;
END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
	T_Axis:ST_AXIS;
	T_AxisRefIn:NCTOPLC_AXLESTRUCT;
END_VAR
VAR
	i:INT;
END_VAR
(* @END_DECLARATION := '0' *)
(* return actual axis state *)
T_Axis.T_LiveValue.dwState:=T_AxisRefIn.nStateDWord;
(* return actual torque value *)
IF NOT(T_Axis.T_CtrleSingle.xAX5000Active) THEN
	T_Axis.T_LiveValue.uiActualTorque:=uiActualTorque;
	IF T_Axis.T_LiveValue.uiActualTorque > 16#7FFF THEN
		(* negativ value *)
		T_Axis.T_LiveValue.diActualTorqueCalc:=UINT_TO_DINT(T_Axis.T_LiveValue.uiActualTorque) - 65535;
	ELSE
		(* positiv value *)
		T_Axis.T_LiveValue.diActualTorqueCalc:=UINT_TO_DINT(T_Axis.T_LiveValue.uiActualTorque);
	END_IF
ELSE
	T_Axis.T_LiveValue.diActualTorqueCalc:=IiActualTorque;
END_IF;
(* return actual velocity *)
IF (T_Axis.T_Config_Gen.iTyp <> 2) THEN
	T_Axis.T_LiveValue.lrActualVelocity:=T_AxisRefIn.fVeloIst;
ELSE
	CASE T_ExchgParam.bToolSpindleActive OF
	1:	(* Maxon Spindel *)
		IF (T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_TorqueSystem.rGearRatioGearBox <> 0.0) THEN
			T_Axis.T_LiveValue.lrActualVelocity:=T_AxisRefIn.fVeloIst/T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_TorqueSystem.rGearRatioGearBox;
		ELSE
			T_Axis.T_LiveValue.lrActualVelocity:=T_AxisRefIn.fVeloIst;
		END_IF;
	2,3:	(* Beckhoff Spindel L *)
		T_Axis.T_LiveValue.lrActualVelocity:=T_AxisRefIn.fVeloIst / T_Axis.T_CtrleSingle.lrScaleFactor;
	END_CASE;
END_IF;
(* return actual position *)
IF (T_Axis.T_Config_Gen.iTyp = 2) THEN
(* modulo position for rotativ axis*)
	CASE T_ExchgParam.bToolSpindleActive OF
	1:	(* Maxon Spindel *)
		T_Axis.T_LiveValue.lrActualPosition:=DINT_TO_REAL(REAL_TO_DINT(100.0 * T_AxisRefIn.fModuloPosIst * grScaleSAxis_Distance_SM) MOD 36000) / 100.0;
		T_Axis.T_LiveValue.lrActualPositionNotModulo:=DINT_TO_REAL(REAL_TO_DINT(100.0 * T_AxisRefIn.fPosIst * grScaleSAxis_Distance_SM) MOD 36000) / 100.0;
	2,3:	(* Beckhoff Spindel *)
		T_Axis.T_LiveValue.lrActualPosition:=DINT_TO_REAL(REAL_TO_DINT(100.0 * T_AxisRefIn.fModuloPosIst * grScaleSAxis_Distance_L) MOD 36000) / 100.0;
		T_Axis.T_LiveValue.lrActualPositionNotModulo:=DINT_TO_REAL(REAL_TO_DINT(100.0 * T_AxisRefIn.fPosIst * grScaleSAxis_Distance_L) MOD 36000) / 100.0;
	END_CASE;
ELSE
(* counter value *)
	T_Axis.T_LiveValue.lrActualPosition:=T_AxisRefIn.fPosIst;
END_IF
T_Axis.T_LiveValue.lrSollPosition:=T_AxisRefIn.fPosSoll;
(* return actual position *)
(*T_Axis.T_LiveValue.lrActualPosition:=T_AxisRefIn.fPosIst;*)
(* return the actual digital input state *)
T_Axis.T_LiveValue.bDigitalInput:=0;
FOR i := 0 TO 7 DO
	IF arxDigitalInput[i+1] THEN
		T_Axis.T_LiveValue.bDigitalInput:=T_Axis.T_LiveValue.bDigitalInput + MUX(i,1,2,4,8,16,32,64,128);
	END_IF
END_FOR;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_AXIS_SINGLE
VAR_INPUT
	xHWLimitPos:BOOL:=FALSE;
	xHWLimitNeg:BOOL:=FALSE;
	xRefHoming:BOOL:=FALSE;
	wInputState:WORD;
	lrNullPointOffset:LREAL;
	IxSoftLimitMaxMonitoring:BOOL;
	wPosLimitSwitchBit:WORD;
	wNegLimitSwitchBit:WORD;
	uiStateAxisZ2_KL2541:UINT;
END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
	T_Axis:ST_AXIS;
	T_AxisRefIn:NCTOPLC_AXLESTRUCT;
	T_AxisRefOut:PLCTONC_AXLESTRUCT;
	T_HDD:ST_HDD;
END_VAR
VAR
(* Axis function block *)
	fbAxisReset:MC_Reset;
	fbAxisPower:MC_Power;
	fbAxisStop:MC_Stop;
	fbAxisMoveVelocity:MC_MoveVelocity;
	fbAxisMoveAbsolute:MC_MoveAbsolute;
	fbAxisMoveRelative:MC_MoveRelative;
	fbAxisMoveModulo:MC_MoveModulo;
	fbAxisHoming:MC_Home;
	fbAxisSetOverride:MC_SetOverride;
	fbAxisSetPosition:MC_SetActualPosition;
	fbAxisNewPosAndVel:MC_NewPosAndVelo;
	fbAxisSetReferenceFlag:MC_SetReferenceFlag;
	fbDefaultAxisPara:FBDefaultAxisValue;
	fbAdsWrite:ADSWRITE;
	fbADS_ReadWriteString:ADSRDWRTEX;
	fbExtSetPointGenDisable:MC_ExtSetPointGenDisable;
	fbExtSetPointGenEnable:MC_ExtSetPointGenEnable;
(* variable *)
	xConfirmResetFB:BOOL:=FALSE;
	xResetAxis:BOOL:=FALSE;
	xPowerOn:BOOL:=FALSE;
	xPowerOff:BOOL:=FALSE;
	xStop:BOOL:=FALSE;
	xMoveVel:BOOL:=FALSE;
	iDirectionVel:INT:=1;
	rVelocity:REAL:=0;
	xMoveAbs:BOOL:=FALSE;
	xMoveRel:BOOL:=FALSE;
	xMoveModulo:BOOL:=FALSE;
	xHoming:BOOL:=FALSE;
	xOverride:BOOL:=FALSE;
	xSetPosition:BOOL:=FALSE;
	xNewVelocity:BOOL:=FALSE;
	xNewPosition:BOOL:=FALSE;
	xCalcAngleRefIndex: BOOL:=FALSE;
	xSetReferenceFlag:BOOL:=FALSE;
	xResetReferenceFlag:BOOL:=FALSE;
	xDefaultAxisParameter:BOOL:=FALSE;
	xSendAxisParameter:BOOL:=FALSE;
	iPtrAxisParameter:INT:=0;
	xSendAxisString:BOOL:=FALSE;
	sSendAxis:STRING:='';
	sReturnAxis:STRING:='';
	iStepSendPara:INT:=0;
	xRestoreAxisPower:BOOL:=FALSE;
	iStepFile:INT:=0;
	xCtrlePositionOn:BOOL:=FALSE;
	xCtrlePositionOff:BOOL:=FALSE;
	xOscillation:BOOL:=FALSE;
	iStepOsc:INT:=0;
	iOscCounter:INT:=0;
	iStepResetFB:INT:=0;
	dwOldOverride:DWORD:=100;
	lrOverrideVel:LREAL;
(* timer *)
	TimerOutSendPara:TON;
	TimerFileLocked:TON;
(* trigger *)
	RisingEdgeResetFB:R_TRIG;
	RisingEdgeExecute:R_TRIG;
	RisingEdgePowerOn:R_TRIG;
	RisingEdgePowerOff:R_TRIG;
(* Temp variable *)
	xTmp:BOOL:=FALSE;
	wTmp:WORD:=0;
	dwTmp:DWORD:=0;
	dwAdrVar:DWORD:=0;
	rTmpFrequence:REAL;
	lrTmpVelocity:LREAL;
	TimerCommTimeLeft:TON;
	xStartTimerComm:BOOL:=FALSE;
	tTimeCommLeft:TIME;
	TimerCommTimeLeft1:TON;
	xStartTimerComm1:BOOL:=FALSE;
	tTimeCommLeft1:TIME;
	xMovement: BOOL;
	xNoHWError: BOOL;
	iStepCalcRefIndex: INT;
	xCheckRefState: BOOL;
	iTmpFctNr: INT;
	lrTechUnitPerMotorTurn: LREAL;	(* Gilt nur für das Aufsuchen des Reference Index-->Die Technische Einheit muss angegeben werden, damit eine Motorrotation durchgeführt werden kann z.B. 2.5mm/U_Motor  oder 30Grad/U_Motor*)
	xSendBlock: BOOL;
	lrCapturePosition: LREAL;
	xTmpCheckDirectionPos: BOOL;
	xTmpCheckDirectionNeg: BOOL;
	TONWaitCheckHWLimitSwitch: TON;
	xActiveFollowError: BOOL;
	xSetSWPosLimitSwitch: BOOL;
	xResetSWPosLimitSwitch: BOOL;
	iStepSWLimitSwitch: INT;
	lrData: LREAL;
	fbSoEReset: FB_SoEReset;
	xResetAX5000Axis: BOOL;
	iStepResetAX5000FB: INT;
	xTmpHWLimitPos: BOOL;
	xTmpHWLimitNeg: BOOL;
	lrSetPosition: LREAL;
	diStepErrorCounter: DINT;
	diStepErrorCounter1: DINT;
	lrDistance: LREAL;
	xStopAxisVelCtrlActive: BOOL;
	iStopAxis: INT;
	TONWaitStop: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(* Test Timer PUM *)
TimerCommTimeLeft(IN:=xStartTimerComm,PT:=T#99999s);
TimerCommTimeLeft1(IN:=xStartTimerComm1,PT:=T#99999s);
(* reset block function *)
	RisingEdgeResetFB(CLK:=T_Axis.T_CtrleSingle.xReset);
	IF RisingEdgeResetFB.Q THEN
	(* Init. block function *)
		fbAxisReset(Execute:=FALSE, Axis:=T_AxisRefIn);
		fbSoEReset(	sNetId:='' ,bExecute:= FALSE, tTimeout:= T#10s, Axis:= T_AxisRefIn);
		fbAxisPower(	Enable:=FALSE,
					AxisRefIn:=T_AxisRefIn,
					AxisRefOut:=T_AxisRefOut);
		fbAxisStop(Execute:=FALSE, Axis:=T_AxisRefIn);
		fbAxisMoveVelocity(Execute:=FALSE, Axis:=T_AxisRefIn);
		fbAxisMoveAbsolute(Execute:=FALSE, Axis:=T_AxisRefIn);
		fbAxisMoveModulo(Execute:=FALSE, Axis:=T_AxisRefIn);
		fbAxisMoveRelative(Execute:=FALSE, Axis:=T_AxisRefIn);
		fbAxisHoming(	Execute:=FALSE,
						Axis:=T_AxisRefIn,
						AxisOut:=T_AxisRefOut);
		fbAxisSetOverride(Execute:=FALSE,
						AxisRefIn:=T_AxisRefIn,
						AxisRefOut:=T_AxisRefOut);
		fbAxisSetPosition(	Execute:=FALSE, Axis:=T_AxisRefIn);
		fbAxisNewPosAndVel(	Execute:=FALSE,
							Axis:=T_AxisRefIn);
		fbAdsWrite(WRITE:=FALSE);
		fbADS_ReadWriteString(WRTRD:=FALSE);
	(* timer *)
		TimerOutSendPara(IN:=TRUE,PT:=T#1ms);
	(* Init. variable *)
		xResetAxis:=FALSE;
		xResetAX5000Axis:=FALSE;
		xPowerOn:=FALSE;
		xPowerOff:=FALSE;
		xStop:=FALSE;
		xMoveVel:=FALSE;
		iDirectionVel:=1;
		rVelocity:=0;
		xMoveAbs:=FALSE;
		xMoveRel:=FALSE;
		xMoveModulo:=FALSE;
		xHoming:=FALSE;
		xOverride:=FALSE;
		xSetPosition:=FALSE;
		xNewVelocity:=FALSE;
		xNewPosition:=FALSE;
		xCalcAngleRefIndex:=FALSE;
		xSetReferenceFlag:=FALSE;
		xResetReferenceFlag:=FALSE;
		xDefaultAxisParameter:=FALSE;
		xSendAxisParameter:=FALSE;
		xSetSWPosLimitSwitch:=FALSE;
		xResetSWPosLimitSwitch:=FALSE;
		iPtrAxisParameter:=1;
		xSendAxisString:=FALSE;
		iStepSendPara:=0;
		iStepSWLimitSwitch:=0;
		xRestoreAxisPower:=FALSE;
		iStepFile:=0;
		xCtrlePositionOn:=FALSE;
		xCtrlePositionOff:=FALSE;
		xOscillation:=FALSE;
		iStepOsc:=0;
		iOscCounter:=0;
		iStepCalcRefIndex:=0;
	(* int. structure *)
		T_Axis.T_CtrleSingle.dwOverride:=100;
		T_Axis.T_CtrleSingle.iFunction:=0;
		T_Axis.T_CtrleSingle.xDone:=FALSE;
		T_Axis.T_CtrleSingle.xErr:=FALSE;
		T_Axis.T_CtrleSingle.udiErrorID:=0;
		T_Axis.T_CtrleSingle.xPower:=FALSE;
		T_Axis.T_CtrleSingle.xReady:=FALSE;
(*		T_Axis.T_CtrleSingle.xRef:=FALSE;*)
		T_Axis.T_CtrleSingle.xSlave:=FALSE;
		T_Axis.T_CtrleSingle.xConstantVel:=FALSE;
		T_Axis.T_CtrleSingle.xBusyNewPosAndVel:=FALSE;
		T_Axis.T_CtrleSingle.xDriveTorque:=FALSE;
		T_Axis.T_CtrleSingle.xAxisCollisionError:=FALSE;
		(* set flag done *)
		xConfirmResetFB:=TRUE;
		(* disable status flag *)
		T_Axis.T_CtrleSingle.xDone:=FALSE;
		T_Axis.T_CtrleSingle.xErr:=FALSE;
		T_Axis.T_CtrleSingle.udiErrorID:=0;
		(* exit function bloc *)
		(* Test Timer PUM *)
		xStartTimerComm:=FALSE;
		xStartTimerComm1:=FALSE;
		xActiveFollowError:=FALSE;
		IF (T_Axis.T_Config_Gen.iTyp = 1) THEN
			gxZFollowDistanceError:=FALSE;
		END_IF;
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_Axis.T_CtrleSingle.xDone:=TRUE;
			T_Axis.T_CtrleSingle.xErr:=FALSE;
			T_Axis.T_CtrleSingle.udiErrorID:=0;
			(* reset variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* return axis state *)
	T_Axis.T_CtrleSingle.xReady:=GETBIT32(T_AxisRefIn.nStateDWord,0) OR gxHardwareOFF;
	IF T_Axis.T_Config_Setting.xAbsoluteEncoder THEN
		T_Axis.T_CtrleSingle.xRef:=xRefHoming;
	ELSE
		T_Axis.T_CtrleSingle.xRef:=GETBIT32(T_AxisRefIn.nStateDWord,1);
	END_IF;
	T_Axis.T_CtrleSingle.xHomingSensor:=xRefHoming;
	T_Axis.T_CtrleSingle.xNotMoving:=GETBIT32(T_AxisRefIn.nStateDWord,2) OR gxHardwareOFF;
	T_Axis.T_CtrleSingle.xSlave:=GETBIT32(T_AxisRefIn.nStateDWord,5);
	T_Axis.T_CtrleSingle.xMovingForward:=GETBIT32(T_AxisRefIn.nStateDWord,9);
	T_Axis.T_CtrleSingle.xMovingBackwards:=GETBIT32(T_AxisRefIn.nStateDWord,10);
	T_Axis.T_CtrleSingle.xConstantVel:=GETBIT32(T_AxisRefIn.nStateDWord,12);
	T_Axis.T_CtrleSingle.xSpindleBlocked:=NOT(T_Axis.T_CtrleSingle.xNotMoving) AND (ABS(T_Axis.T_LiveValue.lrActualVelocity) = 0);
	T_Axis.T_CtrleSingle.xSWLimitSwitchPosActivated:=IxSoftLimitMaxMonitoring;
	IF GETBIT32(T_AxisRefIn.nStateDWord,31) THEN
	(* error servo *)
		T_Axis.T_CtrleSingle.xDone:=FALSE;
		T_Axis.T_CtrleSingle.xErr:=TRUE;
		T_Axis.T_CtrleSingle.udiErrorID:=T_AxisRefIn.nErrorCode;
	END_IF
	(* das Aktivieren dieser Funktion ermöglicht es vom HW Endschalter mittels der Steuerung wegzufahren *)
	T_AxisRefOut.nDeCtrlDWord:=AxisSetAcceptBlockedDriveSignal(nDeCtrlDWord:=T_AxisRefOut.nDeCtrlDWord, bEnable:=T_Axis.T_CtrleSingle.xMoveAwayFromHWLimitSwitchActive);

(* Timer *)
	TimerOutSendPara(IN:=TRUE, PT:=T#10S);
	TimerFileLocked(IN:=TRUE, PT:=T#10S);

(* detection software limit *)
	(* positiv limit *)
	IF T_Axis.T_Config_Setting.xSoftwareLimitPos THEN
		IF AxisSoftLimitMaxExceeded(nStateDWord:=T_AxisRefIn.nStateDWord) THEN
			T_Axis.T_CtrleSingle.xSWLimitPos:=TRUE;
		ELSE
			T_Axis.T_CtrleSingle.xSWLimitPos:=FALSE;
		END_IF;
		T_Axis.T_CtrleSingle.xStateSWLimitPos:=T_Axis.T_CtrleSingle.xSWLimitPos;
	END_IF;
	IF T_Axis.T_Config_Setting.xSoftwareLimitNeg THEN
		IF AxisSoftLimitMinExceeded(nStateDWord:=T_AxisRefIn.nStateDWord) THEN
			T_Axis.T_CtrleSingle.xSWLimitNeg:=TRUE;
		ELSE
			T_Axis.T_CtrleSingle.xSWLimitNeg:=FALSE;
		END_IF;
		T_Axis.T_CtrleSingle.xStateSWLimitNeg:=T_Axis.T_CtrleSingle.xSWLimitNeg;
	END_IF;

(* detection hardware limit *)
	(* positiv limit *)
	IF NOT(T_Axis.T_CtrleSingle.xAX5000Active) THEN
		IF NOT(T_Axis.T_CtrleSingle.xKL2541Active) THEN
			xTmpHWLimitPos:=((USINT_TO_WORD(T_Axis.T_DriveState.usiDriveState1) AND 16#2) = 16#2);
			xTmpHWLimitNeg:=((USINT_TO_WORD(T_Axis.T_DriveState.usiDriveState1) AND 16#4) = 16#4);
		ELSE
			xTmpHWLimitPos:=((UINT_TO_WORD(uiStateAxisZ2_KL2541) AND 16#2) = 16#2);
			xTmpHWLimitNeg:=((UINT_TO_WORD(uiStateAxisZ2_KL2541) AND 16#1) = 16#1);
		END_IF;
	ELSE
		xTmpHWLimitPos:=NOT((wInputState AND wPosLimitSwitchBit) = wPosLimitSwitchBit);
		xTmpHWLimitNeg:=NOT((wInputState AND wNegLimitSwitchBit) = wNegLimitSwitchBit);
	END_IF;
	IF T_Axis.T_Config_Setting.xHardwareLimitPos THEN T_Axis.T_CtrleSingle.xHWLimitPos:=xTmpHWLimitPos;
	ELSE T_Axis.T_CtrleSingle.xHWLimitPos:=FALSE; END_IF
	T_Axis.T_CtrleSingle.xStateHWLimitPos:=T_Axis.T_CtrleSingle.xHWLimitPos;
	(* negativ limit *)
	IF T_Axis.T_Config_Setting.xHardwareLimitNeg THEN T_Axis.T_CtrleSingle.xHWLimitNeg:=xTmpHWLimitNeg;
	ELSE T_Axis.T_CtrleSingle.xHWLimitNeg:=FALSE; END_IF
	T_Axis.T_CtrleSingle.xStateHWLimitNeg:=T_Axis.T_CtrleSingle.xHWLimitNeg;
	xTmpCheckDirectionPos:=	((xMoveVel AND (T_Axis.T_CtrleSingle.lrVelocity >= 0.0)) OR
							(NOT(T_Axis.T_CtrleSingle.xNotMoving) AND (T_Axis.T_CtrleSingle.lrVelocity >= 0.0) AND NOT(xMoveVel) AND NOT(xMoveAbs) AND NOT(xMoveRel)) OR
							(xMoveAbs AND ((T_Axis.T_CtrleSingle.lrPosition - T_Axis.T_LiveValue.lrActualPosition) >= 0)) OR
							(xMoveRel AND (T_Axis.T_CtrleSingle.lrDistance >= 0.0))) AND
							(T_Axis.T_CtrleSingle.xHWLimitPos OR T_Axis.T_CtrleSingle.xSWLimitPos) AND NOT(xHoming);
	xTmpCheckDirectionNeg:=	((xMoveVel AND (T_Axis.T_CtrleSingle.lrVelocity < 0.0)) OR
							(NOT(T_Axis.T_CtrleSingle.xNotMoving) AND (T_Axis.T_CtrleSingle.lrVelocity < 0.0) AND NOT(xMoveVel) AND NOT(xMoveAbs) AND NOT(xMoveRel)) OR
							(xMoveAbs AND ((T_Axis.T_CtrleSingle.lrPosition - T_Axis.T_LiveValue.lrActualPosition) < 0)) OR
							(xMoveRel AND (T_Axis.T_CtrleSingle.lrDistance < 0.0))) AND
							(T_Axis.T_CtrleSingle.xHWLimitNeg OR T_Axis.T_CtrleSingle.xSWLimitNeg) AND NOT(xHoming);
	T_Axis.T_CtrleSingle.xHWLimitPos:=T_Axis.T_CtrleSingle.xHWLimitPos AND xTmpCheckDirectionPos;
	T_Axis.T_CtrleSingle.xHWLimitNeg:=T_Axis.T_CtrleSingle.xHWLimitNeg AND xTmpCheckDirectionNeg;
	T_Axis.T_CtrleSingle.xSWLimitPos:=T_Axis.T_CtrleSingle.xSWLimitPos AND xTmpCheckDirectionPos;
	T_Axis.T_CtrleSingle.xSWLimitNeg:=T_Axis.T_CtrleSingle.xSWLimitNeg AND xTmpCheckDirectionNeg;
	(* monitor hardware limit *)
	IF NOT(T_Axis.T_CtrleSingle.xNotMoving) THEN
		IF T_Axis.T_CtrleSingle.xHWLimitPos OR T_Axis.T_CtrleSingle.xHWLimitNeg OR T_Axis.T_CtrleSingle.xSWLimitPos OR T_Axis.T_CtrleSingle.xSWLimitNeg THEN
		(* set decceleration ramp and make a stop *)
			IF NOT(xStop) THEN
				xStop:=TRUE;
				IF T_Axis.T_CtrleSingle.xHWLimitPos OR T_Axis.T_CtrleSingle.xHWLimitNeg THEN
					xActiveFollowError:=TRUE;
				END_IF;
				IF T_Axis.T_Config_Setting.lrHWLimitDecceleration <> 0 THEN
					T_Axis.T_CtrleSingle.lrDecceleration:=T_Axis.T_Config_Setting.lrHWLimitDecceleration;
				END_IF
			END_IF;
		END_IF
	END_IF
	IF T_Axis.T_CtrleSingle.xNotMoving AND (T_Axis.T_CtrleSingle.xHWLimitPos OR T_Axis.T_CtrleSingle.xHWLimitNeg OR T_Axis.T_CtrleSingle.xSWLimitPos OR T_Axis.T_CtrleSingle.xSWLimitNeg) THEN
		TONWaitCheckHWLimitSwitch(IN:=TRUE,PT:=T#500ms);
		IF TONWaitCheckHWLimitSwitch.Q AND NOT(xStop) THEN
			TONWaitCheckHWLimitSwitch(IN:=FALSE);
			xStop:=TRUE;
			IF T_Axis.T_Config_Setting.lrHWLimitDecceleration <> 0 THEN
				T_Axis.T_CtrleSingle.lrDecceleration:=T_Axis.T_Config_Setting.lrHWLimitDecceleration;
			END_IF
		END_IF;
		IF TONWaitCheckHWLimitSwitch.Q AND xStop THEN
			TONWaitCheckHWLimitSwitch(IN:=FALSE);
		END_IF;
	ELSE
		TONWaitCheckHWLimitSwitch(IN:=FALSE);
	END_IF;

(* detection start *)
	RisingEdgeExecute(CLK:=T_Axis.T_CtrleSingle.xExecute);
	IF RisingEdgeExecute.Q THEN
		RisingEdgeExecute(CLK:=FALSE);
		IF xStop AND (T_Axis.T_CtrleSingle.iFunction <> 1) AND (T_Axis.T_CtrleSingle.iFunction <> 5) AND (T_Axis.T_CtrleSingle.iFunction <> 27) THEN
		(* can not execute a function when 'Stop' activ, except 'Reset' *)
			T_Axis.T_CtrleSingle.xDone:=FALSE;
			T_Axis.T_CtrleSingle.xErr:=TRUE;
			T_Axis.T_CtrleSingle.udiErrorID:=16#F100;		(* Achsfunktion nicht ausführbar wenn Stop-Funktion Aktiv *)
			RETURN;
		END_IF
		CASE T_Axis.T_CtrleSingle.iFunction OF
		(* Reset *)
		1:	xResetAxis:=TRUE;
			iStepResetFB:=1;
			iTmpFctNr:=1;
		(* Power ON *)
		3:	IF NOT(xPowerOn) THEN
				xPowerOn:=TRUE;
				xPowerOff:=NOT(xPowerOn);
				iTmpFctNr:=3;
			ELSE
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#0;
				iTmpFctNr:=3;
				RETURN;
			END_IF;
		(* Power Off *)
		4:	IF xPowerOn THEN
				xPowerOff:=TRUE;
				xPowerOn:=NOT(xPowerOff);
				iTmpFctNr:=4;
			ELSE
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#0;
				iTmpFctNr:=4;
				RETURN;
			END_IF;
		(* Stop *)
		5: 	xStop:=TRUE;
			fbAxisStop(Execute:=FALSE, Axis:=T_AxisRefIn);
			xStartTimerComm1:=TRUE;
			iTmpFctNr:=5;
		(* Velocity *)
		6:	xMoveVel:=TRUE;
			iTmpFctNr:=6;
		(* Absolute *)
		7:	xMoveAbs:=TRUE;
			iTmpFctNr:=7;
		(* Relative *)
		8:	xMoveRel:=TRUE;
			iTmpFctNr:=8;
		(* homing *)
		9:	xHoming:=TRUE;
			iTmpFctNr:=9;
		(* override *)
		10:	xOverride:=TRUE;
			iTmpFctNr:=10;
		(* set position *)
		11:	xSetPosition:=TRUE;
			iTmpFctNr:=11;
		(* change current speed *)
		12:	xNewVelocity:=TRUE;
			T_Axis.T_CtrleSingle.xBusyNewPosAndVel:=TRUE;
			IF xMoveAbs OR xMoveRel OR xMoveModulo OR xOscillation THEN	(* Muss unterschieden werden können, ob Positionsfahrt oder Velocitymode ausgeführt wird *)
				xMovement:=TRUE;
			ELSE
				xMovement:=FALSE;
			END_IF;
			xStartTimerComm:=TRUE;
		(* Set reference flag *)
		13:	xSetReferenceFlag:=TRUE;
			iTmpFctNr:=13;
		(* reset reference flag *)
		14:	xResetReferenceFlag:=TRUE;
			iTmpFctNr:=14;
		(* control position On *)
		15:	xCtrlePositionOn:=TRUE;
			iTmpFctNr:=15;
		(* control position off *)
		16:	xCtrlePositionOff:=TRUE;
			iTmpFctNr:=16;
		(* oscillation *)
		17:	xOscillation:=TRUE;
			iTmpFctNr:=17;
		(* change position *)
		18:	xNewPosition:=TRUE;
			T_Axis.T_CtrleSingle.xBusyNewPosAndVel:=TRUE;
		(* calcultate angle between Reference Index and Reference Sensor *)
		19:	xCalcAngleRefIndex:=TRUE;
			iTmpFctNr:=19;
		(* Default parameter value *)
		20:	xDefaultAxisParameter:=TRUE;
			iTmpFctNr:=20;
		(* Send Parameter *)
		21: 	xSendAxisParameter:=TRUE;
			iPtrAxisParameter:=1;
			iStepSendPara:=1;
			(* copy parameter value *)
			fbDefaultAxisPara(xDefaultValue:=FALSE,T_Axis:=T_Axis);
			iTmpFctNr:=21;
		(* send string *)
		22: 	xSendAxisString:=TRUE;
			sSendAxis:='';
			sReturnAxis:='';
			iTmpFctNr:=22;
		(* Move Modulo *)
		24:	xMoveModulo:=TRUE;
			iTmpFctNr:=24;
		(* Set SW Pos limit switch *)
		25:	xSetSWPosLimitSwitch:=TRUE;
			iStepSWLimitSwitch:=1;
			iTmpFctNr:=25;
		(* Reset SW Pos limit switch *)
		26:	xResetSWPosLimitSwitch:=TRUE;
			iStepSWLimitSwitch:=1;
			iTmpFctNr:=26;
		(* Reset AX5000 Servo function *)
		27:	xResetAX5000Axis:=TRUE;
			iStepResetAX5000FB:=1;
			iTmpFctNr:=27;
		ELSE
		(* function not implemented *)
			T_Axis.T_CtrleSingle.xDone:=FALSE;
			T_Axis.T_CtrleSingle.xErr:=TRUE;
			T_Axis.T_CtrleSingle.udiErrorID:=16#F000;		(* Aufgerufene Achsfunktion besteht nicht *)
			(* Exit FB *)
			RETURN;
		END_CASE
		(* Init. variable *)
		T_Axis.T_CtrleSingle.xDone:=FALSE;
		T_Axis.T_CtrleSingle.xErr:=FALSE;
		T_Axis.T_CtrleSingle.udiErrorID:=0;
		iStopAxis:=1;
		xStopAxisVelCtrlActive:=FALSE;
		IF NOT(xStop) THEN
			T_Axis.T_CtrleSingle.xAxisCollisionError:=FALSE;
		END_IF;
		(* init variable *)
		dwOldOverride:=16#FFFF;
		(* Exit FB *)
		RETURN;
	END_IF

(* Override *)
	IF dwOldOverride <>T_Axis.T_CtrleSingle.dwOverride THEN
		lrOverrideVel:=T_Axis.T_CtrleSingle.lrVelocity; (* T_Axis.T_CtrleSingle.dwOverride / 100;*)
		(* confirm velocity setting *)
		dwOldOverride:=T_Axis.T_CtrleSingle.dwOverride;
	END_IF

(* Reset function *)
	IF xResetAxis THEN
		CASE iStepResetFB OF
		(* check state *)
		1:	xRestoreAxisPower:=FALSE;
			IF xPowerOn THEN iStepResetFB:=10; ELSE iStepResetFB:=20; END_IF
			xActiveFollowError:=FALSE;
			IF (T_Axis.T_Config_Gen.iTyp = 1) THEN
				gxZFollowDistanceError:=FALSE;
			END_IF;
		(* power off *)
		10:	xPowerOff:=TRUE;
			xPowerOn:=NOT(xPowerOff);
			xRestoreAxisPower:=TRUE;
			(* next step *)
			iStepResetFB:=20;
		(* wait power off flag *)
		20:	IF NOT(T_Axis.T_CtrleSingle.xPower) THEN
				fbAxisReset(Execute:=TRUE, Axis:=T_AxisRefIn);
				IF fbAxisReset.Done OR fbAxisReset.Error THEN
					 IF fbAxisReset.Error THEN
						T_Axis.T_CtrleSingle.xDone:=fbAxisReset.Done;
						T_Axis.T_CtrleSingle.xErr:= fbAxisReset.Error;
						T_Axis.T_CtrleSingle.udiErrorID:=fbAxisReset.ErrorID;
					ELSE
					(* activ stop *)
						xStop:=TRUE;
						(* flag reset off only if the power has not to be recovered *)
						IF NOT(xRestoreAxisPower) THEN xResetAxis:=FALSE; END_IF
					END_IF
					(* reset flag busy *)
					T_Axis.T_CtrleSingle.xBusyNewPosAndVel:=FALSE;
					(* init. FB reset *)
					fbAxisReset(Execute:=FALSE, Axis:=T_AxisRefIn);
					(* next step *)
					iStepResetFB:=30;
				END_IF
			END_IF
		(* wait stop done *)
		30:	IF NOT(xStop) OR xStopAxisVelCtrlActive THEN iStepResetFB:=40; END_IF
		(* set power on *)
		40:	xPowerOff:=FALSE;
			xPowerOn:=NOT(xPowerOff);
			(* next step *)
			iStepResetFB:=50;
		(* wait power on flag *)
		50:	IF T_Axis.T_CtrleSingle.xPower THEN
			(* confirm reset *)
				IF NOT(xStopAxisVelCtrlActive) THEN
					T_Axis.T_CtrleSingle.xDone:=TRUE;
					T_Axis.T_CtrleSingle.xErr:= FALSE;
					T_Axis.T_CtrleSingle.udiErrorID:=16#0;
				END_IF;
				(* init. variable *)
				xResetAxis:=FALSE;
			END_IF
		END_CASE
	ELSE fbAxisReset(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF

(* Reset AX5000 Servo function *)
	IF xResetAX5000Axis THEN
		CASE iStepResetAX5000FB OF
		(* check state *)
		1:	xRestoreAxisPower:=FALSE;
			IF xPowerOn THEN iStepResetAX5000FB:=10; ELSE iStepResetAX5000FB:=20; END_IF
			xActiveFollowError:=FALSE;
		(* power off *)
		10:	xPowerOff:=TRUE;
			xPowerOn:=NOT(xPowerOff);
			xRestoreAxisPower:=TRUE;
			(* next step *)
			iStepResetAX5000FB:=20;
		(* wait power off flag *)
		20:	IF NOT(T_Axis.T_CtrleSingle.xPower) THEN
				fbSoEReset(	sNetId:='' ,bExecute:= TRUE, tTimeout:= T#10s, Axis:= T_AxisRefIn);
				IF NOT(fbSoEReset.bBusy) OR fbSoEReset.bError THEN
					 IF fbSoEReset.bError THEN
						T_Axis.T_CtrleSingle.xDone:=NOT(fbSoEReset.bError);
						T_Axis.T_CtrleSingle.xErr:= fbSoEReset.bError;
						IF (fbSoEReset.iSercosErrId <> 0) THEN
							T_Axis.T_CtrleSingle.udiErrorID:=fbSoEReset.iSercosErrId;
						ELSE
							T_Axis.T_CtrleSingle.udiErrorID:=fbSoEReset.iAdsErrId;
						END_IF;
					ELSE
					(* activ stop *)
						xStop:=TRUE;
						(* flag reset off only if the power has not to be recovered *)
						IF NOT(xRestoreAxisPower) THEN
							xResetAX5000Axis:=FALSE;
							T_Axis.T_CtrleSingle.xDone:=TRUE;
							T_Axis.T_CtrleSingle.xErr:= FALSE;
							T_Axis.T_CtrleSingle.udiErrorID:=16#0;
						END_IF
					END_IF
					(* reset flag busy *)
					T_Axis.T_CtrleSingle.xBusyNewPosAndVel:=FALSE;
					(* init. FB reset *)
					fbSoEReset(	sNetId:='' ,bExecute:= FALSE, tTimeout:= T#10s, Axis:= T_AxisRefIn);
					(* next step *)
					iStepResetAX5000FB:=30;
				END_IF
			END_IF
		(* wait stop done *)
		30:	IF NOT(xStop) THEN iStepResetAX5000FB:=40; END_IF
		(* set power on *)
		40:	xPowerOff:=FALSE;
			xPowerOn:=NOT(xPowerOff);
			(* next step *)
			iStepResetAX5000FB:=50;
		(* wait power on flag *)
		50:	IF T_Axis.T_CtrleSingle.xPower THEN
			(* confirm reset *)
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#0;
				(* init. variable *)
				xResetAX5000Axis:=FALSE;
			END_IF
		END_CASE
	ELSE fbSoEReset(	sNetId:='' ,bExecute:= FALSE, tTimeout:= T#10s, Axis:= T_AxisRefIn); END_IF

(* Power function *)
	RisingEdgePowerOn(CLK:=xPowerOn);
	RisingEdgePowerOff(CLK:=xPowerOff);
	IF xPowerOn THEN
		fbAxisPower(	Enable:=TRUE,
					Enable_Positive:=TRUE,
					Enable_Negative:=TRUE,
					Override:= T_Axis.T_CtrleSingle.dwOverride,
					AxisRefIn:=T_AxisRefIn,
					AxisRefOut:=T_AxisRefOut);
		T_Axis.T_CtrleSingle.xPower:=fbAxisPower.Status;
		(* desactiv control flag during sending axis parameter and during reset  *)
		IF NOT(xSendAxisParameter) AND NOT(xResetAxis) AND NOT(xResetAX5000Axis) THEN
			IF RisingEdgePowerOn.Q AND  NOT(fbAxisPower.Error) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
			END_IF
			IF  fbAxisPower.Error THEN
				T_Axis.T_CtrleSingle.xErr:= fbAxisPower.Error;
				T_Axis.T_CtrleSingle.udiErrorID:=fbAxisPower.ErrorID;
			END_IF
		END_IF
	END_IF
	IF xPowerOff THEN
		fbAxisPower(	Enable:=FALSE,
					AxisRefIn:=T_AxisRefIn,
					AxisRefOut:=T_AxisRefOut);
		T_Axis.T_CtrleSingle.xPower:=fbAxisPower.Status;
		(* desactiv control flag during sending axis parameter and during reset *)
		IF NOT(xSendAxisParameter) AND NOT(xResetAxis) AND NOT(xResetAX5000Axis) THEN
			IF RisingEdgePowerOff.Q AND NOT( fbAxisPower.Error) THEN
				T_Axis.T_CtrleSingle.xDone:=TRUE;
			END_IF
			IF  fbAxisPower.Error THEN
				T_Axis.T_CtrleSingle.xErr:= fbAxisPower.Error;
				T_Axis.T_CtrleSingle.udiErrorID:=fbAxisPower.ErrorID;
			END_IF
		END_IF
	END_IF

(* Stop *)
	IF xStop THEN
		(* init. FB vel / abs / rel *)
		xMoveVel:=FALSE;
		xMoveRel:=FALSE;
		xMoveAbs:=FALSE;
		xMoveModulo:=FALSE;
		xNewVelocity:=FALSE;
		xNewPosition:=FALSE;
		xStartTimerComm:=FALSE;
		xHoming:=FALSE;
		IF (iTmpFctNr <> 19) THEN
			xCalcAngleRefIndex:=FALSE;
		END_IF;
		(* flag oscillation off *)
		xOscillation:=FALSE;
		(* FB stop *)
		xStopAxisVelCtrlActive:=FALSE;
		IF (T_Axis.T_Config_Gen.iTyp <> 1) THEN
			fbAxisStop(	Execute:=TRUE,
						Deceleration:=T_Axis.T_CtrleSingle.lrDecceleration,
						Jerk:=T_Axis.T_CtrleSingle.lrJerk,
						Axis:=T_AxisRefIn);
		ELSE
			IF NOT(gxZAxisVelocityCtrlActive) THEN
				fbAxisStop(	Execute:=TRUE,
							Deceleration:=T_Axis.T_CtrleSingle.lrDecceleration,
							Jerk:=T_Axis.T_CtrleSingle.lrJerk,
							Axis:=T_AxisRefIn);
			ELSE
				xStopAxisVelCtrlActive:=TRUE;
			END_IF;
		END_IF;
		(* select bit not moving *)
		dwTmp:=T_Axis.T_LiveValue.dwState AND 16#4;
		IF NOT(xStopAxisVelCtrlActive) THEN
			IF (fbAxisStop.Done AND dwTmp = 16#4) OR fbAxisStop.Error THEN
				IF fbAxisStop.Error OR (NOT(xResetAxis) AND NOT(xResetAX5000Axis) AND NOT(xCalcAngleRefIndex) )THEN
					xResetAxis:=xCalcAngleRefIndex:=xResetAX5000Axis:=FALSE;
				(* confirm reset if error activ or if reset is not activ *)
					T_Axis.T_CtrleSingle.xDone:=fbAxisStop.Done;
					T_Axis.T_CtrleSingle.xErr:= fbAxisStop.Error;
					T_Axis.T_CtrleSingle.udiErrorID:=fbAxisStop.ErrorID;
					(* desactiv reset axis *)
					IF xResetAxis THEN xResetAxis:=FALSE; END_IF
					IF (T_Axis.T_Config_Gen.iTyp = 1) AND gxZFollowDistanceError THEN
						T_Axis.T_CtrleSingle.xDone:=FALSE;
						T_Axis.T_CtrleSingle.xErr:= TRUE;
						T_Axis.T_CtrleSingle.udiErrorID:=16#4550;	(* Schleppabstandsfehler *)
					END_IF;
				END_IF
				(* flag stop off *)
				xStop:=FALSE;
				tTimeCommLeft1:=TimerCommTimeLeft1.ET;
				xStartTimerComm1:=FALSE;
				(* reset flag busy *)
				T_Axis.T_CtrleSingle.xBusyNewPosAndVel:=FALSE;
				(* Init. Stop FB *)
				fbAxisStop(Execute:=FALSE, Axis:=T_AxisRefIn);
				IF xActiveFollowError AND NOT(fbAxisStop.Error) THEN
					T_Axis.T_CtrleSingle.xDone:=FALSE;
					T_Axis.T_CtrleSingle.xErr:= FALSE;
					T_Axis.T_CtrleSingle.udiErrorID:=0;
					xActiveFollowError:=FALSE;
					iStepResetFB:=1;
					xResetAxis:=TRUE;
					RETURN;
				END_IF;
				IF gxSpindleOverloadError AND (T_Axis.T_Config_Gen.iTyp = 2) THEN
					gxSpindleOverloadError:=FALSE;
					T_Axis.T_CtrleSingle.xDone:=FALSE;
					T_Axis.T_CtrleSingle.xErr:= TRUE;
					T_Axis.T_CtrleSingle.udiErrorID:=16#F502;
				END_IF;
			END_IF
		ELSE
			CASE iStopAxis OF
			1:	TONWaitStop(IN:=FALSE);
				iStepResetFB:=1;
				xResetAxis:=TRUE;
				iStopAxis:=iStopAxis + 1;
			2:	IF NOT(xResetAxis) THEN
					iStopAxis:=iStopAxis + 1;
				END_IF;
			3:	TONWaitStop(IN:=TRUE,PT:=T#0.3s);
				IF TONWaitStop.Q THEN
					TONWaitStop(IN:=FALSE);
					T_Axis.T_CtrleSingle.xDone:=TRUE;
					T_Axis.T_CtrleSingle.xErr:= FALSE;
					T_Axis.T_CtrleSingle.udiErrorID:=16#0;
					xStop:=FALSE;
					xStopAxisVelCtrlActive:=FALSE;
					iStopAxis:=1;
					IF (T_Axis.T_Config_Gen.iTyp = 1) AND gxZFollowDistanceError THEN
						T_Axis.T_CtrleSingle.xDone:=FALSE;
						T_Axis.T_CtrleSingle.xErr:= TRUE;
						T_Axis.T_CtrleSingle.udiErrorID:=16#4550;	(* Schleppabstandsfehler *)
					END_IF;
				END_IF;
			END_CASE;
		END_IF;
	ELSE fbAxisStop(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF

(* Velocity *)
	IF xMoveVel AND NOT(fbAxisMoveVelocity.InVelocity) THEN
		IF T_Axis.T_CtrleSingle.lrVelocity >= 0 THEN
		(* positiv direction =1*)
			iDirectionVel:=MC_Positive_Direction;
		ELSE
		(* negativ direction =3*)
			iDirectionVel:=MC_Negative_Direction;
		END_IF
		IF (T_Axis.T_Config_Gen.iTyp <> 2) THEN
			rVelocity:=ABS(lrOverrideVel);
		ELSE
			rVelocity:=ABS(lrOverrideVel) * T_Axis.T_CtrleSingle.lrScaleFactor;
		END_IF;
		fbAxisMoveVelocity(	Execute:=TRUE,
							Velocity:=rVelocity,
							Acceleration:=T_Axis.T_CtrleSingle.lrAcceleration,
							Deceleration:=T_Axis.T_CtrleSingle.lrDecceleration,
							Jerk:=T_Axis.T_CtrleSingle.lrJerk,
							Direction:=iDirectionVel,
							Axis:=T_AxisRefIn);
		IF fbAxisMoveVelocity.InVelocity OR fbAxisMoveVelocity.Error THEN
			T_Axis.T_CtrleSingle.xDone:=fbAxisMoveVelocity.InVelocity;
			T_Axis.T_CtrleSingle.xErr:= fbAxisMoveVelocity.Error;
			T_Axis.T_CtrleSingle.udiErrorID:=fbAxisMoveVelocity.ErrorID;
			(* flag velocity off *)
			xMoveVel:=FALSE;
			(* Init. FB Move *)
			fbAxisMoveVelocity(Execute:=FALSE, Axis:=T_AxisRefIn);
		END_IF
	ELSE fbAxisMoveVelocity(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF

(* Move absolute *)
	IF xMoveAbs THEN
		fbAxisMoveAbsolute(	Execute:=TRUE,
							Position:=T_Axis.T_CtrleSingle.lrPosition,
							Velocity:=ABS(lrOverrideVel),
							Acceleration:=T_Axis.T_CtrleSingle.lrAcceleration,
							Deceleration:=T_Axis.T_CtrleSingle.lrDecceleration,
							Jerk:=T_Axis.T_CtrleSingle.lrJerk,
							Axis:=T_AxisRefIn);
		IF fbAxisMoveAbsolute.Done OR fbAxisMoveAbsolute.Error THEN
			IF NOT(xCalcAngleRefIndex) OR fbAxisMoveAbsolute.Error THEN
				xCalcAngleRefIndex:=FALSE;
				IF NOT(T_Axis.T_CtrleSingle.xErr) THEN	(* xNewVelocity könnte einen Fehler generiert haben, aber diese Funktion ist noch aktiv und darf daher nicht überschrieben werden *)
					T_Axis.T_CtrleSingle.xDone:=fbAxisMoveAbsolute.Done;
					T_Axis.T_CtrleSingle.xErr:= fbAxisMoveAbsolute.Error;
					T_Axis.T_CtrleSingle.udiErrorID:=fbAxisMoveAbsolute.ErrorID;
				END_IF;
				(* test if move has been stopped *)
				IF fbAxisMoveAbsolute.ErrorID = 16#4B00 THEN
				(* clear error *)
					T_Axis.T_CtrleSingle.xDone:=TRUE;
					T_Axis.T_CtrleSingle.xErr:= FALSE;
					T_Axis.T_CtrleSingle.udiErrorID:=16#0;
				END_IF
			END_IF;
			(* flag move absolute off *)
			xMoveAbs:=FALSE;
			(* init. FB *)
			fbAxisMoveAbsolute(Execute:=FALSE, Axis:=T_AxisRefIn);
		END_IF
	ELSE fbAxisMoveAbsolute(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF

(* Move relative *)
	IF xMoveRel THEN
		IF (T_Axis.T_Config_Gen.iTyp <> 2) THEN
			lrDistance:=T_Axis.T_CtrleSingle.lrDistance;
		ELSE
			CASE T_ExchgParam.bToolSpindleActive OF
			1:	(* Maxon Spindel *)
				lrDistance:=T_Axis.T_CtrleSingle.lrDistance / grScaleSAxis_Distance_SM;
			2,3:	(* Beckhoff Spindel *)
				lrDistance:=T_Axis.T_CtrleSingle.lrDistance / grScaleSAxis_Distance_L;
			END_CASE;
		END_IF;
		fbAxisMoveRelative(	Execute:=TRUE,
							Distance:=lrDistance,
							Velocity:=lrOverrideVel,
							Acceleration:=T_Axis.T_CtrleSingle.lrAcceleration,
							Deceleration:=T_Axis.T_CtrleSingle.lrDecceleration,
							Jerk:=T_Axis.T_CtrleSingle.lrJerk,
							Axis:=T_AxisRefIn);
		IF fbAxisMoveRelative.Done OR fbAxisMoveRelative.Error THEN
			IF (NOT(xOscillation) AND NOT(xCalcAngleRefIndex)) OR fbAxisMoveRelative.Error THEN
				xOscillation:=xCalcAngleRefIndex:=FALSE;
			(* normal control variable settings if oscillation disable *)
				IF NOT(T_Axis.T_CtrleSingle.xErr) THEN	(* xNewVelocity könnte einen Fehler generiert haben, aber diese Funktion ist noch aktiv und darf daher nicht überschrieben werden *)
					T_Axis.T_CtrleSingle.xDone:=fbAxisMoveRelative.Done;
					T_Axis.T_CtrleSingle.xErr:= fbAxisMoveRelative.Error;
					T_Axis.T_CtrleSingle.udiErrorID:=fbAxisMoveRelative.ErrorID;
				END_IF;
				(* test if move has been stopped *)
				IF fbAxisMoveRelative.ErrorID = 16#4B00 THEN
				(* clear error *)
					T_Axis.T_CtrleSingle.xDone:=TRUE;
					T_Axis.T_CtrleSingle.xErr:= FALSE;
					T_Axis.T_CtrleSingle.udiErrorID:=16#0;
				END_IF
			END_IF
			(* flag move relative off *)
			xMoveRel:=FALSE;
			(* init. FB *)
			fbAxisMoveRelative(Execute:=FALSE, Axis:=T_AxisRefIn);
		END_IF
	ELSE fbAxisMoveRelative(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF

(* Move modulo *)
	IF xMoveModulo THEN
		fbAxisMoveModulo(	Execute:= TRUE,
							Position:= T_Axis.T_CtrleSingle.lrPosition,
							Velocity:= ABS(lrOverrideVel),
							Acceleration:= T_Axis.T_CtrleSingle.lrAcceleration,
							Deceleration:= T_Axis.T_CtrleSingle.lrDecceleration,
							Jerk:= T_Axis.T_CtrleSingle.lrJerk,
							Direction:= T_Axis.T_CtrleSingle.iModuloDirection,
							Axis:= T_AxisRefIn);
		IF fbAxisMoveModulo.Done OR fbAxisMoveModulo.Error THEN
			xCalcAngleRefIndex:=FALSE;
			T_Axis.T_CtrleSingle.xDone:=fbAxisMoveModulo.Done;
			T_Axis.T_CtrleSingle.xErr:= fbAxisMoveModulo.Error;
			T_Axis.T_CtrleSingle.udiErrorID:=fbAxisMoveModulo.ErrorID;
			(* test if move has been stopped *)
			IF fbAxisMoveModulo.ErrorID = 16#4B00 THEN
			(* clear error *)
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#0;
			END_IF
			(* flag move absolute off *)
			xMoveModulo:=FALSE;
			(* init. FB *)
			fbAxisMoveModulo(Execute:=FALSE, Axis:=T_AxisRefIn);
		END_IF
	ELSE fbAxisMoveModulo(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF

(* Homing *)
	IF xHoming THEN
		IF(T_Axis.T_Config_Gen.iTyp=1) THEN
			lrSetPosition:=T_Axis.T_CtrleSingle.rSetPosition + lrNullPointOffset;
		ELSE
			lrSetPosition:=T_Axis.T_CtrleSingle.rSetPosition;
		END_IF;
		fbAxisHoming(	Execute:=TRUE,
						Position:=lrSetPosition,
						bCalibrationCam:=xRefHoming,
						Axis:=T_AxisRefIn,
						AxisOut:=T_AxisRefOut);
		IF fbAxisHoming.Done OR fbAxisHoming.Error THEN
			IF NOT(xCalcAngleRefIndex) OR fbAxisHoming.Error THEN
				xCalcAngleRefIndex:=FALSE;
				T_Axis.T_CtrleSingle.xDone:=fbAxisHoming.Done;
				T_Axis.T_CtrleSingle.xErr:= fbAxisHoming.Error;
				T_Axis.T_CtrleSingle.udiErrorID:=fbAxisHoming.ErrorID;
			END_IF;
			(* flag homing off *)
			xHoming:=FALSE;
			(* Init. FB Homing *)
			fbAxisHoming(	Execute:=FALSE,
							Axis:=T_AxisRefIn,
							AxisOut:=T_AxisRefOut);
		END_IF
	ELSE
		fbAxisHoming(	Execute:=FALSE,
						Axis:=T_AxisRefIn,
						AxisOut:=T_AxisRefOut);
	END_IF

(* Set override *)
	IF xOverride THEN
		fbAxisSetOverride(Execute:=TRUE,
						Override:=T_Axis.T_CtrleSingle.dwOverride,
						AxisRefIn:=T_AxisRefIn,
						AxisRefOut:=T_AxisRefOut);
		IF fbAxisSetOverride.Done OR fbAxisSetOverride.Error THEN
			T_Axis.T_CtrleSingle.xDone:=fbAxisSetOverride.Done;
			T_Axis.T_CtrleSingle.xErr:= fbAxisSetOverride.Error;
			T_Axis.T_CtrleSingle.udiErrorID:=fbAxisSetOverride.ErrorID;
			(* flag override off *)
			xOverride:=FALSE;
			(* Init. FB Override *)
			fbAxisSetOverride(Execute:=FALSE,
							AxisRefIn:=T_AxisRefIn,
							AxisRefOut:=T_AxisRefOut);
		END_IF
	ELSE
		fbAxisSetOverride(Execute:=FALSE,
						AxisRefIn:=T_AxisRefIn,
						AxisRefOut:=T_AxisRefOut);
	END_IF

(* Set new position *)
	IF xSetPosition THEN
		fbAxisSetPosition(	Execute:=TRUE, Position:=T_Axis.T_CtrleSingle.rSetPosition, Axis:=T_AxisRefIn);
		IF fbAxisSetPosition.Done OR fbAxisSetPosition.Error THEN
			T_Axis.T_CtrleSingle.xDone:=fbAxisSetPosition.Done;
			T_Axis.T_CtrleSingle.xErr:= fbAxisSetPosition.Error;
			T_Axis.T_CtrleSingle.udiErrorID:=fbAxisSetPosition.ErrorID;
			(* flag set position off *)
			xSetPosition:=FALSE;
			(* Init. FB set position *)
			fbAxisSetPosition(Execute:=FALSE, Axis:=T_AxisRefIn);
		END_IF
	ELSE fbAxisSetPosition(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF

(* set new velocity or new position *)
	IF xNewVelocity OR xNewPosition THEN
		IF (T_Axis.T_Config_Gen.iTyp <> 2) THEN
			rVelocity:=ABS(lrOverrideVel);
		ELSE
			rVelocity:=ABS(lrOverrideVel) * T_Axis.T_CtrleSingle.lrScaleFactor;
		END_IF;
		IF NOT(xOscillation) OR xNewPosition THEN
			IF NOT(T_Axis.T_CtrleSingle.xNotMoving) THEN
				xNoHWError:=FALSE;
				IF xNewVelocity THEN
				(* new velocity *)
					fbAxisNewPosAndVel(	Execute:=TRUE,
										Mode:=2,
										NewVelo:=ABS(rVelocity),
										Axis:=T_AxisRefIn);
				ELSE
				(* new position *)
					fbAxisNewPosAndVel(	Execute:=TRUE,
										Mode:=3,
										NewPos:=T_Axis.T_CtrleSingle.lrPosition,
										NewVelo:=lrOverrideVel,
										Axis:=T_AxisRefIn);
				END_IF
			ELSE
				xNoHWError:=TRUE;
			END_IF;
			IF fbAxisNewPosAndVel.Done OR fbAxisNewPosAndVel.Error OR xNoHWError THEN
			(* confirm end function *)
				IF xMovement THEN
					IF NOT(xNoHWError) THEN
						T_Axis.T_CtrleSingle.xDone:=FALSE;
					ELSE
						IF xMoveAbs OR xMoveRel OR xMoveModulo THEN
							T_Axis.T_CtrleSingle.xDone:=FALSE;
						ELSE
							T_Axis.T_CtrleSingle.xDone:=TRUE;
						END_IF;
					END_IF;
				ELSE
					IF NOT(xNoHWError) THEN
						T_Axis.T_CtrleSingle.xDone:=fbAxisNewPosAndVel.Done;
					ELSE
						T_Axis.T_CtrleSingle.xDone:=TRUE;
					END_IF;
				END_IF;
				IF NOT(xNoHWError) THEN
(*					IF (fbAxisNewPosAndVel.ErrorID <> 17022) AND (fbAxisNewPosAndVel.ErrorID <> 16900) THEN	(* Fehler 17022: Während Beschleunigungsphase wird eine neue Geschwindigkeit angefordert und erzeugt ein NC Fehler, Achse fährt aber Normal weiter, daher wird dieser Fehler nicht berücksichtigt *)
*)					IF NOT(xMovement) THEN
						T_Axis.T_CtrleSingle.xErr:= fbAxisNewPosAndVel.Error;
						T_Axis.T_CtrleSingle.udiErrorID:=fbAxisNewPosAndVel.ErrorID;
					END_IF;
					IF (fbAxisNewPosAndVel.ErrorID = 17022) THEN
						diStepErrorCounter:=diStepErrorCounter + 1;
					END_IF;
					IF (fbAxisNewPosAndVel.ErrorID = 16900) THEN
						diStepErrorCounter1:=diStepErrorCounter1 + 1;
					END_IF;
				ELSE
					xNoHWError:=FALSE;
					T_Axis.T_CtrleSingle.xErr:= FALSE;
					T_Axis.T_CtrleSingle.udiErrorID:=0;
				END_IF;
				(* flag new velocity off and new position off *)
				xNewVelocity:=FALSE;
				xNewPosition:=FALSE;
				T_Axis.T_CtrleSingle.iFunction:=iTmpFctNr;
				(* Init. flag busy *)
				T_Axis.T_CtrleSingle.xBusyNewPosAndVel:=FALSE;
				(* Init. FB New pos and vel *)
				fbAxisNewPosAndVel(	Execute:=FALSE, Axis:=T_AxisRefIn);
				tTimeCommLeft:=TimerCommTimeLeft.ET;
				xStartTimerComm:=FALSE;
			END_IF
		ELSE
			(* velocity calculation *)
			IF T_Axis.T_Oscillation.rFrequence >= 0 AND T_Axis.T_Oscillation.rFrequence <= 1 THEN
				rTmpFrequence:=1.05 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence >=1 AND T_Axis.T_Oscillation.rFrequence <= 2 THEN
				rTmpFrequence:=1.25 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence >= 2 AND T_Axis.T_Oscillation.rFrequence <= 3 THEN
				rTmpFrequence:=2.5 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence >= 3 AND T_Axis.T_Oscillation.rFrequence <= 4 THEN
				rTmpFrequence:=5 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence >= 4 AND T_Axis.T_Oscillation.rFrequence <= 5 THEN
				rTmpFrequence:=10 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence > 5 THEN rTmpFrequence:=20; END_IF
			lrTmpVelocity:=(rTmpFrequence * 2 + 1 / rTmpFrequence) * ABS(T_Axis.T_Oscillation.rOffset);
			IF lrTmpVelocity > 250 THEN T_Axis.T_CtrleSingle.lrVelocity:=250;
				ELSE T_Axis.T_CtrleSingle.lrVelocity:=lrTmpVelocity; END_IF
			IF xMovement THEN
				T_Axis.T_CtrleSingle.xDone:=FALSE;
			ELSE
				T_Axis.T_CtrleSingle.xDone:=TRUE;
			END_IF;
			T_Axis.T_CtrleSingle.xErr:= FALSE;
			T_Axis.T_CtrleSingle.udiErrorID:=0;
			xNewVelocity:=FALSE;
			T_Axis.T_CtrleSingle.iFunction:=iTmpFctNr;
			T_Axis.T_CtrleSingle.xBusyNewPosAndVel:=FALSE;
			tTimeCommLeft:=TimerCommTimeLeft.ET;
			xStartTimerComm:=FALSE;
		END_IF;
	ELSE IF NOT(xNewVelocity) AND NOT( xNewPosition) THEN fbAxisNewPosAndVel(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF
	END_IF

(* Set or reset reference flag *)
	IF xSetReferenceFlag OR xResetReferenceFlag THEN
		IF xSetReferenceFlag THEN
		(* set reference flag *)
			xTmp:=TRUE;
		ELSE xTmp:=FALSE;
		END_IF
		fbAxisSetReferenceFlag(Execute:=TRUE, ReferenceFlag:=xTmp, Axis:=T_AxisRefIn);
		IF fbAxisSetReferenceFlag.Done OR fbAxisSetReferenceFlag.Error THEN
			T_Axis.T_CtrleSingle.xDone:=fbAxisSetReferenceFlag.Done;
			T_Axis.T_CtrleSingle.xErr:= fbAxisSetReferenceFlag.Error;
			T_Axis.T_CtrleSingle.udiErrorID:=fbAxisSetReferenceFlag.ErrorID;
			(* set flag 'reference flag' off *)
			xSetReferenceFlag:=FALSE;
			xResetReferenceFlag:=FALSE;
			(* Init. FB set reference *)
			fbAxisSetReferenceFlag(Execute:=FALSE, Axis:=T_AxisRefIn);
		END_IF
	ELSE fbAxisSetReferenceFlag(Execute:=FALSE, Axis:=T_AxisRefIn); END_IF

(* set/reset control position *)
	IF xCtrlePositionOn THEN
		fbExtSetPointGenEnable(	Execute:=TRUE,
								Axis:=T_AxisRefIn);
		IF fbExtSetPointGenEnable.Done OR fbExtSetPointGenEnable.Error THEN
			T_Axis.T_CtrleSingle.xDone:=fbExtSetPointGenEnable.Done;
			T_Axis.T_CtrleSingle.xErr:= fbExtSetPointGenEnable.Error;
			T_Axis.T_CtrleSingle.udiErrorID:=fbExtSetPointGenEnable.ErrorID;
			(* reset flag *)
			xCtrlePositionOn:=FALSE;
		END_IF
	ELSE
		fbExtSetPointGenEnable(	Execute:=FALSE,
								Axis:=T_AxisRefIn);
	END_IF
	IF xCtrlePositionOff THEN
		fbExtSetPointGenDisable(	Execute:=TRUE,
								Axis:=T_AxisRefIn);
		IF fbExtSetPointGenDisable.Done OR fbExtSetPointGenDisable.Error THEN
			T_Axis.T_CtrleSingle.xDone:=fbExtSetPointGenDisable.Done;
			T_Axis.T_CtrleSingle.xErr:= fbExtSetPointGenDisable.Error;
			T_Axis.T_CtrleSingle.udiErrorID:=fbExtSetPointGenDisable.ErrorID;
			(* reset flag *)
			xCtrlePositionOff:=FALSE;
		END_IF
	ELSE
		fbExtSetPointGenDisable(	Execute:=FALSE,
								Axis:=T_AxisRefIn);
	END_IF

(* calcultate angle between Reference Index and Reference Sensor *)
	IF xCalcAngleRefIndex THEN
		(* error or stop => stop oscillation *)
		IF T_Axis.T_CtrleSingle.xErr OR (xStop AND (iTmpFctNr <> 19)) THEN iStepOsc:=99; END_IF
		CASE iStepCalcRefIndex OF
		(* Drive referencing and search the Ref. Index *)
		1:	T_Axis.T_CtrleSingle.rSetPosition:=0.0;
			xHoming:=TRUE;
			iStepCalcRefIndex:=10;
			T_Axis.T_CtrleSingle.iZAngleRefIndex:=0;
			IF (T_Axis.T_Config_Gen.iTyp = 1) THEN
				lrTechUnitPerMotorTurn:=65536.0 * T_Axis.T_Config_ObjFileValue.lrScaleFactor;	(*65536 = inc pro Motorumdrehung-->so kann dann mit dem Skalierungsfaktor ermittelt werden, wieviel Tech.Einheit für eine Motorumdrehung*)
			ELSIF (T_Axis.T_Config_Gen.iTyp = 2) THEN
				lrTechUnitPerMotorTurn:=4096.0 * T_Axis.T_Config_ObjFileValue.lrScaleFactor;	(*4096 = inc pro Motorumdrehung-->so kann dann mit dem Skalierungsfaktor ermittelt werden, wieviel Tech.Einheit für eine Motorumdrehung*)
			ELSE
				lrTechUnitPerMotorTurn:=1048576.0 * T_Axis.T_Config_ObjFileValue.lrScaleFactor;	(*65536 = inc pro Motorumdrehung-->so kann dann mit dem Skalierungsfaktor ermittelt werden, wieviel Tech.Einheit für eine Motorumdrehung*)
			END_IF;
			IF lrTechUnitPerMotorTurn = 0.0 THEN
				IF (T_Axis.T_Config_Gen.iTyp = 1) THEN
					lrTechUnitPerMotorTurn:=2.5;	(* 2.5mm entsprechen einer Motorumdrehung für Stroke Achse *)
				END_IF;
				IF (T_Axis.T_Config_Gen.iTyp = 2) THEN
					lrTechUnitPerMotorTurn:=5.0 / 2.6;	(* 5mm = Steigung, 2.6 = Übersetzunh--<entsprechen einer Motorumdrehung für Z2 Achse *)
				END_IF;
				IF (T_Axis.T_Config_Gen.iTyp = 4) THEN
					lrTechUnitPerMotorTurn:=3.564;	(* 3.564 Grad entsprechen einer Motorumdrehung für PartDisc *)
				END_IF;
				IF (T_Axis.T_Config_Gen.iTyp = 5) THEN
					lrTechUnitPerMotorTurn:=18.0;	(* 18mm entsprechen einer Motorumdrehung für Shuttle *)
				END_IF;
			END_IF;
		10:	IF NOT(xHoming) THEN
				(* Go Absolut to the Reference Index *)
				T_Axis.T_CtrleSingle.lrPosition:=0.0;
				T_Axis.T_CtrleSingle.lrVelocity:=1.0;(*T_Axis.T_Config_ObjFileValue.lrCalVelocityBackward;*)
				T_Axis.T_CtrleSingle.lrAcceleration:=T_Axis.T_Config_ObjFileValue.lrAcceleration;
				T_Axis.T_CtrleSingle.lrDecceleration:=T_Axis.T_Config_ObjFileValue.lrDecceleration;
				T_Axis.T_CtrleSingle.lrJerk:=T_Axis.T_Config_ObjFileValue.lrJerk;
				dwOldOverride:=16#FFFF;
				xMoveAbs:=TRUE;
				iStepCalcRefIndex:=20;
			END_IF;
		20:	IF NOT(xMoveAbs) THEN
				(* Turn the Motor for 360 degrees relativ*)
				xCheckRefState:=xRefHoming;
				T_Axis.T_CtrleSingle.lrDistance:=lrTechUnitPerMotorTurn * -1.0;	(* Der eingesetzte Wert entscheidet ob links oder rechtsdrehend, daher ist es wichtig zu wissen dass der entsprechende Wert, Positiv oder Negativ, die Bewegung zum Ref.Sensor führt *)
				IF (T_Axis.T_Config_Gen.iTyp <> 4) THEN
					T_Axis.T_CtrleSingle.lrVelocity:=1.0;(*T_Axis.T_Config_ObjFileValue.lrCalVelocityBackward;*)
				ELSE
					T_Axis.T_CtrleSingle.lrVelocity:=0.1;(*T_Axis.T_Config_ObjFileValue.lrCalVelocityBackward;*)
				END_IF;
				T_Axis.T_CtrleSingle.lrAcceleration:=T_Axis.T_Config_ObjFileValue.lrAcceleration;
				T_Axis.T_CtrleSingle.lrDecceleration:=T_Axis.T_Config_ObjFileValue.lrDecceleration;
				T_Axis.T_CtrleSingle.lrJerk:=T_Axis.T_Config_ObjFileValue.lrJerk;
				dwOldOverride:=16#FFFF;
				xMoveRel:=TRUE;
				iStepCalcRefIndex:=30;
			END_IF;
		30:	IF (T_Axis.T_Config_Gen.iTyp <> 4) THEN
				T_Axis.T_CtrleSingle.iZAngleRefIndex:=ABS(LREAL_TO_INT((360.0 / lrTechUnitPerMotorTurn) * T_Axis.T_LiveValue.lrActualPosition));	(* Zeiger bewegt sich so dynamisch während der Fahrt auf der Suche des RefSensors *)
			ELSE
				T_Axis.T_CtrleSingle.iZAngleRefIndex:=ABS(LREAL_TO_INT((360.0 / lrTechUnitPerMotorTurn) * (360.0 - T_Axis.T_LiveValue.lrActualPosition)));	(* Zeiger bewegt sich so dynamisch während der Fahrt auf der Suche des RefSensors *)
			END_IF;
			IF xCheckRefState XOR xRefHoming THEN
				lrCapturePosition:=T_Axis.T_LiveValue.lrActualPosition;
				IF (ABS(lrCapturePosition) > ABS(lrTechUnitPerMotorTurn)) THEN
					lrCapturePosition:=360.0 - ABS(lrCapturePosition);
				END_IF;
				xStop:=TRUE;
				iStepCalcRefIndex:=40;
			END_IF;
			IF NOT(xMoveRel) AND NOT(xStop) THEN
				T_Axis.T_CtrleSingle.iZAngleRefIndex:=0;
				iStepCalcRefIndex:=50;
			END_IF;
		40:	IF NOT(xStop) THEN
				T_Axis.T_CtrleSingle.iZAngleRefIndex:=LREAL_TO_INT((360.0 / lrTechUnitPerMotorTurn) * lrCapturePosition);	(* Berechnung der Winkellage des RefIndex zum RefSensor *)
				IF (T_Axis.T_CtrleSingle.iZAngleRefIndex < 0) THEN
					T_Axis.T_CtrleSingle.iZAngleRefIndex:=T_Axis.T_CtrleSingle.iZAngleRefIndex * -1;
				END_IF;
				IF (T_Axis.T_CtrleSingle.iZAngleRefIndex > 360) THEN
					T_Axis.T_CtrleSingle.iZAngleRefIndex:=360;
				END_IF;
				iStepCalcRefIndex:=50;
			END_IF;
		(* End of calc of the ref index position *)
		50:	T_Axis.T_CtrleSingle.xDone:=TRUE;
			T_Axis.T_CtrleSingle.xErr:= FALSE;
			T_Axis.T_CtrleSingle.udiErrorID:=16#0;
			xCalcAngleRefIndex:=FALSE;
		END_CASE;
	ELSE
		iStepCalcRefIndex:=1;
	END_IF;

(* Oscillation *)
	IF xOscillation THEN
		(* error or stop => stop oscillation *)
		IF T_Axis.T_CtrleSingle.xErr OR xStop THEN iStepOsc:=99; END_IF
		CASE iStepOsc OF
		(* init. oscillation + start move*)
		1:	(* init. variable *)
			iOscCounter:=0;
			(* velocity calculation *)
			IF T_Axis.T_Oscillation.rFrequence >= 0 AND T_Axis.T_Oscillation.rFrequence <= 1 THEN
				rTmpFrequence:=1.05 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence >=1 AND T_Axis.T_Oscillation.rFrequence <= 2 THEN
				rTmpFrequence:=1.25 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence >= 2 AND T_Axis.T_Oscillation.rFrequence <= 3 THEN
				rTmpFrequence:=2.5 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence >= 3 AND T_Axis.T_Oscillation.rFrequence <= 4 THEN
				rTmpFrequence:=5 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence >= 4 AND T_Axis.T_Oscillation.rFrequence <= 5 THEN
				rTmpFrequence:=10 * T_Axis.T_Oscillation.rFrequence; END_IF
			IF T_Axis.T_Oscillation.rFrequence > 5 THEN rTmpFrequence:=20; END_IF
			lrTmpVelocity:=(rTmpFrequence * 2 + 1 / rTmpFrequence) * ABS(T_Axis.T_Oscillation.rOffset);
			IF lrTmpVelocity > 250 THEN T_Axis.T_CtrleSingle.lrVelocity:=250;
				ELSE T_Axis.T_CtrleSingle.lrVelocity:=lrTmpVelocity; END_IF
			(*
			(* velocity := frequence * (offset * 2) *)
			T_Axis.T_CtrleSingle.lrVelocity:=T_Axis.T_Oscillation.rFrequence * ABS(T_Axis.T_Oscillation.rOffset) * 2;
			*)
			(* set move *)
			T_Axis.T_CtrleSingle.lrDistance:=T_Axis.T_Oscillation.rOffset;
			xMoveRel:=TRUE;
			(* next step *)
			iStepOsc:=10;
		(* move *)
		10:	IF NOT(xMoveRel) THEN
				(* move *-1 *)
				T_Axis.T_CtrleSingle.lrDistance:=T_Axis.T_Oscillation.rOffset * -1;
				xMoveRel:=TRUE;
				(* next step *)
				iStepOsc:=20;
			END_IF
		(* osc +1 *)
		20:	IF NOT(xMoveRel) THEN
				iOscCounter:=iOscCounter+1;
				IF iOscCounter < T_Axis.T_Oscillation.iCycle THEN
				(* move *)
					T_Axis.T_CtrleSingle.lrDistance:=T_Axis.T_Oscillation.rOffset;
					xMoveRel:=TRUE;
					(* next step *)
					iStepOsc:=10;
				ELSE
				(* oscillation done *)
					T_Axis.T_CtrleSingle.xDone:=TRUE;
					T_Axis.T_CtrleSingle.xErr:= FALSE;
					T_Axis.T_CtrleSingle.udiErrorID:=16#0;
					(* init FB *)
					fbAxisMoveRelative(Execute:=FALSE, Axis:=T_AxisRefIn);
					(* reset flag *)
					xOscillation:=FALSE;
				END_IF
			END_IF
		(* end oscillation *)
		99:	xOscillation:=FALSE;
		END_CASE
	ELSE
	(* init. variable *)
		iStepOsc:=1;
	END_IF

(* Default parameter value *)
	IF xDefaultAxisParameter THEN
		fbDefaultAxisPara(xDefaultValue:=TRUE,T_Axis:=T_Axis);
		T_Axis.T_CtrleSingle.xDone:=TRUE;
		T_Axis.T_CtrleSingle.xErr:= FALSE;
		T_Axis.T_CtrleSingle.udiErrorID:=0;
		(* flag DefaultParameter off *)
		xDefaultAxisParameter:=FALSE;
	END_IF

(* Set/Reset SW Pos limit switch *)
	IF xSetSWPosLimitSwitch OR xResetSWPosLimitSwitch THEN
		CASE iStepSWLimitSwitch OF
		(* control flag *)
		1:	(* init. next step *)
			iStepSWLimitSwitch:=iStepSWLimitSwitch + 1;
			IF T_Axis.T_CtrleSingle.xPower THEN
			(* axis power on, control axis flag *)
				IF (T_AxisRefIn.nStateDWord AND 16#4) = 16#0 THEN
				(* axis is moving, activ error *)
					iStepSWLimitSwitch:=912;
				END_IF
				IF (T_AxisRefIn.nStateDWord AND 16#20) = 16#20 THEN
				(* axis is in slave mode, activ error *)
					iStepSWLimitSwitch:=913;
				END_IF
			END_IF
		2:	IF NOT (fbAdsWrite.BUSY )  THEN
			(* send axis parameter *)
				fbAdsWrite(WRITE:=FALSE);
				IF xSetSWPosLimitSwitch THEN
					lrData:=1;
				ELSE
					lrData:=0;
				END_IF;
				wTmp:=LREAL_TO_WORD(lrData);
				dwAdrVar:=ADR(wTmp);
				fbAdsWrite(	NETID:='',
							PORT:=501,
							IDXGRP:=16#5000 + T_Axis.T_Config_Gen.udiNC_TaskIdxGrp,
							IDXOFFS:=16#C,
							LEN:=16#2,
							SRCADDR:=dwAdrVar,
							WRITE:=TRUE,
							TMOUT:=T#2s);
			ELSE
				fbAdsWrite(WRITE:=FALSE);
			END_IF
			IF NOT(fbAdsWrite.BUSY) AND NOT(fbAdsWrite.ERR) THEN
			(* determin the next step *)
				iStepSWLimitSwitch:=998;
			END_IF
			IF fbAdsWrite.ERR THEN
			(* set next step  *)
				iStepSWLimitSwitch:=901;
			END_IF
				(* ads communication error *)
		901:	T_Axis.T_CtrleSingle.udiErrorID:=fbAdsWrite.ERRID;
			(* set next step *)
			iStepSWLimitSwitch:=991;
		(* error the axis is moving *)
		912:	T_Axis.T_CtrleSingle.udiErrorID:=16#F102;		(* Achsfunktion nicht ausführbar, da Achse in Bewegung ist *)
			(* set next step *)
			iStepSWLimitSwitch:=991;
		(* error the axis is in slave mode *)
		913:	T_Axis.T_CtrleSingle.udiErrorID:=16#F103;		(* Achsfunktion nicht ausführbar, da Achse in Slave Mode ist *)
			(* set next step *)
			iStepSWLimitSwitch:=991;
		(* set flag error *)
		991:	T_Axis.T_CtrleSingle.xDone:=FALSE;
			T_Axis.T_CtrleSingle.xErr:= TRUE;
			(* set last step *)
			iStepSWLimitSwitch:=999;
		(* set flag end function *)
		998:	T_Axis.T_CtrleSingle.xDone:=TRUE;
			T_Axis.T_CtrleSingle.xErr:= FALSE;
			T_Axis.T_CtrleSingle.udiErrorID:=0;
			(* set last step *)
			iStepSWLimitSwitch:=999;
		(* reset variable *)
		999:	xSetSWPosLimitSwitch:=xResetSWPosLimitSwitch:=FALSE;
		END_CASE
	ELSE
		IF NOT(xSendAxisParameter) THEN
			fbAdsWrite(WRITE:=FALSE);
		END_IF;
	END_IF

(* Send parameter *)
	IF xSendAxisParameter THEN
		CASE iStepSendPara OF
		(* control flag *)
		1:	(* init. next step *)
			iStepSendPara:=2;
			xSendBlock:=FALSE;
			IF T_Axis.T_CtrleSingle.xPower THEN
			(* axis power on, control axis flag *)
				IF (T_AxisRefIn.nStateDWord AND 16#4) = 16#0 THEN
				(* axis is moving, activ error *)
					iStepSendPara:=912;
				END_IF
				IF (T_AxisRefIn.nStateDWord AND 16#20) = 16#20 THEN
				(* axis is in slave mode, activ error *)
					iStepSendPara:=913;
				END_IF
			END_IF
		(* set power off *)
		2:	xRestoreAxisPower:=FALSE;
			IF T_Axis.T_CtrleSingle.xPower THEN
			(* set power off *)
				xPowerOff:=TRUE;
				xPowerOn:=NOT(xPowerOff);
				(* set flag restore *)
				xRestoreAxisPower:=TRUE;
				(* start time out *)
				TimerOutSendPara(IN:=FALSE);
				(* next step *)
				iStepSendPara:=3;
			ELSE
			(* already power off, activ send parameter *)
				iStepSendPara:=11;
			END_IF
		(* wait flag power off *)
		3:	IF NOT(T_Axis.T_CtrleSingle.xPower) THEN
			(* activ send parameter *)
				iStepSendPara:=11;
			END_IF
			IF TimerOutSendPara.Q THEN
			(* time out activ, set error *)
				iStepSendPara:=911;
			END_IF
		(* loop sending parameter *)
		11:	IF NOT (fbAdsWrite.BUSY )  AND NOT(xSendBlock) THEN
			(* send axis parameter *)
				fbAdsWrite(WRITE:=FALSE);
				CASE T_Axis.T_ParamFileObj[iPtrAxisParameter].udiLength OF
				(* True/False, 2 bytes*)
				2:	wTmp:=LREAL_TO_WORD(T_Axis.T_ParamFileObj[iPtrAxisParameter].lrReal);
					dwAdrVar:=ADR(wTmp);
				(* dword value, 4 bytes *)
				4:	dwTmp:=LREAL_TO_DWORD(T_Axis.T_ParamFileObj[iPtrAxisParameter].lrReal);
					dwAdrVar:=ADR(dwTmp);
				(* else, 8 bytes *)
				8:	dwAdrVar:=ADR(T_Axis.T_ParamFileObj[iPtrAxisParameter].lrReal);
				END_CASE
				fbAdsWrite(	NETID:='',
							PORT:=501,
							IDXGRP:=T_Axis.T_ParamFileObj[iPtrAxisParameter].udiIdxGroup,
							IDXOFFS:=T_Axis.T_ParamFileObj[iPtrAxisParameter].udiIndexOffset,
							LEN:=T_Axis.T_ParamFileObj[iPtrAxisParameter].udiLength,
							SRCADDR:=dwAdrVar,
							WRITE:=TRUE,
							TMOUT:=T#2s);
				(* next parameter *)
				iPtrAxisParameter:=iPtrAxisParameter+1;
				IF T_Axis.T_ParamFileObj[iPtrAxisParameter].udiIdxGroup = 0 THEN
				(* parameter list empty *)
					xSendBlock:=TRUE;
				END_IF
			ELSE
				fbAdsWrite(WRITE:=FALSE);
			END_IF
			IF NOT(fbAdsWrite.BUSY) AND NOT(fbAdsWrite.ERR) AND T_Axis.T_ParamFileObj[iPtrAxisParameter].udiIdxGroup = 0 THEN
			(* determin the next step *)
				IF xRestoreAxisPower THEN
				(* Restore axis power *)
					iStepSendPara:=101;
				ELSE
				(* set flag end function *)
					iStepSendPara:=998;
				END_IF
			END_IF
			IF fbAdsWrite.ERR THEN
			(* set next step  *)
				iStepSendPara:=901;
			END_IF
		(* set power on *)
		101:	xPowerOn:=TRUE;
			xPowerOff:=NOT(xPowerOn);
			(* start time out *)
			TimerOutSendPara(IN:=FALSE);
			(*  next step *)
			iStepSendPara:=102;
		(* wait flag power on *)
		102:	IF T_Axis.T_CtrleSingle.xPower THEN
			(* set flag end function *)
				iStepSendPara:=998;
			END_IF
			IF TimerOutSendPara.Q THEN
			(* time out activ, set error *)
				iStepSendPara:=911;
			END_IF
		(* ads communication error *)
		901:	T_Axis.T_CtrleSingle.udiErrorID:=fbAdsWrite.ERRID;
			(* set next step *)
			iStepSendPara:=991;
		(* time out after setting axis power on/off *)
		911:	T_Axis.T_CtrleSingle.udiErrorID:=16#F101;		(* Timeout beim senden der Achsparameter an NC Ebene *)
			(* set next step *)
			iStepSendPara:=991;
		(* error the axis is moving *)
		912:	T_Axis.T_CtrleSingle.udiErrorID:=16#F102;		(* Achsfunktion nicht ausführbar, da Achse in Bewegung ist *)
			(* set next step *)
			iStepSendPara:=991;
		(* error the axis is in slave mode *)
		913:	T_Axis.T_CtrleSingle.udiErrorID:=16#F103;		(* Achsfunktion nicht ausführbar, da Achse in Slave Mode ist *)
			(* set next step *)
			iStepSendPara:=991;
		(* set flag error *)
		991:	T_Axis.T_CtrleSingle.xDone:=FALSE;
			T_Axis.T_CtrleSingle.xErr:= TRUE;
			(* set last step *)
			iStepSendPara:=999;
		(* set flag end function *)
		998:	T_Axis.T_CtrleSingle.xDone:=TRUE;
			T_Axis.T_CtrleSingle.xErr:= FALSE;
			T_Axis.T_CtrleSingle.udiErrorID:=0;
			(* set last step *)
			iStepSendPara:=999;
		(* reset variable *)
		999:	xSendAxisParameter:=FALSE;
		END_CASE
	ELSE
		IF NOT(xSetSWPosLimitSwitch) AND NOT(xResetSWPosLimitSwitch) THEN
			fbAdsWrite(WRITE:=FALSE);
		END_IF;
	END_IF

(* send axis string *)
	IF xSendAxisString THEN
		(*IF NOT(fbADS_ReadWriteString.BUSY)   AND sReturnAxis = '' THEN
			fbADS_ReadWriteString(WRTRD:=FALSE);*)
			(* add carriage return and line feed *)
			sSendAxis:=CONCAT(T_Axis.T_CtrleSingle.sSend, '$R$L$00');
			fbADS_ReadWriteString(	NETID:=T_Axis.T_Config_Gen.sServoNetId,
									PORT:=200,
									IDXGRP:=1,
									IDXOFFS:=1,
									WRITELEN:=LEN(sSendAxis)-1,
									READLEN:=LEN(sReturnAxis)-1,
									SRCADDR:=ADR(sSendAxis),
									DESTADDR:=ADR(sReturnAxis),
									WRTRD:=TRUE,
									TMOUT:=T#3s);
		(*ELSE
			fbADS_ReadWriteString(WRTRD:=FALSE);
		END_IF*)
		IF NOT(fbADS_ReadWriteString.BUSY) AND NOT(fbADS_ReadWriteString.ERR) AND sReturnAxis <> '' THEN
			IF sSendAxis = sReturnAxis THEN
			(* received string correct *)
				T_Axis.T_CtrleSingle.xDone:=TRUE;
				T_Axis.T_CtrleSingle.xErr:= FALSE;
				T_Axis.T_CtrleSingle.udiErrorID:=0;
			ELSE
			(* received string incorrect, active error *)
				T_Axis.T_CtrleSingle.xDone:=FALSE;
				T_Axis.T_CtrleSingle.xErr:= TRUE;
				T_Axis.T_CtrleSingle.udiErrorID:=16#F106;		(* Falscher String empfangen beim senden von ASCII Zeichen an NC Ebene *)
			END_IF
			(* set flag xsendaxisstring off *)
			xSendAxisString:=FALSE;
		END_IF
		IF fbADS_ReadWriteString.ERR THEN
		(* set flag error *)
			T_Axis.T_CtrleSingle.xDone:=FALSE;
			T_Axis.T_CtrleSingle.xErr:= TRUE;
			T_Axis.T_CtrleSingle.udiErrorID:=fbADS_ReadWriteString.ERRID;
			(* set flag xsendaxisstring off *)
			xSendAxisString:=FALSE;
		END_IF
	ELSE
		fbADS_ReadWriteString(WRTRD:=FALSE);
	END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_CYL_ANALOG
VAR_INPUT
	xCtrlePosOn:BOOL;
	xCtrlePosOff:BOOL;
	iAnalogIn:INT;
END_VAR
VAR_OUTPUT
	iAnalogOut:INT;
END_VAR
VAR_IN_OUT
	T_Cylinder:ST_CYLINDER;
END_VAR
VAR
(* variable *)
	xConfirmResetFB: BOOL;
	iStep:INT;
(* timer *)
	TimerOn:TON;
	TimerOff:TON;
	TimerPreOn:TON;
	TimerPreOff:TON;
	TimerOut:TON;
	TimerActiv: TON;
(* trigger *)
	RisingEdgeExecute:R_TRIG;
	RisingEdgeReset:R_TRIG;
	RisingEdgeActiv:R_TRIG;
	FallingEdgeActiv:F_TRIG;
	xActiveRampFct: BOOL;
	FBCylAnalogFunction: FB_CylAnalogFunction;
	xStartRampFct: BOOL;
	iTmpAnalogIn: INT;
	xResetRampFct: BOOL;
	TimerAfterSensor: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(* if function bloc set activ then Analog state will be transfered *)
	RisingEdgeActiv(CLK:=T_Cylinder.T_CtrleCyl.xFBActiv);
	FallingEdgeActiv(CLK:=T_Cylinder.T_CtrleCyl.xFBActiv);
	IF RisingEdgeActiv.Q OR FallingEdgeActiv.Q THEN
	(* set Analog Out = In on the rising edge from the activ signal *)
		iAnalogOut:=0;
		T_Cylinder.T_CtrleCyl.T_Analog.xActiv:= FALSE;
	END_IF

(* if bloc disable if activ signal is inactiv *)
	IF T_Cylinder.T_CtrleCyl.xFBActiv THEN
	(* copy control position state *)
		T_Cylinder.T_CtrleCyl.xStatePosOn:=xCtrlePosOn;
		T_Cylinder.T_CtrleCyl.xStatePosOff:=xCtrlePosOff;
	ELSE
	(* exit FB *)
		RETURN;
	END_IF

(* wait for reseting *)
	RisingEdgeReset(CLK:=T_Cylinder.T_CtrleCyl.xReset);
	IF RisingEdgeReset.Q THEN
		(* Init. timer *)
		TimerOn(IN:=TRUE,PT:=T#1ms);
		TimerOff(IN:=TRUE,PT:=T#1ms);
		TimerPreOn(IN:=TRUE,PT:=T#1ms);
		TimerPreOff(IN:=TRUE,PT:=T#1ms);
		TimerOut(IN:=TRUE,PT:=T#1ms);
	(* Init. variable *)
		iStep:=0;
	(* Init. structure *)
		T_Cylinder.T_CtrleCyl.iFunction:=0;
		T_Cylinder.T_CtrleCyl.T_Analog.xActiv:=FALSE;
		IF NOT(T_Cylinder.T_Config.xActivState) THEN
			iAnalogOut:=iAnalogIn;
		ELSE
			iAnalogOut:=0;
		END_IF;
		T_Cylinder.T_CtrleCyl.xDone:=FALSE;
		T_Cylinder.T_CtrleCyl.xErr:=FALSE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
		xActiveRampFct:=xStartRampFct:=FALSE;
		xResetRampFct:=TRUE;
		FBCylAnalogFunction(	xStart:= xStartRampFct,
							xReset:=xResetRampFct);
	(* confirm reset *)
		xConfirmResetFB:=TRUE;
	(* exit function *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_Cylinder.T_CtrleCyl.xDone:=TRUE;
			T_Cylinder.T_CtrleCyl.xErr:=FALSE;
			T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
			(* reset variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* if bloc disable if activ signal is inactiv *)
	IF NOT(T_Cylinder.T_CtrleCyl.xFBActiv) THEN
		RETURN;
	END_IF

(* check active state of the servo valve *)
IF (iAnalogOut <> 0) THEN
	T_Cylinder.T_CtrleCyl.T_Analog.xActiv:=TRUE;
ELSE
	T_Cylinder.T_CtrleCyl.T_Analog.xActiv:=FALSE;
END_IF;

(* wait for execute *)
	RisingEdgeExecute(CLK:=T_Cylinder.T_CtrleCyl.xExecute);
	IF RisingEdgeExecute.Q THEN
		IF NOT(T_Cylinder.T_CtrleCyl.xDone) AND NOT(T_Cylinder.T_CtrleCyl.xErr) THEN
		(* can execute function if both signal are disable *)
			RETURN;
		END_IF
		CASE T_Cylinder.T_CtrleCyl.iFunction OF
		(* disable *)
		1:	iStep:=11;
		(* Activ without sensor position ctrle *)
		2:	iStep:=1;
		(* set value Analog Out = Analog In *)
		4:	iStep:=21;
		(* inverse cylinder state *)
		51:	iStep:=51;
		ELSE
			(* function not implemented *)
			iStep:=0;
			T_Cylinder.T_CtrleCyl.xDone:=FALSE;
			T_Cylinder.T_CtrleCyl.xErr:=TRUE;
			T_Cylinder.T_CtrleCyl.udiErrorID:=16#F000;
			(* exit FB *)
			RETURN;
		END_CASE
		(* Init. variable *)
		T_Cylinder.T_CtrleCyl.xDone:=FALSE;
		T_Cylinder.T_CtrleCyl.xErr:=FALSE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
		(* exit FB *)
		RETURN;
	END_IF

(* Timer activ *)
	TimerOn(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayOn);
	TimerOff(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayOff);
	TimerPreOn(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayPreOn);
	TimerPreOff(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayPreOff);
	TimerOut(IN:=TRUE,PT:=T_Cylinder.T_Config.tTimeOut);
	TimerActiv(IN:=TRUE,PT:=T_Cylinder.T_CtrleCyl.T_Analog.tDelayActiv);
	TimerAfterSensor(IN:=TRUE,PT:=T_Cylinder.T_CtrleCyl.T_Analog.tDelayAfterSensor);

(* waiting for activ *)
	CASE iStep OF
	(* process timer On *)
	1:	IF (T_Cylinder.T_Config.tDelayPreOn = T#0s) THEN
			TimerOn(IN:=FALSE);
			IF (iAnalogIn <> iAnalogOut) AND T_Cylinder.T_Config.xActivState THEN
				iTmpAnalogIn:=iAnalogIn;
				xActiveRampFct:=TRUE;
				iStep:=2;
			ELSIF (iAnalogOut <> 0) AND NOT(T_Cylinder.T_Config.xActivState) THEN
				iTmpAnalogIn:=0;
				xActiveRampFct:=TRUE;
				iStep:=2;
			ELSE
				iStep:=3;
			END_IF;
		ELSE
			TimerPreOn(IN:=FALSE);
			iStep:=4;
		END_IF;
	(* wait for timer On *)
	2:	IF TimerOn.Q AND NOT(xActiveRampFct) THEN
			iStep:=3;
			TimerOut(IN:=FALSE);
		END_IF
	(* control position activ *)
	3:	IF T_Cylinder.T_Config.xCtrlePosOn THEN
		(* position ctrle activ *)
			IF TimerOut.Q THEN
			(* timerout done, activ error cylinder has not activ position reached *)
				iStep:=999;
			ELSE
				IF xCtrlePosOn THEN
				(* Activ position reached, activ confirmation *)
					iStep:=80;
				END_IF
			END_IF
		ELSE
		(* no position ctrle, activ confirm *)
			iStep:=90;
		END_IF
	(* wait for timer Pre On *)
	4:	IF TimerPreOn.Q THEN
			T_Cylinder.T_Config.tDelayPreOn:=T#0s;
			iStep:=1;
		END_IF
	(* process timer Off *)
	11:	IF (T_Cylinder.T_Config.tDelayPreOff = T#0s) THEN
			TimerOff(IN:=FALSE);
			IF (iAnalogIn <> iAnalogOut) AND NOT(T_Cylinder.T_Config.xActivState) THEN
				iTmpAnalogIn:=iAnalogIn;
				xActiveRampFct:=TRUE;
				iStep:=12;
			ELSIF (iAnalogOut <> 0) AND T_Cylinder.T_Config.xActivState THEN
				iTmpAnalogIn:=0;
				xActiveRampFct:=TRUE;
				iStep:=12;
			ELSE
				iStep:=12;
			END_IF;
		ELSE
			TimerPreOff(IN:=FALSE);
			iStep:=14;
		END_IF;
	(* wait for timer Off *)
	12:	IF TimerOff.Q AND NOT(xActiveRampFct) THEN
			iStep:=13;
			TimerOut(IN:=FALSE);
		END_IF
	(* control position inactiv *)
	13:	IF T_Cylinder.T_Config.xCtrlePosOff THEN
		(* control position activ *)
			IF TimerOut.Q THEN
			(* timerout done, activ error 'cylinder has not inactiv position reached' *)
				iStep:=998;
			ELSE
				IF xCtrlePosOff THEN
				(* inactiv position reached, activ confirmation *)
					iStep:=85;
				END_IF
			END_IF
		ELSE
		(* no control position activ, activ confirmation *)
			iStep:=99;
		END_IF
	(* wait for timer Pre Off *)
	14:	IF TimerPreOff.Q THEN
			T_Cylinder.T_Config.tDelayPreOff:=T#0s;
			iStep:=11;
		END_IF
	(* set value Analog Out = Analog In *)
	21:	iTmpAnalogIn:=iAnalogIn;
		xActiveRampFct:=TRUE;
		iStep:=99;
	(* inverse cylinder state *)
	51:	IF (T_Cylinder.T_CtrleCyl.T_Analog.xActiv AND T_Cylinder.T_Config.xActivState) OR (NOT(T_Cylinder.T_CtrleCyl.T_Analog.xActiv) AND NOT(T_Cylinder.T_Config.xActivState)) THEN
			iTmpAnalogIn:=0;
			xActiveRampFct:=TRUE;
		END_IF;
		IF (T_Cylinder.T_CtrleCyl.T_Analog.xActiv AND NOT(T_Cylinder.T_Config.xActivState)) OR (NOT(T_Cylinder.T_CtrleCyl.T_Analog.xActiv) AND T_Cylinder.T_Config.xActivState) THEN
			iTmpAnalogIn:=iAnalogIn;
			xActiveRampFct:=TRUE;
		END_IF;
		iStep:=99;
	80:	IF (T_Cylinder.T_CtrleCyl.T_Analog.tDelayAfterSensor <> T#0s) THEN
			TimerAfterSensor(IN:=FALSE);
			iStep:=81;
		ELSE
			iStep:=90;
		END_IF;
	(* wait for time after sensor *)
	81:	IF TimerAfterSensor.Q THEN
			iStep:=90;
		END_IF
	85:	IF (T_Cylinder.T_CtrleCyl.T_Analog.tDelayAfterSensor <> T#0s) THEN
			TimerAfterSensor(IN:=FALSE);
			iStep:=86;
		ELSE
			iStep:=99;
		END_IF;
	(* wait for time after sensor *)
	86:	IF TimerAfterSensor.Q THEN
			iStep:=99;
		END_IF
	(* test if delay activ *)
	90:	IF T_Cylinder.T_CtrleCyl.T_Analog.tDelayActiv <> T#0s THEN
			TimerActiv(IN:=FALSE);
			iStep:=98;
		ELSE
			iStep:=99;
		END_IF
	(* wait for time delay activ *)
	98:	IF TimerActiv.Q THEN
		(* activ time is over, set variable off *)
			IF NOT(T_Cylinder.T_Config.xActivState) THEN
				iTmpAnalogIn:=iAnalogIn;
				xActiveRampFct:=TRUE;
			ELSE
				iTmpAnalogIn:=0;
				xActiveRampFct:=TRUE;
			END_IF;
			iStep:=99;
		END_IF
	(* process end *)
	99:	IF NOT(xActiveRampFct) THEN
			T_Cylinder.T_CtrleCyl.xDone:=TRUE;
			T_Cylinder.T_CtrleCyl.xErr:=FALSE;
			T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
		END_IF;
	(* error, cylinder not in inactiv position *)
	998:	T_Cylinder.T_CtrleCyl.xDone:=FALSE;
		T_Cylinder.T_CtrleCyl.xErr:=TRUE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#F202;
	(* error, cylinder not in activ position *)
	999:	T_Cylinder.T_CtrleCyl.xDone:=FALSE;
		T_Cylinder.T_CtrleCyl.xErr:=TRUE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#F201;
	END_CASE
(* Set Analog Output with or without Ramp *)
	IF xActiveRampFct THEN
		xStartRampFct:=TRUE;
		FBCylAnalogFunction(	iRampFctOn:= T_Cylinder.T_CtrleCyl.T_Analog.iRampFctOn,
							iRampFctOff:= T_Cylinder.T_CtrleCyl.T_Analog.iRampFctOff,
							rSetOutput:= INT_TO_REAL(iTmpAnalogIn),
							rDeltaOutput:= T_Cylinder.T_CtrleCyl.T_Analog.rStepValue,
							rTau:= 0.0,
							rActualOutput:=INT_TO_REAL(iAnalogOut),
							xStart:= xStartRampFct,
							xReset:=xResetRampFct);
		iAnalogOut:=REAL_TO_INT(FBCylAnalogFunction.rOutput);
		T_Cylinder.T_CtrleCyl.T_Analog.tTimeActivOn:=FBCylAnalogFunction.tOutputTimeOn;
		T_Cylinder.T_CtrleCyl.T_Analog.tTimeActivOff:=FBCylAnalogFunction.tOutputTimeOff;
		IF FBCylAnalogFunction.xEnd THEN
			xActiveRampFct:=xStartRampFct:=FALSE;
			T_Cylinder.T_CtrleCyl.T_Analog.rStepValue:=0.0;
		END_IF;
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_CYL_STANDARD
VAR_INPUT
	xCtrlePosOn:BOOL;
	xCtrlePosOff:BOOL;
END_VAR
VAR_OUTPUT
	xCylinder:BOOL;
END_VAR
VAR_IN_OUT
	T_Cylinder:ST_CYLINDER;
END_VAR
VAR
(* variable *)
	xConfirmResetFB:BOOL:=FALSE;
	iStep:INT;
(* timer *)
	TimerOn:TON;
	TimerOff:TON;
	TimerPreOn:TON;
	TimerPreOff:TON;
	TimerOut:TON;
	TimerActiv: TON;
(* trigger *)
	RisingEdgeActiv:R_TRIG;
	FallingEdgeActiv:F_TRIG;
	RisingEdgeReset:R_TRIG;
	RisingEdgeExecute:R_TRIG;
	TimerAfterSensorOn: TON;
	TimerAfterSensorOff: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(* if function bloc set activ then Analog state will be transfered *)
	RisingEdgeActiv(CLK:=T_Cylinder.T_CtrleCyl.xFBActiv);
	FallingEdgeActiv(CLK:=T_Cylinder.T_CtrleCyl.xFBActiv);
	IF RisingEdgeActiv.Q OR FallingEdgeActiv.Q THEN
	(* set Analog Out = In on the rising edge from the activ signal *)
		xCylinder:=NOT(T_Cylinder.T_Config.xActivState);
		T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:= FALSE;
	END_IF

(* if bloc disable if activ signal is inactiv *)
	IF T_Cylinder.T_CtrleCyl.xFBActiv THEN
	(* copy control position state *)
		T_Cylinder.T_CtrleCyl.xStatePosOn:=xCtrlePosOn;
		T_Cylinder.T_CtrleCyl.xStatePosOff:=xCtrlePosOff;
	ELSE
	(* exit FB *)
		RETURN;
	END_IF

(* wait for reseting *)
	RisingEdgeReset(CLK:=T_Cylinder.T_CtrleCyl.xReset);
	IF RisingEdgeReset.Q THEN
		(* Init. timer *)
		TimerOn(IN:=TRUE,PT:=T#1ms);
		TimerOff(IN:=TRUE,PT:=T#1ms);
		TimerPreOn(IN:=TRUE,PT:=T#1ms);
		TimerPreOff(IN:=TRUE,PT:=T#1ms);
		TimerOut(IN:=TRUE,PT:=T#1ms);
	(* Init. variable *)
		iStep:=0;
	(* Init. structure *)
		T_Cylinder.T_CtrleCyl.iFunction:=0;
		T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:=FALSE;
		xCylinder:=NOT(T_Cylinder.T_Config.xActivState);
		T_Cylinder.T_CtrleCyl.xDone:=FALSE;
		T_Cylinder.T_CtrleCyl.xErr:=FALSE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
	(* confirm reset *)
		xConfirmResetFB:=TRUE;
	(* exit function *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_Cylinder.T_CtrleCyl.xDone:=TRUE;
			T_Cylinder.T_CtrleCyl.xErr:=FALSE;
			T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
			(* reset variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* if bloc disable if activ signal is inactiv *)
	IF NOT(T_Cylinder.T_CtrleCyl.xFBActiv) THEN
		RETURN;
	END_IF

(* wait for execute *)
	RisingEdgeExecute(CLK:=T_Cylinder.T_CtrleCyl.xExecute);
	IF RisingEdgeExecute.Q THEN
		IF NOT(T_Cylinder.T_CtrleCyl.xDone) AND NOT(T_Cylinder.T_CtrleCyl.xErr) THEN
		(* can execute function if both signal are disable *)
			RETURN;
		END_IF
		CASE T_Cylinder.T_CtrleCyl.iFunction OF
		(* disable *)
		1:	iStep:=11;
		(* Activ without sensor position ctrle *)
		2:	iStep:=1;
		(* inverse cylinder state *)
		51:	iStep:=51;
		ELSE
			(* function not implemented *)
			iStep:=0;
			T_Cylinder.T_CtrleCyl.xDone:=FALSE;
			T_Cylinder.T_CtrleCyl.xErr:=TRUE;
			T_Cylinder.T_CtrleCyl.udiErrorID:=16#F000;
			(* exit FB *)
			RETURN;
		END_CASE
		(* Init. variable *)
		T_Cylinder.T_CtrleCyl.xDone:=FALSE;
		T_Cylinder.T_CtrleCyl.xErr:=FALSE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
		(* exit FB *)
		RETURN;
	END_IF

(* Timer activ *)
	TimerOn(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayOn);
	TimerOff(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayOff);
	TimerPreOn(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayPreOn);
	TimerPreOff(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayPreOff);
	TimerOut(IN:=TRUE,PT:=T_Cylinder.T_Config.tTimeOut);
	TimerActiv(IN:=TRUE,PT:=T_Cylinder.T_CtrleCyl.T_Standard.tDelayActiv);
	TimerAfterSensorOn(IN:=TRUE,PT:=T_Cylinder.T_CtrleCyl.T_Standard.tDelayAfterSensorOn);
	TimerAfterSensorOff(IN:=TRUE,PT:=T_Cylinder.T_CtrleCyl.T_Standard.tDelayAfterSensorOff);
(* waiting for activ *)
	IF NOT(T_Cylinder.T_CtrleCyl.xErr) THEN
		CASE iStep OF
		(* process timer On *)
		1:	IF (T_Cylinder.T_Config.tDelayPreOn = T#0s) THEN
				TimerOn(IN:=FALSE);
				xCylinder:=T_Cylinder.T_Config.xActivState;
				T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:=TRUE;
				iStep:=2;
			ELSE
				TimerPreOn(IN:=FALSE);
				iStep:=4;
			END_IF;
		(* wait for timer On *)
		2:	IF TimerOn.Q THEN
				iStep:=3;
				TimerOut(IN:=FALSE);
			END_IF
		(* control position activ *)
		3:	IF T_Cylinder.T_Config.xCtrlePosOn THEN
			(* position ctrle activ *)
				IF TimerOut.Q THEN
				(* timerout done, activ error cylinder has not activ position reached *)
					iStep:=999;
				ELSE
					IF xCtrlePosOn THEN
					(* Activ position reached, activ confirmation *)
						iStep:=80;
					END_IF
				END_IF
			ELSE
			(* no position ctrle, activ confirm *)
				iStep:=90;
			END_IF
		(* wait for timer Pre On *)
		4:	IF TimerPreOn.Q THEN
				T_Cylinder.T_Config.tDelayPreOn:=T#0s;
				iStep:=1;
			END_IF
		(* process timer Off *)
		11:	IF (T_Cylinder.T_Config.tDelayPreOff = T#0s) THEN
				TimerOff(IN:=FALSE);
				xCylinder:=NOT(T_Cylinder.T_Config.xActivState);
				T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:=FALSE;
				iStep:=12;
			ELSE
				TimerPreOff(IN:=FALSE);
				iStep:=14;
			END_IF;
		(* wait for timer Off *)
		12:	IF TimerOff.Q THEN
				iStep:=13;
				TimerOut(IN:=FALSE);
			END_IF
		(* control position inactiv *)
		13:	IF T_Cylinder.T_Config.xCtrlePosOff THEN
			(* control position activ *)
				IF TimerOut.Q THEN
				(* timerout done, activ error 'cylinder has not inactiv position reached' *)
					iStep:=998;
				ELSE
					IF xCtrlePosOff THEN
					(* inactiv position reached, activ confirmation *)
						iStep:=85;
					END_IF
				END_IF
			ELSE
			(* no control position activ, activ confirmation *)
				iStep:=99;
			END_IF
		(* wait for timer Pre Off *)
		14:	IF TimerPreOff.Q THEN
				T_Cylinder.T_Config.tDelayPreOff:=T#0s;
				iStep:=11;
			END_IF
		(* inverse cylinder state *)
		51:	xCylinder:=NOT(xCylinder);
			T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:=NOT(T_Cylinder.T_CtrleCyl.T_Standard.xActivOn);
			iStep:=99;
		80:	IF (T_Cylinder.T_CtrleCyl.T_Standard.tDelayAfterSensorOn <> T#0s) THEN
				TimerAfterSensorOn(IN:=FALSE);
				iStep:=81;
			ELSE
				iStep:=90;
			END_IF;
		(* wait for time after sensor *)
		81:	IF TimerAfterSensorOn.Q THEN
				iStep:=90;
			END_IF
		85:	IF (T_Cylinder.T_CtrleCyl.T_Standard.tDelayAfterSensorOff <> T#0s) THEN
				TimerAfterSensorOff(IN:=FALSE);
				iStep:=86;
			ELSE
				iStep:=99;
			END_IF;
		(* wait for time after sensor *)
		86:	IF TimerAfterSensorOff.Q THEN
				iStep:=99;
			END_IF
		(* test if delay activ *)
		90:	IF T_Cylinder.T_CtrleCyl.T_Standard.tDelayActiv <> T#0s THEN
				TimerActiv(IN:=FALSE);
				iStep:=98;
			ELSE
				iStep:=99;
			END_IF
		(* wait for time delay activ *)
		98:	IF TimerActiv.Q THEN
			(* activ time is over, set variable off *)
				xCylinder:=NOT(T_Cylinder.T_Config.xActivState);
				T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:=FALSE;
				iStep:=99;
			END_IF
		(* process end *)
		99:	T_Cylinder.T_CtrleCyl.xDone:=TRUE;
			T_Cylinder.T_CtrleCyl.xErr:=FALSE;
			T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
		(* error, cylinder not in inactiv position *)
		998:	T_Cylinder.T_CtrleCyl.xDone:=FALSE;
			T_Cylinder.T_CtrleCyl.xErr:=TRUE;
			T_Cylinder.T_CtrleCyl.udiErrorID:=16#F202;
		(* error, cylinder not in activ position *)
		999:	T_Cylinder.T_CtrleCyl.xDone:=FALSE;
			T_Cylinder.T_CtrleCyl.xErr:=TRUE;
			T_Cylinder.T_CtrleCyl.udiErrorID:=16#F201;
		END_CASE
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_CYL_STANDARD_2WAY
VAR_INPUT
	xCtrlePosOn:BOOL;
	xCtrlePosOff:BOOL;
END_VAR
VAR_OUTPUT
	xCylinderOn:BOOL;
	xCylinderOff:BOOL;
END_VAR
VAR_IN_OUT
	T_Cylinder:ST_CYLINDER;
END_VAR
VAR
(* variable *)
	xConfirmResetFB:BOOL:=FALSE;
	iStep:INT;
(* timer *)
	TimerOn:TON;
	TimerOff:TON;
	TimerPreOn:TON;
	TimerPreOff:TON;
	TimerOut:TON;
	TimerActiv: TON;
(* trigger *)
	RisingEdgeActiv:R_TRIG;
	FallingEdgeActiv:F_TRIG;
	RisingEdgeReset:R_TRIG;
	RisingEdgeExecute:R_TRIG;
	TimerAfterSensorOn: TON;
	TimerAfterSensorOff: TON;
	TONWaitSwitch: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(* if function bloc set activ then Analog state will be transfered *)
	RisingEdgeActiv(CLK:=T_Cylinder.T_CtrleCyl.xFBActiv);
	FallingEdgeActiv(CLK:=T_Cylinder.T_CtrleCyl.xFBActiv);
	IF RisingEdgeActiv.Q OR FallingEdgeActiv.Q THEN
	(* set Analog Out = In on the rising edge from the activ signal *)
		xCylinderOn:=NOT(T_Cylinder.T_Config.xActivState);
		xCylinderOff:=NOT(T_Cylinder.T_Config.xActivState);
		T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:= FALSE;
		T_Cylinder.T_CtrleCyl.T_Standard.xActivOff:= FALSE;
	END_IF

(* if bloc disable if activ signal is inactiv *)
	IF T_Cylinder.T_CtrleCyl.xFBActiv THEN
	(* copy control position state *)
		T_Cylinder.T_CtrleCyl.xStatePosOn:=xCtrlePosOn;
		T_Cylinder.T_CtrleCyl.xStatePosOff:=xCtrlePosOff;
	ELSE
	(* exit FB *)
		RETURN;
	END_IF

(* wait for reseting *)
	RisingEdgeReset(CLK:=T_Cylinder.T_CtrleCyl.xReset);
	IF RisingEdgeReset.Q THEN
		(* Init. timer *)
		TimerOn(IN:=TRUE,PT:=T#1ms);
		TimerOff(IN:=TRUE,PT:=T#1ms);
		TimerPreOn(IN:=TRUE,PT:=T#1ms);
		TimerPreOff(IN:=TRUE,PT:=T#1ms);
		TimerOut(IN:=TRUE,PT:=T#1ms);
	(* Init. variable *)
		iStep:=0;
	(* Init. structure *)
		T_Cylinder.T_CtrleCyl.iFunction:=0;
		T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:= FALSE;
		T_Cylinder.T_CtrleCyl.T_Standard.xActivOff:= FALSE;
		xCylinderOn:=NOT(T_Cylinder.T_Config.xActivState);
		xCylinderOff:=NOT(T_Cylinder.T_Config.xActivState);
		T_Cylinder.T_CtrleCyl.xDone:=FALSE;
		T_Cylinder.T_CtrleCyl.xErr:=FALSE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
	(* confirm reset *)
		xConfirmResetFB:=TRUE;
	(* exit function *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_Cylinder.T_CtrleCyl.xDone:=TRUE;
			T_Cylinder.T_CtrleCyl.xErr:=FALSE;
			T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
			(* reset variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* if bloc disable if activ signal is inactiv *)
	IF NOT(T_Cylinder.T_CtrleCyl.xFBActiv) THEN
		RETURN;
	END_IF

(* wait for execute *)
	RisingEdgeExecute(CLK:=T_Cylinder.T_CtrleCyl.xExecute);
	IF RisingEdgeExecute.Q THEN
		IF NOT(T_Cylinder.T_CtrleCyl.xDone) AND NOT(T_Cylinder.T_CtrleCyl.xErr) THEN
		(* can execute function if both signal are disable *)
			RETURN;
		END_IF
		CASE T_Cylinder.T_CtrleCyl.iFunction OF
		(* disable *)
		1:	iStep:=11;
		(* Activ without sensor position ctrle *)
		2:	iStep:=1;
		(* inverse cylinder state *)
		51:	iStep:=51;
		ELSE
			(* function not implemented *)
			iStep:=0;
			T_Cylinder.T_CtrleCyl.xDone:=FALSE;
			T_Cylinder.T_CtrleCyl.xErr:=TRUE;
			T_Cylinder.T_CtrleCyl.udiErrorID:=16#F000;
			(* exit FB *)
			RETURN;
		END_CASE
		(* Init. variable *)
		T_Cylinder.T_CtrleCyl.xDone:=FALSE;
		T_Cylinder.T_CtrleCyl.xErr:=FALSE;
		T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
		(* exit FB *)
		RETURN;
	END_IF

(* Timer activ *)
	TimerOn(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayOn);
	TimerOff(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayOff);
	TimerPreOn(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayPreOn);
	TimerPreOff(IN:=TRUE,PT:=T_Cylinder.T_Config.tDelayPreOff);
	TimerOut(IN:=TRUE,PT:=T_Cylinder.T_Config.tTimeOut);
	TimerActiv(IN:=TRUE,PT:=T_Cylinder.T_CtrleCyl.T_Standard.tDelayActiv);
	TimerAfterSensorOn(IN:=TRUE,PT:=T_Cylinder.T_CtrleCyl.T_Standard.tDelayAfterSensorOn);
	TimerAfterSensorOff(IN:=TRUE,PT:=T_Cylinder.T_CtrleCyl.T_Standard.tDelayAfterSensorOff);

(* waiting for activ *)
	IF NOT(T_Cylinder.T_CtrleCyl.xErr) THEN
		CASE iStep OF
		(* process timer On *)
		1:	IF NOT(xCylinderOn) AND NOT(xCylinderOff) THEN
				iStep:=5;
				xCylinderOn:=FALSE;
				xCylinderOff:=TRUE;
				TONWaitSwitch(IN:=FALSE);
				RETURN;
			END_IF;
			IF (T_Cylinder.T_Config.tDelayPreOn = T#0s) THEN
				TimerOn(IN:=FALSE);
				xCylinderOn:=T_Cylinder.T_Config.xActivState;
				xCylinderOff:=NOT(T_Cylinder.T_Config.xActivState);
				T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:= TRUE;
				T_Cylinder.T_CtrleCyl.T_Standard.xActivOff:= FALSE;
				iStep:=2;
			ELSE
				TimerPreOn(IN:=FALSE);
				iStep:=4;
			END_IF;
		(* wait for timer On *)
		2:	IF TimerOn.Q THEN
				iStep:=3;
				TimerOut(IN:=FALSE);
			END_IF
		(* control position activ *)
		3:	IF T_Cylinder.T_Config.xCtrlePosOn THEN
			(* position ctrle activ *)
				IF TimerOut.Q THEN
				(* timerout done, activ error cylinder has not activ position reached *)
					iStep:=999;
				ELSE
					IF xCtrlePosOn THEN
					(* Activ position reached, activ confirmation *)
						iStep:=80;
					END_IF
				END_IF
			ELSE
			(* no position ctrle, activ confirm *)
				iStep:=90;
			END_IF
		(* wait for timer Pre On *)
		4:	IF TimerPreOn.Q THEN
				T_Cylinder.T_Config.tDelayPreOn:=T#0s;
				iStep:=1;
			END_IF
		5:	TONWaitSwitch(IN:=TRUE,PT:=T#0.1s);
			IF TONWaitSwitch.Q THEN
				TONWaitSwitch(IN:=FALSE);
				iStep:=1;
			END_IF;
		(* process timer Off *)
		11:	IF NOT(xCylinderOn) AND NOT(xCylinderOff) THEN
				iStep:=15;
				xCylinderOn:=FALSE;
				xCylinderOff:=TRUE;
				TONWaitSwitch(IN:=FALSE);
				RETURN;
			END_IF;
			IF (T_Cylinder.T_Config.tDelayPreOff = T#0s) THEN
				TimerOff(IN:=FALSE);
				xCylinderOn:=NOT(T_Cylinder.T_Config.xActivState);
				xCylinderOff:=T_Cylinder.T_Config.xActivState;
				T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:= FALSE;
				T_Cylinder.T_CtrleCyl.T_Standard.xActivOff:= TRUE;
				iStep:=12;
			ELSE
				TimerPreOff(IN:=FALSE);
				iStep:=14;
			END_IF;
		(* wait for timer Off *)
		12:	IF TimerOff.Q THEN
				iStep:=13;
				TimerOut(IN:=FALSE);
			END_IF
		(* control position inactiv *)
		13:	IF T_Cylinder.T_Config.xCtrlePosOff THEN
			(* control position activ *)
				IF TimerOut.Q THEN
				(* timerout done, activ error 'cylinder has not inactiv position reached' *)
					iStep:=998;
				ELSE
					IF xCtrlePosOff THEN
					(* inactiv position reached, activ confirmation *)
						iStep:=85;
					END_IF
				END_IF
			ELSE
			(* no control position activ, activ confirmation *)
				iStep:=99;
			END_IF
		(* wait for timer Pre Off *)
		14:	IF TimerPreOff.Q THEN
				T_Cylinder.T_Config.tDelayPreOff:=T#0s;
				iStep:=11;
			END_IF
		15:	TONWaitSwitch(IN:=TRUE,PT:=T#0.1s);
			IF TONWaitSwitch.Q THEN
				TONWaitSwitch(IN:=FALSE);
				iStep:=11;
			END_IF;
		(* inverse cylinder state *)
		51:	IF xCylinderOn THEN
				xCylinderOn:=FALSE;
				xCylinderOff:=TRUE;
				T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:=FALSE;
				T_Cylinder.T_CtrleCyl.T_Standard.xActivOff:=TRUE;
				iStep:=99;
			ELSIF xCylinderOff THEN
				xCylinderOff:=FALSE;
				xCylinderOn:=TRUE;
				T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:=TRUE;
				T_Cylinder.T_CtrleCyl.T_Standard.xActivOff:=FALSE;
				iStep:=99;
			ELSE
				xCylinderOn:=FALSE;
				xCylinderOff:=FALSE;
				TONWaitSwitch(IN:=FALSE);
				iStep:=52;
			END_IF;
		52:	TONWaitSwitch(IN:=TRUE,PT:=T#0.1s);
			IF TONWaitSwitch.Q THEN
				TONWaitSwitch(IN:=FALSE);
				xCylinderOn:=FALSE;
				xCylinderOff:=TRUE;
				T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:=FALSE;
				T_Cylinder.T_CtrleCyl.T_Standard.xActivOff:=TRUE;
				iStep:=99;
			END_IF;
		80:	IF (T_Cylinder.T_CtrleCyl.T_Standard.tDelayAfterSensorOn <> T#0s) THEN
				TimerAfterSensorOn(IN:=FALSE);
				iStep:=81;
			ELSE
				iStep:=90;
			END_IF;
		(* wait for time after sensor *)
		81:	IF TimerAfterSensorOn.Q THEN
				iStep:=90;
			END_IF
		85:	IF (T_Cylinder.T_CtrleCyl.T_Standard.tDelayAfterSensorOff <> T#0s) THEN
				TimerAfterSensorOff(IN:=FALSE);
				iStep:=86;
			ELSE
				iStep:=99;
			END_IF;
		(* wait for time after sensor *)
		86:	IF TimerAfterSensorOff.Q THEN
				iStep:=99;
			END_IF
		(* test if delay activ *)
		90:	IF T_Cylinder.T_CtrleCyl.T_Standard.tDelayActiv <> T#0s THEN
				TimerActiv(IN:=FALSE);
				iStep:=98;
			ELSE
				iStep:=99;
			END_IF
		(* wait for time delay activ *)
		98:	IF TimerActiv.Q THEN
			(* activ time is over, set variable off *)
				xCylinderOn:=NOT(T_Cylinder.T_Config.xActivState);
				xCylinderOff:=NOT(T_Cylinder.T_Config.xActivState);
				T_Cylinder.T_CtrleCyl.T_Standard.xActivOn:=FALSE;
				T_Cylinder.T_CtrleCyl.T_Standard.xActivOff:=FALSE;
				iStep:=99;
			END_IF
		(* process end *)
		99:	T_Cylinder.T_CtrleCyl.xDone:=TRUE;
			T_Cylinder.T_CtrleCyl.xErr:=FALSE;
			T_Cylinder.T_CtrleCyl.udiErrorID:=16#0;
		(* error, cylinder not in inactiv position *)
		998:	T_Cylinder.T_CtrleCyl.xDone:=FALSE;
			T_Cylinder.T_CtrleCyl.xErr:=TRUE;
			T_Cylinder.T_CtrleCyl.udiErrorID:=16#F202;
		(* error, cylinder not in activ position *)
		999:	T_Cylinder.T_CtrleCyl.xDone:=FALSE;
			T_Cylinder.T_CtrleCyl.xErr:=TRUE;
			T_Cylinder.T_CtrleCyl.udiErrorID:=16#F201;
		END_CASE
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_HDD
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
	T_HDD:ST_HDD;
END_VAR
VAR
(* variable *)
	xConfirmResetFB: BOOL;
	i:INT;
	dwOpenFileMod:DWORD;
	udiHdleFile:UINT;
	xFileOpen: BOOL;
	xFileClose:BOOL;
	xFileRead:BOOL;
	xFileAppendWrite:BOOL;
	xFileCreate:BOOL;
	xFileBiggerAsMaxLine:BOOL;
	xFileDelete: BOOL;
	xRenameFile:BOOL;
(* function bloc *)
	fbFileOpen:FB_FileOpen;
	fbFileWrite:FB_FileWrite;
	fbFileClose:FB_FileClose;
	fbFileGets:FB_FileGets;
	fbFilePuts:FB_FilePuts;
	fbFileDelete:FB_FileDelete;
	fbRenameFile:FB_FileRename;
	fbCreateDir:FB_CreateDir;
	fbRemoveDir:FB_RemoveDir;
(* Trigger *)
	RisingEdgeExecute:R_TRIG;
	RisingEdgeReset:R_TRIG;
	xCreateDirectory: BOOL;
	xRemoveDirectory: BOOL;
	xFileWrite: BOOL;
	ii: INT;
	iCalcLenght: INT;
	jj: INT;
	xFileReadComplete: BOOL;
	fbFileRead: FB_FileRead;
	xFileRead1Line: BOOL;
	xConvertData: BOOL;
	iStepConvertData: INT;
	iStartPoint: INT;
	iStopPoint: INT;
	iStepLength: INT;
	diStepCounter: DINT;
	asCopyString: ARRAY [1..255] OF STRING(255);
	xFirstTime: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* waiting for reset *)
	RisingEdgeReset(CLK:=T_HDD.T_Ctrle.xReset);
	IF RisingEdgeReset.Q THEN
	(* init. function bloc *)
		fbFileOpen(bExecute:=FALSE);
		fbFileClose(bExecute:=FALSE);
		fbFileWrite(bExecute:=FALSE);
		fbFileGets(bExecute:=FALSE);
		fbFilePuts(bExecute:=FALSE);
		fbFileDelete(bExecute:=FALSE);
		fbRenameFile(bExecute:=FALSE);
	(* init. variable *)
		dwOpenFileMod:=0;
		udiHdleFile:=0;
		xFileOpen:=FALSE;
		xFileClose:=FALSE;
		xFileRead:=FALSE;
		xFileRead1Line:=FALSE;
		xFileAppendWrite:=FALSE;
		xFileCreate:=FALSE;
		xFileWrite:=FALSE;
		xFileReadComplete:=FALSE;
		xFileBiggerAsMaxLine:=FALSE;
		xFileDelete:=FALSE;
		xRenameFile:=FALSE;
	(* init. structure *)
		T_HDD.T_Ctrle.xDone:=FALSE;
		T_HDD.T_Ctrle.xErr:=FALSE;
		T_HDD.T_Ctrle.udiErrorID:=0;
		T_HDD.T_Ctrle.iFunction:=0;
		T_HDD.T_File.sPathAndFileName:='';
		T_HDD.T_File.sOldPathAndFileName:='';
		T_HDD.T_Ctrle.tTimeOut:=T#2s;
		T_HDD.T_Ctrle.xLocked:=FALSE;
		IF NOT(xFirstTime) THEN
			xFirstTime:=TRUE;
			FOR ii:= 1 TO 255 DO
				asCopyString[ii]:='';
			END_FOR;
			FOR ii:= 1 TO 255 DO
				FOR jj:=1 TO ii DO
					asCopyString[ii]:=CONCAT(asCopyString[ii],' ');
				END_FOR;
				IF (ii = 250) THEN
					iCalcLenght:=LEN(asCopyString[ii]);
				END_IF;
			END_FOR;
		END_IF;
		(* set flag done *)
		xConfirmResetFB:=TRUE;
		(* exit function *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_HDD.T_Ctrle.xDone:=TRUE;
			T_HDD.T_Ctrle.xErr:=FALSE;
			T_HDD.T_Ctrle.udiErrorID:=0;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			(* init. variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* waiting for execute *)
	RisingEdgeExecute(CLK:=T_HDD.T_Ctrle.xExecute);
	IF RisingEdgeExecute.Q THEN
		CASE T_HDD.T_Ctrle.iFunction OF
		(* Read file *)
		1:	(* activ file open *)
			xFileOpen:=TRUE;
			dwOpenFileMod:=FOPEN_MODEREAD OR FOPEN_MODEPLUS OR FOPEN_MODETEXT;
		(* Write file *)
		2:	(* activ file open *)
			xFileOpen:=TRUE;
			dwOpenFileMod:=FOPEN_MODEWRITE OR FOPEN_MODEPLUS OR FOPEN_MODETEXT;
		(* overwrite file *)
		3:	(* activ file open *)
			xFileOpen:=TRUE;
			dwOpenFileMod:=FOPEN_MODEAPPEND OR FOPEN_MODEPLUS OR FOPEN_MODETEXT;
		(* file exists *)
		4:	(* activ file open *)
			xFileOpen:=TRUE;
			dwOpenFileMod:=FOPEN_MODEREAD OR FOPEN_MODEPLUS OR FOPEN_MODETEXT;
		(* delete file *)
		5:	xFileDelete:=TRUE;
		(* rename file *)
		6:	xRenameFile:=TRUE;
		(* create directory *)
		7:	xCreateDirectory:=TRUE;
		(* remove directory *)
		8:	xRemoveDirectory:=TRUE;
		(* Read file complete *)
		9:	(* activ file open *)
			xFileOpen:=TRUE;
			dwOpenFileMod:=FOPEN_MODEREAD OR FOPEN_MODEPLUS OR FOPEN_MODETEXT;
		(* Write file complete *)
		10:	(* activ file open *)
			xFileOpen:=TRUE;
			dwOpenFileMod:=FOPEN_MODEWRITE OR FOPEN_MODETEXT ;
		(* Read File only 1 line *)
		11:	(* activ file open *)
			xFileOpen:=TRUE;
			dwOpenFileMod:=FOPEN_MODEREAD OR FOPEN_MODEPLUS OR FOPEN_MODETEXT;
		ELSE
		(* function not implemented *)
			 T_HDD.T_Ctrle.xDone:=FALSE;
			 T_HDD.T_Ctrle.xErr:=TRUE;
			 T_HDD.T_Ctrle.udiErrorID:=16#F000;
			 T_HDD.T_Ctrle.xLocked:=FALSE;
			 (* exit FB *)
			 RETURN;
		END_CASE
		(* Init. variable *)
		T_HDD.T_Ctrle.xDone:=FALSE;
		T_HDD.T_Ctrle.xErr:=FALSE;
		T_HDD.T_Ctrle.udiErrorID:=16#0;
		xFileBiggerAsMaxLine:=FALSE;
		(* init. variable*)
		i:=1;
		RETURN;
	END_IF

(* Open file *)
	IF xFileOpen THEN
		fbFileOpen(	sNetId:=T_HDD.T_Config.sNetId,
					sPathName:=T_HDD.T_File.sPathAndFileName,
					nMode:=dwOpenFileMod,
					ePath := PATH_GENERIC,
					bExecute:=TRUE,
					tTimeout:=T#2s);
		IF NOT(fbFileOpen.bBusy) OR fbFileOpen.bError THEN
			IF NOT(fbFileOpen.bError) THEN
				CASE T_HDD.T_Ctrle.iFunction OF
				1:	xFileRead:=TRUE;
				2:	xFileCreate:=TRUE;
				3: 	xFileAppendWrite:=TRUE;
				4:	xFileClose:=TRUE;
				9:	xFileReadComplete:=TRUE;
				10:	xFileWrite:=TRUE;
(*
					FOR ii:=1 TO csiMaxFileLine DO
						iCalcLenght:=LEN(T_HDD.T_Data.sData[ii]);
						iMaxChar:=SIZEOF(T_HDD.T_Data.sData[ii]);
						iCheckElement:=(iMaxChar - 2) - iCalcLenght;
						T_HDD.T_Data.sData[ii]:=CONCAT(T_HDD.T_Data.sData[ii],asCopyString[iCheckElement]);
						iCalcLenght:=LEN(T_HDD.T_Data.sData[ii]);
						T_HDD.T_Data.sData[ii]:=CONCAT(T_HDD.T_Data.sData[ii],'$L');
						iCalcLenght:=LEN(T_HDD.T_Data.sData[ii]);
						IF (ii = 250) THEN
							iCalcLenght:=LEN(T_HDD.T_Data.sData[ii]);
						END_IF;
					END_FOR;
*)
				11:	xFileRead1Line:=TRUE;
				END_CASE
				(* Handle file *)
				udiHdleFile:=fbFileOpen.hFile;
			ELSE
				udiHdleFile:=0;
				 T_HDD.T_Ctrle.xDone:= FALSE;
				 T_HDD.T_Ctrle.xErr:=fbFileOpen.bError;
				 T_HDD.T_Ctrle.udiErrorID:=fbFileOpen.nErrId;
				 T_HDD.T_Ctrle.xLocked:=FALSE;
			END_IF
			(* set flag xfileopen off *)
			xFileOpen:=FALSE;
		END_IF
	ELSE fbFileOpen(bExecute:=FALSE); END_IF

(* Read file *)
	IF xFileRead OR xFileRead1Line THEN
		fbFileGets(	sNetId:=T_HDD.T_Config.sNetId,
					hFile:=udiHdleFile,
					bExecute:=TRUE,
					tTimeOut:=T_HDD.T_Ctrle.tTimeOut);
		IF NOT(fbFileGets.bBusy) OR fbFileGets.bError THEN
			T_HDD.T_Data.sData[i]:=fbFileGets.sLine;
			(* check eof or error *)
			IF fbFileGets.bEOF OR fbFileGets.bError OR i = csiMaxFileLine OR xFileRead1Line THEN
				 (* set flag xFileRead off *)
				 xFileRead:=FALSE;
				xFileRead1Line:=FALSE;
				 (* activ closing file *)
				 xFileClose:=TRUE;
				 (* activ variable file bigger as structure *)
				 IF i = csiMaxFileLine THEN xFileBiggerAsMaxLine:=TRUE; END_IF
			ELSE
			(* read next line *)
				fbFileGets(bExecute:=FALSE);
				i:=i+1;
			END_IF
		END_IF
	ELSE fbFileGets(bExecute:=FALSE); END_IF

(* Write at the end of file or create file *)
	IF xFileAppendWrite OR xFileCreate THEN
		fbFilePuts(	sNetId:=T_HDD.T_Config.sNetId,
					hFile:=udiHdleFile,
					sLine:=CONCAT(T_HDD.T_Data.sData[i],'$L'),
					bExecute:=TRUE,
					tTimeOut:=T_HDD.T_Ctrle.tTimeOut);
		IF NOT(fbFilePuts.bBusy) OR fbFilePuts.bError THEN
			IF T_HDD.T_Data.sData[i+1] = '' THEN
				 (* set flag xFileCreate or xFileAppendWrite off *)
				xFileAppendWrite:=FALSE;
				xFileCreate:=FALSE;
				 (* activ closing file *)
				 xFileClose:=TRUE;
			ELSE
			(* Init. FB *)
				 fbFilePuts(bExecute:=FALSE);
				 (* next line *)
				i:=i+1;
			END_IF
		END_IF
	ELSE IF NOT(xFileAppendWrite) AND NOT(xFileCreate) THEN fbFilePuts(bExecute:=FALSE); END_IF
	END_IF

(* Read the hole file file *)
	IF xFileReadComplete THEN
		fbFileRead(	sNetId:= T_HDD.T_Config.sNetId,
					hFile:= udiHdleFile,
					pReadBuff:=ADR(T_HDD.T_Data.sData),
					cbReadLen:=SIZEOF(T_HDD.T_Data.sData),
					bExecute:= TRUE,
					tTimeout:=T_HDD.T_Ctrle.tTimeOut);
		IF NOT(fbFileRead.bBusy) OR fbFileRead.bError THEN
			fbFileRead(bExecute:=FALSE);
			xFileReadComplete:=FALSE;
			xConvertData:=TRUE;
			iStepConvertData:=1;
		END_IF
	ELSE fbFileRead(bExecute:=FALSE); END_IF
	IF xConvertData THEN
		CASE iStepConvertData OF
		1:	iStartPoint:=1;
			iStepLength:=csiMaxFileLine / 24;
			iStopPoint:=iStartPoint + iStepLength;
			diStepCounter:=0;
			FOR ii:=iStartPoint TO iStopPoint DO
				diStepCounter:=diStepCounter + 1;
				T_HDD.T_Data.sData[ii]:=sFctDeleteChar(T_HDD.T_Data.sData[ii],' ');
				T_HDD.T_Data.sData[ii]:=sFctDeleteChar(T_HDD.T_Data.sData[ii],'$N');
				T_HDD.T_Data.sData[ii]:=sFctDeleteChar(T_HDD.T_Data.sData[ii],'$L');
			END_FOR;
			iStepConvertData:=iStepConvertData + 1;
		2:	iStartPoint:=iStopPoint;
			iStopPoint:=iStartPoint + iStepLength;
			IF (iStartPoint > csiMaxFileLine) THEN iStartPoint:=csiMaxFileLine; END_IF;
			IF (iStopPoint > csiMaxFileLine) THEN iStopPoint:=csiMaxFileLine; END_IF;
			FOR ii:=iStartPoint TO iStopPoint DO
				diStepCounter:=diStepCounter + 1;
				T_HDD.T_Data.sData[ii]:=sFctDeleteChar(T_HDD.T_Data.sData[ii],' ');
				T_HDD.T_Data.sData[ii]:=sFctDeleteChar(T_HDD.T_Data.sData[ii],'$N');
				T_HDD.T_Data.sData[ii]:=sFctDeleteChar(T_HDD.T_Data.sData[ii],'$L');
			END_FOR;
			iStepConvertData:=iStepConvertData + 1;
		3:	IF (iStopPoint >= csiMaxFileLine) THEN
				iStepConvertData:=iStepConvertData + 1;
			ELSE
				iStepConvertData:=2;
			END_IF;
		4:	(* activ closing file *)
			xConvertData:=FALSE;
			iStepConvertData:=1;
			 xFileClose:=TRUE;
		END_CASE;
	END_IF;

(* Write at the end of file or create file *)
	IF xFileWrite THEN
		fbFileWrite(	sNetId:= T_HDD.T_Config.sNetId,
					hFile:= udiHdleFile,
					pWriteBuff:= ADR(T_HDD.T_Data.sData),
					cbWriteLen:= SIZEOF(T_HDD.T_Data.sData),
					bExecute:= TRUE,
					tTimeout:=T_HDD.T_Ctrle.tTimeOut);
		IF NOT(fbFileWrite.bBusy) OR fbFileWrite.bError THEN
			fbFileWrite(bExecute:=FALSE);
			xFileWrite:=FALSE;
			(* activ closing file *)
			 xFileClose:=TRUE;
		END_IF
	ELSE fbFileWrite(bExecute:=FALSE); END_IF

(* Close file *)
	IF xFileClose THEN
		fbFileClose(	sNetId:=T_HDD.T_Config.sNetId,
					hFile:=udiHdleFile,
					bExecute:=TRUE,
					tTimeout:=T#2s);
		IF NOT(fbFileClose.bBusy) OR fbFileClose.bError THEN
			 T_HDD.T_Ctrle.xDone:= NOT(fbFileClose.bBusy);
			 T_HDD.T_Ctrle.xErr:=fbFileClose.bError;
			 T_HDD.T_Ctrle.udiErrorID:=fbFileClose.nErrId;
			 udiHdleFile:=0;
			(* check if file bigger as maximum reading line *)
			IF xFileBiggerAsMaxLine THEN
				T_HDD.T_Ctrle.xErr:=TRUE;
				T_HDD.T_Ctrle.udiErrorID:=16#F501;
			END_IF
			 (* set flag xFileClose off *)
			 xFileClose:=FALSE;
		END_IF
	ELSE fbFileClose(bExecute:=FALSE); END_IF

(* Delete file *)
	IF xFileDelete THEN
		fbFileDelete(	sNetId:=T_HDD.T_Config.sNetId,
					sPathName:=T_HDD.T_File.sPathAndFileName,
					bExecute:=TRUE,
					tTimeout:=T#2s);
		IF NOT(fbFileDelete.bBusy) OR fbFileDelete.bError THEN
			 T_HDD.T_Ctrle.xDone:= NOT(fbFileDelete.bBusy);
			 T_HDD.T_Ctrle.xErr:=fbFileDelete.bError;
			 T_HDD.T_Ctrle.udiErrorID:=fbFileDelete.nErrId;
			 (* set flag xFileDelete off *)
			 xFileDelete:=FALSE;
		END_IF
	ELSE fbFileDelete(bExecute:=FALSE); END_IF

(* rename file *)
	IF xRenameFile THEN
		fbRenameFile(	sNetId:=T_HDD.T_Config.sNetId,
						sOldName:=T_HDD.T_File.sOldPathAndFileName,
						sNewName:=T_HDD.T_File.sPathAndFileName,
						ePath:=PATH_GENERIC,
						bExecute:=TRUE,
						tTimeout:=T#2s);
		IF NOT(fbRenameFile.bBusy) OR fbRenameFile.bError THEN
			 T_HDD.T_Ctrle.xDone:= NOT(fbRenameFile.bBusy);
			 T_HDD.T_Ctrle.xErr:=fbRenameFile.bError;
			 T_HDD.T_Ctrle.udiErrorID:=fbRenameFile.nErrId;
			 (* set flag xFileDelete off *)
			 xRenameFile:=FALSE;
		END_IF
	ELSE fbRenameFile(bExecute:=FALSE); END_IF

(* create directory *)
	IF xCreateDirectory THEN
		fbCreateDir(	sNetId:= T_HDD.T_Config.sNetId,
					sPathName:= T_HDD.T_File.sDirectoryPath,
					ePath:= PATH_GENERIC,
					bExecute:= TRUE,
					tTimeout:= T#2s);
		IF NOT(fbCreateDir.bBusy) OR fbCreateDir.bError THEN
			 T_HDD.T_Ctrle.xDone:= NOT(fbCreateDir.bBusy);
			 T_HDD.T_Ctrle.xErr:=fbCreateDir.bError;
			 T_HDD.T_Ctrle.udiErrorID:=fbCreateDir.nErrId;
			 (* set flag xFileDelete off *)
			 xCreateDirectory:=FALSE;
		END_IF;
	ELSE fbCreateDir(	sNetId:= T_HDD.T_Config.sNetId,
					sPathName:= T_HDD.T_File.sDirectoryPath,
					ePath:= PATH_GENERIC,
					bExecute:= FALSE,
					tTimeout:= T#2s);
	END_IF;

(* remove directory *)
	IF xRemoveDirectory THEN
		(* Verzeichnis kann nur gelöscht werden falls es keine Dateien enthält, anderenfalls wird es nicht gelöscht und diese Funktion setzt einen Fehler *)
		fbRemoveDir(	sNetId:= T_HDD.T_Config.sNetId,
						sPathName:= T_HDD.T_File.sDirectoryPath,
						ePath:= PATH_GENERIC,
						bExecute:= TRUE,
						tTimeout:= T#2s);
		IF NOT(fbRemoveDir.bBusy) OR fbRemoveDir.bError THEN
			 T_HDD.T_Ctrle.xDone:= NOT(fbRemoveDir.bBusy);
			 T_HDD.T_Ctrle.xErr:=fbRemoveDir.bError;
			 T_HDD.T_Ctrle.udiErrorID:=fbRemoveDir.nErrId;
			 (* set flag xFileDelete off *)
			 xRemoveDirectory:=FALSE;
		END_IF;
	ELSE fbRemoveDir(	sNetId:= T_HDD.T_Config.sNetId,
						sPathName:= T_HDD.T_File.sDirectoryPath,
						ePath:= PATH_GENERIC,
						bExecute:= FALSE,
						tTimeout:= T#2s);
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_NOVRAM
VAR_INPUT
	udiDeviceID:UDINT;
END_VAR
VAR_IN_OUT
	T_NovRam:ST_NOVRAM;
END_VAR
VAR_OUTPUT
END_VAR
VAR
(* function bloc *)
	fbNovRamReadWrite:FB_NovRamReadWrite;
(* trigger *)
	RisingEdgeResetFB:R_TRIG;
	RisingEdgeExecute:R_TRIG;
(* variable *)
	xRead:BOOL:=FALSE;
	xWrite:BOOL:=FALSE;
	xConfirmResetFB: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* reset *)
	RisingEdgeResetFB(CLK:=T_NovRam.T_Ctrle.xReset);
	IF RisingEdgeResetFB.Q THEN
	(* init. variable *)
		xRead:=FALSE;
		xWrite:=FALSE;
	(* activ confirmation reset *)
		xConfirmResetFB:=TRUE;
	(* Exit FB *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_NovRam.T_Ctrle.xDone:=TRUE;
			T_NovRam.T_Ctrle.xErr:=FALSE;
			T_NovRam.T_Ctrle.udiErrorID:=16#0;
		(* reset variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* execute *)
	RisingEdgeExecute(CLK:=T_NovRam.T_Ctrle.xExecute);
	IF RisingEdgeExecute.Q THEN
		(* init. capacity and pointer *)
		T_NovRam.T_Ctrle.udipSrcAddr:=ADR(T_NovRam.T_Parameter);
		T_NovRam.T_Ctrle.udiSrcLen:=SIZEOF(T_NovRam.T_Parameter);
		T_NovRam.T_Ctrle.udipDestAddr:=ADR(T_NovRam.T_Parameter);
		T_NovRam.T_Ctrle.udiDestLen:=SIZEOF(T_NovRam.T_Parameter);
		CASE T_NovRam.T_Ctrle.iFunction OF
		(* Read *)
		1:	xRead:=TRUE;
		(* Write *)
		2:	xWrite:=TRUE;
		ELSE
		(* function not implemented *)
			T_NovRam.T_Ctrle.xDone:=FALSE;
			T_NovRam.T_Ctrle.xErr:=TRUE;
			T_NovRam.T_Ctrle.udiErrorID:=16#F000;
			(* Exit FB *)
			RETURN;
		END_CASE
		(* Init. variable *)
		T_NovRam.T_Ctrle.xDone:=FALSE;
		T_NovRam.T_Ctrle.xErr:=FALSE;
		T_NovRam.T_Ctrle.udiErrorID:=0;
	(* Exit FB *)
		RETURN;
	END_IF

(* wait for read/write *)
	IF xRead OR xWrite THEN
		IF NOT(gxHardwareOFF) THEN
			fbNovRamReadWrite(	nDevId:=udiDeviceID,
								bRead:=xRead,
								bWrite:=xWrite,
								cbSrcLen:=T_NovRam.T_Ctrle.udiSrcLen,
								cbDestLen:=T_NovRam.T_Ctrle.udiDestLen,
								pSrcAddr:=T_NovRam.T_Ctrle.udipSrcAddr,
								pDestAddr:=T_NovRam.T_Ctrle.udipDestAddr,
								tTimeOut:=T_NovRam.T_Ctrle.tTimeOut);
			IF NOT(fbNovRamReadWrite.bBusy) OR fbNovRamReadWrite.bError THEN
				IF fbNovRamReadWrite.bError THEN
				(* set error *)
					T_NovRam.T_Ctrle.xDone:=FALSE;
					T_NovRam.T_Ctrle.xErr:=TRUE;
					T_NovRam.T_Ctrle.udiErrorID:=fbNovRamReadWrite.nErrId;
				ELSE
				(* confirm execution *)
					IF xRead THEN
						IF NOT(T_NovRam.T_Ctrle.xBlockReadFirstTime) THEN
							T_NovRam.T_Ctrle.xFirstRead:=TRUE;
						ELSE
							T_NovRam.T_Ctrle.xFirstRead:=FALSE;
						END_IF;
						T_NovRam.T_Ctrle.xBlockReadFirstTime:=FALSE;
					END_IF
					T_NovRam.T_Ctrle.xDone:=TRUE;
					T_NovRam.T_Ctrle.xErr:=FALSE;
					T_NovRam.T_Ctrle.udiErrorID:=0;
				END_IF
				(* reset variable *)
				xRead:=FALSE;
				xWrite:=FALSE;
			END_IF
		ELSE
			T_NovRam.T_Ctrle.xDone:=TRUE;
			T_NovRam.T_Ctrle.xErr:=FALSE;
			T_NovRam.T_Ctrle.udiErrorID:=0;
			(* reset variable *)
			xRead:=FALSE;
			xWrite:=FALSE;
		END_IF;
	ELSE
		fbNovRamReadWrite(	nDevId:=udiDeviceID,
							bRead:=FALSE,
							bWrite:=FALSE);
	END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FB_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_PANEL_IO
VAR_INPUT
	arxButton:ARRAY[1..10] OF BOOL;
END_VAR
VAR_OUTPUT
	arxLed:ARRAY[1..10] OF BOOL;
END_VAR
VAR_IN_OUT
	T_CtrlePanel:ST_CTRLEPANEL;
END_VAR
VAR
(* variable *)
	xConfirmResetFB:BOOL;
	xConfirmFct:BOOL;
	i: INT;
	si: SINT;
(* trigger *)
	RisingEdgeExecute:R_TRIG;
	RisingEdgeReset:R_TRIG;
END_VAR
(* @END_DECLARATION := '0' *)
(* reset function bloc *)
	RisingEdgeReset(CLK:=T_CtrlePanel.xReset);
	IF RisingEdgeReset.Q THEN
	(* reset output *)
		FOR i := 1 TO 10 DO
			arxLed[i]:=FALSE;
		END_FOR
	(* init. structure *)
		T_CtrlePanel.iFunction:=0;
		T_CtrlePanel.xDone:=FALSE;
		T_CtrlePanel.xErr:=FALSE;
		T_CtrlePanel.udiErrorID:=0;
		T_CtrlePanel.udiButton:=0;
		T_CtrlePanel.udiLED:=0;
	(* confirm reset *)
		xConfirmResetFB:=TRUE;
	(* exit fb *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_CtrlePanel.xDone:=TRUE;
			T_CtrlePanel.xErr:=FALSE;
			T_CtrlePanel.udiErrorID:=0;
			(* Init. variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

(* Switch on/off the Led from the control panel *)
	RisingEdgeExecute(CLK:=T_CtrlePanel.xExecute);
	IF RisingEdgeExecute.Q THEN
		CASE T_CtrlePanel.iFunction OF
		(* switch off a specific LED off *)
		-10..-1:	IF arxLed[ABS(T_CtrlePanel.iFunction)] THEN
					arxLed[ABS(T_CtrlePanel.iFunction)]:=FALSE;
					T_CtrlePanel.udiLED:=T_CtrlePanel.udiLED - MUX(ABS(T_CtrlePanel.iFunction)-1,1,2,4,8,16,32,64,128,256,512);
				END_IF
		(* switch off all the LED *)
		0:	FOR i := 1 TO 10 DO
				arxLed[i]:=FALSE;
			END_FOR
			T_CtrlePanel.udiLED:=0;
		(* switch on a specific Led on *)
		1..10:	IF NOT(arxLed[T_CtrlePanel.iFunction]) THEN
					arxLed[T_CtrlePanel.iFunction]:=TRUE;
					T_CtrlePanel.udiLED:=T_CtrlePanel.udiLED + MUX(T_CtrlePanel.iFunction-1,1,2,4,8,16,32,64,128,256,512);
				END_IF
		ELSE
			(* function not implemented *)
			T_CtrlePanel.xDone:=FALSE;
			T_CtrlePanel.xErr:=TRUE;
			T_CtrlePanel.udiErrorID:=16#F000;
			(* exit FB *)
			RETURN;
		END_CASE
		(* Init. variable *)
		T_CtrlePanel.xDone:=FALSE;
		T_CtrlePanel.xErr:=FALSE;
		T_CtrlePanel.udiErrorID:=16#0;
		(* activ confirm *)
		xConfirmFct:=TRUE;
		(* exit FB *)
		RETURN;
	END_IF

(* return the button state *)
	T_CtrlePanel.udiButton:=0;
	FOR i := 0 TO 9 DO
		IF arxButton[i+1] THEN
			T_CtrlePanel.udiButton:=T_CtrlePanel.udiButton + MUX(i,1,2,4,8,16,32,64,128,256,512);
		END_IF
	END_FOR

(* set the led state *)
	FOR si := 0 TO 9 DO
		IF GETBIT32(T_CtrlePanel.udiLED,si) <> 16#0 THEN
			arxLed[si+1]:=TRUE; ELSE arxLed[si+1]:=FALSE; END_IF
	END_FOR

(* wait to confirm *)
	IF xConfirmFct THEN
		T_CtrlePanel.xDone:=TRUE;
		T_CtrlePanel.xErr:=FALSE;
		T_CtrlePanel.udiErrorID:=16#0;
		(* reset variable *)
		xConfirmFct:=FALSE;
	END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/FBDivers' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBConvertParaAxis
VAR_INPUT
	xStart:BOOL;
	iConversion:INT;
	sDeviceName:STRING(255);
END_VAR
VAR_IN_OUT
	T_Axis:ST_AXIS;
	T_Axis_DC : ST_DC_AXIS;
END_VAR
VAR_OUTPUT
	xDone:BOOL;
	xBusy:BOOL;
	xError:BOOL;
	diErrorNr:DINT;
END_VAR
VAR
(* trigger *)
	RisingEdgeStart:R_TRIG;
(* variable *)
	i: INT;
	iPosCarStart,iPosCarStop:INT;
	iStepConvertValueString:INT;
(* tmp variable *)
	sTmp:STRING(255);
	jj: INT;
END_VAR
(* @END_DECLARATION := '0' *)
(* wait start *)
	RisingEdgeStart(CLK:=xStart);
	IF RisingEdgeStart.Q THEN
	(* init. varaible *)
		iStepConvertValueString:=1;
		xDone:=FALSE;
	(*activ busy flag*)
		xBusy:=TRUE;
		xError:=FALSE;
		diErrorNr:=0;
	END_IF

(* test if activ *)
	IF NOT(xBusy) THEN
	(* exit FB *)
		RETURN;
	END_IF
	IF iConversion = 0 THEN
	(* conversion string to value *)
		i:=1;
		(* read string line-->Group or NodeId *)
		sTmp:=T_Axis.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		IF sDeviceName = 'Beckhoff' THEN
			T_Axis.T_Config_Gen.udiNC_TaskIdxGrp:=STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			T_Axis.T_Config_Gen.udiNodeId:=0;
		END_IF;
		IF sDeviceName = 'Maxon' THEN
			T_Axis.T_Config_Gen.udiNC_TaskIdxGrp:=0;
			T_Axis.T_Config_Gen.udiNodeId:=STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
		END_IF;
		i:=i+1;
		(* read string line-->ADS NetID *)
		sTmp:=T_Axis.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		IF sDeviceName = 'Beckhoff' THEN
			T_Axis.T_Config_Gen.sServoNetId:=MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart);
			T_Axis.T_Config_Gen.sAmsNetId:='';
		END_IF;
		IF sDeviceName = 'Maxon' THEN
			T_Axis.T_Config_Gen.sServoNetId:='';
			T_Axis.T_Config_Gen.sAmsNetId:=MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart);
		END_IF;
		i:=i+1;
		(* read string line-->DeviceName *)
		sTmp:=T_Axis.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
   		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		T_Axis.T_Config_Gen.sDeviceFileName:=MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart);
		i:=i+1;
		IF sDeviceName = 'Maxon' THEN
			(* read string line-->Scalefactor only for maxon motor *)
			sTmp:=T_Axis.T_FileObj.sData[i];
			iPosCarStart:=FIND(sTmp,':=')+2;
   			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_CtrleSingle.lrScaleFactor:=STRING_TO_REAL(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			i:=i+1;
			(* read string line-->NominalSpeed only for maxon motor *)
			sTmp:=T_Axis.T_FileObj.sData[i];
			iPosCarStart:=FIND(sTmp,':=')+2;
   			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_CtrleSingle.rNominalSpeed:=STRING_TO_REAL(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			i:=i+1;
		END_IF;
		IF sDeviceName = 'Beckhoff' THEN
			(* read string line-->Quickstop ramp deceleration *)
			sTmp:=T_Axis.T_FileObj.sData[i];
			iPosCarStart:=FIND(sTmp,':=')+2;
	   		iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_Config_Setting.rHCRampDeceleration:=STRING_TO_REAL(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			i:=i+1;
			(* read string line-->Quickstop ramp jerk *)
			sTmp:=T_Axis.T_FileObj.sData[i];
			iPosCarStart:=FIND(sTmp,':=')+2;
	   		iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_Config_Setting.rHCRampJerk:=STRING_TO_REAL(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			i:=i+1;
		END_IF;
		jj:=1;
		(* read string lines *)
		WHILE T_Axis.T_FileObj.sData[i] <> '' DO
			sTmp:=T_Axis.T_FileObj.sData[i];
			(* index group *)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_ParamFileObj[jj].udiIdxGroup:=	STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart))
											+ T_Axis.T_Config_Gen.udiNC_TaskIdxGrp;
			sTmp:=MID(sTmp,LEN(sTmp)-iPosCarStop, iPosCarStop+1);
			(* index offset *)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_ParamFileObj[jj].udiIndexOffset:=STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			sTmp:=MID(sTmp,LEN(sTmp)-iPosCarStop, iPosCarStop+1);
			(* length value *)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_ParamFileObj[jj].udiLength:=STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			sTmp:=MID(sTmp,LEN(sTmp)-iPosCarStop, iPosCarStop+1);
			(* value*)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis.T_ParamFileObj[jj].lrReal:=STRING_TO_REAL(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			(* init existing line, erase text *)
			iPosCarStop:=FIND(T_Axis.T_FileObj.sData[i],'(');
			T_Axis.T_FileObj.sData[i]:=MID(T_Axis.T_FileObj.sData[i],iPosCarStop-1,1);
			(* next line *)
			i:=i+1;
			jj:=jj+1;
		END_WHILE
		(* init. next *)
		T_Axis.T_ParamFileObj[jj].udiIdxGroup:=0;
		T_Axis.T_ParamFileObj[jj].udiIndexOffset:=0;
		T_Axis.T_ParamFileObj[jj].udiLength:=0;
		T_Axis.T_ParamFileObj[jj].lrReal:=0;

	(* Init. NC parameter *)
		i:=1;
		(* Beckhoff *)
		IF sDeviceName = 'Beckhoff' THEN
			(*copy parameter value *)
			WHILE T_Axis.T_ParamFileObj[i].udiIdxGroup <> 0 DO
				CASE (T_Axis.T_ParamFileObj[i].udiIdxGroup - T_Axis.T_Config_Gen.udiNC_TaskIdxGrp) OF
				16#4000:	CASE T_Axis.T_ParamFileObj[i].udiIndexOffset OF
						(* Calibration velocity forward *)
						16#6:	T_Axis.T_Config_ObjFileValue.lrCalVelocityForward:=T_Axis.T_ParamFileObj[i].lrReal;
						(* Calibration velocity backward *)
						16#7:	T_Axis.T_Config_ObjFileValue.lrCalVelocityBackward:=T_Axis.T_ParamFileObj[i].lrReal;
						(* Maximum velocity *)
						16#27:	T_Axis.T_Config_ObjFileValue.lrMaxVelocity:=T_Axis.T_ParamFileObj[i].lrReal;
						(* Acceleration *)
						16#101:	T_Axis.T_Config_ObjFileValue.lrAcceleration:=T_Axis.T_ParamFileObj[i].lrReal;
						(* Decceleration *)
						16#102:	T_Axis.T_Config_ObjFileValue.lrDecceleration:=T_Axis.T_ParamFileObj[i].lrReal;
						(* Jerk *)
						16#103:	T_Axis.T_Config_ObjFileValue.lrJerk:=T_Axis.T_ParamFileObj[i].lrReal;
						END_CASE
				16#5000:	CASE T_Axis.T_ParamFileObj[i].udiIndexOffset OF
						(* Encoder scaling factor *)
						16#6:	T_Axis.T_Config_ObjFileValue.lrScaleFactor:=T_Axis.T_ParamFileObj[i].lrReal;
						(* SW limit negativ On/Off *)
						16#B:	T_Axis.T_Config_ObjFileValue.xSWLimitNeg:=REAL_TO_BOOL(T_Axis.T_ParamFileObj[i].lrReal);
						(* SW limit positiv On/Off *)
						16#C:	T_Axis.T_Config_ObjFileValue.xSWLimitPos:=REAL_TO_BOOL(T_Axis.T_ParamFileObj[i].lrReal);
						(* SW limit negativ value *)
						16#D:	T_Axis.T_Config_ObjFileValue.lrSWLimitNeg:=T_Axis.T_ParamFileObj[i].lrReal;
						(* SW limit position value *)
						16#E:	T_Axis.T_Config_ObjFileValue.lrSWLimitPos:=T_Axis.T_ParamFileObj[i].lrReal;
						END_CASE
				16#6000:;
				16#7000:;
				END_CASE
				(* next parameter *)
				i:=i+1;
			END_WHILE
		END_IF

		(* Maxon *)
		IF sDeviceName = 'Maxon' THEN
			(*copy parameter value *)
			WHILE T_Axis.T_ParamFileObj[i].udiIdxGroup <> 0 DO
				CASE T_Axis.T_ParamFileObj[i].udiIdxGroup  OF
				16#6083:	CASE T_Axis.T_ParamFileObj[i].udiIndexOffset OF
						(* Acceleration *)
						16#0:	T_Axis.T_Config_ObjFileValue.lrAcceleration:=T_Axis.T_ParamFileObj[i].lrReal;
						END_CASE
				16#6084:	CASE T_Axis.T_ParamFileObj[i].udiIndexOffset OF
						(* Decceleration *)
						16#0:	T_Axis.T_Config_ObjFileValue.lrDecceleration:=T_Axis.T_ParamFileObj[i].lrReal;
						END_CASE
				END_CASE
				(* next parameter *)
				i:=i+1;
			END_WHILE
		END_IF
		(* set flag done *)
		xBusy:=FALSE;
		xDone:=TRUE;
	END_IF;
	IF iConversion = 1 THEN
	(* conversion string to value *)
		i:=1;
		(* read string line-->Group or NodeId *)
		sTmp:=T_Axis_DC.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		T_Axis_DC.T_Config_Gen.udiNodeId:=STRING_TO_UDINT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
		i:=i+1;
		(* read string line-->DeviceName *)
		sTmp:=T_Axis_DC.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
   		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		T_Axis_DC.T_Config_Gen.sDeviceFileName:=MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart);
		i:=i+1;
		(* read string line-->Scalefactor *)
		sTmp:=T_Axis_DC.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		T_Axis_DC.T_Config_Gen.lrScaleFactor:=STRING_TO_LREAL(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
		i:=i+1;
		(* read string line-->Initfactor *)
		sTmp:=T_Axis_DC.T_FileObj.sData[i];
		iPosCarStart:=FIND(sTmp,':=')+2;
		iPosCarStop:=FIND(sTmp,';');
		IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
		T_Axis_DC.T_Config_Gen.lrInitFactor:=STRING_TO_LREAL(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
		i:=i+1;
		(* read string lines *)
		WHILE T_Axis_DC.T_FileObj.sData[i] <> '' DO
			sTmp:=T_Axis_DC.T_FileObj.sData[i];
			(* index Register number *)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis_DC.T_ParamFileObj[i - 4].iRegisterNr :=	STRING_TO_INT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			sTmp:=MID(sTmp,LEN(sTmp)-iPosCarStop, iPosCarStop+1);
			(* index bit value *)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis_DC.T_ParamFileObj[i - 4].iBitValue:=STRING_TO_INT(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			sTmp:=MID(sTmp,LEN(sTmp)-iPosCarStop, iPosCarStop+1);
			(* value*)
			iPosCarStart:=FIND(sTmp,':=')+2;
			iPosCarStop:=FIND(sTmp,';');
			IF ((iPosCarStart - 2) = 0) OR (iPosCarStop = 0) OR (iPosCarStart >= iPosCarStop) THEN xBusy:=FALSE;	xDone:=FALSE; xError:=TRUE; diErrorNr:=16#F100;	(* Wrong Syntax from Axis File *) RETURN; END_IF;
			T_Axis_DC.T_ParamFileObj[i - 4].lrReal:=STRING_TO_REAL(MID(sTmp,iPosCarStop-iPosCarStart,iPosCarStart));
			(* init existing line, erase text *)
			iPosCarStop:=FIND(T_Axis_DC.T_FileObj.sData[i],'(');
			T_Axis_DC.T_FileObj.sData[i]:=MID(T_Axis_DC.T_FileObj.sData[i],iPosCarStop-1,1);
			(* next line *)
			i:=i+1;
		END_WHILE
		(* init. next *)
		T_Axis_DC.T_ParamFileObj[i - 4].iRegisterNr:=0;
		T_Axis_DC.T_ParamFileObj[i - 4].iBitValue:=0;
		T_Axis_DC.T_ParamFileObj[i - 4].lrReal:=0;
		(* Init Parameter *)
		i:=1;
		IF sDeviceName = 'MaxonDC' THEN
			(*copy parameter value *)
			WHILE T_Axis_DC.T_ParamFileObj[i].iRegisterNr <> 0 DO
				CASE T_Axis_DC.T_ParamFileObj[i].iRegisterNr OF
				36:	T_Axis_DC.T_Config_ObjFileValue.diMaxMotorCurrent:=LREAL_TO_DINT(T_Axis_DC.T_ParamFileObj[i].lrReal);
				37:	T_Axis_DC.T_Config_ObjFileValue.diNominalMotorCurrent:=LREAL_TO_DINT(T_Axis_DC.T_ParamFileObj[i].lrReal);
				40:	T_Axis_DC.T_Config_ObjFileValue.diMotorResistor:=LREAL_TO_DINT(T_Axis_DC.T_ParamFileObj[i].lrReal);
				42:	T_Axis_DC.T_Config_ObjFileValue.diKpSpeedControl:=LREAL_TO_DINT(T_Axis_DC.T_ParamFileObj[i].lrReal);
				45:	T_Axis_DC.T_Config_ObjFileValue.diTnCurrentControl:=LREAL_TO_DINT(T_Axis_DC.T_ParamFileObj[i].lrReal);
				38:	T_Axis_DC.T_Config_ObjFileValue.diMaxTorqueMotor:=LREAL_TO_DINT(T_Axis_DC.T_ParamFileObj[i].lrReal);
				32:	CASE T_Axis_DC.T_ParamFileObj[i].iBitValue OF
					15:	IF (T_Axis_DC.T_ParamFileObj[i].lrReal = 0) THEN T_Axis_DC.T_Config_ObjFileValue.xSpeedControlAcitv:=TRUE; END_IF;
						IF (T_Axis_DC.T_ParamFileObj[i].lrReal = 1) THEN T_Axis_DC.T_Config_ObjFileValue.xSpeedControlAcitv:=FALSE; END_IF;
					14:	IF (T_Axis_DC.T_ParamFileObj[i].lrReal = 0) THEN T_Axis_DC.T_Config_ObjFileValue.xCurrentControlAcitv:=TRUE; END_IF;
						IF (T_Axis_DC.T_ParamFileObj[i].lrReal = 1) THEN T_Axis_DC.T_Config_ObjFileValue.xCurrentControlAcitv:=FALSE; END_IF;
					13:	IF (T_Axis_DC.T_ParamFileObj[i].lrReal = 0) THEN T_Axis_DC.T_Config_ObjFileValue.xWinCurrentControlActiv:=TRUE; END_IF;
						IF (T_Axis_DC.T_ParamFileObj[i].lrReal = 1) THEN T_Axis_DC.T_Config_ObjFileValue.xWinCurrentControlActiv:=FALSE; END_IF;
					09:	IF (T_Axis_DC.T_ParamFileObj[i].lrReal = 0) THEN T_Axis_DC.T_Config_ObjFileValue.xTorqueControlAcitv:=FALSE; END_IF;
						IF (T_Axis_DC.T_ParamFileObj[i].lrReal = 1) THEN T_Axis_DC.T_Config_ObjFileValue.xTorqueControlAcitv:=TRUE; END_IF;
					10:	IF (T_Axis_DC.T_ParamFileObj[i].lrReal = 0) THEN T_Axis_DC.T_Config_ObjFileValue.xOverVoltageActiv:=FALSE; END_IF;
						IF (T_Axis_DC.T_ParamFileObj[i].lrReal = 1) THEN T_Axis_DC.T_Config_ObjFileValue.xOverVoltageActiv:=TRUE; END_IF;
					END_CASE;
				END_CASE;
				i:=i+1;
			END_WHILE;
		END_IF;
		(* set flag done *)
		xBusy:=FALSE;
		xDone:=TRUE;
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL\/ERROR' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_ErrorMessage
VAR_INPUT
	diErrorNr : DINT;
	T_ErrorList:ST_ERROR_LIST;
END_VAR
VAR_OUTPUT
	sErrorTextEnglish : STRING(100);
	sErrorTextDeutsch : STRING(100);
	sErrorTextFrancais : STRING(100);
END_VAR
VAR
	sTmpText1:STRING(100);
	sTmpText2:STRING(100);
	sTmpText3:STRING(100);
	sTmpText4:STRING(100);
	diTmpErrorNr:DINT;
	ptrErrorList: POINTER TO ST_LANGUAGE_LIST;
	iCounterLanguage: INT;
	sTmpErrorText : STRING(100);
	diTmpDeletePrefix: DINT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                     This Functionblock calculate all errors of the machine an set the follow errornumber                         ************)
(****************************************************************************************************************************************************)
ptrErrorList:=ADR(T_ErrorList.asErrorListDeutsch);	(* pointer of the errorlist, default english *)
sErrorTextEnglish:='';
sErrorTextDeutsch:='';
sErrorTextFrancais:='';
sTmpText1:='';
sTmpText2:='';
diTmpErrorNr:=0;
diTmpDeletePrefix:=0;
(* detect the error of the hardware, station or process *)
(* Fehler aus der Prozesschicht *)
(*IF iStationNr = 0 THEN sTmpText1:='Allg.Fehler: ';END_IF;*)
(* Fehler Prozesschicht *)
IF (diErrorNr < 1000000) THEN
	diTmpDeletePrefix:=0;
END_IF;
(* Fehler Stationen *)
IF (diErrorNr >= 1000000) AND (diErrorNr <= 1999999) THEN
	sTmpText1:='St1: ';
	diTmpDeletePrefix:=1000000;
END_IF;
(* Fehler von den Achsen *)
IF (diErrorNr >= 20000000) AND (diErrorNr <= 20999999) THEN
	diTmpDeletePrefix:=20000000;
	sTmpText2:='Z Achse: ';
END_IF;
IF (diErrorNr >= 24000000) AND (diErrorNr <= 24999999) THEN
	diTmpDeletePrefix:=24000000;
	sTmpText2:='S Achse: ';
END_IF;
(* Fehler von den Zylinder *)
IF (diErrorNr >= 42000000) AND (diErrorNr <= 42999999) THEN
	diTmpDeletePrefix:=42000000;
	sTmpText2:='ZylBremseZ: ';
END_IF;
(* Fehler von Prozessdaten beim schreiben auf USB-Stick *)
IF (diErrorNr >= 82000000) AND (diErrorNr <= 82999999) THEN
	diTmpDeletePrefix:=82000000;
	sTmpText2:='Prozessdaten: ';
END_IF;

FOR iCounterLanguage:=1 TO 3 DO
	sTmpText3:='';
	sTmpText4:='';
	sTmpErrorText:='';
	IF (iCounterLanguage = 1) THEN	ptrErrorList:=ADR(T_ErrorList.asErrorListDeutsch); END_IF;
	IF (iCounterLanguage = 2) THEN	ptrErrorList:=ADR(T_ErrorList.asErrorListEnglish); END_IF;
	IF (iCounterLanguage = 3) THEN	ptrErrorList:=ADR(T_ErrorList.asErrorListFrancais); END_IF;
	IF (diErrorNr >= 0) AND (diErrorNr <= 999999) THEN
		CASE diErrorNr OF
			1:		sTmpText3:=ptrErrorList^.T_LanguagList[76];		(* Not Aus Taste Maschine wurde gedrückt *)
			8:		sTmpText3:=ptrErrorList^.T_LanguagList[83];		(* Keine Druckluft *)
			9:		sTmpText3:=ptrErrorList^.T_LanguagList[100];		(* Spannungsversorgung wurde ausgeschaltet *)
			10:		sTmpText3:=ptrErrorList^.T_LanguagList[6];		(* AX5000 Parameter konnte nicht erfolgreich geschrieben werden *)		(* IGS *)
			11:		sTmpText3:=ptrErrorList^.T_LanguagList[7];		(* Achsen MasterModul2 konnte den Spindelkopf L Kanal 1 nicht finden *)	(* IGS *)
			12:		sTmpText3:=ptrErrorList^.T_LanguagList[10];		(* Achsen MasterModul2 konnte den Spindelkopf M Kanal 2 nicht finden *)	(* IGS *)
			16#F100:	sTmpText3:=ptrErrorList^.T_LanguagList[84];		(* EtherCAT 1 Klemme Fehlerhaft *)
			16#F101:	sTmpText3:=ptrErrorList^.T_LanguagList[85];		(* EtherCAT 2 Klemme Fehlerhaft *)
			16#F102:	sTmpText3:=ptrErrorList^.T_LanguagList[86];		(* Maxon EPOS nicht im Operational Mode OP *)
			16#F103:	sTmpText3:=ptrErrorList^.T_LanguagList[87];		(* SMC Ventilinsel nicht im Operational Mode OP *)
			16#F104:	sTmpText3:=ptrErrorList^.T_LanguagList[88];		(* Achsen MasterModul 1 nicht im Operational Mode OP *)
			16#F105:	sTmpText3:=ptrErrorList^.T_LanguagList[89];		(* Achsen MasterModul 2 nicht im Operational Mode OP *)				(* IGS *)
			16#F106:	sTmpText3:=ptrErrorList^.T_LanguagList[90];		(* Spannungsversorgung 24VDC fehlerhaft *)
			16#F300:	sTmpText3:=ptrErrorList^.T_LanguagList[98];		(* USB-Stick konnte nicht gefunden werden für Profil lesen/schreiben  *)
			16#F301:	sTmpText3:=ptrErrorList^.T_LanguagList[99];		(* USB-Stick konnte nicht gefunden werden für Profil löschen  *)
			16#F303:	sTmpText3:=ptrErrorList^.T_LanguagList[101];		(* Syntaxfehler mindestens einer Profildatei beim lesen aller Profile  *)
			16#F304:	sTmpText3:=ptrErrorList^.T_LanguagList[102];		(* NovRAM Speicher Fehlerhaft  *)
			16#F305:	sTmpText3:=ptrErrorList^.T_LanguagList[104];		(* USB-Stick konnte nicht gefunden werden *)
			16#F306:	sTmpText3:=ptrErrorList^.T_LanguagList[54];		(* Profil konnte nicht gespeichert werden da Verzeichnis fehlt  *)
		ELSE
			sTmpText3:=ptrErrorList^.T_LanguagList[103];	(* Nicht behandelter undefinierter Prozess Fehler *)
		END_CASE;
		IF (iCounterLanguage = 1) THEN sErrorTextDeutsch:=CONCAT(sTmpText1,sTmpText2); sErrorTextDeutsch:=CONCAT(sErrorTextDeutsch,sTmpText3); END_IF;
		IF (iCounterLanguage = 2) THEN sErrorTextEnglish:=CONCAT(sTmpText1,sTmpText2); sErrorTextEnglish:=CONCAT(sErrorTextEnglish,sTmpText3); END_IF;
		IF (iCounterLanguage = 3) THEN sErrorTextFrancais:=CONCAT(sTmpText1,sTmpText2); sErrorTextFrancais:=CONCAT(sErrorTextFrancais,sTmpText3); END_IF;
	ELSE
		IF (diErrorNr >= 1000000) AND (diErrorNr <= 4999999) THEN
			(* Gilt für Bearbeitungsstation *)
			diTmpErrorNr:=diErrorNr - diTmpDeletePrefix;
			CASE diTmpErrorNr OF
				1:	sTmpText3:=ptrErrorList^.T_LanguagList[3];	(* Z Achse-->Negativer HW Endschalter Aktiv *)
				2:	sTmpText3:=ptrErrorList^.T_LanguagList[4];	(* Z Achse-->Positiver HW Endschalter Aktiv *)
				3:	sTmpText3:=ptrErrorList^.T_LanguagList[5];	(* Z Achse-->Positiver + Negativer HW Endschalter Aktiv *)

				5:	sTmpText3:=ptrErrorList^.T_LanguagList[14];	(* Kühlmitteldruck ständig vorhanden *)
				6:	sTmpText3:=ptrErrorList^.T_LanguagList[8];	(* Kalibrierung-->ZylWzAuslenkung Sensor fehlerhaft *)
				7:	sTmpText3:=ptrErrorList^.T_LanguagList[55];	(* Kalibrierung-->ZylWzDrehmHC Sensor fehlerhaft *)
				8:	sTmpText3:=ptrErrorList^.T_LanguagList[56];	(* Kalibrierung-->ZylWzAuslenkung+ZylWzDrehmHC Sensor fehlerhaft *)
				9:	sTmpText3:=ptrErrorList^.T_LanguagList[9];	(* Z Achse muss referenziert sein *)

				11:	sTmpText3:=ptrErrorList^.T_LanguagList[59];	(* Beim starten der Bearbeitung darf DrehmSensorHCÜberlast nicht ON sein *)
				12:	sTmpText3:=ptrErrorList^.T_LanguagList[11];	(* Hubprozesslänge > Z Mech EndPos *)
				13:	sTmpText3:=ptrErrorList^.T_LanguagList[12];	(* Ausfunkhub > Z Mech EndPos *)
				14:	sTmpText3:=ptrErrorList^.T_LanguagList[13];	(* Werkzeug ist nicht im Werkstück eingefädelt *)
				15:	sTmpText3:=ptrErrorList^.T_LanguagList[29];	(* Wz Drehmoment Überlast Aktiv *)
				16:	sTmpText3:=ptrErrorList^.T_LanguagList[28];	(* Wz Drehmoment Max überschritten *)
				17:	sTmpText3:=ptrErrorList^.T_LanguagList[31];	(* Z Bearb EndPos Berechn. > Z Bearb EndPos Max *)

				18:	sTmpText3:=ptrErrorList^.T_LanguagList[33];	(* Zentrier EndPos > Z Mech EndPos *)
				19:	sTmpText3:=ptrErrorList^.T_LanguagList[34];	(* Z ZentrierPos berechn. > Z Bearb EndPos Max *)

				25:	sTmpText3:=ptrErrorList^.T_LanguagList[16];	(* Beim starten der Bearbeitung darf AuslenkSensor nicht ON sein *)
				26:	sTmpText3:=ptrErrorList^.T_LanguagList[17];	(* Beim starten der Bearbeitung darf DrehmSensorHC nicht ON sein *)
				27:	sTmpText3:=ptrErrorList^.T_LanguagList[18];	(* Z LadePos > Z Mech EndPos *)
				28:	sTmpText3:=ptrErrorList^.T_LanguagList[19];	(* Z Bearb StartPos > Z Mech EndPos *)
				29:	sTmpText3:=ptrErrorList^.T_LanguagList[20];	(* Z Bearb EndPos > Z Mech EndPos *)
				30:	sTmpText3:=ptrErrorList^.T_LanguagList[30];	(* Beim Zentrieren muss der ZylWstkEntspannen auf BearbeitPos sein *)			(* IGS3 *)
				31:	sTmpText3:=ptrErrorList^.T_LanguagList[22];	(* Z LadePos: Stimmt nicht mit anderen Positionen überein *)
				32:	sTmpText3:=ptrErrorList^.T_LanguagList[23];	(* Z Bearb StartPos: Stimmt nicht mit anderen Positionen überein *)
				33:	sTmpText3:=ptrErrorList^.T_LanguagList[24];	(* Z Bearb EndPos: Stimmt nicht mit anderen Positionen überein *)
				34:	sTmpText3:=ptrErrorList^.T_LanguagList[21];	(* Z WzWechsel Pos > Z Mech EndPos *)
				35:	sTmpText3:=ptrErrorList^.T_LanguagList[25];	(* Kalibrierung-->ZylWzAuslenkung Zylinder blockiert *)
				36:	sTmpText3:=ptrErrorList^.T_LanguagList[26];	(* Kalibrierung-->ZylWzAuslenkung Sensor fehlerhaft *)

				37:	sTmpText3:=ptrErrorList^.T_LanguagList[32];(* Z ZentrierPos berechn. > Z Mech EndPos *)


				38:	sTmpText3:=ptrErrorList^.T_LanguagList[27];	(* Kalibrierung-->ZylWzAuslenkung Zylinder blockiert *)
				39:	sTmpText3:=ptrErrorList^.T_LanguagList[57];	(* Kalibrierung-->ZylWzDrehmHC Zylinder blockiert *)
				40:	sTmpText3:=ptrErrorList^.T_LanguagList[58];	(* Kalibrierung-->ZylWzAuslenkung+ZylWzDrehmHC Zylinder blockiert *)

				41:	sTmpText3:=ptrErrorList^.T_LanguagList[60];	(* Zentrierproz. HC1 eingetroffen *)
				42:	sTmpText3:=ptrErrorList^.T_LanguagList[61];	(* Zentrierproz. StartPos erreicht und HC2 immer noch ON *)

				43:	sTmpText3:=ptrErrorList^.T_LanguagList[35];	(* Z WzZylinder Pos > Z Mech EndPos *)

				44:	sTmpText3:=ptrErrorList^.T_LanguagList[36];	(* Beim zylindrischer Teil wurde die Max EndPos erreicht  *)

				16#F101:	sTmpText3:=ptrErrorList^.T_LanguagList[48];	(* WzWechsel muss vorgenommen werden *)
				16#F220:	sTmpText3:=ptrErrorList^.T_LanguagList[1];	(* Fehler / Error während disable (Ausschalten) der Station  *)
				16#F300:	sTmpText3:=ptrErrorList^.T_LanguagList[98];	(* USB-Stick konnte nicht gefunden werden für Profil lesen/schreiben  *)
				16#F301:	sTmpText3:=ptrErrorList^.T_LanguagList[49];	(* Datei für zu ladendes Profil nicht gefunden  *)
				16#F302:	sTmpText3:=ptrErrorList^.T_LanguagList[99];	(* USB-Stick konnte nicht gefunden werden für Profil löschen  *)
				16#F303:	sTmpText3:=ptrErrorList^.T_LanguagList[51];	(* Profilname von Datei ist anders als geladenes Profil  *)
				16#F304:	sTmpText3:=ptrErrorList^.T_LanguagList[52];	(* Syntaxfehler von zu ladendes Profil  *)
				16#F305:	sTmpText3:=ptrErrorList^.T_LanguagList[102];	(* NovRAM Speicher Fehlerhaft  *)
				16#F306:	sTmpText3:=ptrErrorList^.T_LanguagList[54];	(* Profil konnte nicht gespeichert werden da Verzeichnis fehlt  *)
			ELSE
						sTmpText3:=ptrErrorList^.T_LanguagList[2];	(* Nicht behandelter undefinierter Station Fehler *)
			END_CASE;
		END_IF;

		IF (diErrorNr >= 20000000) AND (diErrorNr <= 33999999) THEN
			(* Gilt für alle Achsen *)
			diTmpErrorNr:=diErrorNr - diTmpDeletePrefix;
			CASE diTmpErrorNr OF
			(* Gilt für Beckhoff und Maxon *)
				16#F000:	sTmpText3:=ptrErrorList^.T_LanguagList[66];	(* Aufgerufene Achsfunktion besteht nicht *)
				16#F100:	sTmpText3:=ptrErrorList^.T_LanguagList[67];	(* Achsfunktion nicht ausführbar wenn Stop-Funktion Aktiv *)
				16#F501:	sTmpText3:=ptrErrorList^.T_LanguagList[109];	(* Bremse Aktiv von ST1 *)
				16#F502:	sTmpText3:=ptrErrorList^.T_LanguagList[29];	(* Wz Drehmoment Überlast Aktiv *)
			ELSE
				sTmpText3:=DINT_TO_STRING(diTmpErrorNr);
				IF (diTmpErrorNr = 16#4550) THEN
					sTmpText3:=CONCAT(sTmpText3,ptrErrorList^.T_LanguagList[75]);	(* (Schleppabstandsüberschreitung) *)
				END_IF;
			END_CASE;
		END_IF;

		IF (diErrorNr >= 40000000) AND (diErrorNr <= 77999999) THEN
			(* Gilt für alle Zylinder *)
			diTmpErrorNr:=diErrorNr - diTmpDeletePrefix;
			CASE diTmpErrorNr OF
			16#F000:		sTmpText3:=ptrErrorList^.T_LanguagList[105];	(* Zylinder Funktion nicht implementiert *)
			16#F201:		sTmpText3:=ptrErrorList^.T_LanguagList[106];	(* Zylinder Aktiv-->Sensor nicht ON *)
			16#F202:		sTmpText3:=ptrErrorList^.T_LanguagList[107];	(* Zylinder Inaktiv-->Sensor nicht ON *)
			ELSE
						sTmpText3:=ptrErrorList^.T_LanguagList[108];	(* Nicht behandelter undefinierter Zylinder Fehler *)
			END_CASE;
		END_IF;

		IF (diErrorNr >= 82000000) AND (diErrorNr <= 85999999) THEN
			(* Gilt für alle Prozessdaten *)
			diTmpErrorNr:=diErrorNr - diTmpDeletePrefix;
			CASE diTmpErrorNr OF
			201:		sTmpText3:=ptrErrorList^.T_LanguagList[146];	(* HDD steht nicht Bereit *)
			202:		sTmpText3:=ptrErrorList^.T_LanguagList[147];	(* Timeout beim Schreiben auf USB-Stick *)
			203:		sTmpText3:=ptrErrorList^.T_LanguagList[148];	(* USB Stick nicht schreibbar *)
			204:		sTmpText3:=ptrErrorList^.T_LanguagList[149];	(* USB Stick nicht gefunden *)
			END_CASE;
		END_IF;

		IF (iCounterLanguage = 1) THEN sErrorTextDeutsch:=CONCAT(sTmpText1,sTmpText2); sErrorTextDeutsch:=CONCAT(sErrorTextDeutsch,sTmpText3); END_IF;
		IF (iCounterLanguage = 2) THEN sErrorTextEnglish:=CONCAT(sTmpText1,sTmpText2); sErrorTextEnglish:=CONCAT(sErrorTextEnglish,sTmpText3); END_IF;
		IF (iCounterLanguage = 3) THEN sErrorTextFrancais:=CONCAT(sTmpText1,sTmpText2); sErrorTextFrancais:=CONCAT(sErrorTextFrancais,sTmpText3); END_IF;
	END_IF;
END_FOR;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL\/ERROR' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_InitErrorList
VAR_INPUT
END_VAR
VAR_IN_OUT
	T_ErrorList:ST_ERROR_LIST;
END_VAR
VAR_OUTPUT
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
(* Static Deutsch Error List *)
T_ErrorList.asErrorListDeutsch.T_LanguagList[1]:='Fehler / Error während disable (Ausschalten) der Station';
T_ErrorList.asErrorListDeutsch.T_LanguagList[2]:='Nicht behandelter undefinierter Station Fehler';
T_ErrorList.asErrorListDeutsch.T_LanguagList[3]:='Z Achse-->Negativer HW Endschalter Aktiv';
T_ErrorList.asErrorListDeutsch.T_LanguagList[4]:='Z Achse-->Positiver HW Endschalter Aktiv';
T_ErrorList.asErrorListDeutsch.T_LanguagList[5]:='Z Achse-->Positiver + Negativer HW Endschalter Aktiv';
T_ErrorList.asErrorListDeutsch.T_LanguagList[6]:='AX5000 Parameter konnte nicht erfolgreich geschrieben werden';
T_ErrorList.asErrorListDeutsch.T_LanguagList[7]:='Achsen MasterModul2 konnte den Spindelkopf L Kanal 1 nicht finden';
T_ErrorList.asErrorListDeutsch.T_LanguagList[8]:='Kalibrierung-->ZylWzAuslenkung Sensor fehlerhaft';
T_ErrorList.asErrorListDeutsch.T_LanguagList[9]:='Z Achse muss referenziert sein';
T_ErrorList.asErrorListDeutsch.T_LanguagList[10]:='Achsen MasterModul2 konnte den Spindelkopf M Kanal 2 nicht finden';
T_ErrorList.asErrorListDeutsch.T_LanguagList[11]:='Hubprozesslänge > Z Mech EndPos';
T_ErrorList.asErrorListDeutsch.T_LanguagList[12]:='Ausfunkhub > Z Mech EndPos';
T_ErrorList.asErrorListDeutsch.T_LanguagList[13]:='Werkzeug ist nicht im Werkstück eingefädelt';
T_ErrorList.asErrorListDeutsch.T_LanguagList[14]:='Kühlmitteldruck ständig vorhanden';
T_ErrorList.asErrorListDeutsch.T_LanguagList[15]:='Fehler 15';
T_ErrorList.asErrorListDeutsch.T_LanguagList[16]:='Beim starten der Bearbeitung darf AuslenkSensor nicht ON sein';
T_ErrorList.asErrorListDeutsch.T_LanguagList[17]:='Beim starten der Bearbeitung darf DrehmSensorHC nicht ON sein';
T_ErrorList.asErrorListDeutsch.T_LanguagList[18]:='Z LadePos > Z Mech EndPos';
T_ErrorList.asErrorListDeutsch.T_LanguagList[19]:='Z Bearb StartPos > Z Mech EndPos';
T_ErrorList.asErrorListDeutsch.T_LanguagList[20]:='Z Bearb EndPos > Z Mech EndPos';
T_ErrorList.asErrorListDeutsch.T_LanguagList[21]:='Z WzWechsel Pos > Z Mech EndPos';
T_ErrorList.asErrorListDeutsch.T_LanguagList[22]:='Z LadePos: Stimmt nicht mit anderen Positionen überein';
T_ErrorList.asErrorListDeutsch.T_LanguagList[23]:='Z Bearb StartPos: Stimmt nicht mit anderen Positionen überein';
T_ErrorList.asErrorListDeutsch.T_LanguagList[24]:='Z Bearb EndPos: Stimmt nicht mit anderen Positionen überein';
T_ErrorList.asErrorListDeutsch.T_LanguagList[25]:='Kalibrierung-->ZylWzAuslenkung Zylinder blockiert';
T_ErrorList.asErrorListDeutsch.T_LanguagList[26]:='Kalibrierung-->ZylWzAuslenkung Sensor fehlerhaft';
T_ErrorList.asErrorListDeutsch.T_LanguagList[27]:='Fehler 27';
T_ErrorList.asErrorListDeutsch.T_LanguagList[28]:='Wz Drehmoment Max überschritten';
T_ErrorList.asErrorListDeutsch.T_LanguagList[29]:='Wz Drehmoment Überlast Aktiv';
T_ErrorList.asErrorListDeutsch.T_LanguagList[30]:='Beim Zentrieren muss der ZylWstkEntspannen auf BearbeitPos sein';
T_ErrorList.asErrorListDeutsch.T_LanguagList[31]:='Z Bearb EndPos Berechn. > Z Bearb EndPos Max';
T_ErrorList.asErrorListDeutsch.T_LanguagList[32]:='Z ZentrierPos berechn. > Z Mech EndPos';
T_ErrorList.asErrorListDeutsch.T_LanguagList[33]:='Zentrier EndPos > Z Mech EndPos';
T_ErrorList.asErrorListDeutsch.T_LanguagList[34]:='Z ZentrierPos berechn. > Z Bearb EndPos Max';
T_ErrorList.asErrorListDeutsch.T_LanguagList[35]:='Z WzZylinder Pos > Z Mech EndPos';
T_ErrorList.asErrorListDeutsch.T_LanguagList[36]:='Beim zylindrischer Teil wurde die Max EndPos erreicht';
T_ErrorList.asErrorListDeutsch.T_LanguagList[37]:='Fehler 37';
T_ErrorList.asErrorListDeutsch.T_LanguagList[38]:='Fehler 38';
T_ErrorList.asErrorListDeutsch.T_LanguagList[39]:='Fehler 39';
T_ErrorList.asErrorListDeutsch.T_LanguagList[40]:='Fehler 40';
T_ErrorList.asErrorListDeutsch.T_LanguagList[41]:='Fehler 41';
T_ErrorList.asErrorListDeutsch.T_LanguagList[42]:='Fehler 42';
T_ErrorList.asErrorListDeutsch.T_LanguagList[43]:='Fehler 43';
T_ErrorList.asErrorListDeutsch.T_LanguagList[44]:='Fehler 44';
T_ErrorList.asErrorListDeutsch.T_LanguagList[45]:='Fehler 45';
T_ErrorList.asErrorListDeutsch.T_LanguagList[46]:='Fehler 46';
T_ErrorList.asErrorListDeutsch.T_LanguagList[47]:='Fehler 47';
T_ErrorList.asErrorListDeutsch.T_LanguagList[48]:='WzWechsel muss vorgenommen werden';
T_ErrorList.asErrorListDeutsch.T_LanguagList[49]:='Datei für zu ladendes Profil nicht gefunden';
T_ErrorList.asErrorListDeutsch.T_LanguagList[50]:='Fehler 50';
T_ErrorList.asErrorListDeutsch.T_LanguagList[51]:='Profilname von Datei ist anders als geladenes Profil';
T_ErrorList.asErrorListDeutsch.T_LanguagList[52]:='Syntaxfehler von zu ladendes Profil';
T_ErrorList.asErrorListDeutsch.T_LanguagList[53]:='Fehler 53';
T_ErrorList.asErrorListDeutsch.T_LanguagList[54]:='Profil konnte nicht gespeichert werden da Verzeichnis fehlt';
T_ErrorList.asErrorListDeutsch.T_LanguagList[55]:='Kalibrierung-->ZylWzDrehmHC Sensor fehlerhaft';
T_ErrorList.asErrorListDeutsch.T_LanguagList[56]:='Kalibrierung-->ZylWzAuslenkung+ZylWzDrehmHC Sensor fehlerhaft';
T_ErrorList.asErrorListDeutsch.T_LanguagList[57]:='Kalibrierung-->ZylWzDrehmHC Zylinder blockiert';
T_ErrorList.asErrorListDeutsch.T_LanguagList[58]:='Kalibrierung-->ZylWzAuslenkung+ZylWzDrehmHC Zylinder blockiert';
T_ErrorList.asErrorListDeutsch.T_LanguagList[59]:='Beim starten der Bearbeitung darf DrehmSensorHCÜberlast nicht ON sein';
T_ErrorList.asErrorListDeutsch.T_LanguagList[60]:='Zentrierproz. HC1 eingetroffen';
T_ErrorList.asErrorListDeutsch.T_LanguagList[61]:='Zentrierproz. StartPos erreicht und HC2 immer noch ON';
T_ErrorList.asErrorListDeutsch.T_LanguagList[62]:='Fehler 62';
T_ErrorList.asErrorListDeutsch.T_LanguagList[63]:='Fehler 63';
T_ErrorList.asErrorListDeutsch.T_LanguagList[64]:='Fehler 64';
T_ErrorList.asErrorListDeutsch.T_LanguagList[65]:='Fehler 65';
T_ErrorList.asErrorListDeutsch.T_LanguagList[66]:='Aufgerufene Achsfunktion besteht nicht';
T_ErrorList.asErrorListDeutsch.T_LanguagList[67]:='Achsfunktion nicht ausführbar wenn Stop-Funktion Aktiv';
T_ErrorList.asErrorListDeutsch.T_LanguagList[68]:='Fehler 68';
T_ErrorList.asErrorListDeutsch.T_LanguagList[69]:='Fehler 69';
T_ErrorList.asErrorListDeutsch.T_LanguagList[70]:='Fehler 70';
T_ErrorList.asErrorListDeutsch.T_LanguagList[71]:='Fehler 71';
T_ErrorList.asErrorListDeutsch.T_LanguagList[72]:='Fehler 72';
T_ErrorList.asErrorListDeutsch.T_LanguagList[73]:='Fehler 73';
T_ErrorList.asErrorListDeutsch.T_LanguagList[74]:='Fehler 74';
T_ErrorList.asErrorListDeutsch.T_LanguagList[75]:='(Schleppabstandsüberschreitung)';
T_ErrorList.asErrorListDeutsch.T_LanguagList[76]:='Not Aus Taste Maschine wurde gedrückt';
T_ErrorList.asErrorListDeutsch.T_LanguagList[77]:='Fehler 77';
T_ErrorList.asErrorListDeutsch.T_LanguagList[78]:='Fehler 78';
T_ErrorList.asErrorListDeutsch.T_LanguagList[79]:='Fehler 79';
T_ErrorList.asErrorListDeutsch.T_LanguagList[80]:='Fehler 80';
T_ErrorList.asErrorListDeutsch.T_LanguagList[81]:='Fehler 81';
T_ErrorList.asErrorListDeutsch.T_LanguagList[82]:='Fehler 82';
T_ErrorList.asErrorListDeutsch.T_LanguagList[83]:='Keine Druckluft';
T_ErrorList.asErrorListDeutsch.T_LanguagList[84]:='EtherCAT 1 Klemme Fehlerhaft';
T_ErrorList.asErrorListDeutsch.T_LanguagList[85]:='EtherCAT 2 Klemme Fehlerhaft';
T_ErrorList.asErrorListDeutsch.T_LanguagList[86]:='Maxon EPOS nicht im Operational Mode OP';
T_ErrorList.asErrorListDeutsch.T_LanguagList[87]:='SMC Ventilinsel nicht im Operational Mode OP';
T_ErrorList.asErrorListDeutsch.T_LanguagList[88]:='Achsen MasterModul 1 nicht im Operational Mode OP';
T_ErrorList.asErrorListDeutsch.T_LanguagList[89]:='Achsen MasterModul 2 nicht im Operational Mode OP';
T_ErrorList.asErrorListDeutsch.T_LanguagList[90]:='Spannungsversorgung 24VDC fehlerhaft';
T_ErrorList.asErrorListDeutsch.T_LanguagList[91]:='Fehler 91';
T_ErrorList.asErrorListDeutsch.T_LanguagList[92]:='Fehler 92';
T_ErrorList.asErrorListDeutsch.T_LanguagList[93]:='Fehler 93';
T_ErrorList.asErrorListDeutsch.T_LanguagList[94]:='Fehler 94';
T_ErrorList.asErrorListDeutsch.T_LanguagList[95]:='Fehler 95';
T_ErrorList.asErrorListDeutsch.T_LanguagList[96]:='Fehler 96';
T_ErrorList.asErrorListDeutsch.T_LanguagList[97]:='Fehler 97';
T_ErrorList.asErrorListDeutsch.T_LanguagList[98]:='USB-Stick konnte nicht gefunden werden für Profil lesen/schreiben';
T_ErrorList.asErrorListDeutsch.T_LanguagList[99]:='USB-Stick konnte nicht gefunden werden für Profil löschen';
T_ErrorList.asErrorListDeutsch.T_LanguagList[100]:='Spannungsversorgung wurde ausgeschaltet';
T_ErrorList.asErrorListDeutsch.T_LanguagList[101]:='Syntaxfehler mindestens einer Profildatei beim lesen aller Profile';
T_ErrorList.asErrorListDeutsch.T_LanguagList[102]:='NovRAM Speicher Fehlerhaft';
T_ErrorList.asErrorListDeutsch.T_LanguagList[103]:='Nicht behandelter undefinierter Prozess Fehler';
T_ErrorList.asErrorListDeutsch.T_LanguagList[104]:='USB-Stick konnte nicht gefunden werden';
T_ErrorList.asErrorListDeutsch.T_LanguagList[105]:='Zylinder Funktion nicht implementiert';
T_ErrorList.asErrorListDeutsch.T_LanguagList[106]:='Zylinder Aktiv-->Sensor nicht ON';
T_ErrorList.asErrorListDeutsch.T_LanguagList[107]:='Zylinder Inaktiv-->Sensor nicht ON';
T_ErrorList.asErrorListDeutsch.T_LanguagList[108]:='Nicht behandelter undefinierter Zylinder Fehler';
T_ErrorList.asErrorListDeutsch.T_LanguagList[109]:='Bremse Aktiv von ST1';
T_ErrorList.asErrorListDeutsch.T_LanguagList[110]:='Fehler 110';
T_ErrorList.asErrorListDeutsch.T_LanguagList[111]:='Fehler 111';
T_ErrorList.asErrorListDeutsch.T_LanguagList[112]:='Fehler 112';
T_ErrorList.asErrorListDeutsch.T_LanguagList[113]:='Fehler 113';
T_ErrorList.asErrorListDeutsch.T_LanguagList[114]:='Fehler 114';
T_ErrorList.asErrorListDeutsch.T_LanguagList[115]:='Fehler 115';
T_ErrorList.asErrorListDeutsch.T_LanguagList[116]:='Fehler 116';
T_ErrorList.asErrorListDeutsch.T_LanguagList[117]:='Fehler 117';
T_ErrorList.asErrorListDeutsch.T_LanguagList[118]:='Fehler 118';
T_ErrorList.asErrorListDeutsch.T_LanguagList[119]:='Fehler 119';
T_ErrorList.asErrorListDeutsch.T_LanguagList[120]:='Fehler 120';
T_ErrorList.asErrorListDeutsch.T_LanguagList[121]:='Fehler 121';
T_ErrorList.asErrorListDeutsch.T_LanguagList[122]:='Fehler 122';
T_ErrorList.asErrorListDeutsch.T_LanguagList[123]:='Fehler 123';
T_ErrorList.asErrorListDeutsch.T_LanguagList[124]:='Fehler 124';
T_ErrorList.asErrorListDeutsch.T_LanguagList[125]:='Fehler 125';
T_ErrorList.asErrorListDeutsch.T_LanguagList[126]:='Fehler 126';
T_ErrorList.asErrorListDeutsch.T_LanguagList[127]:='Fehler 127';
T_ErrorList.asErrorListDeutsch.T_LanguagList[128]:='Fehler 128';
T_ErrorList.asErrorListDeutsch.T_LanguagList[129]:='Fehler 129';
T_ErrorList.asErrorListDeutsch.T_LanguagList[130]:='Fehler 130';
T_ErrorList.asErrorListDeutsch.T_LanguagList[131]:='Fehler 131';
T_ErrorList.asErrorListDeutsch.T_LanguagList[132]:='Fehler 132';
T_ErrorList.asErrorListDeutsch.T_LanguagList[133]:='Fehler 133';
T_ErrorList.asErrorListDeutsch.T_LanguagList[134]:='Fehler 134';
T_ErrorList.asErrorListDeutsch.T_LanguagList[135]:='Fehler 135';
T_ErrorList.asErrorListDeutsch.T_LanguagList[136]:='Fehler 136';
T_ErrorList.asErrorListDeutsch.T_LanguagList[137]:='Fehler 137';
T_ErrorList.asErrorListDeutsch.T_LanguagList[138]:='Fehler 138';
T_ErrorList.asErrorListDeutsch.T_LanguagList[139]:='Fehler 139';
T_ErrorList.asErrorListDeutsch.T_LanguagList[140]:='Fehler 140';
T_ErrorList.asErrorListDeutsch.T_LanguagList[141]:='Fehler 141';
T_ErrorList.asErrorListDeutsch.T_LanguagList[142]:='Fehler 142';
T_ErrorList.asErrorListDeutsch.T_LanguagList[143]:='Fehler 143';
T_ErrorList.asErrorListDeutsch.T_LanguagList[144]:='Fehler 144';
T_ErrorList.asErrorListDeutsch.T_LanguagList[145]:='Fehler 145';
T_ErrorList.asErrorListDeutsch.T_LanguagList[146]:='HDD steht nicht Bereit';
T_ErrorList.asErrorListDeutsch.T_LanguagList[147]:='Timeout beim Schreiben auf USB-Stick';
T_ErrorList.asErrorListDeutsch.T_LanguagList[148]:='USB Stick nicht schreibbar';
T_ErrorList.asErrorListDeutsch.T_LanguagList[149]:='USB Stick nicht gefunden';
T_ErrorList.asErrorListDeutsch.T_LanguagList[150]:='Fehler 150';
T_ErrorList.asErrorListDeutsch.T_LanguagList[151]:='Fehler 151';
T_ErrorList.asErrorListDeutsch.T_LanguagList[152]:='Fehler 152';
T_ErrorList.asErrorListDeutsch.T_LanguagList[153]:='Fehler 153';
T_ErrorList.asErrorListDeutsch.T_LanguagList[154]:='Fehler 154';
T_ErrorList.asErrorListDeutsch.T_LanguagList[155]:='Fehler 155';
T_ErrorList.asErrorListDeutsch.T_LanguagList[156]:='Fehler 156';
T_ErrorList.asErrorListDeutsch.T_LanguagList[157]:='Fehler 157';
T_ErrorList.asErrorListDeutsch.T_LanguagList[158]:='Fehler 158';
T_ErrorList.asErrorListDeutsch.T_LanguagList[159]:='Fehler 159';
T_ErrorList.asErrorListDeutsch.T_LanguagList[160]:='Fehler 160';
T_ErrorList.asErrorListDeutsch.T_LanguagList[161]:='Fehler 161';
T_ErrorList.asErrorListDeutsch.T_LanguagList[162]:='Fehler 162';
T_ErrorList.asErrorListDeutsch.T_LanguagList[163]:='Fehler 163';
T_ErrorList.asErrorListDeutsch.T_LanguagList[164]:='Fehler 164';
T_ErrorList.asErrorListDeutsch.T_LanguagList[165]:='Fehler 165';
T_ErrorList.asErrorListDeutsch.T_LanguagList[166]:='Fehler 166';
T_ErrorList.asErrorListDeutsch.T_LanguagList[167]:='Fehler 167';
T_ErrorList.asErrorListDeutsch.T_LanguagList[168]:='Fehler 168';
T_ErrorList.asErrorListDeutsch.T_LanguagList[169]:='Fehler 169';
T_ErrorList.asErrorListDeutsch.T_LanguagList[170]:='Fehler 170';
T_ErrorList.asErrorListDeutsch.T_LanguagList[171]:='Fehler 171';
T_ErrorList.asErrorListDeutsch.T_LanguagList[172]:='Fehler 172';
T_ErrorList.asErrorListDeutsch.T_LanguagList[173]:='Fehler 173';
T_ErrorList.asErrorListDeutsch.T_LanguagList[174]:='Fehler 174';
T_ErrorList.asErrorListDeutsch.T_LanguagList[175]:='Fehler 175';
T_ErrorList.asErrorListDeutsch.T_LanguagList[176]:='Fehler 176';
T_ErrorList.asErrorListDeutsch.T_LanguagList[177]:='Fehler 177';
T_ErrorList.asErrorListDeutsch.T_LanguagList[178]:='Fehler 178';
T_ErrorList.asErrorListDeutsch.T_LanguagList[179]:='Fehler 179';
T_ErrorList.asErrorListDeutsch.T_LanguagList[180]:='Fehler 180';
T_ErrorList.asErrorListDeutsch.T_LanguagList[181]:='Fehler 181';
T_ErrorList.asErrorListDeutsch.T_LanguagList[182]:='Fehler 182';
T_ErrorList.asErrorListDeutsch.T_LanguagList[183]:='Fehler 183';
T_ErrorList.asErrorListDeutsch.T_LanguagList[184]:='Fehler 184';
T_ErrorList.asErrorListDeutsch.T_LanguagList[185]:='Fehler 185';
T_ErrorList.asErrorListDeutsch.T_LanguagList[186]:='Fehler 186';
T_ErrorList.asErrorListDeutsch.T_LanguagList[187]:='Fehler 187';
T_ErrorList.asErrorListDeutsch.T_LanguagList[188]:='Fehler 188';
T_ErrorList.asErrorListDeutsch.T_LanguagList[189]:='Fehler 189';
T_ErrorList.asErrorListDeutsch.T_LanguagList[190]:='Fehler 190';
T_ErrorList.asErrorListDeutsch.T_LanguagList[191]:='Fehler 191';
T_ErrorList.asErrorListDeutsch.T_LanguagList[192]:='Fehler 192';
T_ErrorList.asErrorListDeutsch.T_LanguagList[193]:='Fehler 193';
T_ErrorList.asErrorListDeutsch.T_LanguagList[194]:='Fehler 194';
T_ErrorList.asErrorListDeutsch.T_LanguagList[195]:='Fehler 195';
T_ErrorList.asErrorListDeutsch.T_LanguagList[196]:='Fehler 196';
T_ErrorList.asErrorListDeutsch.T_LanguagList[197]:='Fehler 197';
T_ErrorList.asErrorListDeutsch.T_LanguagList[198]:='Fehler 198';
T_ErrorList.asErrorListDeutsch.T_LanguagList[199]:='Fehler 199';
T_ErrorList.asErrorListDeutsch.T_LanguagList[200]:='Fehler 200';
T_ErrorList.asErrorListDeutsch.T_LanguagList[201]:='Fehler 201';
T_ErrorList.asErrorListDeutsch.T_LanguagList[202]:='Fehler 202';
T_ErrorList.asErrorListDeutsch.T_LanguagList[203]:='Fehler 203';
T_ErrorList.asErrorListDeutsch.T_LanguagList[204]:='Fehler 204';
T_ErrorList.asErrorListDeutsch.T_LanguagList[205]:='Fehler 205';
T_ErrorList.asErrorListDeutsch.T_LanguagList[206]:='Fehler 206';
T_ErrorList.asErrorListDeutsch.T_LanguagList[207]:='Fehler 207';
T_ErrorList.asErrorListDeutsch.T_LanguagList[208]:='Fehler 208';
T_ErrorList.asErrorListDeutsch.T_LanguagList[209]:='Fehler 209';
T_ErrorList.asErrorListDeutsch.T_LanguagList[210]:='Fehler 210';
T_ErrorList.asErrorListDeutsch.T_LanguagList[211]:='Fehler 211';
T_ErrorList.asErrorListDeutsch.T_LanguagList[212]:='Fehler 212';
T_ErrorList.asErrorListDeutsch.T_LanguagList[213]:='Fehler 213';
T_ErrorList.asErrorListDeutsch.T_LanguagList[214]:='Fehler 214';
T_ErrorList.asErrorListDeutsch.T_LanguagList[215]:='Fehler 215';
T_ErrorList.asErrorListDeutsch.T_LanguagList[216]:='Fehler 216';
T_ErrorList.asErrorListDeutsch.T_LanguagList[217]:='Fehler 217';
T_ErrorList.asErrorListDeutsch.T_LanguagList[218]:='Fehler 218';
T_ErrorList.asErrorListDeutsch.T_LanguagList[219]:='Fehler 219';
T_ErrorList.asErrorListDeutsch.T_LanguagList[220]:='Fehler 220';
T_ErrorList.asErrorListDeutsch.T_LanguagList[221]:='Fehler 221';
T_ErrorList.asErrorListDeutsch.T_LanguagList[222]:='Fehler 222';
T_ErrorList.asErrorListDeutsch.T_LanguagList[223]:='Fehler 223';
T_ErrorList.asErrorListDeutsch.T_LanguagList[224]:='Fehler 224';
T_ErrorList.asErrorListDeutsch.T_LanguagList[225]:='Fehler 225';
T_ErrorList.asErrorListDeutsch.T_LanguagList[226]:='Fehler 226';
T_ErrorList.asErrorListDeutsch.T_LanguagList[227]:='Fehler 227';
T_ErrorList.asErrorListDeutsch.T_LanguagList[228]:='Fehler 228';
T_ErrorList.asErrorListDeutsch.T_LanguagList[229]:='Fehler 229';
T_ErrorList.asErrorListDeutsch.T_LanguagList[230]:='Fehler 230';
T_ErrorList.asErrorListDeutsch.T_LanguagList[231]:='Fehler 231';
T_ErrorList.asErrorListDeutsch.T_LanguagList[232]:='Fehler 232';
T_ErrorList.asErrorListDeutsch.T_LanguagList[233]:='Fehler 233';
T_ErrorList.asErrorListDeutsch.T_LanguagList[234]:='Fehler 234';
T_ErrorList.asErrorListDeutsch.T_LanguagList[235]:='Fehler 235';
T_ErrorList.asErrorListDeutsch.T_LanguagList[236]:='Fehler 236';
T_ErrorList.asErrorListDeutsch.T_LanguagList[237]:='Fehler 237';
T_ErrorList.asErrorListDeutsch.T_LanguagList[238]:='Fehler 238';
T_ErrorList.asErrorListDeutsch.T_LanguagList[239]:='Fehler 239';
T_ErrorList.asErrorListDeutsch.T_LanguagList[240]:='Fehler 240';
T_ErrorList.asErrorListDeutsch.T_LanguagList[241]:='Fehler 241';
T_ErrorList.asErrorListDeutsch.T_LanguagList[242]:='Fehler 242';
T_ErrorList.asErrorListDeutsch.T_LanguagList[243]:='Fehler 243';
T_ErrorList.asErrorListDeutsch.T_LanguagList[244]:='Fehler 244';
T_ErrorList.asErrorListDeutsch.T_LanguagList[245]:='Fehler 245';
T_ErrorList.asErrorListDeutsch.T_LanguagList[246]:='Fehler 246';
T_ErrorList.asErrorListDeutsch.T_LanguagList[247]:='Fehler 247';
T_ErrorList.asErrorListDeutsch.T_LanguagList[248]:='Fehler 248';
T_ErrorList.asErrorListDeutsch.T_LanguagList[249]:='Fehler 249';
T_ErrorList.asErrorListDeutsch.T_LanguagList[250]:='Fehler 250';
T_ErrorList.asErrorListDeutsch.T_LanguagList[251]:='Fehler 251';
T_ErrorList.asErrorListDeutsch.T_LanguagList[252]:='Fehler 252';
T_ErrorList.asErrorListDeutsch.T_LanguagList[253]:='Fehler 253';
T_ErrorList.asErrorListDeutsch.T_LanguagList[254]:='Fehler 254';
T_ErrorList.asErrorListDeutsch.T_LanguagList[255]:='Fehler 255';
T_ErrorList.asErrorListDeutsch.T_LanguagList[256]:='Fehler 256';
T_ErrorList.asErrorListDeutsch.T_LanguagList[257]:='Fehler 257';
T_ErrorList.asErrorListDeutsch.T_LanguagList[258]:='Fehler 258';
T_ErrorList.asErrorListDeutsch.T_LanguagList[259]:='Fehler 259';
T_ErrorList.asErrorListDeutsch.T_LanguagList[260]:='Fehler 260';
T_ErrorList.asErrorListDeutsch.T_LanguagList[261]:='Fehler 261';
T_ErrorList.asErrorListDeutsch.T_LanguagList[262]:='Fehler 262';
T_ErrorList.asErrorListDeutsch.T_LanguagList[263]:='Fehler 263';
T_ErrorList.asErrorListDeutsch.T_LanguagList[264]:='Fehler 264';
T_ErrorList.asErrorListDeutsch.T_LanguagList[265]:='Fehler 265';
T_ErrorList.asErrorListDeutsch.T_LanguagList[266]:='Fehler 266';
T_ErrorList.asErrorListDeutsch.T_LanguagList[267]:='Fehler 267';
T_ErrorList.asErrorListDeutsch.T_LanguagList[268]:='Fehler 268';
T_ErrorList.asErrorListDeutsch.T_LanguagList[269]:='Fehler 269';
T_ErrorList.asErrorListDeutsch.T_LanguagList[270]:='Fehler 270';
T_ErrorList.asErrorListDeutsch.T_LanguagList[271]:='Fehler 271';
T_ErrorList.asErrorListDeutsch.T_LanguagList[272]:='Fehler 272';
T_ErrorList.asErrorListDeutsch.T_LanguagList[273]:='Fehler 273';
T_ErrorList.asErrorListDeutsch.T_LanguagList[274]:='Fehler 274';
T_ErrorList.asErrorListDeutsch.T_LanguagList[275]:='Fehler 275';
T_ErrorList.asErrorListDeutsch.T_LanguagList[276]:='Fehler 276';
T_ErrorList.asErrorListDeutsch.T_LanguagList[277]:='Fehler 277';
T_ErrorList.asErrorListDeutsch.T_LanguagList[278]:='Fehler 278';
T_ErrorList.asErrorListDeutsch.T_LanguagList[279]:='Fehler 279';
T_ErrorList.asErrorListDeutsch.T_LanguagList[280]:='Fehler 280';
T_ErrorList.asErrorListDeutsch.T_LanguagList[281]:='Fehler 281';
T_ErrorList.asErrorListDeutsch.T_LanguagList[282]:='Fehler 282';
T_ErrorList.asErrorListDeutsch.T_LanguagList[283]:='Fehler 283';
T_ErrorList.asErrorListDeutsch.T_LanguagList[284]:='Fehler 284';
T_ErrorList.asErrorListDeutsch.T_LanguagList[285]:='Fehler 285';
T_ErrorList.asErrorListDeutsch.T_LanguagList[286]:='Fehler 286';
T_ErrorList.asErrorListDeutsch.T_LanguagList[287]:='Fehler 287';
T_ErrorList.asErrorListDeutsch.T_LanguagList[288]:='Fehler 288';
T_ErrorList.asErrorListDeutsch.T_LanguagList[289]:='Fehler 289';
T_ErrorList.asErrorListDeutsch.T_LanguagList[290]:='Fehler 290';
T_ErrorList.asErrorListDeutsch.T_LanguagList[291]:='Fehler 291';
T_ErrorList.asErrorListDeutsch.T_LanguagList[292]:='Fehler 292';
T_ErrorList.asErrorListDeutsch.T_LanguagList[293]:='Fehler 293';
T_ErrorList.asErrorListDeutsch.T_LanguagList[294]:='Fehler 294';
T_ErrorList.asErrorListDeutsch.T_LanguagList[295]:='Fehler 295';
T_ErrorList.asErrorListDeutsch.T_LanguagList[296]:='Fehler 296';
T_ErrorList.asErrorListDeutsch.T_LanguagList[297]:='Fehler 297';
T_ErrorList.asErrorListDeutsch.T_LanguagList[298]:='Fehler 298';
T_ErrorList.asErrorListDeutsch.T_LanguagList[299]:='Fehler 299';
T_ErrorList.asErrorListDeutsch.T_LanguagList[300]:='Fehler 300';

(* Static English Error List *)
T_ErrorList.asErrorListEnglish.T_LanguagList[1]:='Error while disable of the Station';
T_ErrorList.asErrorListEnglish.T_LanguagList[2]:='Not handled undefined Station Error';
T_ErrorList.asErrorListEnglish.T_LanguagList[3]:='Z Axis-->Negative HW limit switch Active';
T_ErrorList.asErrorListEnglish.T_LanguagList[4]:='Z Axis-->Positive HW limit switch Active';
T_ErrorList.asErrorListEnglish.T_LanguagList[5]:='Z Axis-->Positive + Negative HW limit switch Active';
T_ErrorList.asErrorListEnglish.T_LanguagList[6]:='AX5000 Parameter could not be written successfully';
T_ErrorList.asErrorListEnglish.T_LanguagList[7]:='Axis MasterModul2 could not find spindle head L channel 1';
T_ErrorList.asErrorListEnglish.T_LanguagList[8]:='Calibration-->CylToolDeflection Sensor failure';
T_ErrorList.asErrorListEnglish.T_LanguagList[9]:='Z Axis must be referenced';
T_ErrorList.asErrorListEnglish.T_LanguagList[10]:='Axis MasterModul2 could not find spindle head M channel 2';
T_ErrorList.asErrorListEnglish.T_LanguagList[11]:='Z Process stroke > Z Mech EndPos';
T_ErrorList.asErrorListEnglish.T_LanguagList[12]:='Spark-out > Z Mech EndPos';
T_ErrorList.asErrorListEnglish.T_LanguagList[13]:='Tool is not Infeeded into the Workpiece';
T_ErrorList.asErrorListEnglish.T_LanguagList[14]:='Coolant pressure still ON';
T_ErrorList.asErrorListEnglish.T_LanguagList[15]:='Error 15';
T_ErrorList.asErrorListEnglish.T_LanguagList[16]:='During starting of the Working could not be ON the ToolDeflection Sensor';
T_ErrorList.asErrorListEnglish.T_LanguagList[17]:='During starting of the Working could not be ON the ToolTorque Sensor';
T_ErrorList.asErrorListEnglish.T_LanguagList[18]:='Z LoadPos > Z Mech EndPos';
T_ErrorList.asErrorListEnglish.T_LanguagList[19]:='Z Work StartPos > Z Mech EndPos';
T_ErrorList.asErrorListEnglish.T_LanguagList[20]:='Z Work EndPos > Z Mech EndPos';
T_ErrorList.asErrorListEnglish.T_LanguagList[21]:='Z ToolChange Pos > Z Mech EndPos';
T_ErrorList.asErrorListEnglish.T_LanguagList[22]:='Z LoadPos: Discrepancy with other Z Position';
T_ErrorList.asErrorListEnglish.T_LanguagList[23]:='Z Work StartPos: Discrepancy with other Z Position';
T_ErrorList.asErrorListEnglish.T_LanguagList[24]:='Z Work EndPos: Discrepancy with other Z Position';
T_ErrorList.asErrorListEnglish.T_LanguagList[25]:='Calibration-->CylToolDeflection Cylinder is blocked';
T_ErrorList.asErrorListEnglish.T_LanguagList[26]:='Calibration-->CylToolDeflection Sensor failure';
T_ErrorList.asErrorListEnglish.T_LanguagList[27]:='Error 27';
T_ErrorList.asErrorListEnglish.T_LanguagList[28]:='ToolTorque Max exceed';
T_ErrorList.asErrorListEnglish.T_LanguagList[29]:='ToolTorque Overload Active';
T_ErrorList.asErrorListEnglish.T_LanguagList[30]:='When centring, the CylWPUnfix must be to WorkPosition';
T_ErrorList.asErrorListEnglish.T_LanguagList[31]:='Z Work EndPos calc. > Z Work EndPos Max';
T_ErrorList.asErrorListEnglish.T_LanguagList[32]:='Z Centring Pos calc. > Z Mech EndPos';
T_ErrorList.asErrorListEnglish.T_LanguagList[33]:='Z Centring EndPos > Z Mech EndPos';
T_ErrorList.asErrorListEnglish.T_LanguagList[34]:='Z Centring Pos calc. > Z Work EndPos Max';
T_ErrorList.asErrorListEnglish.T_LanguagList[35]:='Z ToolCylindrical Pos > Z Mech EndPos';
T_ErrorList.asErrorListEnglish.T_LanguagList[36]:='On cylindrical part was reach the max EndPos';
T_ErrorList.asErrorListEnglish.T_LanguagList[37]:='Error 37';
T_ErrorList.asErrorListEnglish.T_LanguagList[38]:='Error 38';
T_ErrorList.asErrorListEnglish.T_LanguagList[39]:='Error 39';
T_ErrorList.asErrorListEnglish.T_LanguagList[40]:='Error 40';
T_ErrorList.asErrorListEnglish.T_LanguagList[41]:='Error 41';
T_ErrorList.asErrorListEnglish.T_LanguagList[42]:='Error 42';
T_ErrorList.asErrorListEnglish.T_LanguagList[43]:='Error 43';
T_ErrorList.asErrorListEnglish.T_LanguagList[44]:='Error 44';
T_ErrorList.asErrorListEnglish.T_LanguagList[45]:='Error 45';
T_ErrorList.asErrorListEnglish.T_LanguagList[46]:='Error 46';
T_ErrorList.asErrorListEnglish.T_LanguagList[47]:='Error 47';
T_ErrorList.asErrorListEnglish.T_LanguagList[48]:='Tool must be changed';
T_ErrorList.asErrorListEnglish.T_LanguagList[49]:='File for to load Profile not found';
T_ErrorList.asErrorListEnglish.T_LanguagList[50]:='Error 50';
T_ErrorList.asErrorListEnglish.T_LanguagList[51]:='Profile name of File is different as loaded Profile';
T_ErrorList.asErrorListEnglish.T_LanguagList[52]:='Syntax Error of to load Profile';
T_ErrorList.asErrorListEnglish.T_LanguagList[53]:='Error 53';
T_ErrorList.asErrorListEnglish.T_LanguagList[54]:='Profile not saved because the directory is missing';
T_ErrorList.asErrorListEnglish.T_LanguagList[55]:='Calibration-->CylToolTorque Sensor failure';
T_ErrorList.asErrorListEnglish.T_LanguagList[56]:='Calibration-->CylToolDeflection+CylToolTorque Sensor failure';
T_ErrorList.asErrorListEnglish.T_LanguagList[57]:='Calibration-->CylToolTorque Cylinder is blocked';
T_ErrorList.asErrorListEnglish.T_LanguagList[58]:='Calibration-->CylToolDeflection+CylToolTorque Cylinder is blocked';
T_ErrorList.asErrorListEnglish.T_LanguagList[59]:='During starting of the Working could not be ON the ToolTorque Overload Sensor';
T_ErrorList.asErrorListEnglish.T_LanguagList[60]:='Centring Process HC1 active';
T_ErrorList.asErrorListEnglish.T_LanguagList[61]:='Centring Proc. StartPos reach and HC2 still ON';
T_ErrorList.asErrorListEnglish.T_LanguagList[62]:='Error 62';
T_ErrorList.asErrorListEnglish.T_LanguagList[63]:='Error 63';
T_ErrorList.asErrorListEnglish.T_LanguagList[64]:='Error 64';
T_ErrorList.asErrorListEnglish.T_LanguagList[65]:='Error 65';
T_ErrorList.asErrorListEnglish.T_LanguagList[66]:='Called Axis function do not exist';
T_ErrorList.asErrorListEnglish.T_LanguagList[67]:='Axis function not executable during Stopp- function is Active';
T_ErrorList.asErrorListEnglish.T_LanguagList[68]:='Error 68';
T_ErrorList.asErrorListEnglish.T_LanguagList[69]:='Error 69';
T_ErrorList.asErrorListEnglish.T_LanguagList[70]:='Error 70';
T_ErrorList.asErrorListEnglish.T_LanguagList[71]:='Error 71';
T_ErrorList.asErrorListEnglish.T_LanguagList[72]:='Error 72';
T_ErrorList.asErrorListEnglish.T_LanguagList[73]:='Error 73';
T_ErrorList.asErrorListEnglish.T_LanguagList[74]:='Error 74';
T_ErrorList.asErrorListEnglish.T_LanguagList[75]:='(Position drag excess)';
T_ErrorList.asErrorListEnglish.T_LanguagList[76]:='Emergency Button Machine pressed';
T_ErrorList.asErrorListEnglish.T_LanguagList[77]:='Error 77';
T_ErrorList.asErrorListEnglish.T_LanguagList[78]:='Error 78';
T_ErrorList.asErrorListEnglish.T_LanguagList[79]:='Error 79';
T_ErrorList.asErrorListEnglish.T_LanguagList[80]:='Error 80';
T_ErrorList.asErrorListEnglish.T_LanguagList[81]:='Error 81';
T_ErrorList.asErrorListEnglish.T_LanguagList[82]:='Error 82';
T_ErrorList.asErrorListEnglish.T_LanguagList[83]:='No air pressure';
T_ErrorList.asErrorListEnglish.T_LanguagList[84]:='EtherCAT 1 Terminal failure';
T_ErrorList.asErrorListEnglish.T_LanguagList[85]:='EtherCAT 2 Terminal failure';
T_ErrorList.asErrorListEnglish.T_LanguagList[86]:='Maxon EPOS not in Operational Mode OP';
T_ErrorList.asErrorListEnglish.T_LanguagList[87]:='SMC Valve not in Operational Mode OP';
T_ErrorList.asErrorListEnglish.T_LanguagList[88]:='Axis MasterModul 1 not in Operational Mode OP';
T_ErrorList.asErrorListEnglish.T_LanguagList[89]:='Axis MasterModul 2 not in Operational Mode OP';
T_ErrorList.asErrorListEnglish.T_LanguagList[90]:='Power 24VDC failure';
T_ErrorList.asErrorListEnglish.T_LanguagList[91]:='Error 91';
T_ErrorList.asErrorListEnglish.T_LanguagList[92]:='Error 92';
T_ErrorList.asErrorListEnglish.T_LanguagList[93]:='Error 93';
T_ErrorList.asErrorListEnglish.T_LanguagList[94]:='Error 94';
T_ErrorList.asErrorListEnglish.T_LanguagList[95]:='Error 95';
T_ErrorList.asErrorListEnglish.T_LanguagList[96]:='Error 96';
T_ErrorList.asErrorListEnglish.T_LanguagList[97]:='Error 97';
T_ErrorList.asErrorListEnglish.T_LanguagList[98]:='USB-Stick not founded for Profile read/write';
T_ErrorList.asErrorListEnglish.T_LanguagList[99]:='USB-Stick not founded for Profile delete';
T_ErrorList.asErrorListEnglish.T_LanguagList[100]:='Power Supply is switched off';
T_ErrorList.asErrorListEnglish.T_LanguagList[101]:='At least one Profle has a syntax Error during reading of all Profiles';
T_ErrorList.asErrorListEnglish.T_LanguagList[102]:='NovRAM store failure';
T_ErrorList.asErrorListEnglish.T_LanguagList[103]:='Not handled undefined Process Error';
T_ErrorList.asErrorListEnglish.T_LanguagList[104]:='USB-Stick not founded';
T_ErrorList.asErrorListEnglish.T_LanguagList[105]:='Cylinder function not implemented';
T_ErrorList.asErrorListEnglish.T_LanguagList[106]:='Cylinder Active-->Sensor not ON';
T_ErrorList.asErrorListEnglish.T_LanguagList[107]:='Cylinder Inactive-->Sensor not ON';
T_ErrorList.asErrorListEnglish.T_LanguagList[108]:='Not handled undefined Cylinder Error';
T_ErrorList.asErrorListEnglish.T_LanguagList[109]:='Axis Brake Active of ST1';
T_ErrorList.asErrorListEnglish.T_LanguagList[110]:='Error 110';
T_ErrorList.asErrorListEnglish.T_LanguagList[111]:='Error 111';
T_ErrorList.asErrorListEnglish.T_LanguagList[112]:='Error 112';
T_ErrorList.asErrorListEnglish.T_LanguagList[113]:='Error 113';
T_ErrorList.asErrorListEnglish.T_LanguagList[114]:='Error 114';
T_ErrorList.asErrorListEnglish.T_LanguagList[115]:='Error 115';
T_ErrorList.asErrorListEnglish.T_LanguagList[116]:='Error 116';
T_ErrorList.asErrorListEnglish.T_LanguagList[117]:='Error 117';
T_ErrorList.asErrorListEnglish.T_LanguagList[118]:='Error 118';
T_ErrorList.asErrorListEnglish.T_LanguagList[119]:='Error 119';
T_ErrorList.asErrorListEnglish.T_LanguagList[120]:='Error 120';
T_ErrorList.asErrorListEnglish.T_LanguagList[121]:='Error 121';
T_ErrorList.asErrorListEnglish.T_LanguagList[122]:='Error 122';
T_ErrorList.asErrorListEnglish.T_LanguagList[123]:='Error 123';
T_ErrorList.asErrorListEnglish.T_LanguagList[124]:='Error 124';
T_ErrorList.asErrorListEnglish.T_LanguagList[125]:='Error 125';
T_ErrorList.asErrorListEnglish.T_LanguagList[126]:='Error 126';
T_ErrorList.asErrorListEnglish.T_LanguagList[127]:='Error 127';
T_ErrorList.asErrorListEnglish.T_LanguagList[128]:='Error 128';
T_ErrorList.asErrorListEnglish.T_LanguagList[129]:='Error 129';
T_ErrorList.asErrorListEnglish.T_LanguagList[130]:='Error 130';
T_ErrorList.asErrorListEnglish.T_LanguagList[131]:='Error 131';
T_ErrorList.asErrorListEnglish.T_LanguagList[132]:='Error 132';
T_ErrorList.asErrorListEnglish.T_LanguagList[133]:='Error 133';
T_ErrorList.asErrorListEnglish.T_LanguagList[134]:='Error 134';
T_ErrorList.asErrorListEnglish.T_LanguagList[135]:='Error 135';
T_ErrorList.asErrorListEnglish.T_LanguagList[136]:='Error 136';
T_ErrorList.asErrorListEnglish.T_LanguagList[137]:='Error 137';
T_ErrorList.asErrorListEnglish.T_LanguagList[138]:='Error 138';
T_ErrorList.asErrorListEnglish.T_LanguagList[139]:='Error 139';
T_ErrorList.asErrorListEnglish.T_LanguagList[140]:='Error 140';
T_ErrorList.asErrorListEnglish.T_LanguagList[141]:='Error 141';
T_ErrorList.asErrorListEnglish.T_LanguagList[142]:='Error 142';
T_ErrorList.asErrorListEnglish.T_LanguagList[143]:='Error 143';
T_ErrorList.asErrorListEnglish.T_LanguagList[144]:='Error 144';
T_ErrorList.asErrorListEnglish.T_LanguagList[145]:='Error 145';
T_ErrorList.asErrorListEnglish.T_LanguagList[146]:='HDD not Ready';
T_ErrorList.asErrorListEnglish.T_LanguagList[147]:='Timeout while write on USB-Stick';
T_ErrorList.asErrorListEnglish.T_LanguagList[148]:='USB Stick no writing';
T_ErrorList.asErrorListEnglish.T_LanguagList[149]:='USB Stick not found';
T_ErrorList.asErrorListEnglish.T_LanguagList[150]:='Error 150';
T_ErrorList.asErrorListEnglish.T_LanguagList[151]:='Error 151';
T_ErrorList.asErrorListEnglish.T_LanguagList[152]:='Error 152';
T_ErrorList.asErrorListEnglish.T_LanguagList[153]:='Error 153';
T_ErrorList.asErrorListEnglish.T_LanguagList[154]:='Error 154';
T_ErrorList.asErrorListEnglish.T_LanguagList[155]:='Error 155';
T_ErrorList.asErrorListEnglish.T_LanguagList[156]:='Error 156';
T_ErrorList.asErrorListEnglish.T_LanguagList[157]:='Error 157';
T_ErrorList.asErrorListEnglish.T_LanguagList[158]:='Error 158';
T_ErrorList.asErrorListEnglish.T_LanguagList[159]:='Error 159';
T_ErrorList.asErrorListEnglish.T_LanguagList[160]:='Error 160';
T_ErrorList.asErrorListEnglish.T_LanguagList[161]:='Error 161';
T_ErrorList.asErrorListEnglish.T_LanguagList[162]:='Error 162';
T_ErrorList.asErrorListEnglish.T_LanguagList[163]:='Error 163';
T_ErrorList.asErrorListEnglish.T_LanguagList[164]:='Error 164';
T_ErrorList.asErrorListEnglish.T_LanguagList[165]:='Error 165';
T_ErrorList.asErrorListEnglish.T_LanguagList[166]:='Error 166';
T_ErrorList.asErrorListEnglish.T_LanguagList[167]:='Error 167';
T_ErrorList.asErrorListEnglish.T_LanguagList[168]:='Error 168';
T_ErrorList.asErrorListEnglish.T_LanguagList[169]:='Error 169';
T_ErrorList.asErrorListEnglish.T_LanguagList[170]:='Error 170';
T_ErrorList.asErrorListEnglish.T_LanguagList[171]:='Error 171';
T_ErrorList.asErrorListEnglish.T_LanguagList[172]:='Error 172';
T_ErrorList.asErrorListEnglish.T_LanguagList[173]:='Error 173';
T_ErrorList.asErrorListEnglish.T_LanguagList[174]:='Error 174';
T_ErrorList.asErrorListEnglish.T_LanguagList[175]:='Error 175';
T_ErrorList.asErrorListEnglish.T_LanguagList[176]:='Error 176';
T_ErrorList.asErrorListEnglish.T_LanguagList[177]:='Error 177';
T_ErrorList.asErrorListEnglish.T_LanguagList[178]:='Error 178';
T_ErrorList.asErrorListEnglish.T_LanguagList[179]:='Error 179';
T_ErrorList.asErrorListEnglish.T_LanguagList[180]:='Error 180';
T_ErrorList.asErrorListEnglish.T_LanguagList[181]:='Error 181';
T_ErrorList.asErrorListEnglish.T_LanguagList[182]:='Error 182';
T_ErrorList.asErrorListEnglish.T_LanguagList[183]:='Error 183';
T_ErrorList.asErrorListEnglish.T_LanguagList[184]:='Error 184';
T_ErrorList.asErrorListEnglish.T_LanguagList[185]:='Error 185';
T_ErrorList.asErrorListEnglish.T_LanguagList[186]:='Error 186';
T_ErrorList.asErrorListEnglish.T_LanguagList[187]:='Error 187';
T_ErrorList.asErrorListEnglish.T_LanguagList[188]:='Error 188';
T_ErrorList.asErrorListEnglish.T_LanguagList[189]:='Error 189';
T_ErrorList.asErrorListEnglish.T_LanguagList[190]:='Error 190';
T_ErrorList.asErrorListEnglish.T_LanguagList[191]:='Error 191';
T_ErrorList.asErrorListEnglish.T_LanguagList[192]:='Error 192';
T_ErrorList.asErrorListEnglish.T_LanguagList[193]:='Error 193';
T_ErrorList.asErrorListEnglish.T_LanguagList[194]:='Error 194';
T_ErrorList.asErrorListEnglish.T_LanguagList[195]:='Error 195';
T_ErrorList.asErrorListEnglish.T_LanguagList[196]:='Error 196';
T_ErrorList.asErrorListEnglish.T_LanguagList[197]:='Error 197';
T_ErrorList.asErrorListEnglish.T_LanguagList[198]:='Error 198';
T_ErrorList.asErrorListEnglish.T_LanguagList[199]:='Error 199';
T_ErrorList.asErrorListEnglish.T_LanguagList[200]:='Error 200';
T_ErrorList.asErrorListEnglish.T_LanguagList[201]:='Error 201';
T_ErrorList.asErrorListEnglish.T_LanguagList[202]:='Error 202';
T_ErrorList.asErrorListEnglish.T_LanguagList[203]:='Error 203';
T_ErrorList.asErrorListEnglish.T_LanguagList[204]:='Error 204';
T_ErrorList.asErrorListEnglish.T_LanguagList[205]:='Error 205';
T_ErrorList.asErrorListEnglish.T_LanguagList[206]:='Error 206';
T_ErrorList.asErrorListEnglish.T_LanguagList[207]:='Error 207';
T_ErrorList.asErrorListEnglish.T_LanguagList[208]:='Error 208';
T_ErrorList.asErrorListEnglish.T_LanguagList[209]:='Error 209';
T_ErrorList.asErrorListEnglish.T_LanguagList[210]:='Error 210';
T_ErrorList.asErrorListEnglish.T_LanguagList[211]:='Error 211';
T_ErrorList.asErrorListEnglish.T_LanguagList[212]:='Error 212';
T_ErrorList.asErrorListEnglish.T_LanguagList[213]:='Error 213';
T_ErrorList.asErrorListEnglish.T_LanguagList[214]:='Error 214';
T_ErrorList.asErrorListEnglish.T_LanguagList[215]:='Error 215';
T_ErrorList.asErrorListEnglish.T_LanguagList[216]:='Error 216';
T_ErrorList.asErrorListEnglish.T_LanguagList[217]:='Error 217';
T_ErrorList.asErrorListEnglish.T_LanguagList[218]:='Error 218';
T_ErrorList.asErrorListEnglish.T_LanguagList[219]:='Error 219';
T_ErrorList.asErrorListEnglish.T_LanguagList[220]:='Error 220';
T_ErrorList.asErrorListEnglish.T_LanguagList[221]:='Error 221';
T_ErrorList.asErrorListEnglish.T_LanguagList[222]:='Error 222';
T_ErrorList.asErrorListEnglish.T_LanguagList[223]:='Error 223';
T_ErrorList.asErrorListEnglish.T_LanguagList[224]:='Error 224';
T_ErrorList.asErrorListEnglish.T_LanguagList[225]:='Error 225';
T_ErrorList.asErrorListEnglish.T_LanguagList[226]:='Error 226';
T_ErrorList.asErrorListEnglish.T_LanguagList[227]:='Error 227';
T_ErrorList.asErrorListEnglish.T_LanguagList[228]:='Error 228';
T_ErrorList.asErrorListEnglish.T_LanguagList[229]:='Error 229';
T_ErrorList.asErrorListEnglish.T_LanguagList[230]:='Error 230';
T_ErrorList.asErrorListEnglish.T_LanguagList[231]:='Error 231';
T_ErrorList.asErrorListEnglish.T_LanguagList[232]:='Error 232';
T_ErrorList.asErrorListEnglish.T_LanguagList[233]:='Error 233';
T_ErrorList.asErrorListEnglish.T_LanguagList[234]:='Error 234';
T_ErrorList.asErrorListEnglish.T_LanguagList[235]:='Error 235';
T_ErrorList.asErrorListEnglish.T_LanguagList[236]:='Error 236';
T_ErrorList.asErrorListEnglish.T_LanguagList[237]:='Error 237';
T_ErrorList.asErrorListEnglish.T_LanguagList[238]:='Error 238';
T_ErrorList.asErrorListEnglish.T_LanguagList[239]:='Error 239';
T_ErrorList.asErrorListEnglish.T_LanguagList[240]:='Error 240';
T_ErrorList.asErrorListEnglish.T_LanguagList[241]:='Error 241';
T_ErrorList.asErrorListEnglish.T_LanguagList[242]:='Error 242';
T_ErrorList.asErrorListEnglish.T_LanguagList[243]:='Error 243';
T_ErrorList.asErrorListEnglish.T_LanguagList[244]:='Error 244';
T_ErrorList.asErrorListEnglish.T_LanguagList[245]:='Error 245';
T_ErrorList.asErrorListEnglish.T_LanguagList[246]:='Error 246';
T_ErrorList.asErrorListEnglish.T_LanguagList[247]:='Error 247';
T_ErrorList.asErrorListEnglish.T_LanguagList[248]:='Error 248';
T_ErrorList.asErrorListEnglish.T_LanguagList[249]:='Error 249';
T_ErrorList.asErrorListEnglish.T_LanguagList[250]:='Error 250';
T_ErrorList.asErrorListEnglish.T_LanguagList[251]:='Error 251';
T_ErrorList.asErrorListEnglish.T_LanguagList[252]:='Error 252';
T_ErrorList.asErrorListEnglish.T_LanguagList[253]:='Error 253';
T_ErrorList.asErrorListEnglish.T_LanguagList[254]:='Error 254';
T_ErrorList.asErrorListEnglish.T_LanguagList[255]:='Error 255';
T_ErrorList.asErrorListEnglish.T_LanguagList[256]:='Error 256';
T_ErrorList.asErrorListEnglish.T_LanguagList[257]:='Error 257';
T_ErrorList.asErrorListEnglish.T_LanguagList[258]:='Error 258';
T_ErrorList.asErrorListEnglish.T_LanguagList[259]:='Error 259';
T_ErrorList.asErrorListEnglish.T_LanguagList[260]:='Error 260';
T_ErrorList.asErrorListEnglish.T_LanguagList[261]:='Error 261';
T_ErrorList.asErrorListEnglish.T_LanguagList[262]:='Error 262';
T_ErrorList.asErrorListEnglish.T_LanguagList[263]:='Error 263';
T_ErrorList.asErrorListEnglish.T_LanguagList[264]:='Error 264';
T_ErrorList.asErrorListEnglish.T_LanguagList[265]:='Error 265';
T_ErrorList.asErrorListEnglish.T_LanguagList[266]:='Error 266';
T_ErrorList.asErrorListEnglish.T_LanguagList[267]:='Error 267';
T_ErrorList.asErrorListEnglish.T_LanguagList[268]:='Error 268';
T_ErrorList.asErrorListEnglish.T_LanguagList[269]:='Error 269';
T_ErrorList.asErrorListEnglish.T_LanguagList[270]:='Error 270';
T_ErrorList.asErrorListEnglish.T_LanguagList[271]:='Error 271';
T_ErrorList.asErrorListEnglish.T_LanguagList[272]:='Error 272';
T_ErrorList.asErrorListEnglish.T_LanguagList[273]:='Error 273';
T_ErrorList.asErrorListEnglish.T_LanguagList[274]:='Error 274';
T_ErrorList.asErrorListEnglish.T_LanguagList[275]:='Error 275';
T_ErrorList.asErrorListEnglish.T_LanguagList[276]:='Error 276';
T_ErrorList.asErrorListEnglish.T_LanguagList[277]:='Error 277';
T_ErrorList.asErrorListEnglish.T_LanguagList[278]:='Error 278';
T_ErrorList.asErrorListEnglish.T_LanguagList[279]:='Error 279';
T_ErrorList.asErrorListEnglish.T_LanguagList[280]:='Error 280';
T_ErrorList.asErrorListEnglish.T_LanguagList[281]:='Error 281';
T_ErrorList.asErrorListEnglish.T_LanguagList[282]:='Error 282';
T_ErrorList.asErrorListEnglish.T_LanguagList[283]:='Error 283';
T_ErrorList.asErrorListEnglish.T_LanguagList[284]:='Error 284';
T_ErrorList.asErrorListEnglish.T_LanguagList[285]:='Error 285';
T_ErrorList.asErrorListEnglish.T_LanguagList[286]:='Error 286';
T_ErrorList.asErrorListEnglish.T_LanguagList[287]:='Error 287';
T_ErrorList.asErrorListEnglish.T_LanguagList[288]:='Error 288';
T_ErrorList.asErrorListEnglish.T_LanguagList[289]:='Error 289';
T_ErrorList.asErrorListEnglish.T_LanguagList[290]:='Error 290';
T_ErrorList.asErrorListEnglish.T_LanguagList[291]:='Error 291';
T_ErrorList.asErrorListEnglish.T_LanguagList[292]:='Error 292';
T_ErrorList.asErrorListEnglish.T_LanguagList[293]:='Error 293';
T_ErrorList.asErrorListEnglish.T_LanguagList[294]:='Error 294';
T_ErrorList.asErrorListEnglish.T_LanguagList[295]:='Error 295';
T_ErrorList.asErrorListEnglish.T_LanguagList[296]:='Error 296';
T_ErrorList.asErrorListEnglish.T_LanguagList[297]:='Error 297';
T_ErrorList.asErrorListEnglish.T_LanguagList[298]:='Error 298';
T_ErrorList.asErrorListEnglish.T_LanguagList[299]:='Error 299';
T_ErrorList.asErrorListEnglish.T_LanguagList[300]:='Error 300';

(* Static Francais Error List *)
T_ErrorList.asErrorListFrancais.T_LanguagList[1]:='Error 1';
T_ErrorList.asErrorListFrancais.T_LanguagList[2]:='Error 2';
T_ErrorList.asErrorListFrancais.T_LanguagList[3]:='Error 3';
T_ErrorList.asErrorListFrancais.T_LanguagList[4]:='Error 4';
T_ErrorList.asErrorListFrancais.T_LanguagList[5]:='Error 5';
T_ErrorList.asErrorListFrancais.T_LanguagList[6]:='Error 6';
T_ErrorList.asErrorListFrancais.T_LanguagList[7]:='Error 7';
T_ErrorList.asErrorListFrancais.T_LanguagList[8]:='Error 8';
T_ErrorList.asErrorListFrancais.T_LanguagList[9]:='Error 9';
T_ErrorList.asErrorListFrancais.T_LanguagList[10]:='Error 10';
T_ErrorList.asErrorListFrancais.T_LanguagList[11]:='Error 11';
T_ErrorList.asErrorListFrancais.T_LanguagList[12]:='Error 12';
T_ErrorList.asErrorListFrancais.T_LanguagList[13]:='Error 13';
T_ErrorList.asErrorListFrancais.T_LanguagList[14]:='Error 14';
T_ErrorList.asErrorListFrancais.T_LanguagList[15]:='Error 15';
T_ErrorList.asErrorListFrancais.T_LanguagList[16]:='Error 16';
T_ErrorList.asErrorListFrancais.T_LanguagList[17]:='Error 17';
T_ErrorList.asErrorListFrancais.T_LanguagList[18]:='Error 18';
T_ErrorList.asErrorListFrancais.T_LanguagList[19]:='Error 19';
T_ErrorList.asErrorListFrancais.T_LanguagList[20]:='Error 20';
T_ErrorList.asErrorListFrancais.T_LanguagList[21]:='Error 21';
T_ErrorList.asErrorListFrancais.T_LanguagList[22]:='Error 22';
T_ErrorList.asErrorListFrancais.T_LanguagList[23]:='Error 23';
T_ErrorList.asErrorListFrancais.T_LanguagList[24]:='Error 24';
T_ErrorList.asErrorListFrancais.T_LanguagList[25]:='Error 25';
T_ErrorList.asErrorListFrancais.T_LanguagList[26]:='Error 26';
T_ErrorList.asErrorListFrancais.T_LanguagList[27]:='Error 27';
T_ErrorList.asErrorListFrancais.T_LanguagList[28]:='Error 28';
T_ErrorList.asErrorListFrancais.T_LanguagList[29]:='Error 29';
T_ErrorList.asErrorListFrancais.T_LanguagList[30]:='Error 30';
T_ErrorList.asErrorListFrancais.T_LanguagList[31]:='Error 31';
T_ErrorList.asErrorListFrancais.T_LanguagList[32]:='Error 32';
T_ErrorList.asErrorListFrancais.T_LanguagList[33]:='Error 33';
T_ErrorList.asErrorListFrancais.T_LanguagList[34]:='Error 34';
T_ErrorList.asErrorListFrancais.T_LanguagList[35]:='Error 35';
T_ErrorList.asErrorListFrancais.T_LanguagList[36]:='Error 36';
T_ErrorList.asErrorListFrancais.T_LanguagList[37]:='Error 37';
T_ErrorList.asErrorListFrancais.T_LanguagList[38]:='Error 38';
T_ErrorList.asErrorListFrancais.T_LanguagList[39]:='Error 39';
T_ErrorList.asErrorListFrancais.T_LanguagList[40]:='Error 40';
T_ErrorList.asErrorListFrancais.T_LanguagList[41]:='Error 41';
T_ErrorList.asErrorListFrancais.T_LanguagList[42]:='Error 42';
T_ErrorList.asErrorListFrancais.T_LanguagList[43]:='Error 43';
T_ErrorList.asErrorListFrancais.T_LanguagList[44]:='Error 44';
T_ErrorList.asErrorListFrancais.T_LanguagList[45]:='Error 45';
T_ErrorList.asErrorListFrancais.T_LanguagList[46]:='Error 46';
T_ErrorList.asErrorListFrancais.T_LanguagList[47]:='Error 47';
T_ErrorList.asErrorListFrancais.T_LanguagList[48]:='Error 48';
T_ErrorList.asErrorListFrancais.T_LanguagList[49]:='Error 49';
T_ErrorList.asErrorListFrancais.T_LanguagList[50]:='Error 50';
T_ErrorList.asErrorListFrancais.T_LanguagList[51]:='Error 51';
T_ErrorList.asErrorListFrancais.T_LanguagList[52]:='Error 52';
T_ErrorList.asErrorListFrancais.T_LanguagList[53]:='Error 53';
T_ErrorList.asErrorListFrancais.T_LanguagList[54]:='Error 54';
T_ErrorList.asErrorListFrancais.T_LanguagList[55]:='Error 55';
T_ErrorList.asErrorListFrancais.T_LanguagList[56]:='Error 56';
T_ErrorList.asErrorListFrancais.T_LanguagList[57]:='Error 57';
T_ErrorList.asErrorListFrancais.T_LanguagList[58]:='Error 58';
T_ErrorList.asErrorListFrancais.T_LanguagList[59]:='Error 59';
T_ErrorList.asErrorListFrancais.T_LanguagList[60]:='Error 60';
T_ErrorList.asErrorListFrancais.T_LanguagList[61]:='Error 61';
T_ErrorList.asErrorListFrancais.T_LanguagList[62]:='Error 62';
T_ErrorList.asErrorListFrancais.T_LanguagList[63]:='Error 63';
T_ErrorList.asErrorListFrancais.T_LanguagList[64]:='Error 64';
T_ErrorList.asErrorListFrancais.T_LanguagList[65]:='Error 65';
T_ErrorList.asErrorListFrancais.T_LanguagList[66]:='Error 66';
T_ErrorList.asErrorListFrancais.T_LanguagList[67]:='Error 67';
T_ErrorList.asErrorListFrancais.T_LanguagList[68]:='Error 68';
T_ErrorList.asErrorListFrancais.T_LanguagList[69]:='Error 69';
T_ErrorList.asErrorListFrancais.T_LanguagList[70]:='Error 70';
T_ErrorList.asErrorListFrancais.T_LanguagList[71]:='Error 71';
T_ErrorList.asErrorListFrancais.T_LanguagList[72]:='Error 72';
T_ErrorList.asErrorListFrancais.T_LanguagList[73]:='Error 73';
T_ErrorList.asErrorListFrancais.T_LanguagList[74]:='Error 74';
T_ErrorList.asErrorListFrancais.T_LanguagList[75]:='Error 75';
T_ErrorList.asErrorListFrancais.T_LanguagList[76]:='Error 76';
T_ErrorList.asErrorListFrancais.T_LanguagList[77]:='Error 77';
T_ErrorList.asErrorListFrancais.T_LanguagList[78]:='Error 78';
T_ErrorList.asErrorListFrancais.T_LanguagList[79]:='Error 79';
T_ErrorList.asErrorListFrancais.T_LanguagList[80]:='Error 80';
T_ErrorList.asErrorListFrancais.T_LanguagList[81]:='Error 81';
T_ErrorList.asErrorListFrancais.T_LanguagList[82]:='Error 82';
T_ErrorList.asErrorListFrancais.T_LanguagList[83]:='Error 83';
T_ErrorList.asErrorListFrancais.T_LanguagList[84]:='Error 84';
T_ErrorList.asErrorListFrancais.T_LanguagList[85]:='Error 85';
T_ErrorList.asErrorListFrancais.T_LanguagList[86]:='Error 86';
T_ErrorList.asErrorListFrancais.T_LanguagList[87]:='Error 87';
T_ErrorList.asErrorListFrancais.T_LanguagList[88]:='Error 88';
T_ErrorList.asErrorListFrancais.T_LanguagList[89]:='Error 89';
T_ErrorList.asErrorListFrancais.T_LanguagList[90]:='Error 90';
T_ErrorList.asErrorListFrancais.T_LanguagList[91]:='Error 91';
T_ErrorList.asErrorListFrancais.T_LanguagList[92]:='Error 92';
T_ErrorList.asErrorListFrancais.T_LanguagList[93]:='Error 93';
T_ErrorList.asErrorListFrancais.T_LanguagList[94]:='Error 94';
T_ErrorList.asErrorListFrancais.T_LanguagList[95]:='Error 95';
T_ErrorList.asErrorListFrancais.T_LanguagList[96]:='Error 96';
T_ErrorList.asErrorListFrancais.T_LanguagList[97]:='Error 97';
T_ErrorList.asErrorListFrancais.T_LanguagList[98]:='Error 98';
T_ErrorList.asErrorListFrancais.T_LanguagList[99]:='Error 99';
T_ErrorList.asErrorListFrancais.T_LanguagList[100]:='Error 100';
T_ErrorList.asErrorListFrancais.T_LanguagList[101]:='Error 101';
T_ErrorList.asErrorListFrancais.T_LanguagList[102]:='Error 102';
T_ErrorList.asErrorListFrancais.T_LanguagList[103]:='Error 103';
T_ErrorList.asErrorListFrancais.T_LanguagList[104]:='Error 104';
T_ErrorList.asErrorListFrancais.T_LanguagList[105]:='Error 105';
T_ErrorList.asErrorListFrancais.T_LanguagList[106]:='Error 106';
T_ErrorList.asErrorListFrancais.T_LanguagList[107]:='Error 107';
T_ErrorList.asErrorListFrancais.T_LanguagList[108]:='Error 108';
T_ErrorList.asErrorListFrancais.T_LanguagList[109]:='Error 109';
T_ErrorList.asErrorListFrancais.T_LanguagList[110]:='Error 110';
T_ErrorList.asErrorListFrancais.T_LanguagList[111]:='Error 111';
T_ErrorList.asErrorListFrancais.T_LanguagList[112]:='Error 112';
T_ErrorList.asErrorListFrancais.T_LanguagList[113]:='Error 113';
T_ErrorList.asErrorListFrancais.T_LanguagList[114]:='Error 114';
T_ErrorList.asErrorListFrancais.T_LanguagList[115]:='Error 115';
T_ErrorList.asErrorListFrancais.T_LanguagList[116]:='Error 116';
T_ErrorList.asErrorListFrancais.T_LanguagList[117]:='Error 117';
T_ErrorList.asErrorListFrancais.T_LanguagList[118]:='Error 118';
T_ErrorList.asErrorListFrancais.T_LanguagList[119]:='Error 119';
T_ErrorList.asErrorListFrancais.T_LanguagList[120]:='Error 120';
T_ErrorList.asErrorListFrancais.T_LanguagList[121]:='Error 121';
T_ErrorList.asErrorListFrancais.T_LanguagList[122]:='Error 122';
T_ErrorList.asErrorListFrancais.T_LanguagList[123]:='Error 123';
T_ErrorList.asErrorListFrancais.T_LanguagList[124]:='Error 124';
T_ErrorList.asErrorListFrancais.T_LanguagList[125]:='Error 125';
T_ErrorList.asErrorListFrancais.T_LanguagList[126]:='Error 126';
T_ErrorList.asErrorListFrancais.T_LanguagList[127]:='Error 127';
T_ErrorList.asErrorListFrancais.T_LanguagList[128]:='Error 128';
T_ErrorList.asErrorListFrancais.T_LanguagList[129]:='Error 129';
T_ErrorList.asErrorListFrancais.T_LanguagList[130]:='Error 130';
T_ErrorList.asErrorListFrancais.T_LanguagList[131]:='Error 131';
T_ErrorList.asErrorListFrancais.T_LanguagList[132]:='Error 132';
T_ErrorList.asErrorListFrancais.T_LanguagList[133]:='Error 133';
T_ErrorList.asErrorListFrancais.T_LanguagList[134]:='Error 134';
T_ErrorList.asErrorListFrancais.T_LanguagList[135]:='Error 135';
T_ErrorList.asErrorListFrancais.T_LanguagList[136]:='Error 136';
T_ErrorList.asErrorListFrancais.T_LanguagList[137]:='Error 137';
T_ErrorList.asErrorListFrancais.T_LanguagList[138]:='Error 138';
T_ErrorList.asErrorListFrancais.T_LanguagList[139]:='Error 139';
T_ErrorList.asErrorListFrancais.T_LanguagList[140]:='Error 140';
T_ErrorList.asErrorListFrancais.T_LanguagList[141]:='Error 141';
T_ErrorList.asErrorListFrancais.T_LanguagList[142]:='Error 142';
T_ErrorList.asErrorListFrancais.T_LanguagList[143]:='Error 143';
T_ErrorList.asErrorListFrancais.T_LanguagList[144]:='Error 144';
T_ErrorList.asErrorListFrancais.T_LanguagList[145]:='Error 145';
T_ErrorList.asErrorListFrancais.T_LanguagList[146]:='Error 146';
T_ErrorList.asErrorListFrancais.T_LanguagList[147]:='Error 147';
T_ErrorList.asErrorListFrancais.T_LanguagList[148]:='Error 148';
T_ErrorList.asErrorListFrancais.T_LanguagList[149]:='Error 149';
T_ErrorList.asErrorListFrancais.T_LanguagList[150]:='Error 150';
T_ErrorList.asErrorListFrancais.T_LanguagList[151]:='Error 151';
T_ErrorList.asErrorListFrancais.T_LanguagList[152]:='Error 152';
T_ErrorList.asErrorListFrancais.T_LanguagList[153]:='Error 153';
T_ErrorList.asErrorListFrancais.T_LanguagList[154]:='Error 154';
T_ErrorList.asErrorListFrancais.T_LanguagList[155]:='Error 155';
T_ErrorList.asErrorListFrancais.T_LanguagList[156]:='Error 156';
T_ErrorList.asErrorListFrancais.T_LanguagList[157]:='Error 157';
T_ErrorList.asErrorListFrancais.T_LanguagList[158]:='Error 158';
T_ErrorList.asErrorListFrancais.T_LanguagList[159]:='Error 159';
T_ErrorList.asErrorListFrancais.T_LanguagList[160]:='Error 160';
T_ErrorList.asErrorListFrancais.T_LanguagList[161]:='Error 161';
T_ErrorList.asErrorListFrancais.T_LanguagList[162]:='Error 162';
T_ErrorList.asErrorListFrancais.T_LanguagList[163]:='Error 163';
T_ErrorList.asErrorListFrancais.T_LanguagList[164]:='Error 164';
T_ErrorList.asErrorListFrancais.T_LanguagList[165]:='Error 165';
T_ErrorList.asErrorListFrancais.T_LanguagList[166]:='Error 166';
T_ErrorList.asErrorListFrancais.T_LanguagList[167]:='Error 167';
T_ErrorList.asErrorListFrancais.T_LanguagList[168]:='Error 168';
T_ErrorList.asErrorListFrancais.T_LanguagList[169]:='Error 169';
T_ErrorList.asErrorListFrancais.T_LanguagList[170]:='Error 170';
T_ErrorList.asErrorListFrancais.T_LanguagList[171]:='Error 171';
T_ErrorList.asErrorListFrancais.T_LanguagList[172]:='Error 172';
T_ErrorList.asErrorListFrancais.T_LanguagList[173]:='Error 173';
T_ErrorList.asErrorListFrancais.T_LanguagList[174]:='Error 174';
T_ErrorList.asErrorListFrancais.T_LanguagList[175]:='Error 175';
T_ErrorList.asErrorListFrancais.T_LanguagList[176]:='Error 176';
T_ErrorList.asErrorListFrancais.T_LanguagList[177]:='Error 177';
T_ErrorList.asErrorListFrancais.T_LanguagList[178]:='Error 178';
T_ErrorList.asErrorListFrancais.T_LanguagList[179]:='Error 179';
T_ErrorList.asErrorListFrancais.T_LanguagList[180]:='Error 180';
T_ErrorList.asErrorListFrancais.T_LanguagList[181]:='Error 181';
T_ErrorList.asErrorListFrancais.T_LanguagList[182]:='Error 182';
T_ErrorList.asErrorListFrancais.T_LanguagList[183]:='Error 183';
T_ErrorList.asErrorListFrancais.T_LanguagList[184]:='Error 184';
T_ErrorList.asErrorListFrancais.T_LanguagList[185]:='Error 185';
T_ErrorList.asErrorListFrancais.T_LanguagList[186]:='Error 186';
T_ErrorList.asErrorListFrancais.T_LanguagList[187]:='Error 187';
T_ErrorList.asErrorListFrancais.T_LanguagList[188]:='Error 188';
T_ErrorList.asErrorListFrancais.T_LanguagList[189]:='Error 189';
T_ErrorList.asErrorListFrancais.T_LanguagList[190]:='Error 190';
T_ErrorList.asErrorListFrancais.T_LanguagList[191]:='Error 191';
T_ErrorList.asErrorListFrancais.T_LanguagList[192]:='Error 192';
T_ErrorList.asErrorListFrancais.T_LanguagList[193]:='Error 193';
T_ErrorList.asErrorListFrancais.T_LanguagList[194]:='Error 194';
T_ErrorList.asErrorListFrancais.T_LanguagList[195]:='Error 195';
T_ErrorList.asErrorListFrancais.T_LanguagList[196]:='Error 196';
T_ErrorList.asErrorListFrancais.T_LanguagList[197]:='Error 197';
T_ErrorList.asErrorListFrancais.T_LanguagList[198]:='Error 198';
T_ErrorList.asErrorListFrancais.T_LanguagList[199]:='Error 199';
T_ErrorList.asErrorListFrancais.T_LanguagList[200]:='Error 200';
T_ErrorList.asErrorListFrancais.T_LanguagList[201]:='Error 201';
T_ErrorList.asErrorListFrancais.T_LanguagList[202]:='Error 202';
T_ErrorList.asErrorListFrancais.T_LanguagList[203]:='Error 203';
T_ErrorList.asErrorListFrancais.T_LanguagList[204]:='Error 204';
T_ErrorList.asErrorListFrancais.T_LanguagList[205]:='Error 205';
T_ErrorList.asErrorListFrancais.T_LanguagList[206]:='Error 206';
T_ErrorList.asErrorListFrancais.T_LanguagList[207]:='Error 207';
T_ErrorList.asErrorListFrancais.T_LanguagList[208]:='Error 208';
T_ErrorList.asErrorListFrancais.T_LanguagList[209]:='Error 209';
T_ErrorList.asErrorListFrancais.T_LanguagList[210]:='Error 210';
T_ErrorList.asErrorListFrancais.T_LanguagList[211]:='Error 211';
T_ErrorList.asErrorListFrancais.T_LanguagList[212]:='Error 212';
T_ErrorList.asErrorListFrancais.T_LanguagList[213]:='Error 213';
T_ErrorList.asErrorListFrancais.T_LanguagList[214]:='Error 214';
T_ErrorList.asErrorListFrancais.T_LanguagList[215]:='Error 215';
T_ErrorList.asErrorListFrancais.T_LanguagList[216]:='Error 216';
T_ErrorList.asErrorListFrancais.T_LanguagList[217]:='Error 217';
T_ErrorList.asErrorListFrancais.T_LanguagList[218]:='Error 218';
T_ErrorList.asErrorListFrancais.T_LanguagList[219]:='Error 219';
T_ErrorList.asErrorListFrancais.T_LanguagList[220]:='Error 220';
T_ErrorList.asErrorListFrancais.T_LanguagList[221]:='Error 221';
T_ErrorList.asErrorListFrancais.T_LanguagList[222]:='Error 222';
T_ErrorList.asErrorListFrancais.T_LanguagList[223]:='Error 223';
T_ErrorList.asErrorListFrancais.T_LanguagList[224]:='Error 224';
T_ErrorList.asErrorListFrancais.T_LanguagList[225]:='Error 225';
T_ErrorList.asErrorListFrancais.T_LanguagList[226]:='Error 226';
T_ErrorList.asErrorListFrancais.T_LanguagList[227]:='Error 227';
T_ErrorList.asErrorListFrancais.T_LanguagList[228]:='Error 228';
T_ErrorList.asErrorListFrancais.T_LanguagList[229]:='Error 229';
T_ErrorList.asErrorListFrancais.T_LanguagList[230]:='Error 230';
T_ErrorList.asErrorListFrancais.T_LanguagList[231]:='Error 231';
T_ErrorList.asErrorListFrancais.T_LanguagList[232]:='Error 232';
T_ErrorList.asErrorListFrancais.T_LanguagList[233]:='Error 233';
T_ErrorList.asErrorListFrancais.T_LanguagList[234]:='Error 234';
T_ErrorList.asErrorListFrancais.T_LanguagList[235]:='Error 235';
T_ErrorList.asErrorListFrancais.T_LanguagList[236]:='Error 236';
T_ErrorList.asErrorListFrancais.T_LanguagList[237]:='Error 237';
T_ErrorList.asErrorListFrancais.T_LanguagList[238]:='Error 238';
T_ErrorList.asErrorListFrancais.T_LanguagList[239]:='Error 239';
T_ErrorList.asErrorListFrancais.T_LanguagList[240]:='Error 240';
T_ErrorList.asErrorListFrancais.T_LanguagList[241]:='Error 241';
T_ErrorList.asErrorListFrancais.T_LanguagList[242]:='Error 242';
T_ErrorList.asErrorListFrancais.T_LanguagList[243]:='Error 243';
T_ErrorList.asErrorListFrancais.T_LanguagList[244]:='Error 244';
T_ErrorList.asErrorListFrancais.T_LanguagList[245]:='Error 245';
T_ErrorList.asErrorListFrancais.T_LanguagList[246]:='Error 246';
T_ErrorList.asErrorListFrancais.T_LanguagList[247]:='Error 247';
T_ErrorList.asErrorListFrancais.T_LanguagList[248]:='Error 248';
T_ErrorList.asErrorListFrancais.T_LanguagList[249]:='Error 249';
T_ErrorList.asErrorListFrancais.T_LanguagList[250]:='Error 250';
T_ErrorList.asErrorListFrancais.T_LanguagList[251]:='Error 251';
T_ErrorList.asErrorListFrancais.T_LanguagList[252]:='Error 252';
T_ErrorList.asErrorListFrancais.T_LanguagList[253]:='Error 253';
T_ErrorList.asErrorListFrancais.T_LanguagList[254]:='Error 254';
T_ErrorList.asErrorListFrancais.T_LanguagList[255]:='Error 255';
T_ErrorList.asErrorListFrancais.T_LanguagList[256]:='Error 256';
T_ErrorList.asErrorListFrancais.T_LanguagList[257]:='Error 257';
T_ErrorList.asErrorListFrancais.T_LanguagList[258]:='Error 258';
T_ErrorList.asErrorListFrancais.T_LanguagList[259]:='Error 259';
T_ErrorList.asErrorListFrancais.T_LanguagList[260]:='Error 260';
T_ErrorList.asErrorListFrancais.T_LanguagList[261]:='Error 261';
T_ErrorList.asErrorListFrancais.T_LanguagList[262]:='Error 262';
T_ErrorList.asErrorListFrancais.T_LanguagList[263]:='Error 263';
T_ErrorList.asErrorListFrancais.T_LanguagList[264]:='Error 264';
T_ErrorList.asErrorListFrancais.T_LanguagList[265]:='Error 265';
T_ErrorList.asErrorListFrancais.T_LanguagList[266]:='Error 266';
T_ErrorList.asErrorListFrancais.T_LanguagList[267]:='Error 267';
T_ErrorList.asErrorListFrancais.T_LanguagList[268]:='Error 268';
T_ErrorList.asErrorListFrancais.T_LanguagList[269]:='Error 269';
T_ErrorList.asErrorListFrancais.T_LanguagList[270]:='Error 270';
T_ErrorList.asErrorListFrancais.T_LanguagList[271]:='Error 271';
T_ErrorList.asErrorListFrancais.T_LanguagList[272]:='Error 272';
T_ErrorList.asErrorListFrancais.T_LanguagList[273]:='Error 273';
T_ErrorList.asErrorListFrancais.T_LanguagList[274]:='Error 274';
T_ErrorList.asErrorListFrancais.T_LanguagList[275]:='Error 275';
T_ErrorList.asErrorListFrancais.T_LanguagList[276]:='Error 276';
T_ErrorList.asErrorListFrancais.T_LanguagList[277]:='Error 277';
T_ErrorList.asErrorListFrancais.T_LanguagList[278]:='Error 278';
T_ErrorList.asErrorListFrancais.T_LanguagList[279]:='Error 279';
T_ErrorList.asErrorListFrancais.T_LanguagList[280]:='Error 280';
T_ErrorList.asErrorListFrancais.T_LanguagList[281]:='Error 281';
T_ErrorList.asErrorListFrancais.T_LanguagList[282]:='Error 282';
T_ErrorList.asErrorListFrancais.T_LanguagList[283]:='Error 283';
T_ErrorList.asErrorListFrancais.T_LanguagList[284]:='Error 284';
T_ErrorList.asErrorListFrancais.T_LanguagList[285]:='Error 285';
T_ErrorList.asErrorListFrancais.T_LanguagList[286]:='Error 286';
T_ErrorList.asErrorListFrancais.T_LanguagList[287]:='Error 287';
T_ErrorList.asErrorListFrancais.T_LanguagList[288]:='Error 288';
T_ErrorList.asErrorListFrancais.T_LanguagList[289]:='Error 289';
T_ErrorList.asErrorListFrancais.T_LanguagList[290]:='Error 290';
T_ErrorList.asErrorListFrancais.T_LanguagList[291]:='Error 291';
T_ErrorList.asErrorListFrancais.T_LanguagList[292]:='Error 292';
T_ErrorList.asErrorListFrancais.T_LanguagList[293]:='Error 293';
T_ErrorList.asErrorListFrancais.T_LanguagList[294]:='Error 294';
T_ErrorList.asErrorListFrancais.T_LanguagList[295]:='Error 295';
T_ErrorList.asErrorListFrancais.T_LanguagList[296]:='Error 296';
T_ErrorList.asErrorListFrancais.T_LanguagList[297]:='Error 297';
T_ErrorList.asErrorListFrancais.T_LanguagList[298]:='Error 298';
T_ErrorList.asErrorListFrancais.T_LanguagList[299]:='Error 299';
T_ErrorList.asErrorListFrancais.T_LanguagList[300]:='Error 300';
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL\/ERROR' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_ResetError
VAR_INPUT
END_VAR
VAR_IN_OUT
	xExecute:BOOL;
END_VAR
VAR_OUTPUT
	xDone:BOOL;
END_VAR
VAR
(* Trigger *)
	RisingEdgeExecute:R_TRIG;
(* Pointer *)
	ptrActivStation:POINTER TO ST_STATION;
	xFct_ResetError: BOOL;
	iStep_ResetError: INT;
	iCheckStationNr: INT;
	TONWaitReady:TON;
END_VAR
(* @END_DECLARATION := '0' *)
	RisingEdgeExecute(CLK:=xExecute);
	IF RisingEdgeExecute.Q THEN
	(* Init. variable by start clear error *)
		(* ...output *)
		xDone:=FALSE;
		(* ...input *)
		xExecute:=FALSE;
		xFct_ResetError:=TRUE;
		iStep_ResetError:=1;
		ptrActivStation:=ADR(TStation_Work_St1);
	END_IF;
	IF xFct_ResetError THEN
		CASE iStep_ResetError OF
			(* Überprüfe zuerst ob der Prozess im Fehlerzustand steht *)
			1:	iCheckStationNr:=1;
				IF TProcess.T_Ctrle.xEnable AND TProcess.T_Ctrle.xError THEN
					TProcess.T_Ctrle.xQuitError:=TRUE;
				ELSIF NOT(TProcess.T_Ctrle.xEnable) THEN
					TProcess.T_Ctrle.xEnable:=TRUE;
				END_IF;
				TProcess.T_Ctrle.xStop:=FALSE;
				iStep_ResetError:=iStep_ResetError + 1;
			2:	IF TProcess.T_Ctrle.xEnable AND TProcess.T_Ctrle.xDone AND NOT(TProcess.T_Ctrle.xError) AND NOT(TProcess.T_Ctrle.xQuitError) THEN
					iStep_ResetError:=iStep_ResetError + 1;
				ELSIF NOT(TProcess.T_Ctrle.xDone) AND NOT(TProcess.T_Ctrle.xError) AND NOT(TProcess.T_Ctrle.xQuitError) THEN
					TProcess.T_Ctrle.xEnable:=FALSE;
					iStep_ResetError:=1;
				END_IF;
			(* Überprüfe alle Stationen ob sie im Fehlerzustand sind *)
			3:	IF (iCheckStationNr = 1) THEN
					ptrActivStation:=ADR(TStation_Work_St1);
				ELSE
					iStep_ResetError:=iStep_ResetError + 3;	(* Aktuatoren überprüfen *)
					RETURN;
				END_IF;
				iStep_ResetError:=iStep_ResetError + 1;
			4:	IF ptrActivStation^.TControl.xEnable AND ptrActivStation^.TControl.xError THEN
					ptrActivStation^.TControl.xQuitError:=TRUE;
					iStep_ResetError:=iStep_ResetError + 1;
				ELSE
					iCheckStationNr:=iCheckStationNr + 1;	(* Nächste Station überprüfen *)
					ptrActivStation^.TControl.xQuitError:=FALSE;
					iStep_ResetError:=iStep_ResetError - 1;
				END_IF;
			5:	IF NOT(ptrActivStation^.TControl.xQuitError) AND NOT(ptrActivStation^.TControl.xError) AND ptrActivStation^.TControl.xDone THEN
					iCheckStationNr:=iCheckStationNr + 1;	(* Nächste Station überprüfen *)
					ptrActivStation^.TControl.xQuitError:=FALSE;
					iStep_ResetError:=iStep_ResetError - 2;
				END_IF;
			(* Resetten der Aktuatoren *)
			6:	IF xFct_Reset_Actuator() THEN
					TONWaitReady(IN:=FALSE);
					iStep_ResetError:=iStep_ResetError + 1;
				END_IF;
			7:	TONWaitReady(IN:=TRUE,PT:=T#0.5s);
				IF TONWaitReady.Q THEN
					iStep_ResetError:=1;
					xFct_ResetError:=FALSE;
					xDone:=TRUE;
				END_IF;
		END_CASE;
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL\/ERROR' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION Fct_ConvertDateToString : STRING
VAR_INPUT
		iFormat:INT;	(* 0=Langes Date-Time Format; 1=Kurzes Date-Time Format; 2=Sehr Kurzes Date-Time Format *)
					(* 0='28.March 2007  08:47:01' *)
					(* 1='28.03.07 08:47' *)
					(* 2='28.03 08:47' *)
					(* 3='28.03.2007 08:47:01' *)
		TProcTimeStart:TIMESTRUCT;
END_VAR
VAR
	sTmpData:STRING(255);
	sTmpData1:STRING(255);
	wYear: WORD;
END_VAR
(* @END_DECLARATION := '0' *)
sTmpData:=sTmpData1:='';
IF (iFormat < 0) OR (iFormat > 3) THEN
	sTmpData1:='Wrong Date';
	Fct_ConvertDateToString:=sTmpData1;
	RETURN;
END_IF;
IF (TProcTimeStart.wDay <> 0) THEN
	IF (TProcTimeStart.wDay >= 0) AND (TProcTimeStart.wDay <= 9) THEN
		sTmpData1:=MUX(TProcTimeStart.wDay,'00','01','02','03','04','05','06','07','08','09');
		sTmpData:=CONCAT(sTmpData,sTmpData1);
	ELSE
		sTmpData:=CONCAT(sTmpData,WORD_TO_STRING(TProcTimeStart.wDay));
	END_IF;
	sTmpData:=CONCAT(sTmpData,'.');
ELSE
	sTmpData1:='Wrong Date';
	Fct_ConvertDateToString:=sTmpData1;
	RETURN;
END_IF;
IF (TProcTimeStart.wMonth <> 0) THEN
	IF (iFormat = 0) THEN
		sTmpData1:=MUX(TProcTimeStart.wMonth-1,'January','February','March','April','May','June','July','August','September','October','November','December');
	END_IF;
	IF (iFormat = 1) OR (iFormat = 2) OR (iFormat = 3) THEN
		sTmpData1:=MUX(TProcTimeStart.wMonth-1,'01','02','03','04','05','06','07','08','09','10','11','12');
	END_IF;
ELSE
	sTmpData1:='Wrong Date';
	Fct_ConvertDateToString:=sTmpData1;
	RETURN;
END_IF;
sTmpData:=CONCAT(sTmpData,sTmpData1);
IF (iFormat = 0) THEN
	sTmpData:=CONCAT(sTmpData,' ');
END_IF;
IF (iFormat = 1) THEN
	sTmpData:=CONCAT(sTmpData,'.');
END_IF;
IF (iFormat = 2) THEN
	sTmpData:=CONCAT(sTmpData,' ');
END_IF;
IF (iFormat = 3) THEN
	sTmpData:=CONCAT(sTmpData,'.');
END_IF;
IF (iFormat = 0) OR (iFormat = 1) OR (iFormat = 3) THEN
	IF (TProcTimeStart.wYear <> 0) THEN
		IF (iFormat = 0) OR (iFormat = 3) THEN
			sTmpData:=CONCAT(sTmpData,WORD_TO_STRING(TProcTimeStart.wYear));
			sTmpData:=CONCAT(sTmpData,'  ');
		END_IF;
		IF (iFormat = 1) THEN
			IF (TProcTimeStart.wYear >= 1000) AND (TProcTimeStart.wYear < 2000) THEN
				wYear:=TProcTimeStart.wYear - 1000;
			END_IF;
			IF (TProcTimeStart.wYear >= 2000) AND (TProcTimeStart.wYear < 3000) THEN
				wYear:=TProcTimeStart.wYear - 2000;
			END_IF;
			IF (wYear >= 0) AND (wYear < 10) THEN
				sTmpData1:=MUX(wYear,'00','01','02','03','04','05','06','07','08','09');
				sTmpData:=CONCAT(sTmpData,sTmpData1);
			ELSE
				sTmpData:=CONCAT(sTmpData,WORD_TO_STRING(wYear));
			END_IF;
			sTmpData:=CONCAT(sTmpData,' ');
		END_IF;
	ELSE
		sTmpData1:='Wrong Date';
		Fct_ConvertDateToString:=sTmpData1;
		RETURN;
	END_IF;
END_IF;
IF (TProcTimeStart.wHour >= 0) AND (TProcTimeStart.wHour <= 9) THEN
	sTmpData1:=MUX(TProcTimeStart.wHour,'00','01','02','03','04','05','06','07','08','09');
	sTmpData:=CONCAT(sTmpData,sTmpData1);
ELSE
	sTmpData:=CONCAT(sTmpData,WORD_TO_STRING(TProcTimeStart.wHour));
END_IF;
sTmpData:=CONCAT(sTmpData,':');
IF (TProcTimeStart.wMinute >= 0) AND (TProcTimeStart.wMinute <= 9) THEN
	sTmpData1:=MUX(TProcTimeStart.wMinute,'00','01','02','03','04','05','06','07','08','09');
	sTmpData:=CONCAT(sTmpData,sTmpData1);
ELSE
	sTmpData:=CONCAT(sTmpData,WORD_TO_STRING(TProcTimeStart.wMinute));
END_IF;
IF (iFormat = 0) OR (iFormat = 3) THEN
	sTmpData:=CONCAT(sTmpData,':');
	IF (TProcTimeStart.wSecond >= 0) AND (TProcTimeStart.wSecond <= 9) THEN
		sTmpData1:=MUX(TProcTimeStart.wSecond,'00','01','02','03','04','05','06','07','08','09');
		sTmpData:=CONCAT(sTmpData,sTmpData1);
	ELSE
		sTmpData:=CONCAT(sTmpData,WORD_TO_STRING(TProcTimeStart.wSecond));
	END_IF;
END_IF;
Fct_ConvertDateToString:=sTmpData;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL\/ERROR' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION xFct_Reset_Actuator : BOOL
VAR_INPUT
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
xFct_Reset_Actuator:=FALSE;
(* Resetten der Achsen *)
IF NOT(TStation_Work_St1.TControl.xResetHardware) THEN
	TStation_Work_St1.TControl.xResetHardware:=TRUE;	(* Andere Abhandlung weil Safety Drive Optionskarte im Servo intergriert ist *)
	TStation_Work_St1.TControl.xResetHardwareActivateCurrent:=TRUE;
END_IF;
(* Resetten der Zylinder *)
TStation_Work_St1.THWWorkStation.TCylBrakeReleaseZAxis.T_CtrleCyl.xReset:=TStation_Work_St1.THWWorkStation.TCylBrakeReleaseZAxis.T_CtrleCyl.xErr;
T_ProcessData_St1.T_Ctrle.xReset:=T_ProcessData_St1.T_Ctrle.xErr;
xFct_Reset_Actuator:=TRUE;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL\/PROCESSDATA' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_PROCESSDATA
VAR_INPUT
END_VAR
VAR_IN_OUT
	T_ProcessData:ST_PROCESSDATA;
	T_PartAnalysis:ST_PARTANALYSIS;
	T_HDD:ST_HDD;
END_VAR
VAR_OUTPUT
END_VAR
VAR
	sTmp:STRING(255);
	RisingEdgeReset:R_TRIG;
	RisingEdgeExecute:R_TRIG;
	xConfirmResetFB: BOOL;
	TimerFileLocked:TON;
	tTimeOut: TIME;
	iStepFunction: INT;
	xTmp: BOOL;
	TimerOut: TON;
	FBNT_GetTime:NT_GetTime;
	sGetDate: STRING;
	xInit: BOOL;
	sDeleteData: ARRAY[1..csiMaxFileLine] OF STRING(csiMaxCharPerLine);
	iStepFunction_Intern: INT;
	iStepFunction_Check: INT;
	xWriteData: BOOL;
	sYear: STRING;
	sMonth: STRING;
	sDay: STRING;
	sHour: STRING;
	sMinute: STRING;
	sSecond: STRING;
	xReadTimeStamp: BOOL;
	iStep_TimeStamp: INT;
	iStepCountWriteDirectory: INT;
	xWriteFileFirstTime: BOOL;
	ii: INT;
	sWorkPartQuality: STRING;
	sFirstHC: STRING;
	sHCCounter: STRING;
	sHCCounterCentering: STRING;
	sHCCounterTorque: STRING;
	sHCCounterSpeed:STRING;	(* IGS *)
	sCycleTime: STRING;
	sWorkTime: STRING;
	sInfeedCounterZ: STRING;
	iDataPointer: INT;
	sNumberHole: STRING;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                               This Functionblock manage the FTP Client upload file                                                        ************)
(****************************************************************************************************************************************************)
(* waiting for reset *)
	RisingEdgeReset(CLK:=T_ProcessData.T_Ctrle.xReset);
	IF RisingEdgeReset.Q THEN
	(* init. structure *)
		T_ProcessData.T_Ctrle.xExecute:=FALSE;
		T_ProcessData.T_Ctrle.xReset:=FALSE;
		T_ProcessData.T_Ctrle.xDone:=FALSE;
		T_ProcessData.T_Ctrle.xErr:=FALSE;
		T_ProcessData.T_Ctrle.udiErrorID:=0;
		T_ProcessData.T_Ctrle.iFunction:=0;
		IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; END_IF
		T_HDD.T_Ctrle.xLocked:=FALSE;
		(* Reset HDD if error activ *)
		(* Init. variable *)
		xWriteData:=FALSE;
		(* set flag done *)
		xConfirmResetFB:=TRUE;
		(* exit function *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_ProcessData.T_Ctrle.xDone:=TRUE;
			T_ProcessData.T_Ctrle.xErr:=FALSE;
			T_ProcessData.T_Ctrle.udiErrorID:=0;
			T_ProcessData.T_Ctrle.iFunction:=0;
			(* init. variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

TimerFileLocked(IN:=TRUE, PT:=T#10S);

(* waiting for execute *)
	RisingEdgeExecute(CLK:=T_ProcessData.T_Ctrle.xExecute);
	IF RisingEdgeExecute.Q THEN
		T_ProcessData.T_Ctrle.xExecute:=FALSE;
		CASE T_ProcessData.T_Ctrle.iFunction OF
		(* Write Data File on USB Stick *)
		1:	xWriteData:=TRUE;
			tTimeOut:=T#300s;
		ELSE
		(* function not implemented *)
			 T_ProcessData.T_Ctrle.xDone:=FALSE;
			 T_ProcessData.T_Ctrle.xErr:=TRUE;
			 T_ProcessData.T_Ctrle.udiErrorID:=200;
			 (* exit FB *)
			 RETURN;
		END_CASE
		(* Init. variable *)
		T_ProcessData.T_Ctrle.xDone:=FALSE;
		T_ProcessData.T_Ctrle.xErr:=FALSE;
		T_ProcessData.T_Ctrle.udiErrorID:=16#0;
		(* init. step *)
		iStepFunction:=1;
		iStepFunction_Intern:=1;
		iStepFunction_Check:=1;
		RETURN;
	END_IF

(* Monitor time out *)
	xTmp:=	NOT T_ProcessData.T_Ctrle.xDone
			AND NOT T_ProcessData.T_Ctrle.xErr;
	TimerOut(IN:=xTmp, PT:=tTimeOut);
	IF TimerOut.Q THEN iStepFunction:=97; END_IF

(* Read or Write profile *)
	IF xWriteData THEN
		CASE iStepFunction OF
		(* check if HDD state *)
		(* start timeout *)
		1:	TimerFileLocked(IN:=FALSE);
			iStepFunction:=iStepFunction + 1;
			iStepCountWriteDirectory:=0;
			xWriteFileFirstTime:=FALSE;
		(* file name and activ read or write *)
		2:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) AND NOT(T_HDD.T_Ctrle.xLocked) THEN
				T_HDD.T_Ctrle.xLocked:=TRUE;
				(* next step *)
				iStepFunction:=iStepFunction + 1;
				T_HDD.T_Data.sData:=sDeleteData;
			ELSE
				(* activ error if time out done, HDD not ready *)
				IF TimerFileLocked.Q THEN
					 iStepFunction:=91;
				END_IF
			END_IF;
		(* Überprüfe zuerst welche USB Stick als ProcessData definiert ist *)
		3:	IF (gsDriveNameProcessData = '') THEN
				IF NOT(gxHardwareOFF) THEN
					sTmp:='D:\PROCESSDATA.txt';
				ELSE
					sTmp:='C:\PROCESSDATA.txt';
					(*sTmp:='\Hard Disk2\PROCESSDATA.txt';*)
				END_IF;
				T_HDD.T_File.sPathAndFileName:=sTmp;
				T_HDD.T_Ctrle.iFunction:=1;
				T_HDD.T_Ctrle.xExecute:=TRUE;
				(* next step *)
				iStepFunction:=iStepFunction + 1;
			ELSE
				(* next step *)
				iStepFunction:=iStepFunction + 4;
			END_IF;
		(* waiting flag *)
		4:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN
				iStepFunction:=iStepFunction + 3;
				IF NOT(gxHardwareOFF) THEN
					gsDriveNameProcessData:='D:\';
				ELSE
					gsDriveNameProcessData:='C:\';
					(*gsDriveNameProcessData:='\Hard Disk2\';*)
				END_IF;
			END_IF
			IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; iStepFunction:=iStepFunction + 1; END_IF
		5:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) AND NOT(T_HDD.T_Ctrle.xLocked) THEN
				T_HDD.T_Ctrle.xLocked:=TRUE;
				IF NOT(gxHardwareOFF) THEN
					sTmp:='E:\PROCESSDATA.txt';
				ELSE
					sTmp:='C:\PROCESSDATA.txt';
					(*sTmp:='\Hard Disk2\PROCESSDATA.txt';*)
				END_IF;
				T_HDD.T_File.sPathAndFileName:=sTmp;
				T_HDD.T_Ctrle.iFunction:=1;
				T_HDD.T_Ctrle.xExecute:=TRUE;
				(* next step *)
				iStepFunction:=iStepFunction + 1;
			END_IF;
		(* waiting flag *)
		6:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN iStepFunction:=iStepFunction + 1; gsDriveNameProcessData:='E:\'; END_IF
			IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; iStepFunction:=99; END_IF
		7:	IF NOT(xReadTimeStamp) THEN
				xReadTimeStamp:=TRUE;	(* Zeitstempel lesen *)
				iStepFunction:=iStepFunction + 1;
			END_IF;
		8:	IF NOT(xReadTimeStamp) THEN
				sGetDate:=sYear;
				sGetDate:=CONCAT(sGetDate,'-');
				sGetDate:=CONCAT(sGetDate,sMonth);
				sGetDate:=CONCAT(sGetDate,'-');
				sGetDate:=CONCAT(sGetDate,sDay);
				sGetDate:=CONCAT(sGetDate,'_');
				sGetDate:=CONCAT(sGetDate,sHour);
				sGetDate:=CONCAT(sGetDate,'-');
				sGetDate:=CONCAT(sGetDate,sMinute);
				sGetDate:=CONCAT(sGetDate,'-');
				sGetDate:=CONCAT(sGetDate,sSecond);
				IF (T_PartAnalysis.sFileName = '') THEN
					xWriteFileFirstTime:=TRUE;
					T_PartAnalysis.sFileName:=CONCAT(sGetDate,'-St');
					T_PartAnalysis.sFileName:=CONCAT(T_PartAnalysis.sFileName,UINT_TO_STRING(gciStationSt1));
					T_PartAnalysis.sFileName:=CONCAT(T_PartAnalysis.sFileName,'.csv');
				END_IF;
				iStepFunction:=iStepFunction + 1;
			END_IF;
			xInit:=FALSE;
		(* file name and activ read or write *)
		9:	(* activ write *)
			IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN
				T_HDD.T_Data.sData:=sDeleteData;
				(* copy profile to HDD data structure *)
				 iStepFunction:=iStepFunction + 1;
				(* next step *)
			END_IF;
		(* activ write *)
		10:	sTmp:=CONCAT(gsDriveNameProcessData,'PROCESSDATA\');
			sTmp:=CONCAT(sTmp,T_PartAnalysis.sFileName);
			T_HDD.T_File.sPathAndFileName:=sTmp;
			iDataPointer:=1;
			IF xWriteFileFirstTime THEN
				(*T_HDD.T_Data.sData[iDataPointer]:='WPNumber;Timestamp;Hole Quality;FirstHC(mm);HC Counter(D);HC Counter(T);Cycle time(s);Work time(s);Z Inf.Counter;';*)	(* alt *)
				T_HDD.T_Data.sData[iDataPointer]:='WstkNr;Zeitstempel;Loch Qualität;ErsterHC(mm);HC Zähler(A);HC Zähler(D);HC Zähler(G);Zyklus(s);Bearb(s);Z Einf.Zähler;HC Zähler(Zentr.);';		(* IGS *)
				iDataPointer:=iDataPointer + 1;
			END_IF;
			FOR ii:=1 TO ciMaxWP DO
				IF (T_PartAnalysis.adiNumberHole[ii] = T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].diActual_NumberHoleToWork) THEN
					sNumberHole:=DINT_TO_STRING(T_PartAnalysis.adiNumberHole[ii]);
					sGetDate:=sYear;
					sGetDate:=CONCAT(sGetDate,'.');
					sGetDate:=CONCAT(sGetDate,sMonth);
					sGetDate:=CONCAT(sGetDate,'.');
					sGetDate:=CONCAT(sGetDate,sDay);
					sGetDate:=CONCAT(sGetDate,' ');
					sGetDate:=CONCAT(sGetDate,sHour);
					sGetDate:=CONCAT(sGetDate,':');
					sGetDate:=CONCAT(sGetDate,sMinute);
					sGetDate:=CONCAT(sGetDate,':');
					sGetDate:=CONCAT(sGetDate,sSecond);
					CASE T_PartAnalysis.abWorkPartQuality[ii] OF
					0:	sWorkPartQuality:='Hole not worked';
					1:	sWorkPartQuality:='Go HC';
					2:	sWorkPartQuality:='Go No HC';
					3:	sWorkPartQuality:='NoGo minTime';
					4:	sWorkPartQuality:='NoGo maxTime';
					5:	sWorkPartQuality:='NoGo insert fail';
					6:	sWorkPartQuality:='NoGo NoWP';
					7:	sWorkPartQuality:='Working';
					8:	sWorkPartQuality:='Cycle aborted';
					10:	sWorkPartQuality:='NoGo HC Centr.';
					END_CASE;
					sFirstHC:=REAL_TO_STRING(T_PartAnalysis.arFirstHC[ii]);
					sHCCounter:=INT_TO_STRING(T_PartAnalysis.aiHCCounter[ii]);
					sHCCounterCentering:=INT_TO_STRING(T_PartAnalysis.aiHCCounterCentering[ii]);
					sHCCounterTorque:=INT_TO_STRING(T_PartAnalysis.aiHCCounterTorque[ii]);
					sHCCounterSpeed:=INT_TO_STRING(T_PartAnalysis.aiHCCounterSpeed[ii]);
					sCycleTime:=REAL_TO_STRING(DINT_TO_REAL(T_PartAnalysis.adiCycleTime[ii]) / 1000.0);
					sWorkTime:=REAL_TO_STRING(DINT_TO_REAL(T_PartAnalysis.adiWorkTime[ii]) / 1000.0);
					sInfeedCounterZ:=BYTE_TO_STRING(T_PartAnalysis.abInfeedCounterZ[ii]);
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(sNumberHole,';');
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],sGetDate);
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],';');
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],sWorkPartQuality);
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],';');
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],sFirstHC);
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],';');
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],sHCCounter);
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],';');
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],sHCCounterTorque);
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],';');
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],sHCCounterSpeed);
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],';');
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],sCycleTime);
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],';');
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],sWorkTime);
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],';');
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],sInfeedCounterZ);
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],';');
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],sHCCounterCentering);
					T_HDD.T_Data.sData[iDataPointer]:=CONCAT(T_HDD.T_Data.sData[iDataPointer],';');
				END_IF;
			END_FOR;
			T_HDD.T_Ctrle.iFunction:=3;
			T_HDD.T_Ctrle.xExecute:=TRUE;
			(* next step *)
			iStepFunction:=iStepFunction + 1;
		(* waiting flag *)
		11:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN iStepFunction:=90; END_IF
			IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; iStepFunction:=iStepFunction + 1; iStepCountWriteDirectory:=iStepCountWriteDirectory + 1; END_IF
		(* Create Directory *)
		12:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN
				IF (iStepCountWriteDirectory < 2) THEN
					sTmp:=CONCAT(gsDriveNameProcessData,'PROCESSDATA\');
					T_HDD.T_Ctrle.iFunction:=7;
					T_HDD.T_File.sDirectoryPath:=sTmp;
					T_HDD.T_Ctrle.xExecute:=TRUE;
					(* next step *)
					iStepFunction:=iStepFunction + 1;
				ELSE
					iStepFunction:=98;
				END_IF;
			END_IF;
		(* waiting flag *)
		13:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN iStepFunction:=10; END_IF
			IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; iStepFunction:=98; END_IF
		(* done *)
		90:	T_ProcessData.T_Ctrle.xDone:=TRUE;
			T_ProcessData.T_Ctrle.xErr:=FALSE;
			T_ProcessData.T_Ctrle.udiErrorID:=16#0;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xWriteData:=FALSE;
		(* start read error *)
		91:	T_ProcessData.T_Ctrle.xDone:=FALSE;
			T_ProcessData.T_Ctrle.xErr:=TRUE;
			T_ProcessData.T_Ctrle.udiErrorID:=201;	(* HDD steht nicht Bereit *)
			T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xWriteData:=FALSE;
		(* error *)
		97:	T_ProcessData.T_Ctrle.xDone:=FALSE;
			T_ProcessData.T_Ctrle.xErr:=TRUE;
			T_ProcessData.T_Ctrle.udiErrorID:=202;	(* Timeout beim Schreiben auf USB-Stick *)
			T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xWriteData:=FALSE;
			gsDriveNameProcessData:='';
		(* error *)
		98:	T_ProcessData.T_Ctrle.xDone:=FALSE;
			T_ProcessData.T_Ctrle.xErr:=TRUE;
			T_ProcessData.T_Ctrle.udiErrorID:=203;	(* USB Stick nicht schreibbar *)
			T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xWriteData:=FALSE;
			gsDriveNameProcessData:='';
		(* error *)
		99:	T_ProcessData.T_Ctrle.xDone:=FALSE;
			T_ProcessData.T_Ctrle.xErr:=TRUE;
			T_ProcessData.T_Ctrle.udiErrorID:=204;	(* USB Stick nicht gefunden *)
			T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xWriteData:=FALSE;
			gsDriveNameProcessData:='';
		END_CASE
	END_IF

(* Zeitstempel lesen *)
	IF xReadTimeStamp THEN
		CASE iStep_TimeStamp OF
		1:	FBNT_GetTime(	NETID:= '',
							START:=FALSE );
			iStep_TimeStamp:=iStep_TimeStamp + 1;
		2:	FBNT_GetTime(	NETID:= '',
							START:= TRUE,
							TMOUT:= T#2s);
			IF NOT(FBNT_GetTime.BUSY) OR FBNT_GetTime.ERR THEN
				IF NOT(FBNT_GetTime.ERR) THEN
					sYear:=WORD_TO_STRING(FBNT_GetTime.TIMESTR.wYear);
					IF (FBNT_GetTime.TIMESTR.wMonth < 10) THEN
						sMonth:=CONCAT('0',WORD_TO_STRING(FBNT_GetTime.TIMESTR.wMonth));
					ELSE
						sMonth:=WORD_TO_STRING(FBNT_GetTime.TIMESTR.wMonth);
					END_IF;
					IF (FBNT_GetTime.TIMESTR.wDay < 10) THEN
						sDay:=CONCAT('0',WORD_TO_STRING(FBNT_GetTime.TIMESTR.wDay));
					ELSE
						sDay:=WORD_TO_STRING(FBNT_GetTime.TIMESTR.wDay);
					END_IF;
					IF (FBNT_GetTime.TIMESTR.wHour < 10) THEN
						sHour:=CONCAT('0',WORD_TO_STRING(FBNT_GetTime.TIMESTR.wHour));
					ELSE
						sHour:=WORD_TO_STRING(FBNT_GetTime.TIMESTR.wHour);
					END_IF;
					IF (FBNT_GetTime.TIMESTR.wMinute < 10) THEN
						sMinute:=CONCAT('0',WORD_TO_STRING(FBNT_GetTime.TIMESTR.wMinute));
					ELSE
						sMinute:=WORD_TO_STRING(FBNT_GetTime.TIMESTR.wMinute);
					END_IF;
					IF (FBNT_GetTime.TIMESTR.wSecond < 10) THEN
						sSecond:=CONCAT('0',WORD_TO_STRING(FBNT_GetTime.TIMESTR.wSecond));
					ELSE
						sSecond:=WORD_TO_STRING(FBNT_GetTime.TIMESTR.wSecond);
					END_IF;
				ELSE
					(* Fehler beim lesen der Systemzeit, daher wird ein default-Wert gesetzt *)
					sYear:='0000';
					sMonth:='00';
					sDay:='00';
					sHour:='00';
					sMinute:='00';
					sSecond:='00';
				END_IF;
				FBNT_GetTime(	NETID:= '',
								START:=FALSE );
				xReadTimeStamp:=FALSE;
			END_IF;
		END_CASE;
	ELSE
		iStep_TimeStamp:=1;
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL\/PROFILE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_COMPAREPROFILEPROCESSVALUE
VAR_INPUT
	T_LoadProfileParameter:ST_RETAIN_DATA_PROFILEPARAMETER;	(* Profil Parameter für Profil(LoadData) *)
	T_ProfileParameter:ST_RETAIN_DATA_PROFILEPARAMETER;	(* Profil Parameter für Profil(Data) *)
END_VAR
VAR_OUTPUT
	xProcessValueModified:BOOL;
END_VAR
VAR_IN_OUT
END_VAR
VAR
(* variable *)
	rTmpDifference: REAL;
	rTolerance:REAL:=0.001;
END_VAR
(* @END_DECLARATION := '0' *)

(* compare value *)
	xProcessValueModified:=FALSE;
	(* value *)
	IF T_LoadProfileParameter.T_ProfileOnlineChange.rTorqueLevelHC <> T_ProfileParameter.T_ProfileOnlineChange.rTorqueLevelHC THEN
		rTmpDifference:=ABS(T_LoadProfileParameter.T_ProfileOnlineChange.rTorqueLevelHC - T_ProfileParameter.T_ProfileOnlineChange.rTorqueLevelHC);
		IF (rTmpDifference > rTolerance) THEN
			xProcessValueModified:=TRUE;
		END_IF;
	END_IF
	IF T_LoadProfileParameter.T_ProfileOnlineChange.rForceDeflection <> T_ProfileParameter.T_ProfileOnlineChange.rForceDeflection THEN
		rTmpDifference:=ABS(T_LoadProfileParameter.T_ProfileOnlineChange.rForceDeflection - T_ProfileParameter.T_ProfileOnlineChange.rForceDeflection);
		IF (rTmpDifference > rTolerance) THEN
			xProcessValueModified:=TRUE;
		END_IF;
	END_IF
	IF T_LoadProfileParameter.T_ProfileOnlineChange.rWorkingSpeedForward <> T_ProfileParameter.T_ProfileOnlineChange.rWorkingSpeedForward THEN
		rTmpDifference:=ABS(T_LoadProfileParameter.T_ProfileOnlineChange.rWorkingSpeedForward - T_ProfileParameter.T_ProfileOnlineChange.rWorkingSpeedForward);
		IF (rTmpDifference > rTolerance) THEN
			xProcessValueModified:=TRUE;
		END_IF;
	END_IF
	IF T_LoadProfileParameter.T_ProfileOnlineChange.rWorkingOffsetBackward <> T_ProfileParameter.T_ProfileOnlineChange.rWorkingOffsetBackward THEN
		rTmpDifference:=ABS(T_LoadProfileParameter.T_ProfileOnlineChange.rWorkingOffsetBackward - T_ProfileParameter.T_ProfileOnlineChange.rWorkingOffsetBackward);
		IF (rTmpDifference > rTolerance) THEN
			xProcessValueModified:=TRUE;
		END_IF;
	END_IF
	IF T_LoadProfileParameter.T_ProfileOnlineChange.rWorkingSpeedBackward <> T_ProfileParameter.T_ProfileOnlineChange.rWorkingSpeedBackward THEN
		rTmpDifference:=ABS(T_LoadProfileParameter.T_ProfileOnlineChange.rWorkingSpeedBackward - T_ProfileParameter.T_ProfileOnlineChange.rWorkingSpeedBackward);
		IF (rTmpDifference > rTolerance) THEN
			xProcessValueModified:=TRUE;
		END_IF;
	END_IF
	IF T_LoadProfileParameter.T_ProfileOnlineChange.rWorkingSpindleSpeed <> T_ProfileParameter.T_ProfileOnlineChange.rWorkingSpindleSpeed THEN
		rTmpDifference:=ABS(T_LoadProfileParameter.T_ProfileOnlineChange.rWorkingSpindleSpeed - T_ProfileParameter.T_ProfileOnlineChange.rWorkingSpindleSpeed);
		IF (rTmpDifference > rTolerance) THEN
			xProcessValueModified:=TRUE;
		END_IF;
	END_IF

	IF T_LoadProfileParameter.T_ProzessData.rPositionLoad <> T_ProfileParameter.T_ProzessData.rPositionLoad THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rPositionStartProc <> T_ProfileParameter.T_ProzessData.rPositionStartProc THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rPositionEndProc <> T_ProfileParameter.T_ProzessData.rPositionEndProc THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rPositionToolChange <> T_ProfileParameter.T_ProzessData.rPositionToolChange THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rInfeedZAxisSpeed <> T_ProfileParameter.T_ProzessData.rInfeedZAxisSpeed THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rInfeedSpindleSpeed <> T_ProfileParameter.T_ProzessData.rInfeedSpindleSpeed THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rOutfeedStrokeAxisSpeed <> T_ProfileParameter.T_ProzessData.rOutfeedStrokeAxisSpeed THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rOutfeedSpindleSpeed <> T_ProfileParameter.T_ProzessData.rOutfeedSpindleSpeed THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rInfeedForceDeflection <> T_ProfileParameter.T_ProzessData.rInfeedForceDeflection THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rInfeedOffsetBackward <> T_ProfileParameter.T_ProzessData.rInfeedOffsetBackward THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.iNumberTryInfeed <> T_ProfileParameter.T_ProzessData.iNumberTryInfeed THEN xProcessValueModified:=TRUE; END_IF

	IF T_LoadProfileParameter.T_ProzessData.rProcessMinTime <> T_ProfileParameter.T_ProzessData.rProcessMinTime THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rProcessMaxTime <> T_ProfileParameter.T_ProzessData.rProcessMaxTime THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.iHCStartProcPosCounter <> T_ProfileParameter.T_ProzessData.iHCStartProcPosCounter THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rDeflectionSensorOffset <> T_ProfileParameter.T_ProzessData.rDeflectionSensorOffset THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rTorqueLevel_Overload <> T_ProfileParameter.T_ProzessData.rTorqueLevel_Overload THEN xProcessValueModified:=TRUE; END_IF

	IF T_LoadProfileParameter.T_ProzessData.iSparkOutStrokeCount <> T_ProfileParameter.T_ProzessData.iSparkOutStrokeCount THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rSparkOutStrokeLength <> T_ProfileParameter.T_ProzessData.rSparkOutStrokeLength THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rSparkOutStrokeSpeed <> T_ProfileParameter.T_ProzessData.rSparkOutStrokeSpeed THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rSparkOutForceDeflection <> T_ProfileParameter.T_ProzessData.rSparkOutForceDeflection THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rSparkOutTorqueLevel <> T_ProfileParameter.T_ProzessData.rSparkOutTorqueLevel THEN xProcessValueModified:=TRUE; END_IF

	IF T_LoadProfileParameter.T_ProzessData.rPosToolGuid_Up <> T_ProfileParameter.T_ProzessData.rPosToolGuid_Up THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rPosToolGuid_Down <> T_ProfileParameter.T_ProzessData.rPosToolGuid_Down THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rDistanceToolGuide <> T_ProfileParameter.T_ProzessData.rDistanceToolGuide THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rDistanceToolEndPos <> T_ProfileParameter.T_ProzessData.rDistanceToolEndPos THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rLengthTool_Fixed <> T_ProfileParameter.T_ProzessData.rLengthTool_Fixed THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rLengthTool_Work <> T_ProfileParameter.T_ProzessData.rLengthTool_Work THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rLengthToolGuide <> T_ProfileParameter.T_ProzessData.rLengthToolGuide THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rLengthAirTableBoard <> T_ProfileParameter.T_ProzessData.rLengthAirTableBoard THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.xConfigActive <> T_ProfileParameter.T_ProzessData.xConfigActive THEN xProcessValueModified:=TRUE; END_IF

	IF T_LoadProfileParameter.T_ProzessData.iMaxTorque <> T_ProfileParameter.T_ProzessData.iMaxTorque THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rSpeedZAxisForBackward <> T_ProfileParameter.T_ProzessData.rSpeedZAxisForBackward THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rWorkingSpeedOscillation <> T_ProfileParameter.T_ProzessData.rWorkingSpeedOscillation THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rZ1AxisPosSwitchOAxisOff <> T_ProfileParameter.T_ProzessData.rZ1AxisPosSwitchOAxisOff THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.xActivateCoolantProcess <> T_ProfileParameter.T_ProzessData.xActivateCoolantProcess THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rStrokeAxisPosSwitchCoolantOff <> T_ProfileParameter.T_ProzessData.rStrokeAxisPosSwitchCoolantOff THEN xProcessValueModified:=TRUE; END_IF

	IF T_LoadProfileParameter.T_ProzessData.rCentringPosZ1Axis <> T_ProfileParameter.T_ProzessData.rCentringPosZ1Axis THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rCentringPosSpeedSlowZ1Axis <> T_ProfileParameter.T_ProzessData.rCentringPosSpeedSlowZ1Axis THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rCentringPosSpeedFastZ1Axis <> T_ProfileParameter.T_ProzessData.rCentringPosSpeedFastZ1Axis THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rCentringSpeedSAxis <> T_ProfileParameter.T_ProzessData.rCentringSpeedSAxis THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rCentringSpeedOAxis <> T_ProfileParameter.T_ProzessData.rCentringSpeedOAxis THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rCentringBackStrokeOffsetFirstHC <> T_ProfileParameter.T_ProzessData.rCentringBackStrokeOffsetFirstHC THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rCentringBackStrokeOffsetAfterFirstHC <> T_ProfileParameter.T_ProzessData.rCentringBackStrokeOffsetAfterFirstHC THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rCentringOffsetBeforeLastHC <> T_ProfileParameter.T_ProzessData.rCentringOffsetBeforeLastHC THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rCentringBackStrokeSpeed <> T_ProfileParameter.T_ProzessData.rCentringBackStrokeSpeed THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rCentringTimeHCActive <> T_ProfileParameter.T_ProzessData.rCentringTimeHCActive THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rCentringTimeHCInactive <> T_ProfileParameter.T_ProzessData.rCentringTimeHCInactive THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.iCentringNumberMaxHCinWindow <> T_ProfileParameter.T_ProzessData.iCentringNumberMaxHCinWindow THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rCentringHCWindow <> T_ProfileParameter.T_ProzessData.rCentringHCWindow THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rCentringForceDeflection <> T_ProfileParameter.T_ProzessData.rCentringForceDeflection THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rCentringOffsetBackward <> T_ProfileParameter.T_ProzessData.rCentringOffsetBackward THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rCenteringDeflectionSensorOffset <> T_ProfileParameter.T_ProzessData.rCenteringDeflectionSensorOffset THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rCentringOffsetSlowToFastZSpeed <> T_ProfileParameter.T_ProzessData.rCentringOffsetSlowToFastZSpeed THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.iCentringSelectProcess <> T_ProfileParameter.T_ProzessData.iCentringSelectProcess THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.xPositionEndProcIncOnOff <> T_ProfileParameter.T_ProzessData.xPositionEndProcIncOnOff THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rPositionEndProcMaxInc <> T_ProfileParameter.T_ProzessData.rPositionEndProcMaxInc THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rPositionEndProInc <> T_ProfileParameter.T_ProzessData.rPositionEndProInc THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rOutfeedStrokeAxisSpeedSlow <> T_ProfileParameter.T_ProzessData.rOutfeedStrokeAxisSpeedSlow THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rZ1AxisPosSwitchFastVel <> T_ProfileParameter.T_ProzessData.rZ1AxisPosSwitchFastVel THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rZ1AxisOffsetStartRecordTorque <> T_ProfileParameter.T_ProzessData.rZ1AxisOffsetStartRecordTorque THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.xCentringEndProcIncOnOff <> T_ProfileParameter.T_ProzessData.xCentringEndProcIncOnOff THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rCentringEndProInc <> T_ProfileParameter.T_ProzessData.rCentringEndProInc THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rWorkingSpindleSpeedMinMax <> T_ProfileParameter.T_ProzessData.rWorkingSpindleSpeedMinMax THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rO_Ctrl_TorquePercent_OFF <> T_ProfileParameter.T_ProzessData.rO_Ctrl_TorquePercent_OFF THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rO_Ctrl_HystereseOffset <> T_ProfileParameter.T_ProzessData.rO_Ctrl_HystereseOffset THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rZPositionCylindricalArea <> T_ProfileParameter.T_ProzessData.rZPositionCylindricalArea THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rZMinThresholdTroqueEndProcess <> T_ProfileParameter.T_ProzessData.rZMinThresholdTroqueEndProcess THEN xProcessValueModified:=TRUE; END_IF

	IF T_LoadProfileParameter.T_ProzessData.iWorkControlType <> T_ProfileParameter.T_ProzessData.iWorkControlType THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rZ_PID_Torque <> T_ProfileParameter.T_ProzessData.rZ_PID_Torque THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rZ_PID_MinSpeed <> T_ProfileParameter.T_ProzessData.rZ_PID_MinSpeed THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rZ_PID_MaxSpeed <> T_ProfileParameter.T_ProzessData.rZ_PID_MaxSpeed THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rZ_PID_Kp <> T_ProfileParameter.T_ProzessData.rZ_PID_Kp THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rZ_PID_Ki <> T_ProfileParameter.T_ProzessData.rZ_PID_Ki THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rZ_PID_Kd <> T_ProfileParameter.T_ProzessData.rZ_PID_Kd THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.iZ_PID_FilterM <> T_ProfileParameter.T_ProzessData.iZ_PID_FilterM THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rZ_D_Kd <> T_ProfileParameter.T_ProzessData.rZ_D_Kd THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.iZ_D_FilterM <> T_ProfileParameter.T_ProzessData.iZ_D_FilterM THEN xProcessValueModified:=TRUE; END_IF

	IF T_LoadProfileParameter.T_ProzessData.rSuspensionBubblerSpeed <> T_ProfileParameter.T_ProzessData.rSuspensionBubblerSpeed THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.rSuspensionFeederSpeed <> T_ProfileParameter.T_ProzessData.rSuspensionFeederSpeed THEN xProcessValueModified:=TRUE; END_IF

	IF T_LoadProfileParameter.T_ProzessData.rDistProgressStroke <> T_ProfileParameter.T_ProzessData.rDistProgressStroke THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.iProgressStrokeStartTorque <> T_ProfileParameter.T_ProzessData.iProgressStrokeStartTorque THEN xProcessValueModified:=TRUE; END_IF
	IF T_LoadProfileParameter.T_ProzessData.iCleanNozzleMode <> T_ProfileParameter.T_ProzessData.iCleanNozzleMode THEN xProcessValueModified:=TRUE; END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL\/PROFILE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CopyDataFileToProfile
VAR_INPUT
	ptrStProzessData:POINTER TO ST_EXCHG_PARAM_STANDARDPROCESS;
	ptrOnlineChangeData:POINTER TO ST_PROFILEONLINECHANGE_DATA;
	ptrDataFile:POINTER TO ARRAY[1..csiMaxFileLine] OF STRING(csiMaxCharPerLine);
	ptrNameOfProfile:POINTER TO STRING(30);
END_VAR
VAR_OUTPUT
	bResultCopyData:BYTE;
END_VAR
VAR
(* variable *)
	i:INT;
	iPosStartCarValue:INT;
	iPosStopCarValue:INT;
	sValue:STRING;
	sVariableName:STRING;
(* Tmp variable *)
	sTmp:STRING;
	iCountParameter: INT;
	xWrongSyntax: BOOL;
	iFindChar: INT;
	iStepCopy: INT;
END_VAR
(* @END_DECLARATION := '0' *)
(* Wegen Zykluszeitüberschreitung wurde nun neu ein FB erstellt und das Überprüfen unterteilt *)
CASE iStepCopy OF
0:	(* Init. variable *)
	bResultCopyData:=0;
	xWrongSyntax:=FALSE;
	sTmp:=ptrDataFile^[1];
	sTmp:=sFctDeleteChar(sString:=sTmp, sChar:='$N');
	sTmp:=sFctDeleteChar(sString:=sTmp, sChar:='$L');
	sTmp:=sFctDeleteChar(sString:=sTmp, sChar:=' ');
	IF (FIND(sTmp,';') > 0) THEN
		iFindChar:=FIND(sTmp,';');
		sTmp:=MID(STR:=sTmp,LEN:=iFindChar - 1,POS:=1);
	END_IF;
	ptrNameOfProfile^:=sTmp;
	iCountParameter:=0;
	iStepCopy:=iStepCopy + 1;
1:	FOR i:= 1 TO ciMaxProfileParameter DO
		CheckParameter;
	END_FOR
	iStepCopy:=99;
99:	IF (iCountParameter <> csiMaxProfileParameter) THEN
		xWrongSyntax:=TRUE;
	END_IF;
	(* confirm copy value *)
	IF NOT(xWrongSyntax) THEN
		bResultCopyData:=1;
	ELSE
		bResultCopyData:=2;
	END_IF;
	iStepCopy:=0;
END_CASE;
END_FUNCTION_BLOCK
ACTION	CheckParameter:
sTmp:=ptrDataFile^[i];
sTmp:=sFctDeleteChar(sString:=sTmp, sChar:='$N');
sTmp:=sFctDeleteChar(sString:=sTmp, sChar:='$L');
sTmp:=sFctDeleteChar(sString:=sTmp, sChar:=' ');
IF FIND(sTmp,':=') <> 0 THEN
(* read value *)
	iPosStartCarValue:= FIND(sTmp,':=')+2;
	iPosStopCarValue:= FIND(sTmp,';');
	sValue:=MID(sTmp,iPosStopCarValue - iPosStartCarValue,iPosStartCarValue);

	IF (sFctUpLowCase(xLowConvert:=TRUE, sInString:=sValue) <> 'false') AND (sFctUpLowCase(xLowConvert:=TRUE, sInString:=sValue) <> 'true') THEN
		IF NOT(xFctCheckNumber(sValue:=sValue,xAlowDoubleSign:=FALSE)) THEN
			xWrongSyntax:=TRUE;
		END_IF;
	END_IF;
(* read variable name *)
	IF NOT(xWrongSyntax) THEN
		iPosStartCarValue:= FIND(sTmp,':')+1;
		iPosStopCarValue:= FIND(sTmp,':=');
		sVariableName:=sFctUpLowCase(	xLowConvert:=TRUE,
										sInString:=MID(sTmp,iPosStopCarValue - iPosStartCarValue,iPosStartCarValue));

		IF sVariableName = 'rtorquelevelhc' THEN ptrOnlineChangeData^.rTorqueLevelHC:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rforcedeflection' THEN ptrOnlineChangeData^.rForceDeflection:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rworkingspeedforward' THEN ptrOnlineChangeData^.rWorkingSpeedForward:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rworkingoffsetbackward' THEN ptrOnlineChangeData^.rWorkingOffsetBackward:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rworkingspeedbackward' THEN ptrOnlineChangeData^.rWorkingSpeedBackward:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rworkingspindlespeed' THEN ptrOnlineChangeData^.rWorkingSpindleSpeed:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;

		ELSIF sVariableName = 'rpositionload' THEN ptrStProzessData^.rPositionLoad:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rpositionstartproc' THEN ptrStProzessData^.rPositionStartProc:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rpositionendproc' THEN ptrStProzessData^.rPositionEndProc:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rpositiontoolchange' THEN ptrStProzessData^.rPositionToolChange:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rinfeedzaxisspeed' THEN ptrStProzessData^.rInfeedZAxisSpeed:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rinfeedspindlespeed' THEN ptrStProzessData^.rInfeedSpindleSpeed:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'routfeedstrokeaxisspeed' THEN ptrStProzessData^.rOutfeedStrokeAxisSpeed:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'routfeedspindlespeed' THEN ptrStProzessData^.rOutfeedSpindleSpeed:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rinfeedforcedeflection' THEN ptrStProzessData^.rInfeedForceDeflection:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rinfeedoffsetbackward' THEN ptrStProzessData^.rInfeedOffsetBackward:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'inumbertryinfeed' THEN ptrStProzessData^.iNumberTryInfeed:=STRING_TO_INT(sValue); iCountParameter:=iCountParameter + 1;

		ELSIF sVariableName = 'rprocessmintime' THEN ptrStProzessData^.rProcessMinTime:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rprocessmaxtime' THEN ptrStProzessData^.rProcessMaxTime:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'ihcstartprocposcounter' THEN ptrStProzessData^.iHCStartProcPosCounter:=STRING_TO_INT(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rdeflectionsensoroffset' THEN ptrStProzessData^.rDeflectionSensorOffset:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rtorquelevel_overload' THEN ptrStProzessData^.rTorqueLevel_Overload:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;

		ELSIF sVariableName = 'isparkoutstrokecount' THEN ptrStProzessData^.iSparkOutStrokeCount:=STRING_TO_INT(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rsparkoutstrokelength' THEN ptrStProzessData^.rSparkOutStrokeLength:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rsparkoutstrokespeed' THEN ptrStProzessData^.rSparkOutStrokeSpeed:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rsparkoutforcedeflection' THEN ptrStProzessData^.rSparkOutForceDeflection:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rsparkouttorquelevel' THEN ptrStProzessData^.rSparkOutTorqueLevel:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;

		ELSIF sVariableName = 'rpostoolguid_up' THEN ptrStProzessData^.rPosToolGuid_Up:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rpostoolguid_down' THEN ptrStProzessData^.rPosToolGuid_Down:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rdistancetoolguide' THEN ptrStProzessData^.rDistanceToolGuide:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rdistancetoolendpos' THEN ptrStProzessData^.rDistanceToolEndPos:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rlengthtool_fixed' THEN ptrStProzessData^.rLengthTool_Fixed:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rlengthtool_work' THEN ptrStProzessData^.rLengthTool_Work:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rlengthtoolguide' THEN ptrStProzessData^.rLengthToolGuide:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rlengthairtableboard' THEN ptrStProzessData^.rLengthAirTableBoard:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'xconfigactive' THEN ptrStProzessData^.xConfigActive:=STRING_TO_BOOL(sValue); iCountParameter:=iCountParameter + 1;

		ELSIF sVariableName = 'imaxtorque' THEN ptrStProzessData^.iMaxTorque:=STRING_TO_INT(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rspeedzaxisforbackward' THEN ptrStProzessData^.rSpeedZAxisForBackward:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rworkingspeedoscillation' THEN ptrStProzessData^.rWorkingSpeedOscillation:=STRING_TO_INT(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rz1axisposswitchoaxisoff' THEN ptrStProzessData^.rZ1AxisPosSwitchOAxisOff:=STRING_TO_INT(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'xactivatecoolantprocess' THEN ptrStProzessData^.xActivateCoolantProcess:=STRING_TO_BOOL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rstrokeaxisposswitchcoolantoff' THEN ptrStProzessData^.rStrokeAxisPosSwitchCoolantOff:=STRING_TO_INT(sValue); iCountParameter:=iCountParameter + 1;

		ELSIF sVariableName = 'rcentringposz1axis' THEN ptrStProzessData^.rCentringPosZ1Axis:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rcentringposspeedslowz1axis' THEN ptrStProzessData^.rCentringPosSpeedSlowZ1Axis:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rcentringposspeedfastz1axis' THEN ptrStProzessData^.rCentringPosSpeedFastZ1Axis:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rcentringspeedsaxis' THEN ptrStProzessData^.rCentringSpeedSAxis:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rcentringspeedoaxis' THEN ptrStProzessData^.rCentringSpeedOAxis:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rcentringbackstrokeoffsetfirsthc' THEN ptrStProzessData^.rCentringBackStrokeOffsetFirstHC:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rcentringbackstrokeoffsetafterfirsthc' THEN ptrStProzessData^.rCentringBackStrokeOffsetAfterFirstHC:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rcentringoffsetbeforelasthc' THEN ptrStProzessData^.rCentringOffsetBeforeLastHC:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rcentringbackstrokespeed' THEN ptrStProzessData^.rCentringBackStrokeSpeed:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rcentringtimehcactive' THEN ptrStProzessData^.rCentringTimeHCActive:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rcentringtimehcinactive' THEN ptrStProzessData^.rCentringTimeHCInactive:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'icentringnumbermaxhcinwindow' THEN ptrStProzessData^.iCentringNumberMaxHCinWindow:=STRING_TO_INT(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rcentringhcwindow' THEN ptrStProzessData^.rCentringHCWindow:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rcentringforcedeflection' THEN ptrStProzessData^.rCentringForceDeflection:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rcentringoffsetbackward' THEN ptrStProzessData^.rCentringOffsetBackward:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rcenteringdeflectionsensoroffset' THEN ptrStProzessData^.rCenteringDeflectionSensorOffset:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rcentringoffsetslowtofastzspeed' THEN ptrStProzessData^.rCentringOffsetSlowToFastZSpeed:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'icentringselectprocess' THEN ptrStProzessData^.iCentringSelectProcess:=STRING_TO_INT(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'xpositionendprocinconoff' THEN ptrStProzessData^.xPositionEndProcIncOnOff:=STRING_TO_BOOL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rpositionendprocmaxinc' THEN ptrStProzessData^.rPositionEndProcMaxInc:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rpositionendproinc' THEN ptrStProzessData^.rPositionEndProInc:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'routfeedstrokeaxisspeedslow' THEN ptrStProzessData^.rOutfeedStrokeAxisSpeedSlow:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rz1axisposswitchfastvel' THEN ptrStProzessData^.rZ1AxisPosSwitchFastVel:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rz1axisoffsetstartrecordtorque' THEN ptrStProzessData^.rZ1AxisOffsetStartRecordTorque:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'xcentringendprocinconoff' THEN ptrStProzessData^.xCentringEndProcIncOnOff:=STRING_TO_BOOL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rcentringendproinc' THEN ptrStProzessData^.rCentringEndProInc:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rworkingspindlespeedminmax' THEN ptrStProzessData^.rWorkingSpindleSpeedMinMax:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'ro_ctrl_torquepercent_off' THEN ptrStProzessData^.rO_Ctrl_TorquePercent_OFF:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'ro_ctrl_hystereseoffset' THEN ptrStProzessData^.rO_Ctrl_HystereseOffset:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rzpositioncylindricalarea' THEN ptrStProzessData^.rZPositionCylindricalArea:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rzminthresholdtroqueendprocess' THEN ptrStProzessData^.rZMinThresholdTroqueEndProcess:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;

		ELSIF sVariableName = 'iworkcontroltype' THEN ptrStProzessData^.iWorkControlType:=STRING_TO_INT(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rz_pid_torque' THEN ptrStProzessData^.rZ_PID_Torque:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rz_pid_minspeed' THEN ptrStProzessData^.rZ_PID_MinSpeed:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rz_pid_maxspeed' THEN ptrStProzessData^.rZ_PID_MaxSpeed:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rz_pid_kp' THEN ptrStProzessData^.rZ_PID_Kp:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rz_pid_ki' THEN ptrStProzessData^.rZ_PID_Ki:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rz_pid_kd' THEN ptrStProzessData^.rZ_PID_Kd:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'iz_pid_filterm' THEN ptrStProzessData^.iZ_PID_FilterM:=STRING_TO_INT(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rz_d_kd' THEN ptrStProzessData^.rZ_D_Kd:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'iz_d_filterm' THEN ptrStProzessData^.iZ_D_FilterM:=STRING_TO_INT(sValue); iCountParameter:=iCountParameter + 1;

		ELSIF sVariableName = 'rsuspensionbubblerspeed' THEN ptrStProzessData^.rSuspensionBubblerSpeed:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'rsuspensionfeederspeed' THEN ptrStProzessData^.rSuspensionFeederSpeed:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;

		ELSIF sVariableName = 'rdistprogressstroke' THEN ptrStProzessData^.rDistProgressStroke:=STRING_TO_REAL(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'iprogressstrokestarttorque' THEN ptrStProzessData^.iProgressStrokeStartTorque:=STRING_TO_INT(sValue); iCountParameter:=iCountParameter + 1;
		ELSIF sVariableName = 'icleannozzlemode' THEN ptrStProzessData^.iCleanNozzleMode:=STRING_TO_INT(sValue); iCountParameter:=iCountParameter + 1;

		END_IF;
	END_IF;
END_IF;
END_ACTION




(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL\/PROFILE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_PROFILE_FILE
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
	T_Profile:ST_PROFILE;
	T_HDD:ST_HDD;
END_VAR
VAR
(* Timer *)
	TimerOut:TON;
(* Trigger *)
	RisingEdgeReset:R_TRIG;
	RisingEdgeExecute:R_TRIG;
(* variable *)
	xConfirmResetFB:BOOL;
	xReadProfile:BOOL;
	xWriteProfile:BOOL;
	xReadProfileListeStation: BOOL;
	iStepFunction:INT;
	xStepFunctionDone:BOOL;
	iProfileNr:INT;
	tTimeOut: TIME;
	sDeleteData: ARRAY[1..csiMaxFileLine] OF STRING(csiMaxCharPerLine);
(* Tmp *)
	xTmp:BOOL;
	sTmp:STRING(255);
	xCheckUSBStick: BOOL;
	TimerFileLocked:TON;
	xCreateDefaultProfile: BOOL;
	T_DeleteIDProfileStation:ARRAY[1..csiMaxProfile] OF ST_PROFILE_ID;
	xDeleteProfile: BOOL;
	xRenameProfile: BOOL;
	iFindChar: INT;
	jj:INT;
	FBCopyDataFileToProfile:FB_CopyDataFileToProfile;
	sDriveName: STRING;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                       This Functionblock manage the profile for read and write to a file                                            ************)
(****************************************************************************************************************************************************)
IF (sDriveName = '') THEN
	sDriveName:='D:\';
END_IF;
(* waiting for reset *)
	RisingEdgeReset(CLK:=T_Profile.T_Ctrle.xReset);
	IF RisingEdgeReset.Q THEN
	(* init. structure *)
		T_Profile.T_Ctrle.xDone:=FALSE;
		T_Profile.T_Ctrle.xErr:=FALSE;
		T_Profile.T_Ctrle.udiErrorID:=0;
		T_Profile.T_Ctrle.iFunction:=0;
		(* Reset HDD if error activ *)
		IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; END_IF
		(* Init. variable *)
		xReadProfile:=FALSE;
		xWriteProfile:=FALSE;
		xCheckUSBStick:=FALSE;
		xReadProfileListeStation:=FALSE;
		xCreateDefaultProfile:=FALSE;
		xDeleteProfile:=FALSE;
		xRenameProfile:=FALSE;
		(* set flag done *)
		xConfirmResetFB:=TRUE;
		(* exit function *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_Profile.T_Ctrle.xDone:=TRUE;
			T_Profile.T_Ctrle.xErr:=FALSE;
			T_Profile.T_Ctrle.udiErrorID:=0;
			T_Profile.T_Ctrle.iFunction:=0;
			(* init. variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

TimerFileLocked(IN:=TRUE, PT:=T#10S);

(* waiting for execute *)
	RisingEdgeExecute(CLK:=T_Profile.T_Ctrle.xExecute);
	IF RisingEdgeExecute.Q THEN
		CASE T_Profile.T_Ctrle.iFunction OF
		(* read profile *)
		1:	xReadProfile:=TRUE;
			T_HDD.T_Data.sData:=sDeleteData;
			tTimeOut:=T#10s;
		(* write profile *)
		2:	xWriteProfile:=TRUE;
			tTimeOut:=T#10s;
		(* check if USB Stick exist *)
		3:	xCheckUSBStick:=TRUE;
			tTimeOut:=T#5s;
		(* read profile from File *)
		4:	xReadProfile:=TRUE;
			T_HDD.T_Data.sData:=sDeleteData;
			tTimeOut:=T#20s;
		(* write profile to File *)
		5:	xWriteProfile:=TRUE;
			tTimeOut:=T#10s;
		(* read profile liste station *)
		6:	xReadProfileListeStation:=TRUE;
			tTimeOut:=T#30s;
		(* create default profile *)
		7:	xCreateDefaultProfile:=TRUE;
			tTimeOut:=T#20s;
		(* create default profile *)
		8:	xDeleteProfile:=TRUE;
			tTimeOut:=T#20s;
		(* reanme Profil name *)
		9:	xRenameProfile:=TRUE;
			tTimeOut:=T#20s;
		ELSE
		(* function not implemented *)
			 T_Profile.T_Ctrle.xDone:=FALSE;
			 T_Profile.T_Ctrle.xErr:=TRUE;
			 T_Profile.T_Ctrle.udiErrorID:=16#F000;
			 (* exit FB *)
			 RETURN;
		END_CASE
		(* Init. variable *)
		T_Profile.T_Ctrle.xDone:=FALSE;
		T_Profile.T_Ctrle.xErr:=FALSE;
		T_Profile.T_Ctrle.udiErrorID:=16#0;
		T_HDD.T_File.cssRootPLC:=cssRootUSB;
		(* init. step *)
		iStepFunction:=1;
		xStepFunctionDone:=FALSE;
		RETURN;
	END_IF

(* Monitor time out *)
	xTmp:=	NOT T_Profile.T_Ctrle.xDone
			AND NOT T_Profile.T_Ctrle.xErr;
	TimerOut(IN:=xTmp, PT:=tTimeOut);
	IF TimerOut.Q THEN iStepFunction:=99; END_IF

(* Read or Write profile *)
	IF xReadProfile OR xWriteProfile THEN
		CASE iStepFunction OF
		(* check if HDD state *)
		(* start timeout *)
		1:	TimerFileLocked(IN:=FALSE);
			iStepFunction:=10;
		(* file name and activ read or write *)
		10:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) AND NOT(T_HDD.T_Ctrle.xLocked) THEN
				IF xReadProfile THEN
					sTmp:=CONCAT(sDriveName,T_Profile.T_Ctrle.sPathAndFileName);
					sTmp:=CONCAT(sTmp,'STATION');
					sTmp:=CONCAT(sTmp,UINT_TO_STRING(gciStationSt1));
					sTmp:=CONCAT(sTmp,'\');
					sTmp:=CONCAT(sTmp,INT_TO_STRING(T_Profile.T_Id.iNumber));
					sTmp:=CONCAT(sTmp,'.txt');
				(* activ read *)
					IF (T_Profile.T_Ctrle.iFunction = 1) THEN
						T_HDD.T_Ctrle.iFunction:=1;
					ELSE
						T_HDD.T_Ctrle.iFunction:=1;	(* 9 does not right function *)
					END_IF;
					T_HDD.T_Ctrle.xLocked:=TRUE;
					T_HDD.T_File.sPathAndFileName:=sTmp;
					T_HDD.T_Ctrle.xExecute:=TRUE;
					T_Profile.T_Ctrle.sProfileName:='';
					(* next step *)
					iStepFunction:=20;
					xStepFunctionDone:=FALSE;
				(* activ write *)
				ELSE
					(* copy profile to HDD data structure *)
					IF xFctCopyProfileToDataFile(	sNameOfProfile:=T_Profile.T_Id.sName,
													ptrStProzessData:=ADR(T_Profile.T_CopyProfileParameter.T_ProzessData),
													ptrOnlineChangeData:=ADR(T_Profile.T_CopyProfileParameter.T_ProfileOnlineChange),
													ptrDataFile:=ADR(T_HDD.T_Data)) 	THEN iStepFunction:=50; ELSE iStepFunction:=99; END_IF
					T_HDD.T_Ctrle.xLocked:=TRUE;
					(* next step *)
					xStepFunctionDone:=FALSE;
				END_IF
			ELSE
				(* activ error if time out done, HDD not ready *)
				IF TimerFileLocked.Q THEN
					 iStepFunction:=91;
				END_IF
			END_IF;
		(* waiting flag *)
		20:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN iStepFunction:=30; END_IF
			IF T_HDD.T_Ctrle.xErr THEN iStepFunction:=80; END_IF
		(* copy value from HDD to Profile structure *)
		30:	FBCopyDataFileToProfile(	ptrStProzessData:=ADR(T_Profile.T_CopyProfileParameter.T_ProzessData),
									ptrOnlineChangeData:=ADR(T_Profile.T_CopyProfileParameter.T_ProfileOnlineChange),
									ptrDataFile:=ADR(T_HDD.T_Data),
									ptrNameOfProfile:=ADR(T_Profile.T_Ctrle.sProfileName));
			IF (FBCopyDataFileToProfile.bResultCopyData = 1) THEN
				iStepFunction:=90;
			ELSIF (FBCopyDataFileToProfile.bResultCopyData = 2) THEN
				iStepFunction:=98;
			END_IF
		(* activ write *)
		50:	sTmp:=CONCAT(sDriveName,T_Profile.T_Ctrle.sPathAndFileName);
			sTmp:=CONCAT(sTmp,'STATION');
			sTmp:=CONCAT(sTmp,UINT_TO_STRING(gciStationSt1));
			sTmp:=CONCAT(sTmp,'\');
			sTmp:=CONCAT(sTmp,INT_TO_STRING(T_Profile.T_Id.iNumber));
			sTmp:=CONCAT(sTmp,'.txt');
			T_HDD.T_File.sPathAndFileName:=sTmp;
			IF (T_Profile.T_Ctrle.iFunction = 2) THEN
				T_HDD.T_Ctrle.iFunction:=2;
			ELSE
				T_HDD.T_Ctrle.iFunction:=2;	(* 10 does not right function *)
			END_IF;
			T_HDD.T_Ctrle.xExecute:=TRUE;
			(* next step *)
			iStepFunction:=60;
			xStepFunctionDone:=FALSE;
		(* waiting flag *)
		60:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN iStepFunction:=90; END_IF
			IF T_HDD.T_Ctrle.xErr THEN iStepFunction:=80; END_IF
		(* reset error *)
		80:	T_HDD.T_Ctrle.xReset:=TRUE;
			iStepFunction:=99;
		(* done *)
		90:	T_Profile.T_Ctrle.xDone:=TRUE;
			T_Profile.T_Ctrle.xErr:=FALSE;
			T_Profile.T_Ctrle.udiErrorID:=16#0;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xReadProfile:=FALSE;
			xWriteProfile:=FALSE;
		(* start read error *)
		91:	T_Profile.T_Ctrle.xDone:=FALSE;
			T_Profile.T_Ctrle.xErr:=TRUE;
			T_Profile.T_Ctrle.udiErrorID:=16#F1000 + T_Profile.T_Ctrle.iFunction;
			T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xReadProfile:=FALSE;
			xWriteProfile:=FALSE;
		(* syntax error *)
		98:	T_Profile.T_Ctrle.xDone:=FALSE;
			T_Profile.T_Ctrle.xErr:=TRUE;
			T_Profile.T_Ctrle.udiErrorID:=16#F2000;
			T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xReadProfile:=FALSE;
			xWriteProfile:=FALSE;
		(* error *)
		99:	T_Profile.T_Ctrle.xDone:=FALSE;
			T_Profile.T_Ctrle.xErr:=TRUE;
			T_Profile.T_Ctrle.udiErrorID:=16#F1000 + T_Profile.T_Ctrle.iFunction;
			T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xReadProfile:=FALSE;
			xWriteProfile:=FALSE;
		END_CASE
	END_IF

(* check if the USB stick exist *)
	IF xCheckUSBStick THEN
		CASE iStepFunction OF
		(* start timeout *)
		1:	TimerFileLocked(IN:=FALSE);
			iStepFunction:=2;
			sDriveName:='D:\';
		(* Überprüfe zuerst welchen Laufwerkbuchstabe das USB-Stick für Profile hat *)
		2:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) AND NOT(T_HDD.T_Ctrle.xLocked) THEN
				T_HDD.T_Ctrle.xLocked:=TRUE;
				(* next step *)
				iStepFunction:=iStepFunction + 1;
			ELSE
				(* activ error if time out done, HDD not ready *)
				IF TimerFileLocked.Q THEN
					 iStepFunction:=91;
				END_IF
			END_IF;
		(* Überprüfe zuerst welche USB Stick als CAQ definiert ist *)
		3:	IF NOT(gxHardwareOFF) THEN
				sTmp:='D:\PROFILE.txt';
			ELSE
				sTmp:='C:\PROFILE.txt';
			END_IF;
			T_HDD.T_File.sPathAndFileName:=sTmp;
			T_HDD.T_Ctrle.iFunction:=1;
			T_HDD.T_Ctrle.xExecute:=TRUE;
			(* next step *)
			iStepFunction:=iStepFunction + 1;
		(* waiting flag *)
		4:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN
				iStepFunction:=10;
				IF NOT(gxHardwareOFF) THEN
					sDriveName:='D:\';
				ELSE
					sDriveName:='C:\';
				END_IF;
			END_IF
			IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; iStepFunction:=iStepFunction + 1; END_IF
		5:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN
				sTmp:='E:\PROFILE.txt';
				T_HDD.T_File.sPathAndFileName:=sTmp;
				T_HDD.T_Ctrle.iFunction:=1;
				T_HDD.T_Ctrle.xExecute:=TRUE;
				(* next step *)
				iStepFunction:=iStepFunction + 1;
			END_IF;
		(* waiting flag *)
		6:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN iStepFunction:=10; sDriveName:='E:\'; END_IF
			IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; iStepFunction:=99; END_IF
		(* start read *)
		10:	sTmp:=CONCAT(sDriveName,'PROFILETMP1234');
			(* create directory *)
			T_HDD.T_Ctrle.iFunction:=7;
			T_HDD.T_Ctrle.xLocked:=TRUE;
			T_HDD.T_File.sDirectoryPath:=sTmp;
			T_HDD.T_Ctrle.xExecute:=TRUE;
			(* next step *)
			iStepFunction:=20;
			xStepFunctionDone:=FALSE;
		(* waiting flag *)
		20:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN iStepFunction:=30; END_IF
			IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; iStepFunction:=30; END_IF
		(* waiting flag *)
		30:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN
				sTmp:=CONCAT(sDriveName,'PROFILETMP1234');
				(* remove directory *)
				T_HDD.T_Ctrle.iFunction:=8;
				T_HDD.T_File.sDirectoryPath:=sTmp;
				T_HDD.T_Ctrle.xExecute:=TRUE;
				(* next step *)
				iStepFunction:=40;
				xStepFunctionDone:=FALSE;
			END_IF;
		(* waiting flag *)
		40:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN iStepFunction:=90; END_IF
			IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; iStepFunction:=99; END_IF
		(* done *)
		90:	T_Profile.T_Ctrle.xDone:=TRUE;
			T_Profile.T_Ctrle.xErr:=FALSE;
			T_Profile.T_Ctrle.udiErrorID:=16#0;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xCheckUSBStick:=FALSE;
		(* start read error *)
		91:	T_Profile.T_Ctrle.xDone:=FALSE;
			T_Profile.T_Ctrle.xErr:=TRUE;
			T_Profile.T_Ctrle.udiErrorID:=16#F1000 + T_Profile.T_Ctrle.iFunction;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xCheckUSBStick:=FALSE;
		(* start read error *)
		99:	T_Profile.T_Ctrle.xDone:=FALSE;
			T_Profile.T_Ctrle.xErr:=TRUE;
			T_Profile.T_Ctrle.udiErrorID:=16#FFFF;	(* USB-Stick does not exist *)
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xCheckUSBStick:=FALSE;
		END_CASE;
	END_IF;

(* Read liste profile station *)
	IF xReadProfileListeStation THEN
		CASE iStepFunction OF
		(* start timeout *)
		1:	TimerFileLocked(IN:=FALSE);
			iStepFunction:=10;
		(* start read *)
		10:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) AND NOT(T_HDD.T_Ctrle.xLocked) THEN
				(* Init. value *)
				iProfileNr:=1;
				T_Profile.T_IDProfileStation:=T_DeleteIDProfileStation;
				FOR jj:=1 TO csiMaxProfile DO
					T_Profile.T_IDProfileStation[jj].iNumber:=jj;
					T_Profile.T_IDProfileStation[jj].sName:='';
				END_FOR;
				T_Profile.T_IDProfileStation[1].iNumber:=1;
				T_Profile.T_IDProfileStation[1].sName:='Default';
				(* next step *)
				iStepFunction:=20;
				xStepFunctionDone:=FALSE;
				T_HDD.T_Ctrle.xLocked:=TRUE;
			ELSE
				(* activ error if time out done, HDD not ready *)
				IF TimerFileLocked.Q THEN
					 iStepFunction:=91;
				END_IF
			END_IF;
		20:	T_HDD.T_Data.sData:=sDeleteData;
			sTmp:=CONCAT(sDriveName,T_Profile.T_Ctrle.sPathAndFileName);
			sTmp:=CONCAT(sTmp,'STATION');
			sTmp:=CONCAT(sTmp,UINT_TO_STRING(gciStationSt1));
			sTmp:=CONCAT(sTmp,'\');
			sTmp:=CONCAT(sTmp,INT_TO_STRING(iProfileNr));
			sTmp:=CONCAT(sTmp,'.txt');
			(* read file only 1 line *)
			T_HDD.T_Ctrle.iFunction:=11;
			T_HDD.T_File.sPathAndFileName:=sTmp;
			T_HDD.T_Ctrle.xExecute:=TRUE;
			(* next step *)
			iStepFunction:=30;
			xStepFunctionDone:=FALSE;
		(* waiting flag *)
		30:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN
				T_Profile.T_IDProfileStation[iProfileNr].iNumber:=iProfileNr;
				sTmp:=T_HDD.T_Data.sData[1];
				sTmp:=sFctDeleteChar(sString:=sTmp, sChar:='$N');
				sTmp:=sFctDeleteChar(sString:=sTmp, sChar:='$L');
				sTmp:=sFctDeleteChar(sString:=sTmp, sChar:=' ');
				IF (FIND(sTmp,';') > 0) THEN
					iFindChar:=FIND(sTmp,';');
					sTmp:=MID(STR:=sTmp,LEN:=iFindChar - 1,POS:=1);
				END_IF;
				T_Profile.T_IDProfileStation[iProfileNr].sName:=sTmp;
				iStepFunction:=35;
			END_IF
			IF T_HDD.T_Ctrle.xErr THEN
				T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
				T_Profile.T_IDProfileStation[iProfileNr].iNumber:=iProfileNr;
				T_Profile.T_IDProfileStation[iProfileNr].sName:='';
				iStepFunction:=35;
			END_IF
		(* next file *)
		35:	IF iProfileNr < csiMaxProfile THEN
				iProfileNr:=iProfileNr+1; iStepFunction:=20;
			ELSE
				iStepFunction:=90;
			END_IF
		(* reset HDD error *)
		80:	T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
			iStepFunction:=99;
		(* done *)
		90:	T_Profile.T_Ctrle.xDone:=TRUE;
			T_Profile.T_Ctrle.xErr:=FALSE;
			T_Profile.T_Ctrle.udiErrorID:=16#0;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xReadProfileListeStation:=FALSE;
		(* start read error *)
		91:	T_Profile.T_Ctrle.xDone:=FALSE;
			T_Profile.T_Ctrle.xErr:=TRUE;
			T_Profile.T_Ctrle.udiErrorID:=16#F1000 + T_Profile.T_Ctrle.iFunction;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xReadProfileListeStation:=FALSE;
		(* error *)
		99:	T_Profile.T_Ctrle.xDone:=FALSE;
			T_Profile.T_Ctrle.xErr:=TRUE;
			T_Profile.T_Ctrle.udiErrorID:=16#F1000 + T_Profile.T_Ctrle.iFunction;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xReadProfileListeStation:=FALSE;
		END_CASE
	END_IF

	IF xCreateDefaultProfile THEN
		CASE iStepFunction OF
		(* start timeout *)
		1:	TimerFileLocked(IN:=FALSE);
			iStepFunction:=10;
		(* start read *)
		10:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) AND NOT(T_HDD.T_Ctrle.xLocked) THEN
				(* next step *)
				iStepFunction:=20;
				xStepFunctionDone:=FALSE;
				T_HDD.T_Ctrle.xLocked:=TRUE;
			ELSE
				(* activ error if time out done, HDD not ready *)
				IF TimerFileLocked.Q THEN
					 iStepFunction:=91;
				END_IF
			END_IF;
		20:	T_HDD.T_Data.sData:=sDeleteData;
			xFctSetDefaultValueStaticProfile(	ptrT_DefaultProfileParameter:=ADR(T_Profile.T_DefaultProfileParameter));
			xFctCopyProfileToDataFile(	sNameOfProfile:='Default',
									ptrStProzessData:=ADR(T_Profile.T_DefaultProfileParameter.T_ProzessData),
									ptrOnlineChangeData:=ADR(T_Profile.T_DefaultProfileParameter.T_ProfileOnlineChange),
									ptrDataFile:=ADR(T_HDD.T_Data));
			sTmp:=CONCAT(sDriveName,T_Profile.T_Ctrle.sPathAndFileName);
			sTmp:=CONCAT(sTmp,'1');
			sTmp:=CONCAT(sTmp,'.txt');
			(* write file complete *)
			T_HDD.T_Ctrle.iFunction:=2;	(* 10 does not right function *)
			T_HDD.T_File.sPathAndFileName:=sTmp;
			T_HDD.T_Ctrle.xExecute:=TRUE;
			(* next step *)
			iStepFunction:=30;
			xStepFunctionDone:=FALSE;
		(* waiting flag *)
		30:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN
				T_Profile.T_IDProfileStation[1].iNumber:=1;
				T_Profile.T_IDProfileStation[1].sName:='Default';
				iStepFunction:=90;
			END_IF
			IF T_HDD.T_Ctrle.xErr THEN
				T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
				iStepFunction:=35;
			END_IF
		(* try to create first level directory *)
		35:	IF T_HDD.T_Ctrle.xDone THEN
				sTmp:=CONCAT(sDriveName,T_Profile.T_Ctrle.sPathAndFileName);
				(* create directory *)
				T_HDD.T_Ctrle.iFunction:=7;
				T_HDD.T_Ctrle.xLocked:=TRUE;
				T_HDD.T_File.sDirectoryPath:=sTmp;
				T_HDD.T_Ctrle.xExecute:=TRUE;
				(* next step *)
				iStepFunction:=36;
				xStepFunctionDone:=FALSE;
			END_IF;
		(* waiting flag *)
		36:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN
				iStepFunction:=37;
			END_IF
			IF T_HDD.T_Ctrle.xErr THEN
				T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
				iStepFunction:=37;
			END_IF
		(* try to create second level directory *)
		37:	IF T_HDD.T_Ctrle.xDone THEN
				sTmp:=T_Profile.T_Ctrle.sPathAndFileName;
				sTmp:=CONCAT(sTmp,'PROFILE');
				(* create directory *)
				T_HDD.T_Ctrle.iFunction:=7;
				T_HDD.T_Ctrle.xLocked:=TRUE;
				T_HDD.T_File.sDirectoryPath:=sTmp;
				T_HDD.T_Ctrle.xExecute:=TRUE;
				(* next step *)
				iStepFunction:=38;
				xStepFunctionDone:=FALSE;
			END_IF;
		(* waiting flag *)
		38:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN
				iStepFunction:=20;
			END_IF
			IF T_HDD.T_Ctrle.xErr THEN
				T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
				iStepFunction:=99;
			END_IF
		(* reset HDD error *)
		80:	T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
			iStepFunction:=99;
		(* done *)
		90:	T_Profile.T_Ctrle.xDone:=TRUE;
			T_Profile.T_Ctrle.xErr:=FALSE;
			T_Profile.T_Ctrle.udiErrorID:=16#0;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xCreateDefaultProfile:=FALSE;
		(* start read error *)
		91:	T_Profile.T_Ctrle.xDone:=FALSE;
			T_Profile.T_Ctrle.xErr:=TRUE;
			T_Profile.T_Ctrle.udiErrorID:=16#F1000 + T_Profile.T_Ctrle.iFunction;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xCreateDefaultProfile:=FALSE;
		(* error *)
		99:	T_Profile.T_Ctrle.xDone:=FALSE;
			T_Profile.T_Ctrle.xErr:=TRUE;
			T_Profile.T_Ctrle.udiErrorID:=16#F1000 + T_Profile.T_Ctrle.iFunction;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xCreateDefaultProfile:=FALSE;
		END_CASE
	END_IF;

(* Delete profile *)
	IF xDeleteProfile THEN
		CASE iStepFunction OF
		(* check if HDD state *)
		(* start timeout *)
		1:	TimerFileLocked(IN:=FALSE);
			iStepFunction:=10;
		(* file name and activ read or write *)
		10:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) AND NOT(T_HDD.T_Ctrle.xLocked) THEN
				sTmp:=CONCAT(sDriveName,T_Profile.T_Ctrle.sPathAndFileName);
				sTmp:=CONCAT(sTmp,'STATION');
				sTmp:=CONCAT(sTmp,UINT_TO_STRING(gciStationSt1));
				sTmp:=CONCAT(sTmp,'\');
				sTmp:=CONCAT(sTmp,INT_TO_STRING(T_Profile.T_Id.iNumber));
				sTmp:=CONCAT(sTmp,'.txt');
				T_HDD.T_Ctrle.iFunction:=5;	(* Delete Profile *)
				T_HDD.T_Ctrle.xLocked:=TRUE;
				T_HDD.T_File.sPathAndFileName:=sTmp;
				T_HDD.T_Ctrle.xExecute:=TRUE;
				T_Profile.T_Ctrle.sProfileName:='';
				(* next step *)
				iStepFunction:=20;
				xStepFunctionDone:=FALSE;
			ELSE
				(* activ error if time out done, HDD not ready *)
				IF TimerFileLocked.Q THEN
					 iStepFunction:=91;
				END_IF
			END_IF;
		(* waiting flag *)
		20:	IF NOT(T_HDD.T_Ctrle.xExecute) AND T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN iStepFunction:=90; END_IF
			IF NOT(T_HDD.T_Ctrle.xExecute) AND T_HDD.T_Ctrle.xErr THEN iStepFunction:=80; END_IF
		(* reset error *)
		80:	T_HDD.T_Ctrle.xReset:=TRUE;
			iStepFunction:=99;
		(* done *)
		90:	T_Profile.T_Ctrle.xDone:=TRUE;
			T_Profile.T_Ctrle.xErr:=FALSE;
			T_Profile.T_Ctrle.udiErrorID:=16#0;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xDeleteProfile:=FALSE;
		(* start read error *)
		91:	T_Profile.T_Ctrle.xDone:=FALSE;
			T_Profile.T_Ctrle.xErr:=TRUE;
			T_Profile.T_Ctrle.udiErrorID:=16#F1000 + T_Profile.T_Ctrle.iFunction;
			T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xDeleteProfile:=FALSE;
		(* error *)
		99:	T_Profile.T_Ctrle.xDone:=FALSE;
			T_Profile.T_Ctrle.xErr:=TRUE;
			T_Profile.T_Ctrle.udiErrorID:=16#F1000 + T_Profile.T_Ctrle.iFunction;
			T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xDeleteProfile:=FALSE;
		END_CASE
	END_IF

	IF xRenameProfile THEN
		CASE iStepFunction OF
		(* start timeout *)
		1:	TimerFileLocked(IN:=FALSE);
			iStepFunction:=10;
		(* start read *)
		10:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) AND NOT(T_HDD.T_Ctrle.xLocked) THEN
				T_HDD.T_Data.sData:=sDeleteData;
				sTmp:=CONCAT(sDriveName,T_Profile.T_Ctrle.sPathAndFileName);
				sTmp:=CONCAT(sTmp,'STATION');
				sTmp:=CONCAT(sTmp,UINT_TO_STRING(gciStationSt1));
				sTmp:=CONCAT(sTmp,'\');
				sTmp:=CONCAT(sTmp,INT_TO_STRING(T_Profile.T_Id.iNumber));
				sTmp:=CONCAT(sTmp,'.txt');
				T_HDD.T_Ctrle.iFunction:=1;	(* Read Profile, 9 does not right function *)
				T_HDD.T_Ctrle.xLocked:=TRUE;
				T_HDD.T_File.sPathAndFileName:=sTmp;
				T_HDD.T_Ctrle.xExecute:=TRUE;
				T_Profile.T_Ctrle.sProfileName:='';
				(* next step *)
				iStepFunction:=20;
				xStepFunctionDone:=FALSE;
			ELSE
				(* activ error if time out done, HDD not ready *)
				IF TimerFileLocked.Q THEN
					 iStepFunction:=91;
				END_IF
			END_IF;
		(* waiting flag *)
		20:	IF NOT(T_HDD.T_Ctrle.xExecute) AND T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN
				FBCopyDataFileToProfile(	ptrStProzessData:=ADR(T_Profile.T_LoadProfileParameter.T_ProzessData),
										ptrOnlineChangeData:=ADR(T_Profile.T_LoadProfileParameter.T_ProfileOnlineChange),
										ptrDataFile:=ADR(T_HDD.T_Data),
										ptrNameOfProfile:=ADR(T_Profile.T_Ctrle.sProfileName));
				IF (FBCopyDataFileToProfile.bResultCopyData = 1) THEN
					iStepFunction:=30;
				ELSIF (FBCopyDataFileToProfile.bResultCopyData = 2) THEN
					iStepFunction:=98;
				END_IF
			END_IF
			IF NOT(T_HDD.T_Ctrle.xExecute) AND T_HDD.T_Ctrle.xErr THEN
				iStepFunction:=80;
			END_IF
		30:	(* copy profile to HDD data structure *)
			IF xFctCopyProfileToDataFile(	sNameOfProfile:=T_Profile.T_Id.sName,
										ptrStProzessData:=ADR(T_Profile.T_LoadProfileParameter.T_ProzessData),
										ptrOnlineChangeData:=ADR(T_Profile.T_LoadProfileParameter.T_ProfileOnlineChange),
										ptrDataFile:=ADR(T_HDD.T_Data)) 	THEN iStepFunction:=40; ELSE iStepFunction:=99; END_IF
			sTmp:=CONCAT(sDriveName,T_Profile.T_Ctrle.sPathAndFileName);
			sTmp:=CONCAT(sTmp,'STATION');
			sTmp:=CONCAT(sTmp,UINT_TO_STRING(gciStationSt1));
			sTmp:=CONCAT(sTmp,'\');
			sTmp:=CONCAT(sTmp,INT_TO_STRING(T_Profile.T_Id.iNumber));
			sTmp:=CONCAT(sTmp,'.txt');
			(* write file  *)
			T_HDD.T_Ctrle.iFunction:=2;	(* 10 does not right function *)
			T_HDD.T_File.sPathAndFileName:=sTmp;
			T_HDD.T_Ctrle.xExecute:=TRUE;
			(* next step *)
			iStepFunction:=40;
			xStepFunctionDone:=FALSE;
		(* waiting flag *)
		40:	IF NOT(T_HDD.T_Ctrle.xExecute) AND T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN
				iStepFunction:=90;
			END_IF
			IF NOT(T_HDD.T_Ctrle.xExecute) AND T_HDD.T_Ctrle.xErr THEN
				iStepFunction:=80;
			END_IF
		(* reset HDD error *)
		80:	T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
			iStepFunction:=99;
		(* done *)
		90:	T_Profile.T_Ctrle.xDone:=TRUE;
			T_Profile.T_Ctrle.xErr:=FALSE;
			T_Profile.T_Ctrle.udiErrorID:=16#0;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xRenameProfile:=FALSE;
		(* start read error *)
		91:	T_Profile.T_Ctrle.xDone:=FALSE;
			T_Profile.T_Ctrle.xErr:=TRUE;
			T_Profile.T_Ctrle.udiErrorID:=16#F1000 + T_Profile.T_Ctrle.iFunction;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xRenameProfile:=FALSE;
		(* syntax error *)
		98:	T_Profile.T_Ctrle.xDone:=FALSE;
			T_Profile.T_Ctrle.xErr:=TRUE;
			T_Profile.T_Ctrle.udiErrorID:=16#F2000;
			T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xRenameProfile:=FALSE;
		(* error *)
		99:	T_Profile.T_Ctrle.xDone:=FALSE;
			T_Profile.T_Ctrle.xErr:=TRUE;
			T_Profile.T_Ctrle.udiErrorID:=16#F1000 + T_Profile.T_Ctrle.iFunction;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xRenameProfile:=FALSE;
		END_CASE
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL\/PROFILE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION iFctExistProfileName : INT
VAR_INPUT
	sProfileName:STRING(30);
	ptrProfileList:POINTER TO ARRAY[1..4,1..csiMaxProfile] OF ST_PROFILE_ID;
END_VAR
VAR
	i:INT;
	sTmp:STRING;
	sTmp2:STRING;
END_VAR
(* @END_DECLARATION := '0' *)
(* Init. function *)
	iFctExistProfileName:=0;
	sTmp:=sFctUpLowCase(	xLowConvert:=TRUE,
							sInString:=sProfileName);

(* Search if name already exists *)
	FOR i:=1 TO csiMaxProfile DO
		sTmp2:=	sFctUpLowCase(	xLowConvert:=TRUE,
								sInString:=ptrProfileList^[gciStationSt1,i].sName);
		IF sTmp = sTmp2 AND sTmp2 <> '' THEN iFctExistProfileName:=i; RETURN; END_IF
	END_FOR

END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL\/PROFILE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION xFctCopyProfileToDataFile : BOOL
VAR_INPUT
	sNameOfProfile:STRING(30);
	ptrStProzessData:POINTER TO ST_EXCHG_PARAM_STANDARDPROCESS;
	ptrOnlineChangeData:POINTER TO ST_PROFILEONLINECHANGE_DATA;
	ptrDataFile:POINTER TO ARRAY[1..csiMaxFileLine] OF STRING(csiMaxCharPerLine);
END_VAR
VAR
(* variable *)
	i:INT;
(* Tmp *)
	sTmp:STRING;
END_VAR
(* @END_DECLARATION := '0' *)
(* Init. variable *)
	xFctCopyProfileToDataFile:=FALSE;
	i:=1;

(* copy value *)
	(* Name of the profile *)
		ptrDataFile^[i]:=sNameOfProfile;i:=i+1;
		sTmp:=CONCAT('001:rTorqueLevelHC:=',REAL_TO_STRING(ptrOnlineChangeData^.rTorqueLevelHC));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('002:rForceDeflection:=',REAL_TO_STRING(ptrOnlineChangeData^.rForceDeflection));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('003:rWorkingSpeedForward:=',REAL_TO_STRING(ptrOnlineChangeData^.rWorkingSpeedForward));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('004:rWorkingOffsetBackward:=',REAL_TO_STRING(ptrOnlineChangeData^.rWorkingOffsetBackward));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('005:rWorkingSpeedBackward:=',REAL_TO_STRING(ptrOnlineChangeData^.rWorkingSpeedBackward));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('006:rWorkingSpindleSpeed:=',REAL_TO_STRING(ptrOnlineChangeData^.rWorkingSpindleSpeed));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

		sTmp:=CONCAT('007:rPositionLoad:=',REAL_TO_STRING(ptrStProzessData^.rPositionLoad));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('008:rPositionStartProc:=',REAL_TO_STRING(ptrStProzessData^.rPositionStartProc));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('009:rPositionEndProc:=',REAL_TO_STRING(ptrStProzessData^.rPositionEndProc));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('010:rPositionToolChange:=',REAL_TO_STRING(ptrStProzessData^.rPositionToolChange));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('011:rInfeedZAxisSpeed:=',REAL_TO_STRING(ptrStProzessData^.rInfeedZAxisSpeed));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('012:rInfeedSpindleSpeed:=',REAL_TO_STRING(ptrStProzessData^.rInfeedSpindleSpeed));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('013:rOutfeedStrokeAxisSpeed:=',REAL_TO_STRING(ptrStProzessData^.rOutfeedStrokeAxisSpeed));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('014:rOutfeedSpindleSpeed:=',REAL_TO_STRING(ptrStProzessData^.rOutfeedSpindleSpeed));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('015:rInfeedForceDeflection:=',REAL_TO_STRING(ptrStProzessData^.rInfeedForceDeflection));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('016:rInfeedOffsetBackward:=',REAL_TO_STRING(ptrStProzessData^.rInfeedOffsetBackward));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('017:iNumberTryInfeed:=',INT_TO_STRING(ptrStProzessData^.iNumberTryInfeed));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

		sTmp:=CONCAT('018:rProcessMinTime:=',REAL_TO_STRING(ptrStProzessData^.rProcessMinTime));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('019:rProcessMaxTime:=',REAL_TO_STRING(ptrStProzessData^.rProcessMaxTime));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('020:iHCStartProcPosCounter:=',INT_TO_STRING(ptrStProzessData^.iHCStartProcPosCounter));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('021:rDeflectionSensorOffset:=',REAL_TO_STRING(ptrStProzessData^.rDeflectionSensorOffset));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('022:rTorqueLevel_Overload:=',REAL_TO_STRING(ptrStProzessData^.rTorqueLevel_Overload));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

		sTmp:=CONCAT('023:iSparkOutStrokeCount:=',INT_TO_STRING(ptrStProzessData^.iSparkOutStrokeCount));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('024:rSparkOutStrokeLength:=',REAL_TO_STRING(ptrStProzessData^.rSparkOutStrokeLength));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('025:rSparkOutStrokeSpeed:=',REAL_TO_STRING(ptrStProzessData^.rSparkOutStrokeSpeed));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('026:rSparkOutForceDeflection:=',REAL_TO_STRING(ptrStProzessData^.rSparkOutForceDeflection));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('027:rSparkOutTorqueLevel:=',REAL_TO_STRING(ptrStProzessData^.rSparkOutTorqueLevel));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

		sTmp:=CONCAT('028:rPosToolGuid_Up:=',REAL_TO_STRING(ptrStProzessData^.rPosToolGuid_Up));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('029:rPosToolGuid_Down:=',REAL_TO_STRING(ptrStProzessData^.rPosToolGuid_Down));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('030:rDistanceToolGuide:=',REAL_TO_STRING(ptrStProzessData^.rDistanceToolGuide));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('031:rDistanceToolEndPos:=',REAL_TO_STRING(ptrStProzessData^.rDistanceToolEndPos));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('032:rLengthTool_Fixed:=',REAL_TO_STRING(ptrStProzessData^.rLengthTool_Fixed));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('033:rLengthTool_Work:=',REAL_TO_STRING(ptrStProzessData^.rLengthTool_Work));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('034:rLengthToolGuide:=',REAL_TO_STRING(ptrStProzessData^.rLengthToolGuide));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('035:rLengthAirTableBoard:=',REAL_TO_STRING(ptrStProzessData^.rLengthAirTableBoard));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('036:xConfigActive:=',BOOL_TO_STRING(ptrStProzessData^.xConfigActive));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

		sTmp:=CONCAT('037:iMaxTorque:=',INT_TO_STRING(ptrStProzessData^.iMaxTorque));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('038:rSpeedZAxisForBackward:=',REAL_TO_STRING(ptrStProzessData^.rSpeedZAxisForBackward));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('039:rWorkingSpeedOscillation:=',REAL_TO_STRING(ptrStProzessData^.rWorkingSpeedOscillation));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('040:rZ1AxisPosSwitchOAxisOff:=',REAL_TO_STRING(ptrStProzessData^.rZ1AxisPosSwitchOAxisOff));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('041:xActivateCoolantProcess:=',BOOL_TO_STRING(ptrStProzessData^.xActivateCoolantProcess));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('042:rStrokeAxisPosSwitchCoolantOff:=',REAL_TO_STRING(ptrStProzessData^.rStrokeAxisPosSwitchCoolantOff));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

		sTmp:=CONCAT('043:rCentringPosZ1Axis:=',REAL_TO_STRING(ptrStProzessData^.rCentringPosZ1Axis));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('044:rCentringPosSpeedSlowZ1Axis:=',REAL_TO_STRING(ptrStProzessData^.rCentringPosSpeedSlowZ1Axis));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('045:rCentringPosSpeedFastZ1Axis:=',REAL_TO_STRING(ptrStProzessData^.rCentringPosSpeedFastZ1Axis));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('046:rCentringSpeedSAxis:=',REAL_TO_STRING(ptrStProzessData^.rCentringSpeedSAxis));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('047:rCentringSpeedOAxis:=',REAL_TO_STRING(ptrStProzessData^.rCentringSpeedOAxis));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('048:rCentringBackStrokeOffsetFirstHC:=',REAL_TO_STRING(ptrStProzessData^.rCentringBackStrokeOffsetFirstHC));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('049:rCentringBackStrokeOffsetAfterFirstHC:=',REAL_TO_STRING(ptrStProzessData^.rCentringBackStrokeOffsetAfterFirstHC));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('050:rCentringOffsetBeforeLastHC:=',REAL_TO_STRING(ptrStProzessData^.rCentringOffsetBeforeLastHC));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('051:rCentringBackStrokeSpeed:=',REAL_TO_STRING(ptrStProzessData^.rCentringBackStrokeSpeed));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('052:rCentringTimeHCActive:=',REAL_TO_STRING(ptrStProzessData^.rCentringTimeHCActive));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('053:rCentringTimeHCInactive:=',REAL_TO_STRING(ptrStProzessData^.rCentringTimeHCInactive));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('054:iCentringNumberMaxHCinWindow:=',INT_TO_STRING(ptrStProzessData^.iCentringNumberMaxHCinWindow));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('055:rCentringHCWindow:=',REAL_TO_STRING(ptrStProzessData^.rCentringHCWindow));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('056:rCentringForceDeflection:=',REAL_TO_STRING(ptrStProzessData^.rCentringForceDeflection));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('057:rCentringOffsetBackward:=',REAL_TO_STRING(ptrStProzessData^.rCentringOffsetBackward));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('058:rCenteringDeflectionSensorOffset:=',REAL_TO_STRING(ptrStProzessData^.rCenteringDeflectionSensorOffset));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('059:rCentringOffsetSlowToFastZSpeed:=',REAL_TO_STRING(ptrStProzessData^.rCentringOffsetSlowToFastZSpeed));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('060:iCentringSelectProcess:=',INT_TO_STRING(ptrStProzessData^.iCentringSelectProcess));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('061:xPositionEndProcIncOnOff:=',BOOL_TO_STRING(ptrStProzessData^.xPositionEndProcIncOnOff));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('062:rPositionEndProcMaxInc:=',REAL_TO_STRING(ptrStProzessData^.rPositionEndProcMaxInc));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('063:rPositionEndProInc:=',REAL_TO_STRING(ptrStProzessData^.rPositionEndProInc));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

		sTmp:=CONCAT('064:iWorkControlType:=',INT_TO_STRING(ptrStProzessData^.iWorkControlType));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('065:rZ_PID_Torque:=',REAL_TO_STRING(ptrStProzessData^.rZ_PID_Torque));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('066:rZ_PID_MinSpeed:=',REAL_TO_STRING(ptrStProzessData^.rZ_PID_MinSpeed));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('067:rZ_PID_MaxSpeed:=',REAL_TO_STRING(ptrStProzessData^.rZ_PID_MaxSpeed));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('068:rZ_PID_Kp:=',REAL_TO_STRING(ptrStProzessData^.rZ_PID_Kp));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('069:rZ_PID_Ki:=',REAL_TO_STRING(ptrStProzessData^.rZ_PID_Ki));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('070:rZ_PID_Kd:=',REAL_TO_STRING(ptrStProzessData^.rZ_PID_Kd));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('071:iZ_PID_FilterM:=',INT_TO_STRING(ptrStProzessData^.iZ_PID_FilterM));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('072:rZ_D_Kd:=',REAL_TO_STRING(ptrStProzessData^.rZ_D_Kd));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('073:iZ_D_FilterM:=',INT_TO_STRING(ptrStProzessData^.iZ_D_FilterM));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

		sTmp:=CONCAT('074:rSuspensionBubblerSpeed:=',REAL_TO_STRING(ptrStProzessData^.rSuspensionBubblerSpeed));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('075:rSuspensionFeederSpeed:=',REAL_TO_STRING(ptrStProzessData^.rSuspensionFeederSpeed));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

		sTmp:=CONCAT('076:rOutfeedStrokeAxisSpeedSlow:=',REAL_TO_STRING(ptrStProzessData^.rOutfeedStrokeAxisSpeedSlow));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('077:rZ1AxisPosSwitchFastVel:=',REAL_TO_STRING(ptrStProzessData^.rZ1AxisPosSwitchFastVel));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('078:rZ1AxisOffsetStartRecordTorque:=',REAL_TO_STRING(ptrStProzessData^.rZ1AxisOffsetStartRecordTorque));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

		sTmp:=CONCAT('079:xCentringEndProcIncOnOff:=',BOOL_TO_STRING(ptrStProzessData^.xCentringEndProcIncOnOff));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('080:rCentringEndProInc:=',REAL_TO_STRING(ptrStProzessData^.rCentringEndProInc));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

		sTmp:=CONCAT('081:rWorkingSpindleSpeedMinMax:=',REAL_TO_STRING(ptrStProzessData^.rWorkingSpindleSpeedMinMax));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('082:rO_Ctrl_TorquePercent_OFF:=',REAL_TO_STRING(ptrStProzessData^.rO_Ctrl_TorquePercent_OFF));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('083:rO_Ctrl_HystereseOffset:=',REAL_TO_STRING(ptrStProzessData^.rO_Ctrl_HystereseOffset));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

		sTmp:=CONCAT('084:rZPositionCylindricalArea:=',REAL_TO_STRING(ptrStProzessData^.rZPositionCylindricalArea));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('085:rZMinThresholdTroqueEndProcess:=',REAL_TO_STRING(ptrStProzessData^.rZMinThresholdTroqueEndProcess));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

		sTmp:=CONCAT('086:rDistProgressStroke:=',REAL_TO_STRING(ptrStProzessData^.rDistProgressStroke));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('087:iProgressStrokeStartTorque:=',INT_TO_STRING(ptrStProzessData^.iProgressStrokeStartTorque));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;
		sTmp:=CONCAT('088:iCleanNozzleMode:=',INT_TO_STRING(ptrStProzessData^.iCleanNozzleMode));
		ptrDataFile^[i]:=CONCAT(sTmp,';');i:=i+1;

	(* add empty line to set the end *)
	ptrDataFile^[i]:='';

	(* confirm copy *)
	xFctCopyProfileToDataFile:=TRUE;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL\/PROFILE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION xFctSetDefaultValueStaticProfile : BOOL
VAR_INPUT
	ptrT_DefaultProfileParameter:POINTER TO ARRAY [1..1] OF ST_RETAIN_DATA_PROFILEPARAMETER;
END_VAR
VAR
(* variable *)
	ii:INT;
END_VAR
(* @END_DECLARATION := '0' *)
	(* Init. value *)
	xFctSetDefaultValueStaticProfile:=FALSE;
	FOR ii:=1 TO 1 DO
		ptrT_DefaultProfileParameter^[ii].T_ProfileOnlineChange.rTorqueLevelHC:=80.0;
		ptrT_DefaultProfileParameter^[ii].T_ProfileOnlineChange.rForceDeflection:=18.0;
		ptrT_DefaultProfileParameter^[ii].T_ProfileOnlineChange.rWorkingSpeedForward:=100.0;
		ptrT_DefaultProfileParameter^[ii].T_ProfileOnlineChange.rWorkingOffsetBackward:=0.0;
		ptrT_DefaultProfileParameter^[ii].T_ProfileOnlineChange.rWorkingSpeedBackward:=0.5;
		ptrT_DefaultProfileParameter^[ii].T_ProfileOnlineChange.rWorkingSpindleSpeed:=6000.0;

		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rPositionLoad:=-446.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rPositionStartProc:=-410.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rPositionEndProc:=-80.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rPositionToolChange:=-510.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rInfeedZAxisSpeed:=50.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rInfeedSpindleSpeed:=500.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rOutfeedStrokeAxisSpeed:=250.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rOutfeedSpindleSpeed:=500.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rInfeedForceDeflection:=5.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rInfeedOffsetBackward:=-10.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.iNumberTryInfeed:=5;

		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rProcessMinTime:=5.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rProcessMaxTime:=120.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.iHCStartProcPosCounter:=3;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rDeflectionSensorOffset:=0.2;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rTorqueLevel_Overload:=60.0;

		ptrT_DefaultProfileParameter^[ii].T_ProzessData.iSparkOutStrokeCount:=2;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rSparkOutStrokeLength:=-20.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rSparkOutStrokeSpeed:=200.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rSparkOutForceDeflection:=80.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rSparkOutTorqueLevel:=20.0;

		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rPosToolGuid_Up:=210;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rPosToolGuid_Down:=185;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rDistanceToolGuide:=4.5;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rDistanceToolEndPos:=4.5;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rLengthTool_Fixed:=450.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rLengthTool_Work:=325.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rLengthToolGuide:=10.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rLengthAirTableBoard:=33.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.xConfigActive:=FALSE;

		ptrT_DefaultProfileParameter^[ii].T_ProzessData.iMaxTorque:=130;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rSpeedZAxisForBackward:=1.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rWorkingSpeedOscillation:=0.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rZ1AxisPosSwitchOAxisOff:=0.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.xActivateCoolantProcess:=FALSE;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rStrokeAxisPosSwitchCoolantOff:=-300.0;

		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rCentringPosZ1Axis:=-400.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rCentringPosSpeedSlowZ1Axis:=20.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rCentringPosSpeedFastZ1Axis:=50.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rCentringSpeedSAxis:=500.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rCentringSpeedOAxis:=40.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rCentringBackStrokeOffsetFirstHC:=-5.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rCentringBackStrokeOffsetAfterFirstHC:=-15.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rCentringOffsetBeforeLastHC:=-3.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rCentringBackStrokeSpeed:=10.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rCentringTimeHCActive:=5.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rCentringTimeHCInactive:=0.5;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.iCentringNumberMaxHCinWindow:=5;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rCentringHCWindow:=0.5;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rCentringForceDeflection:=20.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rCentringOffsetBackward:=-1.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rCenteringDeflectionSensorOffset:=0.3;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rCentringOffsetSlowToFastZSpeed:=40.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.iCentringSelectProcess:=1;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.xPositionEndProcIncOnOff:=0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rPositionEndProcMaxInc:=-10.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rPositionEndProInc:=0.2;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rOutfeedStrokeAxisSpeedSlow:=2.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rZ1AxisPosSwitchFastVel:=0.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rZ1AxisOffsetStartRecordTorque:=0.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.xCentringEndProcIncOnOff:=0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rCentringEndProInc:=0.2;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rWorkingSpindleSpeedMinMax:=6000.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rO_Ctrl_TorquePercent_OFF:=100.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rO_Ctrl_HystereseOffset:=10.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rZPositionCylindricalArea:=-240.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rZMinThresholdTroqueEndProcess:=12.0;

		ptrT_DefaultProfileParameter^[ii].T_ProzessData.iWorkControlType:=1;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rZ_PID_Torque:=50.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rZ_PID_MinSpeed:=2.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rZ_PID_MaxSpeed:=40.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rZ_PID_Kp:=2.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rZ_PID_Ki:=0.5;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rZ_PID_Kd:=0.01;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.iZ_PID_FilterM:=20;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rZ_D_Kd:=0.01;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.iZ_D_FilterM:=20;

		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rSuspensionBubblerSpeed:=20.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rSuspensionFeederSpeed:=20.0;

		ptrT_DefaultProfileParameter^[ii].T_ProzessData.rDistProgressStroke:=0.0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.iProgressStrokeStartTorque:=0;
		ptrT_DefaultProfileParameter^[ii].T_ProzessData.iCleanNozzleMode:=0;

	END_FOR;
	(* Confirm Default setting *)
	xFctSetDefaultValueStaticProfile:=TRUE;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL\/PROFILE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION xFctSetOnlineChangeMaxMin : BOOL
VAR_INPUT
	ptrProfileOnlineChange:POINTER TO ST_PROFILEONLINECHANGE;
	rMaxToolSpindleSpeed:REAL;
	rMaxForceDeflection:REAL;
	rMaxTorqueLevel:REAL;
	rMinTorqueLevel:REAL;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
(* Init. function state *)
	xFctSetOnlineChangeMaxMin:=FALSE;

(* Set Max/Min for the online change value *)
		ptrProfileOnlineChange^.T_Max.rWorkingOffsetBackward:=0.0;
		ptrProfileOnlineChange^.T_Min.rWorkingOffsetBackward:=-100.0;
		ptrProfileOnlineChange^.T_Max.rWorkingSpeedForward:=150.0;
		ptrProfileOnlineChange^.T_Min.rWorkingSpeedForward:=0.1;
		ptrProfileOnlineChange^.T_Max.rWorkingSpeedBackward:=250.0;
		ptrProfileOnlineChange^.T_Min.rWorkingSpeedBackward:=0.1;
		ptrProfileOnlineChange^.T_Max.rWorkingSpindleSpeed:=rMaxToolSpindleSpeed;
		ptrProfileOnlineChange^.T_Min.rWorkingSpindleSpeed:=rMaxToolSpindleSpeed * -1.0;
		ptrProfileOnlineChange^.T_Max.rForceDeflection:=rMaxForceDeflection;
		ptrProfileOnlineChange^.T_Min.rForceDeflection:=0.1;
		ptrProfileOnlineChange^.T_Max.rTorqueLevelHC:=rMaxTorqueLevel;
		ptrProfileOnlineChange^.T_Min.rTorqueLevelHC:=rMinTorqueLevel;

(* Confirm function execution *)
	xFctSetOnlineChangeMaxMin:=TRUE;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL\/PROFILE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION xFctUpdateOnlineChangeValue : BOOL
VAR_INPUT
	ptrProfileOnlineChange:POINTER TO ST_PROFILEONLINECHANGE;	(* Min Max Werte der OnlineChange Parameter *)
	ptrProfileOnlineChangeLoad:POINTER TO ST_PROFILEONLINECHANGE_DATA;	(* Min Max Werte der OnlineChange Parameter *)
	ptrExchgParamStationCommon:POINTER TO ST_EXCHG_PARAM_ONLINECHANGE;
	TOnlineChangeParameter:ST_PROFILEONLINECHANGE_DATA;	(* Datenübergabe *)
END_VAR
VAR
(* Tmp variable *)
	rTmp:REAL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Update online value *)
	ptrExchgParamStationCommon^.T_Data:=TOnlineChangeParameter;

(* Update Abs perzent *)
	IF ptrProfileOnlineChange^.T_Min.rWorkingOffsetBackward <> 0 THEN
		ptrExchgParamStationCommon^.T_DataValPercentAbs.rWorkingOffsetBackward
			:=ABS(TOnlineChangeParameter.rWorkingOffsetBackward/ptrProfileOnlineChange^.T_Min.rWorkingOffsetBackward*100);
	ELSE ptrExchgParamStationCommon^.T_DataValPercentAbs.rWorkingOffsetBackward:=-1; END_IF
	IF ptrProfileOnlineChange^.T_Max.rWorkingSpeedForward <> 0 THEN
		ptrExchgParamStationCommon^.T_DataValPercentAbs.rWorkingSpeedForward
			:=ABS(TOnlineChangeParameter.rWorkingSpeedForward/ptrProfileOnlineChange^.T_Max.rWorkingSpeedForward*100);
	ELSE ptrExchgParamStationCommon^.T_DataValPercentAbs.rWorkingSpeedForward:=-1; END_IF
	IF ptrProfileOnlineChange^.T_Max.rWorkingSpeedBackward <> 0 THEN
		ptrExchgParamStationCommon^.T_DataValPercentAbs.rWorkingSpeedBackward
			:=ABS(TOnlineChangeParameter.rWorkingSpeedBackward/ptrProfileOnlineChange^.T_Max.rWorkingSpeedBackward*100);
	ELSE ptrExchgParamStationCommon^.T_DataValPercentAbs.rWorkingSpeedBackward:=-1; END_IF
	IF ptrProfileOnlineChange^.T_Max.rForceDeflection <> 0 THEN
		rTmp:=TOnlineChangeParameter.rForceDeflection;
		rTmp:=rTmp/ptrProfileOnlineChange^.T_Max.rForceDeflection*100;
		ptrExchgParamStationCommon^.T_DataValPercentAbs.rForceDeflection:=ABS(rTmp);
	ELSE ptrExchgParamStationCommon^.T_DataValPercentAbs.rForceDeflection:=-1; END_IF
	IF ptrProfileOnlineChange^.T_Max.rTorqueLevelHC <> 0 THEN
		ptrExchgParamStationCommon^.T_DataValPercentAbs.rTorqueLevelHC
			:=ABS(TOnlineChangeParameter.rTorqueLevelHC/ptrProfileOnlineChange^.T_Max.rTorqueLevelHC*100);
	ELSE ptrExchgParamStationCommon^.T_DataValPercentAbs.rTorqueLevelHC:=-1; END_IF
	IF ptrProfileOnlineChange^.T_Min.rWorkingSpindleSpeed <> 0 THEN
		ptrExchgParamStationCommon^.T_DataValPercentAbs.rWorkingSpindleSpeed
			:=ABS(TOnlineChangeParameter.rWorkingSpindleSpeed/ptrProfileOnlineChange^.T_Min.rWorkingSpindleSpeed*100);
	ELSE ptrExchgParamStationCommon^.T_DataValPercentAbs.rWorkingSpindleSpeed:=-1; END_IF

(*  Update Rel perzent *)
	IF ptrProfileOnlineChangeLoad^.rWorkingOffsetBackward <> 0 THEN
		ptrExchgParamStationCommon^.T_DataValPercentRel.rWorkingOffsetBackward
			:=ABS(TOnlineChangeParameter.rWorkingOffsetBackward/ptrProfileOnlineChangeLoad^.rWorkingOffsetBackward*100);
	ELSE ptrExchgParamStationCommon^.T_DataValPercentRel.rWorkingOffsetBackward:=-1; END_IF
	IF ptrProfileOnlineChangeLoad^.rWorkingSpeedForward <> 0 THEN
		ptrExchgParamStationCommon^.T_DataValPercentRel.rWorkingSpeedForward
			:=ABS(TOnlineChangeParameter.rWorkingSpeedForward/ptrProfileOnlineChangeLoad^.rWorkingSpeedForward*100);
	ELSE ptrExchgParamStationCommon^.T_DataValPercentRel.rWorkingSpeedForward:=-1; END_IF
	IF ptrProfileOnlineChangeLoad^.rWorkingSpeedBackward <> 0 THEN
		ptrExchgParamStationCommon^.T_DataValPercentRel.rWorkingSpeedBackward
			:=ABS(TOnlineChangeParameter.rWorkingSpeedBackward/ptrProfileOnlineChangeLoad^.rWorkingSpeedBackward*100);
	ELSE ptrExchgParamStationCommon^.T_DataValPercentRel.rWorkingSpeedBackward:=-1; END_IF
	IF ptrProfileOnlineChangeLoad^.rForceDeflection <> 0 THEN
		rTmp:=TOnlineChangeParameter.rForceDeflection;
		rTmp:=rTmp/ptrProfileOnlineChangeLoad^.rForceDeflection*100;
		ptrExchgParamStationCommon^.T_DataValPercentRel.rForceDeflection:=ABS(rTmp);
	ELSE ptrExchgParamStationCommon^.T_DataValPercentRel.rForceDeflection:=-1; END_IF
	IF ptrProfileOnlineChangeLoad^.rTorqueLevelHC <> 0 THEN
		ptrExchgParamStationCommon^.T_DataValPercentRel.rTorqueLevelHC
			:=ABS(TOnlineChangeParameter.rTorqueLevelHC/ptrProfileOnlineChangeLoad^.rTorqueLevelHC*100);
	ELSE ptrExchgParamStationCommon^.T_DataValPercentRel.rTorqueLevelHC:=-1; END_IF
	IF ptrProfileOnlineChangeLoad^.rWorkingSpindleSpeed <> 0 THEN
		ptrExchgParamStationCommon^.T_DataValPercentRel.rWorkingSpindleSpeed
			:=ABS(TOnlineChangeParameter.rWorkingSpindleSpeed/ptrProfileOnlineChangeLoad^.rWorkingSpindleSpeed*100);
	ELSE ptrExchgParamStationCommon^.T_DataValPercentRel.rWorkingSpindleSpeed:=-1; END_IF

(* Min/Max value *)
	ptrExchgParamStationCommon^.T_Max:=ptrProfileOnlineChange^.T_Max;
	ptrExchgParamStationCommon^.T_Min:=ptrProfileOnlineChange^.T_Min;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_BIOSPARAMETER
VAR_INPUT
	dwBIOSPasswordPage:DWORD;		(* Page number of the BIOS password page *)
	dwBIOSParameterPage:DWORD;		(* Page number of the BIOS parameter page *)
	xActiveCurrentAxes:BOOL;
	xReadyToSwitchPasswordPage:BOOL;
END_VAR
VAR_IN_OUT
	T_Visu:ST_QVIS;						(* Data structure of the visualisation *)
	T_ExchgParam :ST_QVIS_EXCHG_PARAM;
	T_HDD:ST_HDD;						(* Data structure of the File Management *)
	T_NovRam : ST_NOVRAM;				(* Data structure of the NovRam *)
	T_CtrlePanel:ST_CTRLEPANEL;		(* Data structure of the ControlPanel *)
END_VAR
VAR_OUTPUT
END_VAR
VAR
	TONShowMessage: TON;
	xChangeToBIOSPassword: BOOL;
	xChangeToBIOSParameter: BOOL;
	xSaveBIOSParameterToNovRAM: BOOL;
	xCopyBIOSParameter: BOOL;
	iStepSaveToNovRAM: INT;
	iStepReadFirstTimeParameter: INT;
	xCheckMsgBoxActive: BOOL;
(* Random *)
	fbGetCpuAccount:GETCPUCOUNTER;
	FBPassword_SystemLevel:FB_Password_SystemLevel;
	diPwSystem:DINT;
	xNovRAMParaReaded: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********     This Functionblock gives the possibility to set the bios parameter, with input a SystemLevel password     ************)
(****************************************************************************************************************************************************)
xNovRAMParaReaded:=TRUE;
(* Managing BIOS Parameter on Startup *)
	IF (T_ExchgParam.T_Visu.T_Message.iStateBIOS <> 0) THEN
		TONShowMessage(IN:=TRUE,PT:=T#3s);
		IF TONShowMessage.Q THEN
			T_ExchgParam.T_Visu.T_Message.iStateBIOS:=0;
		END_IF;
	ELSE
		TONShowMessage(IN:=FALSE);
	END_IF;
	xCheckMsgBoxActive:=	(T_ExchgParam.T_SafetyCtrl.bStateMessageError <> 0) OR
							(T_ExchgParam.T_SafetyCtrl.bStateMessageInfo <> 0) OR
							(T_ExchgParam.T_SafetyCtrl.bStateMessageWarning <> 0);
	IF ((T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iStart_Page1) AND NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone) OR xCheckMsgBoxActive THEN
		xChangeToBIOSPassword:=FALSE;
		xChangeToBIOSParameter:=FALSE;
		xSaveBIOSParameterToNovRAM:=FALSE;
		xCopyBIOSParameter:=FALSE;
		iStepSaveToNovRAM:=1;
		iStepReadFirstTimeParameter:=1;
		T_ExchgParam.T_Visu.T_Message.iStateBIOS:=0;
	END_IF;
	IF (T_Visu.T_PlcParam.dwActualPage = dwBIOSPasswordPage) OR (T_Visu.T_PlcParam.dwActualPage = dwBIOSParameterPage) THEN
		IF xActiveCurrentAxes THEN	(* check if external relase button has been pressed *)
			IF NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone THEN
				T_Visu.T_PlcParam.dwSetNewPage:=0;
				T_Visu.T_CtrleVisu.iFunction:=1;
				T_Visu.T_CtrleVisu.xExecute:=TRUE;
			END_IF;
		END_IF;
	END_IF;
	(* check if the function button is pressed-->if it is pressed the change to the BIOS password page *)
	IF NOT(xChangeToBIOSPassword) THEN
		IF (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iStart_Page1) AND NOT(T_StartUp.T_State.xCompleted) AND NOT(xCheckMsgBoxActive) THEN
			IF T_ExchgParam.T_BtFunctionPanel.wActivBt = 16#1 THEN
				T_ExchgParam.T_BtFunctionPanel.wActivBt:=0;
				IF NOT(xActiveCurrentAxes) THEN
					IF NOT(gxAxisPositionSettled) THEN
						IF NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone THEN
							T_ExchgParam.T_Visu.T_Message.iStateBIOS:=0;
							xChangeToBIOSPassword:=TRUE;
							T_Visu.T_PlcParam.dwSetNewPage:=dwBIOSPasswordPage;
							T_Visu.T_CtrleVisu.iFunction:=1;
							T_Visu.T_CtrleVisu.xExecute:=TRUE;
							(* Der Counter respektive Random muss 9 Stellig sein welches aus dem Zyklusticker der CPU ausgelesen wird *)
							fbGetCpuAccount;
							FBPassword_SystemLevel(	dwCounterHI:= fbGetCpuAccount.cpuCntHiDW,
													dwCounterLOW:=fbGetCpuAccount.cpuCntLoDW);
							T_ExchgParam.T_Visu.T_Level.diRandom:=FBPassword_SystemLevel.diRandom;
							diPwSystem:=FBPassword_SystemLevel.diPwSystem;
						END_IF;
					ELSE
						T_ExchgParam.T_Visu.T_Message.iState:=225;	(* Warnung: BIOS Parameter nur vor dem erstmaligen Booten zugänglich ! *)
					END_IF;
				ELSE
					T_ExchgParam.T_Visu.T_Message.iState:=226;	(* Warnung: BIOS Parameter nur bei ausgeschalteter Energieversorgung ! *)
				END_IF;
			END_IF;
		END_IF;
	END_IF;
	(* check the settled password *)
	IF xChangeToBIOSPassword THEN
		IF (T_Visu.T_PlcParam.dwActualPage = dwBIOSPasswordPage) THEN
			IF T_ExchgParam.T_Visu.xKey_Escape THEN	(* ESC Button for exit and go to the Startpage *)
				T_ExchgParam.T_Visu.xKey_Escape:=FALSE;
				IF NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone THEN
					xChangeToBIOSPassword:=FALSE;
					T_Visu.T_PlcParam.dwSetNewPage:=0;
					T_Visu.T_CtrleVisu.iFunction:=1;
					T_Visu.T_CtrleVisu.xExecute:=TRUE;
					T_ExchgParam.T_Visu.T_Level.diPwSystem:=-1;
				END_IF;
			END_IF;
			IF (T_ExchgParam.T_Visu.T_Level.diPwSystem = diPwSystem) THEN
				T_ExchgParam.T_Visu.T_Message.iStateBIOS:=0;
				T_ExchgParam.T_Visu.T_Level.diPwSystem:=-1;
				IF NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone THEN
					xChangeToBIOSPassword:=FALSE;
					xChangeToBIOSParameter:=TRUE;
					T_Visu.T_PlcParam.dwSetNewPage:=dwBIOSParameterPage;
					T_Visu.T_CtrleVisu.iFunction:=1;
					T_Visu.T_CtrleVisu.xExecute:=TRUE;
					xCopyBIOSParameter:=TRUE;
					T_CtrlePanel.udiButton:=0;
				END_IF;
			END_IF;
			IF (T_ExchgParam.T_Visu.T_Level.diPwSystem <> -1) THEN
				IF (T_ExchgParam.T_Visu.T_Level.diPwSystem <> diPwSystem) THEN
					T_ExchgParam.T_Visu.T_Message.iStateBIOS:=2;	(* Falsches Passwort *)
					T_ExchgParam.T_Visu.T_Level.diPwSystem:=-1;
					(* Der Counter respektive Random muss 9 Stellig sein welches aus dem Zyklusticker der CPU ausgelesen wird *)
					fbGetCpuAccount;
					FBPassword_SystemLevel(	dwCounterHI:= fbGetCpuAccount.cpuCntHiDW,
											dwCounterLOW:=fbGetCpuAccount.cpuCntLoDW);
					T_ExchgParam.T_Visu.T_Level.diRandom:=FBPassword_SystemLevel.diRandom;
					diPwSystem:=FBPassword_SystemLevel.diPwSystem;
				END_IF;
			END_IF;
		END_IF;
	END_IF;
	(* the edit parameterlist is now active *)
	IF xChangeToBIOSParameter THEN
		IF (T_Visu.T_PlcParam.dwActualPage = dwBIOSParameterPage) AND NOT(xSaveBIOSParameterToNovRAM) AND NOT(xCopyBIOSParameter) THEN
			IF T_ExchgParam.T_Visu.xKey_Escape THEN	(* ESC Button for exit and go to the Startpage *)
				T_ExchgParam.T_Visu.xKey_Escape:=FALSE;
				IF NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone THEN
					xChangeToBIOSParameter:=FALSE;
					xSaveBIOSParameterToNovRAM:=FALSE;
					xCopyBIOSParameter:=TRUE;
					T_Visu.T_PlcParam.dwSetNewPage:=0;
					T_Visu.T_CtrleVisu.iFunction:=1;
					T_Visu.T_CtrleVisu.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF (UDINT_TO_WORD(T_CtrlePanel.udiButton) = 16#200) AND NOT(xSaveBIOSParameterToNovRAM) THEN	(* Right Panel Button for save Parameter *)
				T_CtrlePanel.udiButton:=0;
				T_ExchgParam.T_Visu.T_Message.iStateBIOS:=1;	(* Parameter gespeichert *)
				xSaveBIOSParameterToNovRAM:=TRUE;
				xCopyBIOSParameter:=FALSE;
				iStepSaveToNovRAM:=1;
			END_IF;
		END_IF;
	END_IF;
	(* save the settled parameter to the NovRam *)
	IF xSaveBIOSParameterToNovRAM THEN
		CASE iStepSaveToNovRAM OF
		1:	IF xNovRAMParaReaded THEN
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.xReferencedZAxis:=T_ExchgParam.T_ParamBIOS.xReferencedZAxis_St1;
				T_NovRAM.T_Ctrle.iFunction:=2;
				T_NovRAM.T_Ctrle.xExecute:=TRUE;
				iStepSaveToNovRAM:=10;
			ELSE
				iStepSaveToNovRAM:=1;
				xSaveBIOSParameterToNovRAM:=FALSE;
			END_IF;
		10:	IF NOT(T_NovRAM.T_Ctrle.xExecute) AND T_NovRAM.T_Ctrle.xDone THEN
				iStepSaveToNovRAM:=1;
				xSaveBIOSParameterToNovRAM:=FALSE;
				T_Visu.T_CtrleVisu.xReset:=TRUE;	(* Exit the BIOS Parameter Page *)
			END_IF;
		END_CASE;
	END_IF;
	(* copy the NovRam config parameter to the visu structure *)
	IF xCopyBIOSParameter THEN
		IF xNovRAMParaReaded THEN
			T_ExchgParam.T_ParamBIOS.xReferencedZAxis_St1:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.xReferencedZAxis;
			xCopyBIOSParameter:=FALSE;
		ELSE
			xCopyBIOSParameter:=FALSE;
		END_IF;
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CalcCuttingSpeed
VAR_INPUT
	rActualPosition : REAL;
	iCountStep : INT;	(* Durchschnitt von diesem Counter wird berechnet *)
END_VAR
VAR_IN_OUT
	xCapturePosition : BOOL;
	xReset : BOOL;
END_VAR
VAR_OUTPUT
	rCuttingSpeed : REAL;
END_VAR
VAR
	arCuttingSpeed: ARRAY [1..2,1..200] OF REAL;
	arDeleteData: ARRAY [1..2,1..200] OF REAL;
	iStepCounter: INT;
	rSumDeltaPos : REAL;
	rSumDeltaTime : REAL;
	ii: INT;
	iStepPos: INT;
	xFirstCycle: BOOL;
	rTmpSavePosition: REAL;
	TONCycleTime: TON;
	xStartTimer: BOOL;
	rTmpSaveTime: REAL;
	iTmpStepCount: INT;
END_VAR
(* @END_DECLARATION := '0' *)
(* Berechnung der Schnittgeschwindigkeit *)
IF xReset THEN
	xReset:=FALSE;
	xFirstCycle:=TRUE;
	xStartTimer:=FALSE;
	rCuttingSpeed:=0.0;
	arCuttingSpeed:=arDeleteData;
END_IF;
TONCycleTime(IN:=xStartTimer,PT:=T#999999s);
IF xCapturePosition THEN
	xCapturePosition:=xStartTimer:=FALSE;
	IF xFirstCycle THEN
		iTmpStepCount:=iCountStep;
		IF (iTmpStepCount <= 0) THEN
			iTmpStepCount:=1;
		ELSIF (iTmpStepCount > 200) THEN
			iTmpStepCount:=200;
		END_IF;
		xFirstCycle:=FALSE;
		iStepCounter:=iStepPos:=1;
		rCuttingSpeed:=0.0;
		rTmpSavePosition:=rActualPosition;
		xStartTimer:=TRUE;
		RETURN;
	END_IF;
	rTmpSavePosition:=rActualPosition - rTmpSavePosition;			(* Delta Position *)
	rTmpSaveTime:=TIME_TO_REAL(TONCycleTime.ET)/1000.0;		(* Delta Time *)
	arCuttingSpeed[1,iStepCounter]:=rTmpSavePosition;
	arCuttingSpeed[2,iStepCounter]:=rTmpSaveTime;
	rTmpSavePosition:=rActualPosition;
	rSumDeltaPos:=rSumDeltaTime:=0.0;
	FOR ii:=1 TO iStepPos DO
		rSumDeltaPos:=rSumDeltaPos + arCuttingSpeed[1,ii];
		rSumDeltaTime:=rSumDeltaTime + arCuttingSpeed[2,ii];
	END_FOR;
	rCuttingSpeed:=(rSumDeltaPos/INT_TO_REAL(iStepPos))/(rSumDeltaTime/INT_TO_REAL(iStepPos));
	iStepCounter:=iStepCounter + 1;
	IF (iStepCounter > iTmpStepCount) THEN
		iStepCounter:=1;
	END_IF;
	IF (iStepPos < iTmpStepCount) THEN
		iStepPos:=iStepPos + 1;
	END_IF;
ELSE
	IF NOT(xFirstCycle) THEN
		xStartTimer:=TRUE;
	END_IF;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CalcSpindleForce
VAR_INPUT
	rForcePistonIn:REAL;	(* in Newton *)
	rPistonDiameterD1:REAL;	(* in mm *)
	rPistonDiameterD2:REAL;	(* in mm *)
	rMaxAirpressure:REAL;		(* in bar *)
	rMaxServoVoltage:REAL;	(* in Volt *)
END_VAR
VAR_OUTPUT
	iAnalogOutput:INT;		(* range 0 - 32767 *)
	rSetMaxForce:REAL;		(* in Newton *)
	rForcePistonOut:REAL;	(* in Newton *)
END_VAR
VAR
	rMaxForce: REAL;
	rAreaOutside: REAL;
	rArea: REAL;
	rTmpMaxAirpressure: REAL;
	rTmpAnalogOut:REAL;
	rMaxDigitAnalogOutput: REAL;
END_VAR
(* @END_DECLARATION := '0' *)
	rMaxDigitAnalogOutput:=(32767.0 / 10.0) * rMaxServoVoltage;
	rAreaOutside:=((rPistonDiameterD1/2.0)*(rPistonDiameterD1/2.0))*PI;
	rArea:=ABS(rAreaOutside) * 2.0;	(* the new spindle has two piston *)
	rArea:=rArea / 1000000.0;	(* Umwandeln von mm^2 in m^2 *)
	rTmpMaxAirpressure:=rMaxAirpressure * 100000.0;	(* convert from bar to pascal *)
	rMaxForce:=rArea * rTmpMaxAirpressure;
	rSetMaxForce:=rMaxForce;
	IF(rMaxForce = 0) THEN rMaxForce:=0.01; END_IF;	(* check divide by zero *)
	IF(rMaxForce <> 0.0) THEN
		rTmpAnalogOut:=(rForcePistonIn/rMaxForce)*rMaxDigitAnalogOutput;
		IF (rTmpAnalogOut > rMaxDigitAnalogOutput) THEN
			iAnalogOutput:=REAL_TO_INT(rMaxDigitAnalogOutput);
		ELSE
			iAnalogOutput:=REAL_TO_INT(rTmpAnalogOut);
		END_IF;
		rForcePistonOut:=rForcePistonIn;
	ELSE
		iAnalogOutput:=0;
		rForcePistonOut:=0;
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CHECKMACHINESTATE
VAR_INPUT
	xSecurityKey:BOOL;		(* state of the keyswitch-->TRUE=EinrichtBetrieb *)
	iSetupMode:INT;			(* Turn switch --> 1=EinrichtBetriebA, 2=EinrichtBetriebB, 0=Normalbetrieb *)
	xNormalOperate_EnergyON:BOOL;
	xSetupOperateA_EnergyON:BOOL;
	xSetupOperateB_EnergyON:BOOL;
END_VAR
VAR_OUTPUT
END_VAR
VAR
	xTmp: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
T_ExchgParam.T_Visu.bMachineState:=0;
(* Abfragen für Allgemeiner Maschinenzustand *)
xTmp:=	xNormalOperate_EnergyON OR xSetupOperateA_EnergyON OR xSetupOperateB_EnergyON;
xTmp:=	xTmp AND
		TStation_Work_St1.TControl.xReferenced;
IF xTmp THEN
	T_ExchgParam.T_Visu.bMachineState:=T_ExchgParam.T_Visu.bMachineState OR 2#001;		(* 1=Maschine hat keinen Fehler, kein Prozess-/Stationsfunktion aktiv, kein Aktuator ist in Bewegung und die Energieversorgung ist eingeschaltet *)
ELSE
	T_ExchgParam.T_Visu.bMachineState:=T_ExchgParam.T_Visu.bMachineState AND 2#110;
END_IF;
xTmp:=	NOT(TStation_Work_St1.TControl.xDone) OR TStation_Work_St1.TControl.xActiveMovement OR
		T_StartUp.T_State.xBlockChangeMovementVisu OR NOT(T_VisuQVis.T_CtrleProcess.xDone) OR
		NOT(T_VisuQVis.T_CtrleAction.xDone) OR T_VisuQVis.T_CtrleAction.xFunctionActive;
IF xTmp THEN
	T_ExchgParam.T_Visu.bMachineState:=T_ExchgParam.T_Visu.bMachineState OR 2#010;		(* 2=Prozess-/Stationsfunktion Aktiv oder mindestens ein Aktuator ist in Bewegung *)
ELSE
	T_ExchgParam.T_Visu.bMachineState:=T_ExchgParam.T_Visu.bMachineState AND 2#101;
END_IF;
IF (T_ExchgParam.T_Visu.T_Message.iState = 401) THEN
	T_ExchgParam.T_Visu.bMachineState:=T_ExchgParam.T_Visu.bMachineState OR 2#100;		(* 4=Maschine hat mindestens einen Fehler *)
ELSE
	T_ExchgParam.T_Visu.bMachineState:=T_ExchgParam.T_Visu.bMachineState AND 2#011;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CHECKSETUPMODE
VAR_INPUT
	T_TwinSafeIn:ST_TWINSAFE_IN;
END_VAR
VAR_OUTPUT
	iSetupMode:INT;	(* 1=A, 2=B, 0=Normalbetrieb *)
END_VAR
VAR
	xSetupModeA: BOOL;
	xSetupModeB: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
xSetupModeA:=			T_TwinSafeIn.IxKeySwitchProcObservationCh1 AND
						T_TwinSafeIn.IxKeySwitchProcObservationCh2 AND
						NOT(T_TwinSafeIn.IxKeySwitchWorkStationCh1) AND
						NOT(T_TwinSafeIn.IxKeySwitchWorkStationCh2);
xSetupModeB:=			NOT(T_TwinSafeIn.IxKeySwitchProcObservationCh1) AND
						NOT(T_TwinSafeIn.IxKeySwitchProcObservationCh2) AND
						T_TwinSafeIn.IxKeySwitchWorkStationCh1 AND
						T_TwinSafeIn.IxKeySwitchWorkStationCh2;

(* Prozessbeobachtung *)
IF xSetupModeA THEN
	iSetupMode:=1;		(* 1=Prozessbeobachtung *)
(* Bearb.Station *)
ELSIF xSetupModeB THEN
	iSetupMode:=2;		(* 2=Einricht Bearbeitungsstation *)
ELSE
	iSetupMode:=0;		(* 0=Normalbetrieb *)
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_ControlLamp
VAR_INPUT
	xStartUpCompleted:BOOL;
	iStateMessage:INT;
	xSetupActive:BOOL;
	xPreWarningActive:BOOL;
END_VAR
VAR_IN_OUT
	TProcess : ST_PROCESS;
	TCtrlePanel:ST_CTRLEPANEL;
END_VAR
VAR_OUTPUT
	xLampGreen:BOOL;
	xLampRed:BOOL;
	xLampYellow:BOOL;
END_VAR
VAR
(* Timer *)
	TimerON:TON;
	TimerOFF:TOF;
	tTimerCadence:TIME;
	xTimerSignal:BOOL;
(* variable *)
	xFirstExecution:BOOL;
	xPanelLedBlinked: BOOL;
(* Tmp *)
	xTmp:BOOL;
	bLampGreen: BYTE;
	bLampYellow: BYTE;
	bLampRed: BYTE;
END_VAR
(* @END_DECLARATION := '0' *)
(* First execution *)
	IF NOT xFirstExecution THEN
		(* Init. variable *)
		tTimerCadence:=T#0.5s;
		xTimerSignal:=FALSE;
		(* Timer *)
		TimerON(IN:=FALSE);
		TimerOFF(IN:=TRUE);
		(* Confirm execution *)
		xFirstExecution:=TRUE;
	END_IF

(* Each cycle, init. lamp state *)
	xLampGreen:=FALSE;
	xLampRed:=FALSE;
	xLampYellow:=FALSE;
	TCtrlePanel.udiLED:=16#0;

(* Each cycle, init. lamp state function *)
	xTmp:=FALSE;
	bLampGreen:=0;bLampYellow:=0;bLampRed:=0;
	xPanelLedBlinked:=FALSE;

	IF NOT(xStartUpCompleted) THEN
		(* Maschine ist eingeschaltet, Betriebssystem ist geladen resp. SPS steht bereit, Maschine wurde aber noch nicht aufgestartet oder ist noch am aufstarten *)
		bLampGreen:=1;bLampYellow:=1;bLampRed:=1;	(* Grün ON, Gelb ON, Rot ON *)
	ELSE
		IF (iStateMessage = 401) THEN
			(* Error state *)
			(* Automatik- oder Einrichtbetrieb-->Störung (Warnung aber nicht Aktiv) *)
			bLampGreen:=0;bLampYellow:=0;bLampRed:=1;	(* Grün OFF, Gelb OFF, Rot ON *)
			xPanelLedBlinked:=TRUE;
		ELSIF NOT(TProcess.T_Ctrle.xDone)  AND NOT(xSetupActive) THEN
			IF NOT(xPreWarningActive) THEN
				(* Automatikbetrieb --> Prozess (Automatik, Masch.Ref, WstkEntladen) Aktiv *)
				bLampGreen:=1;bLampYellow:=0;bLampRed:=0;	(* Grün ON, Gelb OFF, Rot OFF *)
			ELSE
				(* Automatikbetrieb --> Prozess Aktiv --> Vorwarnung Materialmangel (Wstk, Wz, Kühlmittelfüllstand) *)
				bLampGreen:=1;bLampYellow:=1;bLampRed:=0;	(* Grün ON, Gelb ON, Rot OFF *)
			END_IF;
		ELSIF TProcess.T_Ctrle.xDone AND NOT(xSetupActive) THEN
			(* Automatikbetrieb --> Maschinenstillstand ohne Störung *)
			IF NOT(xPreWarningActive) THEN
				bLampGreen:=2;bLampYellow:=0;bLampRed:=0;	(* Grün BLINK, Gelb OFF, Rot OFF *)
			ELSE
				bLampGreen:=2;bLampYellow:=1;bLampRed:=0;	(* Grün BLINK, Gelb ON, Rot OFF *)
			END_IF;
		ELSIF xSetupActive THEN
			(* Einrichtbetrieb --> unabhängig ob eine Bewegung stattfindet oder nicht *)
			bLampGreen:=2;bLampYellow:=2;bLampRed:=2;	(* Grün BLINK, Gelb BLINK, Rot BLINK *)
		ELSE
			(* Maschine ist ausgeschaltet oder Maschine ist eingeschaltet, aber Betriebssystem ist noch nicht geladen resp. SPS steht noch nicht bereit *)
			bLampGreen:=0;bLampYellow:=0;bLampRed:=0;	(* Grün OFF, Gelb OFF, Rot OFF *)
		END_IF;
	END_IF;

(* Blink *)
	TimerON(IN:=TRUE,PT:=tTimerCadence);
	IF TimerON.Q THEN
		TimerOFF(IN:=FALSE,PT:=tTimerCadence);
		IF NOT TimerOFF.Q THEN TimerON(IN:=FALSE); TimerOFF(IN:=TRUE); END_IF
	END_IF
(* Grüne Lampe-->Werkerruflampe *)
	IF (bLampGreen = 0) THEN
		xLampGreen:=FALSE;	(* Grüne Lampe ausgeschaltet *)
	ELSIF (bLampGreen = 1) THEN
		xLampGreen:=TRUE;	(* Grüne Lampe eingeschaltet *)
	ELSIF (bLampGreen = 2) THEN
		xLampGreen:=TimerON.Q;	(* Grüne Lampe blinkt *)
	END_IF;
(* Gelbe Lampe-->Werkerruflampe *)
	IF (bLampYellow = 0) THEN
		xLampYellow:=FALSE;	(* Gelbe Lampe ausgeschaltet *)
	ELSIF (bLampYellow = 1) THEN
		xLampYellow:=TRUE;	(* Gelbe Lampe eingeschaltet *)
	ELSIF (bLampYellow = 2) THEN
		xLampYellow:=TimerON.Q;	(* Gelbe Lampe blinkt *)
	END_IF;
(* Rote Lampe-->Werkerruflampe *)
	IF (bLampRed = 0) THEN
		xLampRed:=FALSE;	(* Rote Lampe ausgeschaltet *)
	ELSIF (bLampRed = 1) THEN
		xLampRed:=TRUE;	(* Rote Lampe eingeschaltet *)
	ELSIF (bLampRed = 2) THEN
		xLampRed:=TimerON.Q;	(* Rote Lampe blinkt *)
	END_IF;

(* Panel led blinked *)
	IF xPanelLedBlinked THEN
		IF TimerON.Q THEN TCtrlePanel.udiLED:=16#3FF; ELSE TCtrlePanel.udiLED:=16#0; END_IF
	END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CTRLEBUTTON
VAR_INPUT
	xReadyFB:BOOL;
	xHWStart:BOOL;
	xHWStop:BOOL;
	dwActualPage:DWORD;
	T_VisuQVis:ST_QVIS;
	T_ExchgParam:ST_QVIS_EXCHG_PARAM;
	xSecurityKey:BOOL;		(* state of the keyswitch-->TRUE=EinrichtBetrieb *)
	iSetupMode:INT;			(* Turn switch --> 1=EinrichtBetriebA, 2=EinrichtBetriebB *)
	xNormalOperate_EnergyON:BOOL;
	xSetupOperateA_EnergyON:BOOL;
	xSetupOperateB_EnergyON:BOOL;
	xSetupOperateC_EnergyON:BOOL;
END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
	T_StartButton: ST_BUTTON;
	T_StopButton:ST_BUTTON;
END_VAR
VAR
(* Variable *)
	iIndexActivPage:INT;
(* FB Mask *)
	xMaskPageBtStart:BOOL;
	xMaskPageBtStop:BOOL;
(* Trigger *)
	RisingEdgeSignalStartButton:R_TRIG;
	RisingEdgeSignalStopButton:R_TRIG;
(* Tmp variable *)
	xTmp:BOOL;
	xNotCheckState: BOOL;
	xProcessReady: BOOL;
	xVisuActionReady: BOOL;
	xNotCheckStateStop: BOOL;
	xProcessActive: BOOL;
	xStationReady_SetupMode1: BOOL;
	xStationReady_SetupMode2: BOOL;
	xStationReady_NormalMode: BOOL;
	xStationSecurityStateON: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* exit FB if machine is not start up and ready *)
	IF NOT(xReadyFB) THEN RETURN;	END_IF;

(* Index Activ Page *)
	iIndexActivPage:=T_VisuQVis.T_PageIndex[dwActualPage].iIndexConfigPage;
	xMaskPageBtStart:=FALSE;
	xMaskPageBtStop:=FALSE;


	xProcessReady:=	NOT(TProcess.T_Ctrle.xExecute) AND TProcess.T_Ctrle.xDone AND NOT(T_VisuQVis.T_CtrleProcess.xExecute) AND T_VisuQVis.T_CtrleProcess.xDone;
	xProcessActive:=	(NOT(TProcess.T_Ctrle.xExecute) AND NOT(TProcess.T_Ctrle.xDone)) OR
						(NOT(T_VisuQVis.T_CtrleProcess.xExecute) AND NOT(T_VisuQVis.T_CtrleProcess.xDone) AND NOT(T_VisuQVis.T_CtrleProcess.xErr));

	xStationSecurityStateON:=	TStation_Work_St1.TControl.xSecurityCircuitOn;


	xStationReady_SetupMode1:=	(TStation_Work_St1.TControl.xDone AND TStation_Work_St1.TControl.xRdy AND NOT(TStation_Work_St1.TControl.xError)) AND
									xSetupOperateA_EnergyON;

	xStationReady_SetupMode2:=	(TStation_Work_St1.TControl.xDone AND TStation_Work_St1.TControl.xRdy AND NOT(TStation_Work_St1.TControl.xError)) AND
									xSetupOperateB_EnergyON;

	xStationReady_NormalMode:=	xStationReady_SetupMode1 AND xStationReady_SetupMode2 AND xNormalOperate_EnergyON;

	xVisuActionReady:=NOT(T_VisuQVis.T_CtrleAction.xExecute) AND T_VisuQVis.T_CtrleAction.xDone;

	IF NOT(xSecurityKey) THEN
		xNotCheckState:=		NOT(xNormalOperate_EnergyON) OR (T_ExchgParam.T_Visu.bMachineState = 4) OR
								(T_ExchgParam.T_SafetyCtrl.bStateMessageError <> 0) OR (T_ExchgParam.T_SafetyCtrl.bStateMessageInfo <> 0) OR
								(T_ExchgParam.T_SafetyCtrl.bStateMessageWarning <> 0) OR NOT(xProcessReady) OR NOT(xVisuActionReady) OR NOT(xStationReady_NormalMode);
		xNotCheckStateStop:=	NOT(xNormalOperate_EnergyON) OR (T_ExchgParam.T_Visu.bMachineState = 4) OR
								(T_ExchgParam.T_SafetyCtrl.bStateMessageError <> 0) OR (T_ExchgParam.T_SafetyCtrl.bStateMessageInfo <> 0) OR
								(T_ExchgParam.T_SafetyCtrl.bStateMessageWarning <> 0);
	ELSE
		IF (iSetupMode = 1) THEN
			xNotCheckState:=	NOT(xSetupOperateA_EnergyON) OR (T_ExchgParam.T_Visu.bMachineState = 4) OR NOT(xProcessReady) OR NOT(xVisuActionReady) OR NOT(xStationReady_SetupMode1);
			xNotCheckStateStop:=NOT(xSetupOperateA_EnergyON) OR (T_ExchgParam.T_Visu.bMachineState = 4);
		ELSIF (iSetupMode = 2) THEN
			xNotCheckState:=	NOT(xSetupOperateB_EnergyON) OR (T_ExchgParam.T_Visu.bMachineState = 4) OR NOT(xVisuActionReady) OR NOT(xStationReady_SetupMode2);
			xNotCheckStateStop:=NOT(xSetupOperateB_EnergyON) OR (T_ExchgParam.T_Visu.bMachineState = 4);
		ELSE
			xNotCheckState:=TRUE;
		END_IF;
	END_IF;
(* Start Button *)
	IF NOT(xNotCheckState) OR T_CtrleBtStartStop.xForceSetStartButton THEN
		CASE dwActualPage OF
		gT_PageNumber.iAutoMode_Process, gT_PageNumber.iAutoMode_ProcessValue1, gT_PageNumber.iAutoMode_ProcessValue2, gT_PageNumber.iAutoMode_PartQuality:		(* Automat Prozess *)
			xMaskPageBtStart:=TRUE;
			IF T_CtrleBtStartStop.xForceSetStartButton THEN
				xMaskPageBtStart:=TRUE;
			END_IF;
		gT_PageNumber.iAutoMode_Referencing:	(* Maschinenreferenzierung Prozess *)
			xMaskPageBtStart:=TRUE;
		gT_PageNumber.iHandMode_Process,gT_PageNumber.iHandMode_WorkParameter,gT_PageNumber.iHandMode_RegulatorPara,gT_PageNumber.iHandMode_OnlineChange,gT_PageNumber.iHandMode_ConfigPosition:		(* HandBetrieb Prozess *)
			xMaskPageBtStart:=TRUE;
			IF T_CtrleBtStartStop.xForceSetStartButton THEN
				xMaskPageBtStart:=TRUE;
			END_IF;
		gT_PageNumber.iWorkStation_Axis1:		(* TeachIN für Absolut Bewegung oder Geschwindigkeitsbewegung *)
			IF (T_ExchgParam.T_StationCommon.wState AND 16#6) = 16#0 THEN
				(* Station darf nicht Aktiv sein und kein Fehler darf vorhanden sein *)
				CASE T_ExchgParam.T_TeachIn.iSetup_AxisSel OF
				gciAxisZ_St1:
					IF (T_ExchgParam.T_TeachIn.arAxis[gciAxisZ_St1].bActState AND 16#F) = 16#3 THEN
						xMaskPageBtStart:=TRUE;	(* Achse muss Referenziert sein, Achsenstrom muss eingeschaltet sein, kein Fehler und Achse darf sich nicht bewegen *)
					END_IF;
				gciAxisS_St1,3:
					IF (T_ExchgParam.T_TeachIn.arAxis[gciAxisS_St1].bActState AND 16#F) = 16#1 THEN
						xMaskPageBtStart:=TRUE;	(* Achse muss Referenziert sein, Achsenstrom muss eingeschaltet sein, kein Fehler und Achse darf sich nicht bewegen *)
					END_IF;
				END_CASE;
			END_IF;
		gT_PageNumber.iWorkStation_Function1:		(* Ausführen von Stationsfunktionen der Bearbeitungsstation MicroHead und EntgratStation *)
			IF ((T_ExchgParam.T_StationCommon.wState AND 16#6) = 16#0) THEN
				(* Stationen Bearb, Lade/Entlade und Teller dürfen nicht Aktiv sein und kein Fehler darf vorhanden sein *)
				xMaskPageBtStart:=TRUE;
			END_IF;
			IF T_CtrleBtStartStop.xForceSetStartButton THEN
				xMaskPageBtStart:=TRUE;
			END_IF;
		gT_PageNumber.iWorkStation_Setup1:		(* Ausführen der Stationsfunktion für das Kalibrieren des ToolDefelction und ToolTorque *)
			IF ((T_ExchgParam.T_StationCommon.wState AND 16#6) = 16#0) THEN
				(* Station Bearb darf nicht Aktiv sein und kein Fehler darf vorhanden sein *)
				xMaskPageBtStart:=TRUE;
			END_IF;
		gT_PageNumber.iWorkStation_Setup2:		(* Ausführen der Stationsfunktion für das Kalibrieren des ToolDefelction und ToolTorque *)
			IF ((T_ExchgParam.T_StationCommon.wState AND 16#6) = 16#0) THEN
				(* Station Bearb darf nicht Aktiv sein und kein Fehler darf vorhanden sein *)
				xMaskPageBtStart:=TRUE;
			END_IF;
		gT_PageNumber.iWorkStation_Setup3:			(* Ausführen von Stationsfunktionen für das Einrichten der Z Achse für die erst einrichtung *)
			IF (T_ExchgParam.T_StationCommon.iZAxisFirstSetup_StepNr = 1) THEN
				IF (T_ExchgParam.T_StationCommon.wState AND 16#6) = 16#0 THEN
					(* Arbeitsstation darf nicht Aktiv sein und kein Fehler darf vorhanden sein *)
					xMaskPageBtStart:=TRUE;
				END_IF;
			END_IF;
			IF T_CtrleBtStartStop.xForceSetStartButton THEN
				xMaskPageBtStart:=TRUE;
			END_IF;
		END_CASE;

		IF (T_ExchgParam.T_Visu.T_Message.iState = 401) THEN
			xMaskPageBtStart:=FALSE;
		END_IF;
	END_IF;

	(* Set state button start *)
	RisingEdgeSignalStartButton(CLK:=xHWStart);
	IF RisingEdgeSignalStartButton.Q THEN T_StartButton.xInputState:=TRUE; ELSE T_StartButton.xInputState:=FALSE; END_IF
	T_StartButton.xInputState:=T_StartButton.xInputState AND T_VisuQVis.T_ConfigPage[iIndexActivPage].xMaskBtStart;

	(* Led off if action is starting *)
	T_StartButton.xLedState:=T_VisuQVis.T_ConfigPage[iIndexActivPage].xMaskBtStart;

	(* set page mask *)
	T_StartButton.xInputState:=T_StartButton.xInputState AND xMaskPageBtStart;
	T_StartButton.xLedState:=T_StartButton.xLedState AND xMaskPageBtStart;

	T_CtrleBtStartStop.xForceSetStartButton:=FALSE;

(* Stop Button *)
	IF NOT(xNotCheckStateStop) OR T_CtrleBtStartStop.xForceSetStopButton THEN
		IF xProcessActive OR T_CtrleBtStartStop.xForceSetStopButton THEN
			xMaskPageBtStop:=NOT(TProcess.T_Ctrle.xStop) AND (T_ExchgParam.T_Visu.T_Message.iState <> 235);
			IF T_CtrleBtStartStop.xForceSetStopButton THEN
				xMaskPageBtStop:=TRUE;
			END_IF;
			IF (T_ExchgParam.T_Visu.T_Message.iState = 401) THEN
				xMaskPageBtStop:=FALSE;
			END_IF;
		ELSE
			xTmp:=	((((T_ExchgParam.T_Station1.wState AND 16#6) = 16#2)) AND gT_SafetyStatus.xSetupOperateModeActive) OR
					T_VisuQVis.T_CtrleAction.xFunctionActive;
			xTmp:=	xTmp OR
					(((T_VisuQVis.T_CtrleAction.iFunction >= 400) AND (T_VisuQVis.T_CtrleAction.iFunction <= 498)) AND
					NOT(T_VisuQVis.T_CtrleAction.xDone) AND NOT(T_VisuQVis.T_CtrleAction.xErr));
			IF xTmp THEN
				(* Station aktiv *)
				xMaskPageBtStop:=TRUE;
			ELSE
				(* Kein Prozess und keine Stationsfunktion ist aktiv *)
				CASE dwActualPage OF
				gT_PageNumber.iAutoMode_ToolChange:
					IF (T_ExchgParam.T_TeachIn.arAxis[gciAxisZ_St1].bActState AND 16#4) = 16#4 THEN
						xMaskPageBtStop:=TRUE;	(* Achse bewegt sich *)
					END_IF;
				gT_PageNumber.iWorkStation_Axis1:		(* TeachIN für Absolut Bewegung oder Geschwindigkeitsbewegung *)
					CASE T_ExchgParam.T_TeachIn.iSetup_AxisSel OF
					gciAxisZ_St1:
						IF (T_ExchgParam.T_TeachIn.arAxis[gciAxisZ_St1].bActState AND 16#4) = 16#4 THEN
							xMaskPageBtStop:=TRUE;	(* Achse bewegt sich *)
						END_IF;
					gciAxisS_St1,3:
						IF (T_ExchgParam.T_TeachIn.arAxis[gciAxisS_St1].bActState AND 16#4) = 16#4 THEN
							xMaskPageBtStop:=TRUE;	(* Achse bewegt sich *)
						END_IF;
					END_CASE;
				END_CASE;
			END_IF;
		END_IF;
		IF xStationSecurityStateON THEN
			xMaskPageBtStop:=FALSE;
		END_IF;
	END_IF;

	RisingEdgeSignalStopButton(CLK:=xHWStop);
	IF RisingEdgeSignalStopButton.Q THEN T_StopButton.xInputState:=TRUE; ELSE T_StopButton.xInputState:=FALSE; END_IF
	T_StopButton.xInputState:=T_StopButton.xInputState AND T_VisuQVis.T_ConfigPage[iIndexActivPage].xMaskBtStop;

	T_StopButton.xLedState:=T_VisuQVis.T_ConfigPage[iIndexActivPage].xMaskBtStop;

	(* set page mask *)
	T_StopButton.xInputState:=T_StopButton.xInputState AND xMaskPageBtStop;
	T_StopButton.xLedState:=T_StopButton.xLedState AND xMaskPageBtStop;

	T_CtrleBtStartStop.xForceSetStopButton:=FALSE;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_CylAnalogFunction
VAR_INPUT
	iRampFctOn:INT;
	iRampFctOff:INT;
	rSetOutput:REAL;
	rDeltaOutput:REAL;
	rTau:REAL;
	rActualOutput:REAL;
END_VAR
VAR_IN_OUT
	xStart: BOOL;
	xReset: BOOL;
END_VAR
VAR_OUTPUT
	rOutput:REAL;
	xEnd:BOOL;
	tOutputTimeOn:TIME;
	tOutputTimeOff:TIME;
END_VAR
VAR
	xInit: BOOL;
	TONTimeCalc: TON;
	xFirstTime: BOOL;
	rTmpDeltaSum: REAL;
	TONTimeOutput: TON;
	aValue: ARRAY [0..1000] OF REAL;
	aDeltaValue: ARRAY [0..1000] OF REAL;
	aDelete: ARRAY [0..1000] OF REAL;
	iIndex: INT;
	yn1: REAL;
	xWait: BOOL;
	rTmpOutput: REAL;
	rTmp1Output: REAL;
	iTmpIndex: INT;
	rSum: REAL;
	rTmpMaxOutput: REAL;
	xIncrease: BOOL;
	xDecrease: BOOL;
	iFunctNr:INT;
END_VAR
(* @END_DECLARATION := '0' *)
IF NOT(xFirstTime) THEN
	xFirstTime:=TRUE;
	xEnd:=TRUE;
END_IF;
IF xReset THEN
	xReset:=FALSE;
	xStart:=FALSE;
	xEnd:=TRUE;
	xInit:=FALSE;
END_IF;
IF xStart OR xInit THEN
	IF NOT(xInit) THEN
		xInit:=TRUE;
		xStart:=FALSE;
		TONTimeCalc(IN:=FALSE);
		TONTimeOutput(IN:=FALSE);
		xEnd:=FALSE;
		rTmpDeltaSum:=0.0;
		tOutputTimeOn:=T#0s;
		tOutputTimeOff:=T#0s;
		iIndex:=0;
		yn1:=0;
		aValue:=aDeltaValue:=aDelete;
		xWait:=FALSE;
		rTmpOutput:=0.0;
		rTmp1Output:=0.0;
		rSum:=0.0;
		rOutput:=rActualOutput;
	END_IF;
	IF (rDeltaOutput = 0.0) THEN
		rOutput:=rSetOutput;
		xInit:=FALSE;
		xEnd:=TRUE;
		RETURN;
	END_IF;
	IF (rSetOutput - rOutput) >= 0 THEN xIncrease:=TRUE; xDecrease:=FALSE; END_IF;
	IF (rSetOutput - rOutput) < 0 THEN xIncrease:=FALSE; xDecrease:=TRUE; END_IF;
	IF xIncrease THEN rTmpMaxOutput:=rSetOutput - rOutput; iFunctNr:=iRampFctOn; END_IF;
	IF xDecrease THEN rTmpMaxOutput:=rOutput - rSetOutput; iFunctNr:=iRampFctOff; END_IF;
	IF (iFunctNr = 1) OR (iFunctNr = 2) OR (iFunctNr = 3) THEN
		TONTimeOutput(IN:=TRUE,PT:=T#1000s);
		IF xIncrease THEN tOutputTimeOn:=TONTimeOutput.ET; END_IF;
		IF xDecrease THEN tOutputTimeOff:=TONTimeOutput.ET; END_IF;
		WHILE(NOT(xWait)) DO
			rTmpDeltaSum:=rTmpDeltaSum + rDeltaOutput;
			rTmpOutput:=rTmpOutput + rTmpDeltaSum;
			(* Aufzeichnung *)
			aValue[iIndex]:=rTmpOutput - rTmp1Output;
			rTmp1Output:=rTmpOutput;
			iIndex:=iIndex + 1;
			IF rTmpOutput >= rTmpMaxOutput THEN
				iTmpIndex:=iIndex-1;
				xWait:=TRUE;
				iIndex:=0;
			END_IF;
		END_WHILE;
		IF (iFunctNr = 1) AND xIncrease THEN			(* Parabelfunktion-->steigend *)
			rOutput:=rOutput + aValue[iIndex];
			iIndex:=iIndex + 1;
		END_IF;
		IF (iFunctNr = 1) AND xDecrease THEN			(* Parabelfunktion-->fallend *)
			rOutput:=rOutput - aValue[iIndex];
			iIndex:=iIndex + 1;
		END_IF;
		IF (iFunctNr = 2) AND xIncrease THEN			(* e-Funktion-->steigend *)
			rOutput:=rOutput + aValue[iTmpIndex];
			iTmpIndex:=iTmpIndex - 1;
		END_IF;
		IF (iFunctNr = 2) AND xDecrease THEN			(* e-Funktion-->fallend *)
			rOutput:=rOutput - aValue[iTmpIndex];
			iTmpIndex:=iTmpIndex - 1;
		END_IF;
		IF (iFunctNr = 3) AND xIncrease THEN			(* Linearfunktion-->steigend *)
			WHILE(iTmpIndex > iIndex) DO
				rSum:=rSum + aValue[iIndex];
				iIndex:=iIndex + 1;
				IF (iTmpIndex <= iIndex) THEN
					rSum:=rSum / iTmpIndex;
				END_IF;
			END_WHILE;
			rOutput:=rOutput + rSum;
		END_IF;
		IF (iFunctNr = 3) AND xDecrease THEN			(* Linearfunktion-->fallend *)
			WHILE(iTmpIndex > iIndex) DO
				rSum:=rSum + aValue[iIndex];
				iIndex:=iIndex + 1;
				IF (iTmpIndex <= iIndex) THEN
					rSum:=rSum / iTmpIndex;
				END_IF;
			END_WHILE;
			rOutput:=rOutput - rSum;
		END_IF;
		IF xIncrease THEN
			IF rOutput >= rSetOutput THEN
				rOutput:=rSetOutput;
				xInit:=FALSE;
				xEnd:=TRUE;
			END_IF;
		END_IF;
		IF xDecrease THEN
			IF rOutput <= rSetOutput THEN
				rOutput:=rSetOutput;
				xInit:=FALSE;
				xEnd:=TRUE;
			END_IF;
		END_IF;
	END_IF;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_D_CONTROL
VAR_INPUT
    rActualValue      : REAL;
END_VAR
VAR_IN_OUT
	T_CtrlPara:ST_CTRL_PID_PARAM;
END_VAR
VAR_OUTPUT
	rOut:REAL;
	xMaxOutputReach:BOOL;
	xMinOutputReach:BOOL;
END_VAR
VAR
	r_E_Fehler:REAL;
	r_E_Fehler_Alt:REAL;
	r_Zykluszeit:REAL;
	r_D_Anteil:REAL;
END_VAR

(* @END_DECLARATION := '0' *)
(* Es wird nur eine Ausgabe bei Abweichung zwischen vorgehendem und aktuellen Wert berechnet *)
r_E_Fehler:= rActualValue;
r_Zykluszeit:=T_CtrlPara.rCtrlCycleTime;
IF (r_Zykluszeit = 0.0) THEN
	r_Zykluszeit:=0.001;
END_IF
r_D_Anteil:=(T_CtrlPara.rKd/r_Zykluszeit) * (r_E_Fehler - r_E_Fehler_Alt);
rOut:=r_D_Anteil;
r_E_Fehler_Alt:=r_E_Fehler;
IF (rOut >= T_CtrlPara.rOutMaxLimit) THEN
	rOut:=T_CtrlPara.rOutMaxLimit;
	xMaxOutputReach:=TRUE;
ELSE
	xMaxOutputReach:=FALSE;
END_IF
IF (rOut <= T_CtrlPara.rOutMinLimit) THEN
	rOut:=T_CtrlPara.rOutMinLimit;
	xMinOutputReach:=TRUE;
ELSE
	xMinOutputReach:=FALSE;
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_Linearization_Potentiometer
VAR_INPUT
	adi_X_MeasurePoint_Voltage:ARRAY [0..11] OF DINT;	(* 0 - 32768 *)
	lr_X_Voltage:LREAL;	(* 0 - 32768 *)
END_VAR
VAR_OUTPUT
	lrValuePercent:LREAL;		(* in N *)
	lrScaledValuePercent:LREAL;	(* in N *)
END_VAR
VAR
	ii: INT;
	lr_M_gradient: LREAL;
	lr_B_AxisIntercept: LREAL;
	adi_X_FixedValue:ARRAY [0..10] OF DINT;
END_VAR
(* @END_DECLARATION := '0' *)
(***********************************               Linearisierung für Potentiometer              ***********************************)
lr_M_gradient:=0.0;
lr_B_AxisIntercept:=0.0;
lrValuePercent:=lrScaledValuePercent:=0.0;
adi_X_FixedValue[0]:=0;
adi_X_FixedValue[1]:=10;
adi_X_FixedValue[2]:=20;
adi_X_FixedValue[3]:=30;
adi_X_FixedValue[4]:=40;
adi_X_FixedValue[5]:=50;
adi_X_FixedValue[6]:=60;
adi_X_FixedValue[7]:=70;
adi_X_FixedValue[8]:=80;
adi_X_FixedValue[9]:=90;
adi_X_FixedValue[10]:=100;
IF (lr_X_Voltage <> 0) THEN
	FOR ii:=0 TO 9 DO
		IF (lr_X_Voltage >= DINT_TO_REAL(adi_X_MeasurePoint_Voltage[ii])) AND (lr_X_Voltage <= DINT_TO_REAL(adi_X_MeasurePoint_Voltage[ii + 1])) THEN
			IF ((adi_X_MeasurePoint_Voltage[ii+1] - adi_X_MeasurePoint_Voltage[ii]) <> 0.0) THEN
				lr_M_gradient:=(DINT_TO_REAL(adi_X_FixedValue[ii+1]) - DINT_TO_REAL(adi_X_FixedValue[ii])) / (DINT_TO_REAL(adi_X_MeasurePoint_Voltage[ii+1]) - DINT_TO_REAL(adi_X_MeasurePoint_Voltage[ii]));	(* Berechnung der Steigung m *)
			END_IF;
			lr_B_AxisIntercept:=DINT_TO_REAL(adi_X_FixedValue[ii]) - (lr_M_gradient * DINT_TO_REAL(adi_X_MeasurePoint_Voltage[ii]));	(* berechnung des Y-Achsenabschnittes *)
			EXIT;
		END_IF;
	END_FOR;
	IF (ii <= 9) THEN
		IF (lr_M_gradient <> 0.0) THEN
			lrScaledValuePercent:=(lr_M_gradient * lr_X_Voltage) + lr_B_AxisIntercept;	(* Lineare Funktion-->ausrechnen des linearisierten Kraft *)
		END_IF;
	ELSE
		IF (lr_X_Voltage > adi_X_MeasurePoint_Voltage[10]) THEN
			lrScaledValuePercent:=DINT_TO_LREAL(adi_X_FixedValue[10]);
		ELSE
			lrScaledValuePercent:=DINT_TO_REAL(adi_X_FixedValue[0]);
		END_IF;
	END_IF;
ELSE
	lrScaledValuePercent:=DINT_TO_REAL(adi_X_FixedValue[0]);
END_IF;
IF (lrScaledValuePercent < DINT_TO_REAL(adi_X_FixedValue[0])) THEN
	lrScaledValuePercent:=DINT_TO_REAL(adi_X_FixedValue[0]);
END_IF;
IF (lrScaledValuePercent > DINT_TO_REAL(adi_X_FixedValue[10])) THEN
	lrScaledValuePercent:=DINT_TO_REAL(adi_X_FixedValue[10]);
END_IF;
lrScaledValuePercent:=DINT_TO_LREAL(LREAL_TO_DINT(lrScaledValuePercent));
lrValuePercent:=REAL_TO_BYTE((100.0/32768.0) * lr_X_Voltage);	(* Nicht linearisierter Wert-->0% bis 100% *)
IF (lrValuePercent < DINT_TO_REAL(adi_X_FixedValue[0])) THEN
	lrValuePercent:=DINT_TO_REAL(adi_X_FixedValue[0]);
END_IF;
IF (lrValuePercent > DINT_TO_REAL(adi_X_FixedValue[10])) THEN
	lrValuePercent:=DINT_TO_REAL(adi_X_FixedValue[10]);
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_PASSWORD
VAR_INPUT
END_VAR
VAR_IN_OUT
	T_Password:ST_PASSWORD;
	T_HDD:ST_HDD;
END_VAR
VAR_OUTPUT
END_VAR
VAR
	RisingEdgeReset: R_TRIG;
	xConfirmResetFB: BOOL;
	TimerFileLocked: TON;
	RisingEdgeExecute: R_TRIG;
	TimerOut: TON;
	xTmp: BOOL;
	tTimeOut: TIME;
	iStepFunction: INT;
	xReadPassword: BOOL;
	sDeleteData: ARRAY[1..csiMaxFileLine] OF STRING(csiMaxCharPerLine);
	sTmp:STRING(255);
	xWritePassword: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                            	      This Functionblock read and write the Operator Password from a File                		    ************)
(****************************************************************************************************************************************************)
(* waiting for reset *)
	RisingEdgeReset(CLK:=T_Password.T_Ctrle.xReset);
	IF RisingEdgeReset.Q THEN
	(* init. structure *)
		T_Password.T_Ctrle.xDone:=FALSE;
		T_Password.T_Ctrle.xErr:=FALSE;
		T_Password.T_Ctrle.udiErrorID:=0;
		T_Password.T_Ctrle.iFunction:=0;
		(* Reset HDD if error activ *)
		IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; END_IF
		(* Init. variable *)
		xReadPassword:=FALSE;
		xWritePassword:=FALSE;
		(* set flag done *)
		xConfirmResetFB:=TRUE;
		(* exit function *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
		(* confirm reset FB *)
			T_Password.T_Ctrle.xDone:=TRUE;
			T_Password.T_Ctrle.xErr:=FALSE;
			T_Password.T_Ctrle.udiErrorID:=0;
			T_Password.T_Ctrle.iFunction:=0;
			(* init. variable *)
			xConfirmResetFB:=FALSE;
		END_IF
	END_IF

TimerFileLocked(IN:=TRUE, PT:=T#10S);

(* waiting for execute *)
	RisingEdgeExecute(CLK:=T_Password.T_Ctrle.xExecute);
	IF RisingEdgeExecute.Q THEN
		CASE T_Password.T_Ctrle.iFunction OF
		(* read Operator Password *)
		1:	xReadPassword:=TRUE;
			T_HDD.T_Data.sData:=sDeleteData;
			tTimeOut:=T#10s;
		(* write Operator Password *)
		2:	xWritePassword:=TRUE;
			T_HDD.T_Data.sData:=sDeleteData;
			tTimeOut:=T#10s;
		ELSE
		(* function not implemented *)
			 T_Password.T_Ctrle.xDone:=FALSE;
			 T_Password.T_Ctrle.xErr:=TRUE;
			 T_Password.T_Ctrle.udiErrorID:=16#F000;
			 (* exit FB *)
			 RETURN;
		END_CASE
		(* Init. variable *)
		T_Password.T_Ctrle.xDone:=FALSE;
		T_Password.T_Ctrle.xErr:=FALSE;
		T_Password.T_Ctrle.udiErrorID:=16#0;
		(* init. step *)
		iStepFunction:=1;
		RETURN;
	END_IF

(* Monitor time out *)
	xTmp:=	NOT T_Password.T_Ctrle.xDone
			AND NOT T_Password.T_Ctrle.xErr;
	TimerOut(IN:=xTmp, PT:=tTimeOut);
	IF TimerOut.Q THEN iStepFunction:=99; END_IF

(* read Operator Password *)
	IF xReadPassword THEN
		CASE iStepFunction OF
		(* start timeout *)
		1:	TimerFileLocked(IN:=FALSE);
			T_Password.T_Ctrle.udiGetOperatorPassword:=123456;
			T_Password.T_Ctrle.sGetOperatorPassword:='123456';
			iStepFunction:=iStepFunction + 1;
		(* file name and activ read or write *)
		2:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) AND NOT(T_HDD.T_Ctrle.xLocked) THEN
				sTmp:=CONCAT(cssRootPLC,'Bore800\Password\OperatorPassword.txt');
			(* activ read *)
				T_HDD.T_Ctrle.iFunction:=1;
				T_HDD.T_Ctrle.xLocked:=TRUE;
				T_HDD.T_File.sPathAndFileName:=sTmp;
				T_HDD.T_Ctrle.xExecute:=TRUE;
				(* next step *)
				iStepFunction:=iStepFunction + 1;
			ELSE
				(* activ error if time out done, HDD not ready *)
				IF TimerFileLocked.Q THEN
					 iStepFunction:=90;
				END_IF
			END_IF;
		(* waiting flag *)
		3:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN iStepFunction:=iStepFunction + 1; END_IF
			IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; iStepFunction:=5; END_IF
		(* check syntax *)
		4:	IF (FIND(STR1:=T_HDD.T_Data.sData[1],STR2:=';') > 0) THEN
				sTmp:=T_HDD.T_Data.sData[1];
				sTmp:=sFctDeleteChar(sString:=sTmp, sChar:='$N');
				sTmp:=sFctDeleteChar(sString:=sTmp, sChar:='$L');
				sTmp:=sFctDeleteChar(sString:=sTmp, sChar:=';');
				IF xFctCheckNumber(sValue:=sTmp,xAlowDoubleSign:=FALSE) THEN
				(* Syntax correct *)
					T_Password.T_Ctrle.sGetOperatorPassword:=sTmp;
					T_Password.T_Ctrle.udiGetOperatorPassword:=STRING_TO_UDINT(T_Password.T_Ctrle.sGetOperatorPassword);
					iStepFunction:=90;
				ELSE
					(* Wrong Syntax *)
					iStepFunction:=10;	(* Create new File *)
				END_IF;
			ELSE
				(* Wrong Syntax *)
				iStepFunction:=10;	(* Create new File *)
			END_IF;
		5:	IF NOT(T_HDD.T_Ctrle.xReset) AND T_HDD.T_Ctrle.xDone THEN
				iStepFunction:=iStepFunction + 1;
			END_IF
		(* Create FirstLevel directory *)
		6:	sTmp:=CONCAT(cssRootPLC,'Bore800\');
			(* activ read *)
			T_HDD.T_Ctrle.iFunction:=7;
			T_HDD.T_File.sDirectoryPath:=sTmp;
			T_HDD.T_Ctrle.xExecute:=TRUE;
			(* next step *)
			iStepFunction:=iStepFunction + 1;
		(* waiting flag *)
		7:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN iStepFunction:=iStepFunction + 1; END_IF
			IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; iStepFunction:=iStepFunction + 1; END_IF
		(* Create SecondLevel directory *)
		8:	IF NOT(T_HDD.T_Ctrle.xReset) AND T_HDD.T_Ctrle.xDone THEN
				sTmp:=CONCAT(cssRootPLC,'Bore800\Password\');
				(* activ read *)
				T_HDD.T_Ctrle.iFunction:=7;
				T_HDD.T_File.sDirectoryPath:=sTmp;
				T_HDD.T_Ctrle.xExecute:=TRUE;
				(* next step *)
				iStepFunction:=iStepFunction + 1;
			END_IF;
		(* waiting flag *)
		9:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN iStepFunction:=iStepFunction + 1; END_IF
			IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; iStepFunction:=iStepFunction + 1; END_IF
		(* Create Password File *)
		10:	IF NOT(T_HDD.T_Ctrle.xReset) AND T_HDD.T_Ctrle.xDone THEN
				T_HDD.T_Data.sData:=sDeleteData;
				T_HDD.T_Data.sData[1]:='123456;';	(* Set Default Password *)
				T_Password.T_Ctrle.udiGetOperatorPassword:=123456;
				T_Password.T_Ctrle.sGetOperatorPassword:='123456';
				sTmp:=CONCAT(cssRootPLC,'Bore800\Password\OperatorPassword.txt');
				T_HDD.T_File.sPathAndFileName:=sTmp;
				T_HDD.T_Ctrle.iFunction:=2;
				T_HDD.T_Ctrle.xExecute:=TRUE;
				(* next step *)
				iStepFunction:=iStepFunction + 1;
			END_IF;
		(* waiting flag *)
		11:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN iStepFunction:=90; END_IF
			IF T_HDD.T_Ctrle.xErr THEN iStepFunction:=80; END_IF
		(* reset error *)
		80:	T_HDD.T_Ctrle.xReset:=TRUE;
			iStepFunction:=91;
		(* done *)
		90:	T_Password.T_Ctrle.xDone:=TRUE;
			T_Password.T_Ctrle.xErr:=FALSE;
			T_Password.T_Ctrle.udiErrorID:=16#0;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xReadPassword:=FALSE;
		(* start read error *)
		91:	T_Password.T_Ctrle.xDone:=FALSE;
			T_Password.T_Ctrle.xErr:=TRUE;
			T_Password.T_Ctrle.udiErrorID:=16#F1000 + T_Password.T_Ctrle.iFunction;
			T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xReadPassword:=FALSE;
		(* error *)
		99:	T_Password.T_Ctrle.xDone:=FALSE;
			T_Password.T_Ctrle.xErr:=TRUE;
			T_Password.T_Ctrle.udiErrorID:=16#F1000 + T_Password.T_Ctrle.iFunction;
			T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xReadPassword:=FALSE;
		END_CASE;
	END_IF;

(* read Operator Password *)
	IF xWritePassword THEN
		CASE iStepFunction OF
		(* start timeout *)
		1:	TimerFileLocked(IN:=FALSE);
			T_Password.T_Ctrle.udiGetOperatorPassword:=T_Password.T_Ctrle.udiSetOperatorPassword;
			T_Password.T_Ctrle.sGetOperatorPassword:=UDINT_TO_STRING(T_Password.T_Ctrle.udiGetOperatorPassword);
			iStepFunction:=iStepFunction + 1;
		(* Create Password File *)
		2:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) AND NOT(T_HDD.T_Ctrle.xLocked) THEN
				T_HDD.T_Data.sData:=sDeleteData;
				T_HDD.T_Data.sData[1]:=CONCAT(T_Password.T_Ctrle.sGetOperatorPassword,';');	(* Set Password to file *)
				sTmp:=CONCAT(cssRootPLC,'Bore800\Password\OperatorPassword.txt');
				T_HDD.T_File.sPathAndFileName:=sTmp;
				T_HDD.T_Ctrle.iFunction:=2;
				T_HDD.T_Ctrle.xExecute:=TRUE;
				(* next step *)
				iStepFunction:=iStepFunction + 1;
			ELSE
				(* activ error if time out done, HDD not ready *)
				IF TimerFileLocked.Q THEN
					 iStepFunction:=90;
				END_IF
			END_IF;
		(* waiting flag *)
		3:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN iStepFunction:=90; END_IF
			IF T_HDD.T_Ctrle.xErr THEN iStepFunction:=iStepFunction + 1; (* evtl. besteht das Verzeichnis nicht *) END_IF
		(* Create FirstLevel directory *)
		4:	sTmp:=CONCAT(cssRootPLC,'Bore800\');
			(* activ read *)
			T_HDD.T_Ctrle.iFunction:=7;
			T_HDD.T_File.sDirectoryPath:=sTmp;
			T_HDD.T_Ctrle.xExecute:=TRUE;
			(* next step *)
			iStepFunction:=iStepFunction + 1;
		(* waiting flag *)
		5:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN iStepFunction:=iStepFunction + 1; END_IF
			IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; iStepFunction:=iStepFunction + 1; (* Vielleicht besteht schon dieses Verzeichnis *) END_IF
		(* Create SecondLevel directory *)
		6:	IF NOT(T_HDD.T_Ctrle.xReset) AND T_HDD.T_Ctrle.xDone THEN
				sTmp:=CONCAT(cssRootPLC,'Bore800\Password\');
				(* activ read *)
				T_HDD.T_Ctrle.iFunction:=7;
				T_HDD.T_File.sDirectoryPath:=sTmp;
				T_HDD.T_Ctrle.xExecute:=TRUE;
				(* next step *)
				iStepFunction:=iStepFunction + 1;
			END_IF;
		(* waiting flag *)
		7:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN iStepFunction:=iStepFunction + 1; END_IF
			IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; iStepFunction:=99; (* generelles Problem mit dem schreiben auf die Flash Karte *) END_IF
		(* Create again Password File *)
		8:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) AND NOT(T_HDD.T_Ctrle.xLocked) THEN
				T_HDD.T_Data.sData:=sDeleteData;
				T_HDD.T_Data.sData[1]:=CONCAT(T_Password.T_Ctrle.sGetOperatorPassword,';');	(* Set Password to file *)
				sTmp:=CONCAT(cssRootPLC,'Bore800\Password\OperatorPassword.txt');
				T_HDD.T_File.sPathAndFileName:=sTmp;
				T_HDD.T_Ctrle.iFunction:=2;
				T_HDD.T_Ctrle.xExecute:=TRUE;
				(* next step *)
				iStepFunction:=iStepFunction + 1;
			ELSE
				(* activ error if time out done, HDD not ready *)
				IF TimerFileLocked.Q THEN
					 iStepFunction:=90;
				END_IF
			END_IF;
		(* waiting flag *)
		9:	IF T_HDD.T_Ctrle.xDone AND NOT(T_HDD.T_Ctrle.xErr) THEN iStepFunction:=90; END_IF
			IF T_HDD.T_Ctrle.xErr THEN iStepFunction:=iStepFunction + 1; (* abbrechen, da schon wieder nicht geschrieben werden konnte *) END_IF
		(* reset error *)
		80:	T_HDD.T_Ctrle.xReset:=TRUE;
			iStepFunction:=91;
		(* done *)
		90:	T_Password.T_Ctrle.xDone:=TRUE;
			T_Password.T_Ctrle.xErr:=FALSE;
			T_Password.T_Ctrle.udiErrorID:=16#0;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xWritePassword:=FALSE;
		(* start read error *)
		91:	T_Password.T_Ctrle.xDone:=FALSE;
			T_Password.T_Ctrle.xErr:=TRUE;
			T_Password.T_Ctrle.udiErrorID:=16#F1000 + T_Password.T_Ctrle.iFunction;
			T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xWritePassword:=FALSE;
		(* error *)
		99:	T_Password.T_Ctrle.xDone:=FALSE;
			T_Password.T_Ctrle.xErr:=TRUE;
			T_Password.T_Ctrle.udiErrorID:=16#F1000 + T_Password.T_Ctrle.iFunction;
			T_HDD.T_Ctrle.xReset:=T_HDD.T_Ctrle.xErr;
			T_HDD.T_Ctrle.xExecute:=FALSE;
			T_HDD.T_Ctrle.xLocked:=FALSE;
			xWritePassword:=FALSE;
		END_CASE;
	END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_Password_SystemLevel
VAR_INPUT
	dwCounterHI:DWORD;
	dwCounterLOW:DWORD;
END_VAR
VAR_OUTPUT
	diRandom:DINT;
	diPwSystem:DINT;
END_VAR
VAR
	ii:INT;
	diCounter:DINT;
	sTmp:STRING;
	sValueHighAndLow: STRING;
	iMissingPlace: INT;
END_VAR
(* @END_DECLARATION := '0' *)
(*
	dynamic System password
	ex : Counter=123456789 => pw=825
	formul : 1+2+3+4+5+6+7+8+9+ 80 + 700 = 825
*)

(* Init. value *)
	diPwSystem:=0;
(* Convert value *)
	(* Counter auf 9 Stellig definieren *)
	IF (dwCounterHI <> 0) AND (dwCounterLOW <> 0) THEN
		sValueHighAndLow:=CONCAT(DWORD_TO_STRING(dwCounterHI),DWORD_TO_STRING(dwCounterLOW));
	ELSIF (dwCounterHI = 0) AND (dwCounterLOW <> 0) THEN
		sValueHighAndLow:=DWORD_TO_STRING(dwCounterLOW);
	ELSIF (dwCounterHI <> 0) AND (dwCounterLOW = 0) THEN
		sValueHighAndLow:=DWORD_TO_STRING(dwCounterHI);
	ELSE
		sValueHighAndLow:='';
	END_IF;
	IF (LEN(sValueHighAndLow) >= 9) THEN
		diCounter:=STRING_TO_DINT(MID(sValueHighAndLow,9,LEN(sValueHighAndLow)-8));
	ELSE
		(* Fehlende Zeichen noch aufüllen bis 9 Zeichen *)
		iMissingPlace:=LEN(sValueHighAndLow);
		FOR ii:=1 TO 9 - iMissingPlace DO
			sValueHighAndLow:=CONCAT(INT_TO_STRING(ii),sValueHighAndLow);
		END_FOR;
		diCounter:=STRING_TO_DINT(sValueHighAndLow);
	END_IF;

(* Set Random value *)
	diRandom:=diCounter;
	sTmp:=DINT_TO_STRING(diCounter);
(* Set System pw *)
	FOR ii:=0 TO LEN(sTmp)-1 DO
		diPwSystem:=diPwSystem+STRING_TO_DINT(MID(sTmp,1,LEN(sTmp)-ii));
		IF ii=1 THEN diPwSystem:=diPwSystem+STRING_TO_DINT(MID(sTmp,1,LEN(sTmp)-ii))*10; END_IF
		IF ii=2 THEN diPwSystem:=diPwSystem+STRING_TO_DINT(MID(sTmp,1,LEN(sTmp)-ii))*100; END_IF
	END_FOR
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_PID_CONTROL
VAR_INPUT
	rSetpointValue    : REAL;
    rActualValue      : REAL;
END_VAR
VAR_IN_OUT
	T_CtrlPara:ST_CTRL_PID_PARAM;
END_VAR
VAR_OUTPUT
	rOut:REAL;
	xMaxOutputReach:BOOL;
	xMinOutputReach:BOOL;
END_VAR
VAR
	r_E_Fehler:REAL;
	r_E_Fehler_Sum:REAL;
	r_E_Fehler_Alt:REAL;
	r_Zykluszeit:REAL;
	r_P_Anteil:REAL;
	r_I_Anteil:REAL;
	r_D_Anteil:REAL;
	TONWaitMinTime: TON;
END_VAR

(* @END_DECLARATION := '0' *)
r_E_Fehler:=rSetpointValue - rActualValue;	(* Regelabweichung *)
IF NOT(xMaxOutputReach) AND NOT(xMinOutputReach) THEN
	r_E_Fehler_Sum:=r_E_Fehler_Sum + r_E_Fehler;
END_IF
r_Zykluszeit:=T_CtrlPara.rCtrlCycleTime;
IF (r_Zykluszeit = 0.0) THEN
	r_Zykluszeit:=0.001;
END_IF
r_P_Anteil:=T_CtrlPara.rKp * r_E_Fehler;
r_I_Anteil:=T_CtrlPara.rKi * r_Zykluszeit * r_E_Fehler_Sum;
r_D_Anteil:=(T_CtrlPara.rKd/r_Zykluszeit) * (r_E_Fehler - r_E_Fehler_Alt);
rOut:=r_P_Anteil + r_I_Anteil + r_D_Anteil;
r_E_Fehler_Alt:=r_E_Fehler;
IF (rOut >= T_CtrlPara.rOutMaxLimit) THEN
	rOut:=T_CtrlPara.rOutMaxLimit;
	xMaxOutputReach:=TRUE;
ELSE
	xMaxOutputReach:=FALSE;
END_IF
IF (rOut <= T_CtrlPara.rOutMinLimit) THEN
	rOut:=T_CtrlPara.rOutMinLimit;
	TONWaitMinTime(IN:=TRUE,PT:=T#100MS);
	IF TONWaitMinTime.Q THEN
		xMinOutputReach:=TRUE;	(* Das Minimum muss mindestens 100ms anstehen, damit dieser Ausgang gesetzt wird. Dies veranlasst dann ein HC, da die minimale Geschwindigkeit erreicht ist *)
	END_IF;
ELSE
	TONWaitMinTime(IN:=FALSE);
	xMinOutputReach:=FALSE;
END_IF
IF T_CtrlPara.xReset_I_Anteil THEN
	T_CtrlPara.xReset_I_Anteil:=FALSE;
	r_E_Fehler_Sum:=0.0;
END_IF

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_SAFETYLOGIC
VAR_INPUT
	T_TwinSafeIn:ST_TWINSAFE_IN;
	T_TwinSafeOut:ST_TWINSAFE_OUT;
	xActiveBooting:BOOL;
	xVisuFunctionActive:BOOL;
	dwActualPage:DWORD;			(* activate page on the visualisation *)
	xOverlayMessageAcitve:BOOL;
	iStateMessage:INT;
	TCommonAxis : ST_AXIS;
END_VAR
VAR_IN_OUT
	xActiveBootingError:BOOL;
END_VAR
VAR_OUTPUT
	bStateSafetyCtrl:BYTE;
	xSafetyNotActive: BOOL;
END_VAR
VAR
	FBCheckSetupMode: FB_CHECKSETUPMODE;
	xNoEmergency: BOOL;
	xGeneralState: BOOL;
	xMachineDoorUpClose: BOOL;
	xMachineDoorClose: BOOL;
	xCheckStateEnableSwitch: BOOL;
	TONWaitCheck: TON;
	xGeneralEnergyON: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
FBCheckSetupMode(T_TwinSafeIn:=T_TwinSafeIn);

gT_SafetyStatus.iSetupMode:=					FBCheckSetupMode.iSetupMode;

gT_SafetyStatus.xSetupOperateModeActive:=		(T_TwinSafeIn.IxKeySwitchProcObservationCh1 AND T_TwinSafeIn.IxKeySwitchProcObservationCh2) OR (T_TwinSafeIn.IxKeySwitchWorkStationCh1 AND T_TwinSafeIn.IxKeySwitchWorkStationCh2);

xNoEmergency:=			T_TwinSafeIn.IxEmergencyStopButtonCh1 AND T_TwinSafeIn.IxEmergencyStopButtonCh2;

xMachineDoorUpClose:=	(T_TwinSafeIn.IxCabinDoorCloseCh1 AND T_TwinSafeIn.IxCabinDoorCloseCh2 AND T_TwinSafeIn.IxCabinDoorClose AND
						NOT(T_TwinSafeIn.IxCabinDoorOpen));

xMachineDoorClose:=					xMachineDoorUpClose;

gT_SafetyStatus.xSecurityDoorOpen:=	NOT(xMachineDoorClose);

gT_SafetyStatus.xSecurityDoorClose:=	xMachineDoorClose;

gT_SafetyStatus.xSecuritySwitch:=		T_TwinSafeIn.IxAxesCurrentOffCh1 AND T_TwinSafeIn.IxAxesCurrentOffCh2;


xGeneralEnergyON:=	T_TwinSafeOut.QxContactorMasterModul400VCh1 AND T_TwinSafeOut.QxContactorMasterModul400VCh2 AND
						T_TwinSafeOut.QxContactor24VCh1 AND T_TwinSafeOut.QxContactor24VCh2;

gT_SafetyStatus.xMachineDoorClose:=				xMachineDoorUpClose;

gT_SafetyStatus.xMachineEmergStopActive:=			NOT(xNoEmergency);

gT_SafetyStatus.xEnergyONNormalMode:=			xGeneralEnergyON AND
													T_TwinSafeOut.QxEnablingAxisSpindle_St1 AND
													IxTwinSafeQuickStopMaster1_1;

gT_SafetyStatus.xEnergyONSetupModeASt1:=		xGeneralEnergyON AND
													T_TwinSafeOut.QxEnablingAxisSpindle_St1 AND
													IxTwinSafeQuickStopMaster1_1;

gT_SafetyStatus.xEnergyONSetupModeBSt1:=		xGeneralEnergyON AND
													T_TwinSafeOut.QxEnablingAxisSpindle_St1 AND
													IxTwinSafeQuickStopMaster1_1;

xGeneralState:=	T_TwinSafeIn.IxReadyToOperateMasterModul1 AND T_TwinSafeIn.IxReadyToOperateMasterModul2;

IF NOT(gT_SafetyStatus.xSetupOperateModeActive) THEN
	xSafetyNotActive:=		xNoEmergency AND xMachineDoorUpClose AND
							NOT(T_TwinSafe_Status_Z_Axis_St1.xError) AND NOT(T_TwinSafe_Status_S2_Axis_St1.xError) AND NOT(T_TwinSafe_Status_S3_Axis_St1.xError) AND xGeneralState AND gT_SafetyStatus.xSecuritySwitch;
ELSE
	IF (gT_SafetyStatus.iSetupMode = 1)THEN
		xSafetyNotActive:=	xNoEmergency AND xGeneralState AND gT_SafetyStatus.xSecuritySwitch AND
							NOT(T_TwinSafe_Status_Z_Axis_St1.xError) AND NOT(T_TwinSafe_Status_S2_Axis_St1.xError) AND NOT(T_TwinSafe_Status_S3_Axis_St1.xError);
	ELSIF (gT_SafetyStatus.iSetupMode = 2)THEN
		xSafetyNotActive:=	xNoEmergency AND xGeneralState AND gT_SafetyStatus.xSecuritySwitch AND
							NOT(T_TwinSafe_Status_Z_Axis_St1.xError) AND NOT(T_TwinSafe_Status_S2_Axis_St1.xError) AND NOT(T_TwinSafe_Status_S3_Axis_St1.xError);
	END_IF;
END_IF;

xCheckStateEnableSwitch:=FALSE;
bStateSafetyCtrl:=99;	(* 99=Sicherheitsmeldungen unterdrücken *)
IF (dwActualPage = gT_PageNumber.iStart_Page1) OR (dwActualPage = gT_PageNumber.iBIOS_Page1) OR (dwActualPage = gT_PageNumber.iBIOS_Page2) THEN
	(* Sicherheitsmeldungen für wenn Maschine noch nicht aufgestartet ist *)
	IF NOT(xNoEmergency) THEN
		bStateSafetyCtrl:=19;	(* < Not Aus Taster Maschine deaktivieren > *)
	ELSIF NOT(gT_SafetyStatus.xSecuritySwitch) THEN
		bStateSafetyCtrl:=17;	(* < AntriebSperrTaste deaktivieren > *)
	ELSIF NOT(xOverlayMessageAcitve) AND xActiveBootingError AND (iStateMessage <> 401) THEN
		xActiveBootingError:=FALSE;
	ELSIF xOverlayMessageAcitve OR xActiveBootingError OR (iStateMessage = 401) THEN
		bStateSafetyCtrl:=99;	(* Keine Meldung Anzeigen-->Auserhalb des FB muss die Sicherheitsmeldung auf der Visualisierung unterdrückt werden *)
	ELSIF NOT(T_TwinSafeIn.IxReadyToOperateMasterModul1) THEN
		bStateSafetyCtrl:=12;	(* < Servo MasterModul 1 steht nicht bereit > *)
	ELSIF NOT(T_TwinSafeIn.IxReadyToOperateMasterModul2) THEN
		bStateSafetyCtrl:=13;	(* < Servo MasterModul 2 steht nicht bereit > *)
	ELSIF NOT(xMachineDoorUpClose) THEN
		bStateSafetyCtrl:=5;	(* < MaschinenTüre schliessen > *)
	ELSIF gT_SafetyStatus.xSetupOperateModeActive THEN
		bStateSafetyCtrl:=18; 	(* < Schlüsselschalter deaktivieren > *)
	ELSIF NOT(gT_SafetyStatus.xEnergyONNormalMode) AND QxCtrlLampReleaseButton THEN
		bStateSafetyCtrl:=2;	(* < FreigabeTaste drücken > *)
	ELSIF gT_SafetyStatus.xEnergyONNormalMode AND NOT(xActiveBooting) THEN
		bStateSafetyCtrl:=3;	(* < StartTaste drücken > *)
	ELSIF gT_SafetyStatus.xEnergyONNormalMode AND xActiveBooting THEN
		bStateSafetyCtrl:=1;	(* < Maschine ist am aufstarten... > *)
	END_IF;
ELSE
	(* Sicherheitsmeldungen für wenn Maschine aufgestartet ist *)
	IF xOverlayMessageAcitve OR (iStateMessage = 401) THEN
		bStateSafetyCtrl:=99;	(* Keine Meldung Anzeigen-->Auserhalb des FB muss die Sicherheitsmeldung auf der Visualisierung unterdrückt werden *)
	ELSIF NOT(T_TwinSafeIn.IxReadyToOperateMasterModul1) THEN
		bStateSafetyCtrl:=12;	(* < Servo MasterModul 1 steht nicht bereit > *)
	ELSIF NOT(T_TwinSafeIn.IxReadyToOperateMasterModul2) THEN
		bStateSafetyCtrl:=13;	(* < Servo MasterModul 2 steht nicht bereit > *)
	ELSE
		IF NOT(gT_SafetyStatus.xSetupOperateModeActive) THEN
			(* NormalBetrieb *)
			IF NOT(xMachineDoorUpClose) THEN
				bStateSafetyCtrl:=5;	(* < MaschinenTüre schliessen > *)
			ELSIF NOT(gT_SafetyStatus.xSecuritySwitch) THEN
				bStateSafetyCtrl:=17;	(* < AntriebSperrTaste deaktivieren > *)
			ELSIF NOT(gT_SafetyStatus.xEnergyONNormalMode) AND QxCtrlLampReleaseButton THEN
				bStateSafetyCtrl:=2;	(* < FreigabeTaste drücken > *)
			ELSIF gT_SafetyStatus.xEnergyONNormalMode AND ((dwActualPage = gT_PageNumber.iAutoMode_Process)
			OR (dwActualPage = gT_PageNumber.iAutoMode_ProcessValue1) OR (dwActualPage = gT_PageNumber.iAutoMode_ProcessValue2)		(* IGS *)
			OR (dwActualPage = gT_PageNumber.iAutoMode_PartQuality)) AND TProcess.T_Ctrle.xDone THEN
				IF NOT(gxOnlyCentringActive) AND NOT(gxCentringActive) THEN
					bStateSafetyCtrl:=3;	(* < StartTaste drücken > *)
				ELSIF gxOnlyCentringActive THEN
					bStateSafetyCtrl:=35;	(* < StartTaste drücken (nur Zentrierung Aktiv) > *)
				ELSE
					bStateSafetyCtrl:=36;	(* < StartTaste drücken (Zentrierung + Bearb. Aktiv) > *)
				END_IF;
			ELSIF gT_SafetyStatus.xEnergyONNormalMode AND (dwActualPage = gT_PageNumber.iAutoMode_Referencing) AND TProcess.T_Ctrle.xDone THEN
				bStateSafetyCtrl:=3;	(* < StartTaste drücken > *)
			ELSIF gT_SafetyStatus.xEnergyONNormalMode AND NOT(TProcess.T_Ctrle.xDone) AND (TProcess.T_Ctrle.iFunctNr = 1) THEN
				bStateSafetyCtrl:=26;	(* < Masch.Ref/Grundstellung in Ausführung > *)
			ELSIF gT_SafetyStatus.xEnergyONNormalMode AND NOT(TProcess.T_Ctrle.xDone) AND (TProcess.T_Ctrle.iFunctNr = 2) THEN
				IF NOT(gxOnlyCentringActive) AND NOT(gxCentringActive) THEN
					bStateSafetyCtrl:=25;	(* < Automat in Ausführung > *)
				ELSIF gxOnlyCentringActive THEN
					bStateSafetyCtrl:=37;	(* < Automat in Ausführung (nur Zentrierung Aktiv) > *)
				ELSE
					bStateSafetyCtrl:=38;	(* < Automat in Ausführung (Zentrierung + Bearb. Aktiv) > *)
				END_IF;
			END_IF;
		ELSE
			(* EinrichtBetrieb *)
			IF NOT(gT_SafetyStatus.xSecuritySwitch) THEN
				bStateSafetyCtrl:=17;	(* < AntriebSperrTaste deaktivieren > *)
			ELSIF (gT_SafetyStatus.iSetupMode = 1) AND
			  NOT(gT_SafetyStatus.xEnergyONSetupModeASt1) THEN
				IF gT_SafetyStatus.xSecurityDoorClose THEN
					bStateSafetyCtrl:=2;	(* < FreigabeTaste drücken > *)
				ELSE
					IF T_TwinSafeIn.IxEnablingSwitchActiveCh1 OR T_TwinSafeIn.IxEnablingSwitchActiveCh2 THEN
						xCheckStateEnableSwitch:=TRUE;
					ELSE
						bStateSafetyCtrl:=4;	(* < Zustimmschalter drücken > *)
					END_IF;
				END_IF;
			ELSIF (gT_SafetyStatus.iSetupMode = 2) AND
			  NOT(gT_SafetyStatus.xEnergyONSetupModeBSt1) THEN
				IF gT_SafetyStatus.xSecurityDoorClose THEN
					bStateSafetyCtrl:=2;	(* < FreigabeTaste drücken > *)
				ELSE
					IF T_TwinSafeIn.IxEnablingSwitchActiveCh1 OR T_TwinSafeIn.IxEnablingSwitchActiveCh2 THEN
						xCheckStateEnableSwitch:=TRUE;
					ELSE
						bStateSafetyCtrl:=4;	(* < Zustimmschalter drücken > *)
					END_IF;
				END_IF;
			ELSE
				CASE dwActualPage OF
				gT_PageNumber.iHandMode_Process,gT_PageNumber.iHandMode_WorkParameter,gT_PageNumber.iHandMode_RegulatorPara,gT_PageNumber.iHandMode_OnlineChange,gT_PageNumber.iHandMode_ConfigPosition:
					IF TProcess.T_Ctrle.xDone THEN
						IF NOT(gxOnlyCentringActive) AND NOT(gxCentringActive) THEN
							bStateSafetyCtrl:=3;	(* < StartTaste drücken > *)
						ELSIF gxOnlyCentringActive THEN
							bStateSafetyCtrl:=35;	(* < StartTaste drücken (nur Zentrierung Aktiv) > *)
						ELSE
							bStateSafetyCtrl:=36;	(* < StartTaste drücken (Zentrierung + Bearb. Aktiv) > *)
						END_IF;
					ELSIF NOT(TProcess.T_Ctrle.xDone) AND (TProcess.T_Ctrle.iFunctNr = 3) THEN
						IF NOT(gxOnlyCentringActive) AND NOT(gxCentringActive) THEN
							bStateSafetyCtrl:=28;	(* < HandBetrieb in Ausführung > *)
						ELSIF gxOnlyCentringActive THEN
							bStateSafetyCtrl:=39;	(* < HandBetrieb in Ausführung (nur Zentrierung Aktiv) > *)
						ELSE
							bStateSafetyCtrl:=40;	(* < HandBetrieb in Ausführung (Zentrierung + Bearb. Aktiv) > *)
						END_IF;
					END_IF;
				gT_PageNumber.iHandMode_ProfileMngmt1,gT_PageNumber.iHandMode_ErrorList,gT_PageNumber.iHandMode_Setup1:
					IF NOT(TProcess.T_Ctrle.xDone) AND (TProcess.T_Ctrle.iFunctNr = 3) THEN
						IF NOT(gxOnlyCentringActive) AND NOT(gxCentringActive) THEN
							bStateSafetyCtrl:=28;	(* < HandBetrieb in Ausführung > *)
						ELSIF gxOnlyCentringActive THEN
							bStateSafetyCtrl:=39;	(* < HandBetrieb in Ausführung (nur Zentrierung Aktiv) > *)
						ELSE
							bStateSafetyCtrl:=40;	(* < HandBetrieb in Ausführung (Zentrierung + Bearb. Aktiv) > *)
						END_IF;
					END_IF;
				gT_PageNumber.iWorkStation_Axis1:
					IF TCommonAxis.T_CtrleSingle.xNotMoving THEN
						IF (TCommonAxis.T_Config_Gen.iTyp = 2) OR (TCommonAxis.T_Config_Gen.iTyp = 2) THEN
							IF TCommonAxis.T_CtrleSingle.xPower THEN
								bStateSafetyCtrl:=8;	(* < Für Drehbewegung StartTaste drücken > *)
							ELSE
								bStateSafetyCtrl:=33;	(* < Drehmoment der Achse einschalten > *)
							END_IF;
						ELSE
							IF TCommonAxis.T_CtrleSingle.xRef AND TCommonAxis.T_CtrleSingle.xPower THEN
								bStateSafetyCtrl:=7;	(* < Für Positionsfahrt StartTaste drücken > *)
							ELSIF NOT(TCommonAxis.T_CtrleSingle.xPower) THEN
								bStateSafetyCtrl:=33;	(* < Drehmoment der Achse einschalten > *)
							ELSIF NOT(TCommonAxis.T_CtrleSingle.xRef) THEN
								bStateSafetyCtrl:=34;	(* < Achse Referenzieren für Positionsfahrt > *)
							END_IF;
						END_IF;
					ELSE
						IF (TCommonAxis.T_Config_Gen.iTyp = 2) OR (TCommonAxis.T_Config_Gen.iTyp = 2) THEN
							bStateSafetyCtrl:=9;	(* < Funktion in Ausführung > *)
						ELSE
							bStateSafetyCtrl:=10;	(* < Funktion in Ausführung...MMI ist blockiert > *)
						END_IF;
					END_IF;
				gT_PageNumber.iWorkStation_Cylinder1:
					bStateSafetyCtrl:=22;	(* < Zylinderbewegung EIN/AUS drücken > *)
				gT_PageNumber.iWorkStation_Valve1:
					IF (T_ExchgParam.T_Cylinder.iSelCyl_Setup = 5) THEN
						bStateSafetyCtrl:=20;	(* < Zylinderbewegung mit Joystick bewegen > *)
					ELSE
						bStateSafetyCtrl:=21;	(* < Ventile mit Joystick bewegen > *)
					END_IF;
				gT_PageNumber.iWorkStation_Function1,gT_PageNumber.iWorkStation_Setup1,gT_PageNumber.iWorkStation_Setup2:
					IF xVisuFunctionActive THEN
						bStateSafetyCtrl:=10;	(* < Funktion in Ausführung...MMI ist blockiert > *)
					ELSE
						bStateSafetyCtrl:=3;	(* < StartTaste drücken > *)
					END_IF;
				gT_PageNumber.iWorkStation_Setup3:
					IF xVisuFunctionActive THEN
						bStateSafetyCtrl:=10;	(* < Funktion in Ausführung...MMI ist blockiert > *)
					ELSE
						bStateSafetyCtrl:=3;	(* < StartTaste drücken > *)
					END_IF;
				END_CASE;
			END_IF;
			IF xCheckStateEnableSwitch THEN
				IF (bStateSafetyCtrl = 99) THEN
					TONWaitCheck(IN:=TRUE,PT:=T#100ms);
					IF TONWaitCheck.Q THEN
						bStateSafetyCtrl:=6;	(* < Zustimmtaster lösen > *)
					END_IF;
				END_IF;
			ELSE
				TONWaitCheck(IN:=FALSE);
			END_IF;

		END_IF;
	END_IF;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_SparkOutProcess
VAR_INPUT
	lrHubLength: LREAL;
	iCountHub: INT;
	T_Station_Parameter: ST_RETAIN_DATA_STATIONWORK;
	xToolDeflection : BOOL;
	xToolTorqueHC : BOOL;
	xToolTorqueSparkOut : BOOL;
END_VAR
VAR_IN_OUT
	xStart: BOOL;
	xReset: BOOL;
	TCylToolDeflection : ST_CYLINDER;
	TAxisZ : ST_AXIS;
END_VAR
VAR_OUTPUT
	xEnd: BOOL;
	xBlockProcess: BOOL;
	xRepeatProcess: BOOL;
	wStatus: WORD;
	rLastOverLimitPosition: REAL;
	xBlockOutput:BOOL;
	xBlockDeflectionOutput:BOOL;
END_VAR
VAR
	xTmpStart: BOOL;
	xInit: BOOL;
	iStepCounter: INT;
	xInitStep: BOOL;
	lrSaveSlidePosition: LREAL;
	iTmpCountHub: INT;
	xSetForceDeflection: BOOL;
	xInitSetForceDeflection: BOOL;
	xActiveChgForceDeflection: BOOL;
	xBlockCounter: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
IF xReset THEN
	xReset:=FALSE;
	xEnd:=TRUE;
	xStart:=FALSE;
	xTmpStart:=FALSE;
	xInit:=FALSE;
	xBlockProcess:=FALSE;
	xRepeatProcess:=FALSE;
	xInitStep:=FALSE;
	iTmpCountHub:=0;
	xBlockOutput:=FALSE;
	RETURN;
END_IF;
IF xStart OR xTmpStart THEN
	IF NOT(xInit) THEN
		iStepCounter:=1;
		iTmpCountHub:=0;
		xInit:=TRUE;
		xStart:=FALSE;
		xTmpStart:=TRUE;
		lrSaveSlidePosition:=TAxisZ.T_LiveValue.lrActualPosition;
		xBlockProcess:=xRepeatProcess:=FALSE;
	END_IF;
	CASE iStepCounter OF
		1:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				xBlockProcess:=TRUE;
				xBlockCounter:=FALSE;
				IF (iCountHub > 0) AND (lrHubLength <> 0) THEN
					IF (T_Station_Parameter.T_StProcess.rSparkOutForceDeflection <> 0.0) THEN xActiveChgForceDeflection:=TRUE; ELSE xActiveChgForceDeflection:=FALSE; END_IF;
					IF NOT(xActiveChgForceDeflection) THEN
						xInitStep:=FALSE;
						iStepCounter:=iStepCounter + 1;
						RETURN;
					END_IF;
					IF xActiveChgForceDeflection THEN
						xBlockDeflectionOutput:=TRUE;
						xSetForceDeflection:=TRUE;
						TCylToolDeflection.T_CtrleCyl.T_Analog.rForceIn:=(T_Station_Parameter.T_OnlineChange.rForceDeflection/100.0) * T_Station_Parameter.T_StProcess.rSparkOutForceDeflection;
					ELSE
						xSetForceDeflection:=FALSE;
					END_IF;
				ELSE
					xEnd:=TRUE;
					xInit:=FALSE;
					xInitStep:=FALSE;
					xTmpStart:=FALSE;
					xBlockProcess:=xRepeatProcess:=xBlockOutput:=xBlockDeflectionOutput:=FALSE;
					RETURN;
				END_IF;
			END_IF;
			IF NOT(xSetForceDeflection) THEN
				xInitStep:=FALSE;
				iStepCounter:=iStepCounter + 1;
			END_IF;
		2:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				(* Move Absolut backward or forward *)
				TAxisZ.T_CtrleSingle.iFunction:=7;
				TAxisZ.T_CtrleSingle.lrPosition:=TAxisZ.T_LiveValue.lrActualPosition + lrHubLength;
				TAxisZ.T_CtrleSingle.lrAcceleration:=TAxisZ.T_Config_ObjFileValue.lrAcceleration;
				TAxisZ.T_CtrleSingle.lrDecceleration:=TAxisZ.T_Config_ObjFileValue.lrDecceleration;
				TAxisZ.T_CtrleSingle.lrJerk:=TAxisZ.T_Config_ObjFileValue.lrJerk;
				TAxisZ.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rSparkOutStrokeSpeed;
				TAxisZ.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF TAxisZ.T_CtrleSingle.xMovingForward THEN
				IF xToolDeflection THEN
					wStatus:=1;	(* 1 = < Wz Auslenk. Sensor > *)
					xInitStep:=FALSE;
					iStepCounter:=iStepCounter + 2;
					RETURN;
				END_IF;
				IF xToolTorqueHC THEN
					wStatus:=2;	(* 2 = < Wz Drehmom. HC> *)
					xInitStep:=FALSE;
					iStepCounter:=iStepCounter + 2;
					RETURN;
				END_IF
				IF xToolDeflection AND xToolTorqueHC THEN
					wStatus:=3;	(* 3 = < Wz Auslenk.+Wz Drehm.HC > *)
					xInitStep:=FALSE;
					iStepCounter:=iStepCounter + 2;
					RETURN;
				END_IF;
				IF xToolTorqueSparkOut THEN
					xBlockCounter:=TRUE;
				END_IF;
			END_IF;
			IF NOT(TAxisZ.T_CtrleSingle.xExecute) AND TAxisZ.T_CtrleSingle.xDone THEN
				xInitStep:=FALSE;
				iStepCounter:=iStepCounter + 1;
			END_IF;
		3:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				(* Move Absolut forward or backward *)
				TAxisZ.T_CtrleSingle.iFunction:=7;
				TAxisZ.T_CtrleSingle.lrPosition:=lrSaveSlidePosition;
				TAxisZ.T_CtrleSingle.lrAcceleration:=TAxisZ.T_Config_ObjFileValue.lrAcceleration;
				TAxisZ.T_CtrleSingle.lrDecceleration:=TAxisZ.T_Config_ObjFileValue.lrDecceleration;
				TAxisZ.T_CtrleSingle.lrJerk:=TAxisZ.T_Config_ObjFileValue.lrJerk;
				TAxisZ.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rSparkOutStrokeSpeed;
				TAxisZ.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF TAxisZ.T_CtrleSingle.xMovingForward THEN
				IF xToolDeflection THEN
					wStatus:=1;	(* 1 = < Wz Auslenk. Sensor > *)
					xInitStep:=FALSE;
					iStepCounter:=iStepCounter + 1;
					RETURN;
				END_IF;
				IF xToolTorqueHC THEN
					wStatus:=2;	(* 2 = < Wz Drehmom. HC> *)
					xInitStep:=FALSE;
					iStepCounter:=iStepCounter + 1;
					RETURN;
				END_IF
				IF xToolDeflection AND xToolTorqueHC THEN
					wStatus:=3;	(* 3 = < Wz Auslenk.+Wz Drehm.HC > *)
					xInitStep:=FALSE;
					iStepCounter:=iStepCounter + 1;
					RETURN;
				END_IF;
				IF xToolTorqueSparkOut THEN
					xBlockCounter:=TRUE;
				END_IF;
			END_IF;
			IF NOT(TAxisZ.T_CtrleSingle.xExecute) AND TAxisZ.T_CtrleSingle.xDone THEN
				IF NOT(xBlockCounter) THEN
					iTmpCountHub:=iTmpCountHub + 1;
				END_IF;
				xBlockCounter:=FALSE;
				IF (iTmpCountHub >= iCountHub) THEN
					IF NOT(xActiveChgForceDeflection) THEN
						xEnd:=TRUE;
						xInit:=FALSE;
						xInitStep:=FALSE;
						xTmpStart:=FALSE;
						xBlockProcess:=xRepeatProcess:=xBlockOutput:=xBlockDeflectionOutput:=FALSE;
					ELSE
						xInitStep:=FALSE;
						iStepCounter:=5;
					END_IF;
				ELSE
					xInitStep:=FALSE;
					iStepCounter:=2;
				END_IF;
			END_IF;
		4:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF NOT(TAxisZ.T_CtrleSingle.xNotMoving) THEN
					rLastOverLimitPosition:=TAxisZ.T_LiveValue.lrActualPosition;
					TAxisZ.T_CtrleSingle.iFunction:=5;
					TAxisZ.T_CtrleSingle.xExecute:=TRUE;
					RETURN;
				END_IF
				IF NOT(TAxisZ.T_CtrleSingle.xDone) THEN
					xInitStep:=FALSE;
					RETURN;
				END_IF;
			END_IF;
			IF NOT(TAxisZ.T_CtrleSingle.xExecute) AND TAxisZ.T_CtrleSingle.xDone THEN
				IF NOT(xActiveChgForceDeflection) THEN
					xRepeatProcess:=TRUE;
					xEnd:=TRUE;
					xInit:=FALSE;
					xInitStep:=FALSE;
					xTmpStart:=FALSE;
					xBlockProcess:=FALSE;
					xBlockOutput:=FALSE;
					xBlockDeflectionOutput:=FALSE;
				ELSE
					xInitStep:=FALSE;
					iStepCounter:=6;
				END_IF;
			END_IF;
		5:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF xActiveChgForceDeflection THEN
					xSetForceDeflection:=TRUE;
					xBlockDeflectionOutput:=TRUE;
					TCylToolDeflection.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_OnlineChange.rForceDeflection;
				ELSE
					xSetForceDeflection:=FALSE;
				END_IF;
			END_IF;
			IF NOT(xSetForceDeflection) THEN
				xBlockOutput:=FALSE;
				xBlockDeflectionOutput:=FALSE;
				xEnd:=TRUE;
				xInit:=FALSE;
				xInitStep:=FALSE;
				xTmpStart:=FALSE;
				xBlockProcess:=xRepeatProcess:=FALSE;
			END_IF;
		6:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF xActiveChgForceDeflection THEN
					xSetForceDeflection:=TRUE;
					xBlockDeflectionOutput:=TRUE;
					TCylToolDeflection.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_OnlineChange.rForceDeflection;
				ELSE
					xSetForceDeflection:=FALSE;
				END_IF;
			END_IF;
			IF NOT(xSetForceDeflection) THEN
				xBlockOutput:=FALSE;
				xBlockDeflectionOutput:=FALSE;
				xRepeatProcess:=TRUE;
				xEnd:=TRUE;
				xInit:=FALSE;
				xInitStep:=FALSE;
				xTmpStart:=FALSE;
				xBlockProcess:=FALSE;
			END_IF;
	END_CASE;

	IF xSetForceDeflection THEN
		IF NOT(xInitSetForceDeflection) THEN
			IF NOT(TCylToolDeflection.T_CtrleCyl.xExecute) AND TCylToolDeflection.T_CtrleCyl.xDone THEN
				xInitSetForceDeflection:=TRUE;
				TCylToolDeflection.T_CtrleCyl.iFunction:=4;
				TCylToolDeflection.T_CtrleCyl.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF NOT(TCylToolDeflection.T_CtrleCyl.xExecute) AND TCylToolDeflection.T_CtrleCyl.xDone AND xInitSetForceDeflection THEN
			xInitSetForceDeflection:=FALSE;
			xSetForceDeflection:=FALSE;
		END_IF;
	END_IF;
ELSE
	xBlockOutput:=FALSE;
	xBlockDeflectionOutput:=FALSE;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_TorqueLevelAirPressureAnalog
VAR_INPUT
	xActiveWorkProcess:BOOL;
	xBlockOutput:BOOL;
	rForceIn:REAL;			(* Range 0 - MaxTorque (mNm) *)
	T_Station_Parameter:ST_RETAIN_DATA_STATIONWORK;
	lrZ1ActualPosition:LREAL;
	xCylHCActive:BOOL;
END_VAR
VAR_OUTPUT
	iAnalogOutput:INT;		(* Range 0 - 32767 *)
	rForceOut:REAL;			(* Range 0 - MaxTorque (mNm) *)
	rMaxTorque:REAL;		(* mNm *)
END_VAR
VAR_IN_OUT
	TCylTorque:ST_CYLINDER;
END_VAR
VAR
	rTorque:REAL;
	rTorqueEndPosition:REAL;
	rAirPressureP:REAL;
	rDiffTorqueLEvel:REAL;
(* Tmp variable *)
	rMaxAirPressure: REAL;
	rTmpAnalogOut:REAL;
	rTmpForceOut: REAL;
	rPistonArea: REAL;
	rGearRatioGearBox: REAL;
	rPlanetCarrier: REAL;
	rGearRatioRocker: REAL;
	rMaxTmpAirPressure: REAL;
	rTorqueStartPosition: REAL;
	rZ1Position: REAL;
	rZ1Length: REAL;
	rTorqueLevel1_StartPosition: REAL;
	rTorqueLevel1_EndPosition: REAL;
	rMaxDigitAnalogOutput: REAL;
END_VAR
(* @END_DECLARATION := '0' *)
IF xCylHCActive THEN
	rMaxDigitAnalogOutput:=(32767.0 / 10.0) * T_Station_Parameter.T_TorqueSystem.rMaxServoVoltage_HC;
	rPistonArea:=((T_Station_Parameter.T_TorqueSystem.rPistonTorqueHC/2.0)*(T_Station_Parameter.T_TorqueSystem.rPistonTorqueHC/2.0)*PI)/1000000.0;	(* Umwandlung in Quadratmeter *)
	rMaxAirPressure:=T_Station_Parameter.T_TorqueSystem.rMaxServoAirPressure_HC;
ELSE
	rMaxDigitAnalogOutput:=(32767.0 / 10.0) * T_Station_Parameter.T_TorqueSystem.rMaxServoVoltage_HCOver;
	rPistonArea:=((T_Station_Parameter.T_TorqueSystem.rPistonTorqueHCOverload/2.0)*(T_Station_Parameter.T_TorqueSystem.rPistonTorqueHCOverload/2.0)*PI)/1000000.0;	(* Umwandlung in Quadratmeter *)
	rMaxAirPressure:=T_Station_Parameter.T_TorqueSystem.rMaxServoAirPressure_HCOver;
END_IF;
rGearRatioGearBox:=T_Station_Parameter.T_TorqueSystem.rGearRatioGearBox;
rGearRatioRocker:=T_Station_Parameter.T_TorqueSystem.rGearRatioRocker;
rPlanetCarrier:=T_Station_Parameter.T_TorqueSystem.rPlanetCarrier_Radius;
rTorque:=rForceIn;		(* in mNm *)
rTorqueLevel1_StartPosition:=T_Station_Parameter.T_OnlineChange.rTorqueLevelHC;
rTorqueLevel1_EndPosition:=T_Station_Parameter.T_OnlineChange.rTorqueLevelHC;
IF ((rPlanetCarrier * rPistonArea) <> 0.0) AND (rMaxAirPressure <> 0.0) AND ((1.0 - rGearRatioGearBox) <> 0.0) THEN
	rAirPressureP:=(rTorque - (rTorque * rGearRatioGearBox))/(rPlanetCarrier * rPistonArea);	(* Pascal *)
	rAirPressureP:=rAirPressureP / 100000.0;	(* convert in bar *)
	rTmpAnalogOut:=((rMaxDigitAnalogOutput/rMaxAirPressure)*rAirPressureP);
	rMaxTmpAirPressure:=rMaxAirPressure * 100000.0;		(* convert from bar to pascal *)
	rMaxTorque:=(rMaxTmpAirPressure * rPlanetCarrier * rPistonArea) / (1.0 - rGearRatioGearBox);
	rMaxTorque:=(rMaxTorque / 32767.0) * rMaxDigitAnalogOutput;
ELSE
	rAirPressureP:=0.0;
	rMaxTmpAirPressure:=0.0;
	rMaxTorque:=0.0;
END_IF;
IF xActiveWorkProcess THEN
	(* Drehmoment wird in Abhängigkeit der Z1 Achse Position gesetzt *)
	rTorqueStartPosition:=(rTorqueLevel1_StartPosition + T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]);
	rTorqueEndPosition:=(rTorqueLevel1_EndPosition + T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]);
	IF ((rPlanetCarrier * rPistonArea) <> 0.0) AND (rMaxAirPressure <> 0.0) AND ((1.0 - rGearRatioGearBox) <> 0.0) THEN
		IF NOT(xBlockOutput) THEN
			IF (lrZ1ActualPosition >= grZ_WorkStartPos) THEN
				rZ1Length:=ABS(grZ_WorkStartPos - garPositionEndProcCalc[1]);
				rZ1Position:=ABS(lrZ1ActualPosition - grZ_WorkStartPos);
				rDiffTorqueLevel:=rTorqueEndPosition - rTorqueStartPosition;
				IF (rZ1Length <> 0.0) THEN
					rTorque:=rTorqueStartPosition + ((rDiffTorqueLevel / rZ1Length) * rZ1Position);
					rAirPressureP:=(rTorque - (rTorque * rGearRatioGearBox))/(rPlanetCarrier * rPistonArea);	(* Pascal *)
					rAirPressureP:=rAirPressureP / 100000.0;	(* convert in bar *)
					rTmpAnalogOut:=((rMaxDigitAnalogOutput/rMaxAirPressure)*rAirPressureP);
					rTmpForceOut:=rTorque;
				ELSE
					rTmpAnalogOut:=0.0;
					rTmpForceOut:=0.0;
				END_IF;
				IF NOT(TCylTorque.T_CtrleCyl.xExecute) AND TCylTorque.T_CtrleCyl.xDone THEN
					TCylTorque.T_CtrleCyl.iFunction:=4;
					TCylTorque.T_CtrleCyl.xExecute:=TRUE;
				END_IF;
			END_IF
		END_IF;
	END_IF;
ELSE
	rTmpForceOut:=rForceIn;
END_IF;
(* Set Output value *)
rForceOut:=rTmpForceOut;
IF (rTmpAnalogOut < 32767.0) AND (rTmpAnalogOut >= 0.0) THEN
	iAnalogOutput:=REAL_TO_INT(rTmpAnalogOut);
ELSIF (rTmpAnalogOut >= 32767.0) THEN
	iAnalogOutput:=32767;
ELSIF (rTmpAnalogOut < 0.0) THEN
	iAnalogOutput:=0;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_WRAP_WPQUALITY
VAR_INPUT
	T_PartAnalysis:ST_PARTANALYSIS;
END_VAR
VAR_IN_OUT
	diHoleNumber:DINT;
END_VAR
VAR_OUTPUT
	T_DataOut:ST_PARTANALYSIS_OUTPUT;
END_VAR
VAR
	diTmpHoleNumber: DINT;
	ii:INT;
END_VAR
(* @END_DECLARATION := '0' *)
IF (diHoleNumber <> 0) THEN
	FOR ii:=1 TO ciMaxWP DO
		IF (T_PartAnalysis.adiNumberHole[ii] = diHoleNumber) THEN
			diTmpHoleNumber:=ii;
		END_IF;
	END_FOR;
	IF (diTmpHoleNumber < 1) THEN
		diTmpHoleNumber:=1;
	END_IF;
	IF (diTmpHoleNumber > ciMaxWP) THEN
		diTmpHoleNumber:=ciMaxWP;
	END_IF;
	T_DataOut.bHole_WorkPartQuality:=T_PartAnalysis.abWorkPartQuality[diTmpHoleNumber];
	T_DataOut.diHole_CycleTime:=T_PartAnalysis.adiCycleTime[diTmpHoleNumber];
	T_DataOut.diHole_WorkTime:=T_PartAnalysis.adiWorkTime[diTmpHoleNumber];
	T_DataOut.iHole_HCCounter:=T_PartAnalysis.aiHCCounter[diTmpHoleNumber];
	T_DataOut.iHole_HCCounterCentering:=T_PartAnalysis.aiHCCounterCentering[diTmpHoleNumber];
	T_DataOut.iHole_HCCounterTorque:=T_PartAnalysis.aiHCCounterTorque[diTmpHoleNumber];
	T_DataOut.iHole_HCCounterSpeed:=T_PartAnalysis.aiHCCounterSpeed[diTmpHoleNumber];
	T_DataOut.rHole_FirstHC:=T_PartAnalysis.arFirstHC[diTmpHoleNumber];
	T_DataOut.bHole_InfeedCounterZ:=T_PartAnalysis.abInfeedCounterZ[diTmpHoleNumber];
ELSE
	T_DataOut.bHole_WorkPartQuality:=0;
	T_DataOut.diHole_CycleTime:=0;
	T_DataOut.diHole_WorkTime:=0;
	T_DataOut.iHole_HCCounter:=0;
	T_DataOut.iHole_HCCounterCentering:=0;
	T_DataOut.iHole_HCCounterTorque:=0;
	T_DataOut.iHole_HCCounterSpeed:=0;
	T_DataOut.rHole_FirstHC:=0.0;
	T_DataOut.bHole_InfeedCounterZ:=0;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBDefaultAxisValue
VAR_INPUT
	xDefaultValue:BOOL:=FALSE;
	sDeviceName:STRING(255);
END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
	T_Axis:ST_AXIS;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
IF xDefaultValue THEN
	IF sDeviceName = 'Beckhoff' THEN
		CASE T_Axis.T_Config_Gen.iTyp OF
		(* linear axis Bore 800 *)
		1:	T_Axis.T_FileObj.sData[1]:='01:idxGrp:=16#4000;idxOff:=16#27;LEN:=16#8;Value:=200.0';(* Max velocity *)
			T_Axis.T_FileObj.sData[2]:='02:idxGrp:=16#4000;idxOff:=16#6;Len:=16#8;Value:=20.0';(* Vel Ref forward *)
			T_Axis.T_FileObj.sData[3]:='03:idxGrp:=16#4000;idxOff:=16#7;LEN:=16#8;Value:=20.0';(* Vel Ref backward *)
			T_Axis.T_FileObj.sData[4]:='04:idxGrp:=16#4000;idxOff:=16#101;Len:=16#8;Value:=3800.0';(* Acc *)
			T_Axis.T_FileObj.sData[5]:='05:idxGrp:=16#4000;idxOff:=16#102;Len:=16#8;Value:=3800.0';(* Dec *)
			T_Axis.T_FileObj.sData[6]:='06:idxGrp:=16#4000;idxOff:=16#103;Len:=16#8;Value:=80222.0';(* Jerk *)
			T_Axis.T_FileObj.sData[7]:='07:idxGrp:=16#4000;idxOff:=16#A;Len:=16#8;Value:=200.0';(* Rapid traverse vel *)
			T_Axis.T_FileObj.sData[8]:='08:idxGrp:=16#5000;idxOff:=16#B;Len:=16#2;Value:=0';(* Enable min soft pos *)
			T_Axis.T_FileObj.sData[9]:='09:idxGrp:=16#5000;idxOff:=16#D;Len:=16#8;Value:=0';(* Min soft pos *)
			T_Axis.T_FileObj.sData[10]:='10:idxGrp:=16#5000;idxOff:=16#C;Len:=16#2;Value:=0';(* Enable max soft pos *)
			T_Axis.T_FileObj.sData[11]:='11:idxGrp:=16#5000;idxOff:=16#E;Len:=16#8;Value:=0';(* Max soft pos *)
			T_Axis.T_FileObj.sData[12]:='12:idxGrp:=16#6000;idxOff:=16#10;Len:=16#2;Value:=1';(* Enable pos lag *)
			T_Axis.T_FileObj.sData[13]:='13:idxGrp:=16#6000;idxOff:=16#12;Len:=16#8;Value:=10.0';(* Max Pos lag *)
			T_Axis.T_FileObj.sData[14]:='14:idxGrp:=16#5000;idxOff:=16#8;Len:=16#2;Value:=0';(* Invert Enc counting *)
			T_Axis.T_FileObj.sData[15]:='15:idxGrp:=16#5000;idxOff:=16#6;Len:=16#8;Value:=3.81e-5';(* Enc scaling factor *)
			T_Axis.T_FileObj.sData[16]:='16:idxGrp:=16#5000;idxOff:=16#9;Len:=16#8;Value:=1';(* Enc modulo factor *)
			T_Axis.T_FileObj.sData[17]:='17:idxGrp:=16#5000;idxOff:=16#101;Len:=16#2;Value:=1';(* Enc dir for ref search *)
			T_Axis.T_FileObj.sData[18]:='18:idxGrp:=16#5000;idxOff:=16#102;Len:=16#2;Value:=0';(* Enc dir for sync impuls*)
			T_Axis.T_FileObj.sData[19]:='19:idxGrp:=16#5000;idxOff:=16#103;Len:=16#8;Value:=0';(* Enc ref value *)
			T_Axis.T_FileObj.sData[20]:='20:idxGrp:=16#5000;idxOff:=16#106;Len:=16#2;Value:=0';(* Enc Ext sync impuls *)
			T_Axis.T_FileObj.sData[21]:='21:idxGrp:=16#5000;idxOff:=16#107;Len:=16#4;Value:=5';(* Enc ref sequence *)
			T_Axis.T_FileObj.sData[22]:='22:idxGrp:=16#7000;idxOff:=16#6;Len:=16#2;Value:=0';(* Driver invert polarity *)
			T_Axis.T_FileObj.sData[23]:='23:idxGrp:=16#7000;idxOff:=16#101;Len:=16#8;Value:=220';(* Driver Max Ref vel *)
			T_Axis.T_FileObj.sData[24]:='24:idxGrp:=16#7000;idxOff:=16#102;Len:=16#8;Value:=0.75';(* Driver output ration *)
			T_Axis.T_FileObj.sData[25]:='25:idxGrp:=16#6000;idxOff:=16#B;Len:=16#8;Value:=1';(* Ctrler pre-ctrl weighting *)
			T_Axis.T_FileObj.sData[26]:='26:idxGrp:=16#6000;idxOff:=16#102;LEN:=16#8;Value:=50';(* Ctrler Kv factor *)
			T_Axis.T_FileObj.sData[27]:='';
		(* spindle axis Bore800 master *)
		2:	T_Axis.T_FileObj.sData[1]:='01:idxGrp:=16#4000;idxOff:=16#27;LEN:=16#8;Value:=24000.0';(* Max velocity *)
			T_Axis.T_FileObj.sData[2]:='02:idxGrp:=16#4000;idxOff:=16#6;Len:=16#8;Value:=60.0';(* Vel Ref forward *)
			T_Axis.T_FileObj.sData[3]:='03:idxGrp:=16#4000;idxOff:=16#7;LEN:=16#8;Value:=60.0';(* Vel Ref backward *)
			T_Axis.T_FileObj.sData[4]:='04:idxGrp:=16#4000;idxOff:=16#101;Len:=16#8;Value:=42000.0';(* Acc *)
			T_Axis.T_FileObj.sData[5]:='05:idxGrp:=16#4000;idxOff:=16#102;Len:=16#8;Value:=42000.0';(* Dec *)
			T_Axis.T_FileObj.sData[6]:='06:idxGrp:=16#4000;idxOff:=16#103;Len:=16#8;Value:=98000.0';(* Jerk *)
			T_Axis.T_FileObj.sData[7]:='07:idxGrp:=16#4000;idxOff:=16#A;Len:=16#8;Value:=24000.0';(* Rapid traverse vel *)
			T_Axis.T_FileObj.sData[8]:='08:idxGrp:=16#5000;idxOff:=16#B;Len:=16#2;Value:=0';(* Enable min soft pos *)
			T_Axis.T_FileObj.sData[9]:='09:idxGrp:=16#5000;idxOff:=16#D;Len:=16#8;Value:=0';(* Min soft pos *)
			T_Axis.T_FileObj.sData[10]:='10:idxGrp:=16#5000;idxOff:=16#C;Len:=16#2;Value:=0';(* Enable max soft pos *)
			T_Axis.T_FileObj.sData[11]:='11:idxGrp:=16#5000;idxOff:=16#E;Len:=16#8;Value:=0';(* Max soft pos *)
			T_Axis.T_FileObj.sData[12]:='12:idxGrp:=16#6000;idxOff:=16#10;Len:=16#2;Value:=1';(* Enable pos lag *)
			T_Axis.T_FileObj.sData[13]:='13:idxGrp:=16#6000;idxOff:=16#12;Len:=16#8;Value:=90.0';(* Max Pos lag *)
			T_Axis.T_FileObj.sData[14]:='14:idxGrp:=16#5000;idxOff:=16#8;Len:=16#2;Value:=0';(* Invert Enc counting *)
			T_Axis.T_FileObj.sData[15]:='15:idxGrp:=16#5000;idxOff:=16#6;Len:=16#8;Value:=0.00549';(* Enc scaling factor *)
			T_Axis.T_FileObj.sData[16]:='16:idxGrp:=16#5000;idxOff:=16#9;Len:=16#8;Value:=360';(* Enc modulo factor *)
			T_Axis.T_FileObj.sData[17]:='17:idxGrp:=16#5000;idxOff:=16#101;Len:=16#2;Value:=1';(* Enc dir for ref search *)
			T_Axis.T_FileObj.sData[18]:='18:idxGrp:=16#5000;idxOff:=16#102;Len:=16#2;Value:=0';(* Enc dir for sync impuls*)
			T_Axis.T_FileObj.sData[19]:='19:idxGrp:=16#5000;idxOff:=16#103;Len:=16#8;Value:=0';(* Enc ref value *)
			T_Axis.T_FileObj.sData[20]:='20:idxGrp:=16#5000;idxOff:=16#106;Len:=16#2;Value:=0';(* Enc Ext sync impuls *)
			T_Axis.T_FileObj.sData[21]:='21:idxGrp:=16#5000;idxOff:=16#107;Len:=16#4;Value:=5';(* Enc ref sequence *)
			T_Axis.T_FileObj.sData[22]:='22:idxGrp:=16#7000;idxOff:=16#6;Len:=16#2;Value:=0';(* Driver invert polarity *)
			T_Axis.T_FileObj.sData[23]:='23:idxGrp:=16#7000;idxOff:=16#101;Len:=16#8;Value:=26000';(* Driver Max Ref vel *)
			T_Axis.T_FileObj.sData[24]:='24:idxGrp:=16#7000;idxOff:=16#102;Len:=16#8;Value:=1';(* Driver output ration *)
			T_Axis.T_FileObj.sData[25]:='25:idxGrp:=16#6000;idxOff:=16#B;Len:=16#8;Value:=1';(* Ctrler pre-ctrl weighting *)
			T_Axis.T_FileObj.sData[26]:='26:idxGrp:=16#6000;idxOff:=16#102;LEN:=16#8;Value:=0.5';(* Ctrler Kv factor *)
			T_Axis.T_FileObj.sData[27]:='';
		(* handling *)
		4:	T_Axis.T_FileObj.sData[1]:='01:idxGrp:=16#4000;idxOff:=16#27;LEN:=16#8;Value:=500.0';(* Max velocity *)
			T_Axis.T_FileObj.sData[2]:='02:idxGrp:=16#4000;idxOff:=16#6;Len:=16#8;Value:=20.0';(* Vel Ref forward *)
			T_Axis.T_FileObj.sData[3]:='03:idxGrp:=16#4000;idxOff:=16#7;LEN:=16#8;Value:=10.0';(* Vel Ref backward *)
			T_Axis.T_FileObj.sData[4]:='04:idxGrp:=16#4000;idxOff:=16#101;Len:=16#8;Value:=3800.0';(* Acc *)
			T_Axis.T_FileObj.sData[5]:='05:idxGrp:=16#4000;idxOff:=16#102;Len:=16#8;Value:=3800.0';(* Dec *)
			T_Axis.T_FileObj.sData[6]:='06:idxGrp:=16#4000;idxOff:=16#103;Len:=16#8;Value:=80222.0';(* Jerk *)
			T_Axis.T_FileObj.sData[7]:='07:idxGrp:=16#4000;idxOff:=16#A;Len:=16#8;Value:=500.0';(* Rapid traverse vel *)
			T_Axis.T_FileObj.sData[8]:='08:idxGrp:=16#5000;idxOff:=16#B;Len:=16#2;Value:=0';(* Enable min soft pos *)
			T_Axis.T_FileObj.sData[9]:='09:idxGrp:=16#5000;idxOff:=16#D;Len:=16#8;Value:=0';(* Min soft pos *)
			T_Axis.T_FileObj.sData[10]:='10:idxGrp:=16#5000;idxOff:=16#C;Len:=16#2;Value:=0';(* Enable max soft pos *)
			T_Axis.T_FileObj.sData[11]:='11:idxGrp:=16#5000;idxOff:=16#E;Len:=16#8;Value:=0';(* Max soft pos *)
			T_Axis.T_FileObj.sData[12]:='12:idxGrp:=16#6000;idxOff:=16#10;Len:=16#2;Value:=1';(* Enable pos lag *)
			T_Axis.T_FileObj.sData[13]:='13:idxGrp:=16#6000;idxOff:=16#12;Len:=16#8;Value:=200.0';(* Max Pos lag *)
			T_Axis.T_FileObj.sData[14]:='14:idxGrp:=16#5000;idxOff:=16#8;Len:=16#2;Value:=1';(* Invert Enc counting *)
			T_Axis.T_FileObj.sData[15]:='15:idxGrp:=16#5000;idxOff:=16#6;Len:=16#8;Value:=3.433279926e-4';(* Enc scaling factor *)
			T_Axis.T_FileObj.sData[16]:='16:idxGrp:=16#5000;idxOff:=16#9;Len:=16#8;Value:=360';(* Enc modulo factor *)
			T_Axis.T_FileObj.sData[17]:='17:idxGrp:=16#5000;idxOff:=16#101;Len:=16#2;Value:=1';(* Enc dir for ref search *)
			T_Axis.T_FileObj.sData[18]:='18:idxGrp:=16#5000;idxOff:=16#102;Len:=16#2;Value:=0';(* Enc dir for sync impuls*)
			T_Axis.T_FileObj.sData[19]:='19:idxGrp:=16#5000;idxOff:=16#103;Len:=16#8;Value:=0';(* Enc ref value *)
			T_Axis.T_FileObj.sData[20]:='20:idxGrp:=16#5000;idxOff:=16#106;Len:=16#2;Value:=0';(* Enc Ext sync impuls *)
			T_Axis.T_FileObj.sData[21]:='21:idxGrp:=16#5000;idxOff:=16#107;Len:=16#4;Value:=5';(* Enc ref sequence *)
			T_Axis.T_FileObj.sData[22]:='22:idxGrp:=16#7000;idxOff:=16#6;Len:=16#2;Value:=1';(* Driver invert polarity *)
			T_Axis.T_FileObj.sData[23]:='23:idxGrp:=16#7000;idxOff:=16#101;Len:=16#8;Value:=550';(* Driver Max Ref vel *)
			T_Axis.T_FileObj.sData[24]:='24:idxGrp:=16#7000;idxOff:=16#102;Len:=16#8;Value:=0.1';(* Driver output ration *)
			T_Axis.T_FileObj.sData[25]:='25:idxGrp:=16#6000;idxOff:=16#B;Len:=16#8;Value:=1';(* Ctrler pre-ctrl weighting *)
			T_Axis.T_FileObj.sData[26]:='26:idxGrp:=16#6000;idxOff:=16#102;LEN:=16#8;Value:=120';(* Ctrler Kv factor *)
			T_Axis.T_FileObj.sData[27]:='';
		END_CASE
	END_IF
	IF sDeviceName = 'Maxon' THEN
		CASE T_Axis.T_Config_Gen.iTyp OF
		(* Spindel Master *)
		2:	T_Axis.T_FileObj.sData[1]:='01:idxGrp:=16#6402;idxOff:=16#0;LEN:=16#2;Value:=10';(* Motor typ *)
			T_Axis.T_FileObj.sData[2]:='02:idxGrp:=16#6410;idxOff:=16#1;Len:=16#2;Value:=668';(* Continuous current limit *)
			T_Axis.T_FileObj.sData[3]:='03:idxGrp:=16#6410;idxOff:=16#2;Len:=16#2;Value:=1336';(* Output current limit *)
			T_Axis.T_FileObj.sData[4]:='04:idxGrp:=16#607F;idxOff:=16#0;LEN:=16#4;Value:=18000';(* Max profile velocity *)
			T_Axis.T_FileObj.sData[5]:='05:idxGrp:=16#6083;idxOff:=16#0;LEN:=16#4;Value:=10000';(* Profile acceleration *)
			T_Axis.T_FileObj.sData[6]:='06:idxGrp:=16#6084;idxOff:=16#0;LEN:=16#4;Value:=10000';(* Profile decceleration *)
			T_Axis.T_FileObj.sData[7]:='07:idxGrp:=16#6085;idxOff:=16#0;Len:=16#4;Value:=10000';(* Profile quickstop *)
			T_Axis.T_FileObj.sData[8]:='08:idxGrp:=16#2210;idxOff:=16#1;Len:=16#2;Value:=128';(* Encoder pulse number *)
			T_Axis.T_FileObj.sData[9]:='09:idxGrp:=16#60F6;idxOff:=16#1;Len:=16#2;Value:=1301';(* Current Regulator P-Gain *)
			T_Axis.T_FileObj.sData[10]:='10:idxGrp:=16#60F6;idxOff:=16#2;Len:=16#2;Value:=898';(* Current Regulator I-Gain *)
			T_Axis.T_FileObj.sData[11]:='11:idxGrp:=16#60F9;idxOff:=16#1;Len:=16#2;Value:=2186';(* Speed Regulator P-Gain *)
			T_Axis.T_FileObj.sData[12]:='12:idxGrp:=16#60F9;idxOff:=16#2;Len:=16#2;Value:=555';(* Speed Regulator P-Gain *)
			T_Axis.T_FileObj.sData[13]:='13:idxGrp:=16#6065;idxOff:=16#0;Len:=16#4;Value:=2000';(* Max Following error *)
			T_Axis.T_FileObj.sData[14]:='14:idxGrp:=16#2300;idxOff:=16#2;LEN:=16#2;Value:=1';(* Scaling numerator *)
			T_Axis.T_FileObj.sData[15]:='14:idxGrp:=16#2300;idxOff:=16#3;LEN:=16#2;Value:=1';(* Scaling denominator *)
			T_Axis.T_FileObj.sData[16]:='14:idxGrp:=16#2300;idxOff:=16#4;LEN:=16#1;Value:=0';(* Digital position polarity *)
			T_Axis.T_FileObj.sData[17]:='';
		(* Spindel Slave *)
		3:	T_Axis.T_FileObj.sData[1]:='01:idxGrp:=16#6402;idxOff:=16#0;LEN:=16#2;Value:=10';(* Motor typ *)
			T_Axis.T_FileObj.sData[2]:='02:idxGrp:=16#6410;idxOff:=16#1;Len:=16#2;Value:=668';(* Continuous current limit *)
			T_Axis.T_FileObj.sData[3]:='03:idxGrp:=16#6410;idxOff:=16#2;Len:=16#2;Value:=1336';(* Output current limit *)
			T_Axis.T_FileObj.sData[4]:='04:idxGrp:=16#607F;idxOff:=16#0;LEN:=16#4;Value:=18000';(* Max profile velocity *)
			T_Axis.T_FileObj.sData[5]:='05:idxGrp:=16#6083;idxOff:=16#0;LEN:=16#4;Value:=10000';(* Profile acceleration *)
			T_Axis.T_FileObj.sData[6]:='06:idxGrp:=16#6084;idxOff:=16#0;LEN:=16#4;Value:=10000';(* Profile decceleration *)
			T_Axis.T_FileObj.sData[7]:='07:idxGrp:=16#6085;idxOff:=16#0;Len:=16#4;Value:=10000';(* Profile quickstop *)
			T_Axis.T_FileObj.sData[8]:='08:idxGrp:=16#2210;idxOff:=16#1;Len:=16#2;Value:=128';(* Encoder pulse number *)
			T_Axis.T_FileObj.sData[9]:='09:idxGrp:=16#60F6;idxOff:=16#1;Len:=16#2;Value:=1301';(* Current Regulator P-Gain *)
			T_Axis.T_FileObj.sData[10]:='10:idxGrp:=16#60F6;idxOff:=16#2;Len:=16#2;Value:=898';(* Current Regulator I-Gain *)
			T_Axis.T_FileObj.sData[11]:='11:idxGrp:=16#60F9;idxOff:=16#1;Len:=16#2;Value:=2186';(* Speed Regulator P-Gain *)
			T_Axis.T_FileObj.sData[12]:='12:idxGrp:=16#60F9;idxOff:=16#2;Len:=16#2;Value:=555';(* Speed Regulator P-Gain *)
			T_Axis.T_FileObj.sData[13]:='13:idxGrp:=16#6065;idxOff:=16#0;Len:=16#4;Value:=2000';(* Max Following error *)
			T_Axis.T_FileObj.sData[14]:='14:idxGrp:=16#2300;idxOff:=16#2;LEN:=16#2;Value:=1';(* Scaling numerator *)
			T_Axis.T_FileObj.sData[15]:='14:idxGrp:=16#2300;idxOff:=16#3;LEN:=16#2;Value:=1';(* Scaling denominator *)
			T_Axis.T_FileObj.sData[16]:='14:idxGrp:=16#2300;idxOff:=16#4;LEN:=16#1;Value:=1';(* Digital position polarity *)
			T_Axis.T_FileObj.sData[17]:='';
		END_CASE
	END_IF
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION sFctDeleteChar : STRING(255)
VAR_INPUT
	sString:STRING(255);
	sChar:STRING(1);
END_VAR
VAR
	sCopyString: STRING(255);
	iFindChar: INT;
END_VAR
(* @END_DECLARATION := '0' *)
sFctDeleteChar:='';
sCopyString:=sString;
WHILE (FIND(sCopyString,sChar) <> 0) DO
	iFindChar:=FIND(sCopyString,sChar);
	sCopyString:=DELETE(sCopyString,1,iFindChar);
END_WHILE;
sFctDeleteChar:=sCopyString;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION sFctUpLowCase : STRING
VAR_INPUT
	xLowConvert:BOOL;
	sInString:STRING;
END_VAR
VAR
(* variable *)
	sListUpCase:STRING:='ABCDEFGHIJKLMNOPQRSTUVWXYZ';
	sListLowCase:STRING:='abcdefghijklmnopqrstuvwxyz';
	i:INT;
(* Tmp *)
	sTmp:STRING;
	iTmp:INT;
END_VAR
(* @END_DECLARATION := '0' *)
(* Init. *)
	sFctUpLowCase:='';

(*Test string size*)
	IF LEN(sInString) < 1 OR LEN(sInString) > 255 THEN RETURN; END_IF

	IF xLowConvert THEN
	(* Conversion to low case *)
		FOR i:= 1 TO LEN(sInString) DO
			sTmp:=MID(sInString,1,i);
			iTmp:=FIND(sListUpCase,sTmp);
			IF iTmp > 0 THEN sFctUpLowCase:=CONCAT(sFctUpLowCase,MID(sListLowCase,1,iTmp));
				ELSE sFctUpLowCase:=CONCAT(sFctUpLowCase,sTmp); END_IF
		END_FOR
	(* Conversion to up case *)
	ELSE
		FOR i:= 1 TO LEN(sInString) DO
			sTmp:=MID(sInString,1,i);
			iTmp:=FIND(sListLowCase,sTmp);
			IF iTmp > 0 THEN sFctUpLowCase:=CONCAT(sFctUpLowCase,MID(sListUpCase,1,iTmp));
				ELSE sFctUpLowCase:=CONCAT(sFctUpLowCase,sTmp); END_IF
		END_FOR
	END_IF
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION udiFct_FormatNumber : UDINT
VAR_INPUT
	udiNumber:UDINT;
	iNumberLength:INT;
END_VAR
VAR
	sNumberToConvert: STRING(40);
	iCharCount: INT;
	sNumberConverted: STRING(40);
END_VAR
(* @END_DECLARATION := '0' *)
sNumberToConvert:=UDINT_TO_STRING(udiNumber);
iCharCount:=LEN(sNumberToConvert);
udiFct_FormatNumber:=0;
IF (iNumberLength > 0) THEN
	IF (iCharCount >= iNumberLength) THEN
		sNumberConverted:=MID(STR:=sNumberToConvert,LEN:=iNumberLength,POS:=iCharCount - iNumberLength + 1);
	ELSE
		sNumberConverted:=MID(STR:=sNumberToConvert,LEN:=iCharCount,POS:=1);
	END_IF;
	udiFct_FormatNumber:=STRING_TO_UDINT(sNumberConverted);
END_IF;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/GENERAL' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION xFctCheckNumber : BOOL
VAR_INPUT
	sValue:STRING(255);
	xAlowDoubleSign:BOOL;
END_VAR
VAR
	iCharCount: INT;
	ii: INT;
	sCopyChar: STRING;
	xTmp: BOOL;
	xSyntaxError: BOOL;
	iCountPointChar: INT;
	iCountMinusChar: INT;
	iCountPlusChar: INT;
	iCountExponentChar: INT;
END_VAR
(* @END_DECLARATION := '0' *)
xFctCheckNumber:=FALSE;
iCharCount:=LEN(sValue);
iCountPointChar:=0;
iCountMinusChar:=0;
iCountPlusChar:=0;
iCountExponentChar:=0;
xSyntaxError:=FALSE;
IF (sValue <> '') THEN
	FOR ii:=1 TO iCharCount DO
		sCopyChar:=MID(sValue,1,ii);
		xTmp:=	(sCopyChar = '0') OR (sCopyChar = '1') OR (sCopyChar = '2') OR (sCopyChar = '3') OR (sCopyChar = '4') OR
				(sCopyChar = '5') OR (sCopyChar = '6') OR (sCopyChar = '7') OR (sCopyChar = '8') OR (sCopyChar = '9') OR
				(sCopyChar = '.') OR (sCopyChar = '-') OR (sCopyChar = '+') OR (sCopyChar = 'e') OR (sCopyChar = 'E');
		IF (sCopyChar = '.') THEN
			iCountPointChar:=iCountPointChar + 1;
		END_IF;
		IF (sCopyChar = '-') THEN
			iCountMinusChar:=iCountMinusChar + 1;
		END_IF;
		IF (sCopyChar = '+') THEN
			iCountPlusChar:=iCountPlusChar + 1;
		END_IF;
		IF (sCopyChar = 'e') OR (sCopyChar = 'E') THEN
			iCountExponentChar:=iCountExponentChar + 1;
			IF (iCountMinusChar > 0) THEN
				iCountMinusChar:=iCountMinusChar -1;
			END_IF;
			IF (iCountPlusChar > 0) THEN
				iCountPlusChar:=iCountPlusChar -1;
			END_IF;
		END_IF;
		IF NOT(xTmp) OR (iCountPointChar > 1) OR ((iCountMinusChar > 1) AND NOT(xAlowDoubleSign)) OR ((iCountMinusChar > 2) AND xAlowDoubleSign) OR
		    ((iCountPlusChar > 1) AND NOT(xAlowDoubleSign)) OR ((iCountPlusChar > 2) AND xAlowDoubleSign) OR (iCountExponentChar > 1) THEN
			xSyntaxError:=TRUE;
			EXIT;
		END_IF;
	END_FOR;
ELSE
	xSyntaxError:=TRUE;
END_IF;
xFctCheckNumber:=NOT(xSyntaxError);

END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER2_HARDWARE\/FBHWSTATIONEN' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBHW_STATION_WORK
VAR_INPUT
	iStationNr:INT;
	(* IO's *)
	xStationPowerON:BOOL;
	IxToolDeflection:BOOL;	(* Überwachung der Werkzeug Auslenkung für die Werkzeug Spindel *)
	IiAToolTorque:INT;	(* Drehmoment Sensor für Drehmomentüberwachung für die Werkzeug Spindel *)
	IiAToolTorque2:INT;	(* Drehmoment Sensor für Drehmomentüberwachung für die Werkzeug Spindel *)	(* IGS *)
	IxBrakeReleaseZAxis:BOOL;	(* Sensor für Bremse gelöst bei der Z Achse (Hubachse) *)
	IxUpperToolGuide_WorkpieceClamped:BOOL;	(* Sensor für Überwachung der Werkstückfixierung *)
	IbTooSpindleActive:BYTE;																		(* IGS *)
	iSlaveAddr_AxisZ:INT;
	iSlaveAddr_AxisS:INT;																			(* IGS *)
	IxTorqueOverload:BOOL;			(* Clock-->Signal induktiver Sensor für Drehmomentüberlast *)			(* IGS *)
END_VAR
VAR_IN_OUT
	T_Station_Parameter: ST_RETAIN_DATA_STATIONWORK;
	T_Station_Work : ST_STATION;
	(* Axis value *)
	IuiActualTorqueAxisZ :UINT;
	IwInputState_Z_Axis:WORD;
	IuiActualTorqueAxisS :UINT;
	IwInputState_S1_Axis:WORD;
	IwInputState_S2_Axis:WORD;									(* IGS *)
	IwInputState_S3_Axis:WORD;									(* IGS *)
	(* Axis structure *)
	stZRefIn :NCTOPLC_AXLESTRUCT;
	stZRefOut :PLCTONC_AXLESTRUCT;
	stZDriveState :ST_AXIS_DRIVESTATE;
	stSRefIn :NCTOPLC_AXLESTRUCT;
	stSRefOut :PLCTONC_AXLESTRUCT;
	stS2RefIn :NCTOPLC_AXLESTRUCT;	(* Beckhoff Spindel *)		(* IGS *)
	stS2RefOut :PLCTONC_AXLESTRUCT;	(* Beckhoff Spindel *)		(* IGS *)
	stS3RefIn :NCTOPLC_AXLESTRUCT;	(* Beckhoff Spindel *)		(* IGS *)
	stS3RefOut :PLCTONC_AXLESTRUCT;	(* Beckhoff Spindel *)		(* IGS *)
	T_HDD : ST_HDD;
	T_TwinSafe_Ctrle_Z_Axis:ST_TWINSAFE_DRIVE;
	T_TwinSafe_Status_Z_Axis:ST_TWINSAFE_DRIVE;
	T_TwinSafe_Ctrle_S2_Axis:ST_TWINSAFE_DRIVE;				(* IGS *)
	T_TwinSafe_Status_S2_Axis:ST_TWINSAFE_DRIVE;				(* IGS *)
	T_TwinSafe_Ctrle_S3_Axis:ST_TWINSAFE_DRIVE;				(* IGS *)
	T_TwinSafe_Status_S3_Axis:ST_TWINSAFE_DRIVE;				(* IGS *)
	(* Axis DC structure *)
	stBubblerDataIN : ST_COMM_IN_DCAXIS;						(* IGS3 *)
	stBubblerDataOUT : ST_COMM_OUT_DCAXIS;					(* IGS3 *)
	stFeedpumpINData : ST_COMM_IN_DCAXIS;						(* IGS3 *)
	stFeedpumpOUTData : ST_COMM_OUT_DCAXIS;					(* IGS3 *)
END_VAR
VAR_OUTPUT
	xActiveHWStation : BOOL;
	xActiveStation : BOOL;
	xEnableMasterModul:BOOL;	(* is for the Shuttle Axis *)
	QiAToolDeflection_SM:INT;
	QiAToolTorqueHC_SM:INT;
	QiAToolTorqueOverload_SM:INT;
	QxCylBrakeReleaseZAxis_Open:BOOL;	(* Ventil für Bremszylinder der Z(St1) Achse für Bremse lösen *)
	QxCylBrakeReleaseZAxis_Close:BOOL;	(* Ventil für Bremszylinder der Z(St1) Achse für Bremse aktivieren *)
	QxCylWorkpieceClamp_Open:BOOL;	(* Ventil für Werkstückfixierzylinder öffnen *)
	QxCylWorkpieceClamp_Close:BOOL;	(* Ventil für Werkstückfixierzylinder schliessen *)
	QxAirTable:BOOL;	(* Ventil für die Luft des Tisches *)
	QxVacuumTable:BOOL;	(* Ventil für das Vakuum des Tisches *)
	QxMeasRangeTorqueSensor:BOOL;		(* Drehmoment Sensor Bereichsumschaltung von 0-2Nm auf 0-0.5Nm *)		(* IGS *)
	QxControlTorqueSensor:BOOL;			(* Drehmoment Sensor Kontrollfunktion aktivieren *)						(* IGS *)
END_VAR
VAR
(* Pointer auf Actuatoren *)
	ptrTAxisZ 							:POINTER TO ST_AXIS;			(* Achse für die Hubachse *)
	ptrTAxisS 							:POINTER TO ST_AXIS;			(* Achse für die Werkzeugspindel *)
	ptrTCylToolDeflection					:POINTER TO ST_CYLINDER;	(* Servoventil für das bestimmen der vertikalen Auslenkraft *)
	ptrTCylToolTorqueHC 					:POINTER TO ST_CYLINDER;	(* Drehmomentueberwachung HC *)
	ptrTCylToolTorqueOverload 			:POINTER TO ST_CYLINDER;	(* Drehmomentueberwachung Ueberlast *)
	ptrTTorqueSensorMeasRange			:POINTER TO ST_CYLINDER;	(* Controlling für den Drehmomentsensor, Einstellung des Drehmomentbereiches *)	(* IGS *)
	ptrTTorqueSensorControl				:POINTER TO ST_CYLINDER;	(* Controlling für den Drehmomentsensor, Ueberpruefung auf Funktionalitaet *)			(* IGS *)
	ptrTSensorTorque 					:POINTER TO ST_CYLINDER;	(* Analoger Sensor für Drehmoment detektion *)
	ptrTSensorTorqueOverload 			:POINTER TO ST_CYLINDER;	(* Digitaler Sensor für Drehmoment Ueberlast detektion *)							(* IGS *)
	ptrTCylBrakeReleaseZAxis 				:POINTER TO ST_CYLINDER;	(* Zylinder für lösen der Bremse bei der Z Achse *)
	ptrTCylWorkpieceClamp				:POINTER TO ST_CYLINDER;	(* Ventil fuer Werkstueckfixierzylinder *)
	ptrTValveAirTable						:POINTER TO ST_CYLINDER;	(* Ventil fuer die Luft des Tisches *)
	ptrTValveVacuumTable				:POINTER TO ST_CYLINDER;	(* Ventil fuer die Luft des Tisches *)
	ptrTValveCleanNozzle					:POINTER TO ST_CYLINDER;	(* Ventil fuer die Reinigungsduese *)											(* BEF *)
	ptrTAxisBubbler						:POINTER TO ST_DC_AXIS;	(* Ruehrwerk fuer Suspension *)												(* IGS3 *)
	ptrTAxisFeedPump					:POINTER TO ST_DC_AXIS;	(* Foerderpumpe fuer Suspension *)											(* IGS3 *)

(* Functionblock axis *)
	fbAxisZ:FBHW_AXIS_SINGLE;
	fbAxisZLiveValues:FBHW_AXIS_LIVEVALUES;
	fbAxisToolSpindleS: FBHW_AXIS_SINGLE;
	fbAxisToolSpindleSLiveValues: FBHW_AXIS_LIVEVALUES;
	(* DC Motor Maxon *)
	fbBubbler:FBHW_AXIS_DC;			(* Motor für das Rührwerk der Suspension *)		(* IGS3 *)
	fbFeedpump:FBHW_AXIS_DC;		(* Motor für die Förderpumpe der Suspension *)		(* IGS3 *)
(* Functionblock cylinder *)
	fbCylToolDeflection : FBHW_CYL_ANALOG;
	fbCylToolTorqueHC : FBHW_CYL_ANALOG;
	fbCylToolTorqueOverload : FBHW_CYL_ANALOG;
	fbTorqueSensorMeasRange	:FBHW_CYL_STANDARD;		(* IGS *)
	fbTorqueSensorControl		:FBHW_CYL_STANDARD;		(* IGS *)
	FBCalcSpindleForce: FB_CalcSpindleForce;
	FBTorqueLevelAirPressureAnalog_HC:FB_TorqueLevelAirPressureAnalog;
	FBTorqueLevelAirPressureAnalog_Overload:FB_TorqueLevelAirPressureAnalog;
	fbCylTBrakeReleaseZAxis : FBHW_CYL_STANDARD_2WAY;
	fbCylWorkpieceClamp : FBHW_CYL_STANDARD_2WAY;
	fbValveAirTable : FBHW_CYL_STANDARD;
	fbValveVacuumTable : FBHW_CYL_STANDARD;
	fbValveCleanNozzle : FBHW_CYL_STANDARD;
	iStepResetHardware: INT;
	xHardwareActive: BOOL;
	TONWaitTimeOut: TON;
	RisingEdgeHWConfig: R_TRIG;
	xHardwareConfigError: BOOL;
	xCkeckAcitveMovement: BOOL;
	TONTickTime: TON;
	iStepCountError: INT;
	FBReadAxisState: FB_ReadAxisState;
	rCalcForceIn: REAL;
	T_RegulatorSpindle:ST_EXCHG_PARAM_CONTRMOT;
	FBWriteObject: FB_WriteObject;
	ii:INT;
	rDefaultValue: REAL;
	rQualitySum: REAL;
	rQualityArea: REAL;
	jj: INT;
	rQuality: REAL;
	TONWaitCycle: TON;
	xFirstTime: BOOL;
	TONCalcImpuls: TON;
	xInitCountHC: BOOL;
	xTorqueActive: BOOL;
	xSetParameter: BOOL;
	xInitState: BOOL;															(* IGS *)
	udiTorqueOverloadCounterValue:UDINT;										(* IGS *)
	TOFSetOutput:TOF;														(* IGS *)
	(* .A01_AX5000_Parametrization *)
	fbGetAmsNetID				:FB_GetAxisAmsAddr;							(* IGS *)
	fbSetSlaveState				:FB_EcSetSlaveState;							(* IGS *)
	fbGetSlaveState				:FB_EcGetSlaveState;							(* IGS *)
	fbSoERead					:FB_EcSoERead;								(* IGS *)
	fbSoEWrite					:FB_EcSoEWrite;								(* IGS *)
	sEtherCATNetId 				:STRING;	(*Master Ethercat AMS Adress *)		(* IGS *)
	xReadSoEParameter:BOOL;												(* IGS *)
	iStepReadSoEParameter:INT;												(* IGS *)
	iStepWriteSoEParameter:INT;												(* IGS *)
	lrCalcSpeed: LREAL;
	lrActualSpeed: LREAL;
	lrCheckSpeed: LREAL;
	lrCtrlSpeed: LREAL;
	xZMovementNOK: BOOL;
	TONCheckMovement: TON;
	diCounterTest: DINT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                                            This Functionblock manage all the machine hardware                                                           ************)
(****************************************************************************************************************************************************)
T_Station_Work.iStationNr:=iStationNr;
IF T_Station_Work.TControl.xResetHardware THEN
	CASE iStepResetHardware OF
		1:	iStepCountError:=iStepCountError + 1;
			xHardwareActive:=T_Station_Work.TControl.xActiveHardware;
			T_Station_Work.TControl.xActiveHardware:=TRUE;
			iStepResetHardware:=iStepResetHardware + 1;
		2:	T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xReset:=TRUE;
			T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.xReset:=TRUE;
			IF NOT(xSetParameter) AND (T_ExchgParam.bToolSpindleActive = 1) THEN		(* nur laden wenn Maxon Spindel aktiv ist *)
				iStepResetHardware:=iStepResetHardware + 1;
			ELSE
				iStepResetHardware:=iStepResetHardware + 2;
			END_IF;
		3:	T_RegulatorSpindle:=T_Station_Parameter.T_RegulatorSpindle_SM;
			FBWriteObject(	bExecute:= TRUE,
							iFunctionNr:= 1,
							nSlaveAddr:= iSlaveAddr_AxisS,
							T_RegulatorSpindle:= T_RegulatorSpindle,
							T_AxisRefIn:= stSRefIn);
			IF FBWriteObject.Done THEN
				iStepResetHardware:=iStepResetHardware + 1;
				FBWriteObject(	bExecute:=FALSE,
								T_AxisRefIn:= stSRefIn);
				xSetParameter:=TRUE;
			END_IF;


		4:	FBReadAxisState(	bExecute:= TRUE,
								iFunctionNr:= 1,
								nSlaveAddr:=iSlaveAddr_AxisZ,
								nSubIndex:=7,		(* Stauts für Z Achse *)
								T_AxisRefIn:= stZRefIn);
			IF FBReadAxisState.Done THEN
				iStepResetHardware:=iStepResetHardware + 1;
				FBReadAxisState(	bExecute:=FALSE,
								T_AxisRefIn:= stZRefIn);
				IF ((FBReadAxisState.dwValueOut AND 16#FF00) = 16#9000) THEN
					T_ExchgParam.T_Visu.T_Message.iState:=310;	(* Warnung: Z Achse: SLS Sicherheitsfunktion aktiviert ! *)
				END_IF;
			END_IF;
		5:	IF (T_ExchgParam.bToolSpindleActive <> 1) THEN	(* nur ausführen wenn nicht Maxon Spindel aktiv ist *)
				CASE T_ExchgParam.bToolSpindleActive OF
				2:	FBReadAxisState(	bExecute:= TRUE,
									iFunctionNr:= 1,
									nSlaveAddr:=iSlaveAddr_AxisS,
									nSubIndex:=7,		(* Stauts für S2 Achse *)
									T_AxisRefIn:= stS2RefIn);
				3:	FBReadAxisState(	bExecute:= TRUE,
									iFunctionNr:= 1,
									nSlaveAddr:=iSlaveAddr_AxisS,
									nSubIndex:=8,		(* Stauts für S3 Achse *)
									T_AxisRefIn:= stS3RefIn);
				END_CASE;
			END_IF;
			IF FBReadAxisState.Done THEN
				iStepResetHardware:=iStepResetHardware + 1;
				CASE T_ExchgParam.bToolSpindleActive OF
				2:	FBReadAxisState(	bExecute:=FALSE,
									T_AxisRefIn:= stS2RefIn);
				3:	FBReadAxisState(	bExecute:=FALSE,
									T_AxisRefIn:= stS3RefIn);
				END_CASE;
				IF ((FBReadAxisState.dwValueOut AND 16#FF00) = 16#9000) THEN
					T_ExchgParam.T_Visu.T_Message.iState:=311;	(* Warnung: S Achse: SLS Sicherheitsfunktion aktiviert ! *)
				END_IF;
			END_IF;

		6:	IF (NOT(T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xReset) AND (T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xDone OR
			     T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xErr)) OR
			    (NOT(T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.xReset) AND (T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.xDone OR
			     T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.xErr)) THEN
				T_TwinSafe_Ctrle_Z_Axis.xError:=TRUE;	(* Resetten der Drive Optionskarte zu AX5000 Servo *)
				T_TwinSafe_Ctrle_S2_Axis.xError:=TRUE;	(* Resetten der Drive Optionskarte zu AX5000 Servo *)
				T_TwinSafe_Ctrle_S3_Axis.xError:=TRUE;	(* Resetten der Drive Optionskarte zu AX5000 Servo *)
				iStepResetHardware:=iStepResetHardware + 1;
			END_IF;
		7:	IF NOT(T_TwinSafe_Status_Z_Axis.xError) AND NOT(T_TwinSafe_Status_S2_Axis.xError) AND NOT(T_TwinSafe_Status_S3_Axis.xError) THEN
				T_TwinSafe_Ctrle_Z_Axis.xError:=FALSE;
				T_TwinSafe_Ctrle_S2_Axis.xError:=FALSE;
				T_TwinSafe_Ctrle_S3_Axis.xError:=FALSE;
				iStepResetHardware:=iStepResetHardware + 1;
			END_IF;
		8:	T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xExecute:=TRUE;
			T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.iFunction:=1;	(* Resetten der NC Ebene *)
			T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.xExecute:=TRUE;
			T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.iFunction:=1;	(* Resetten der NC Ebene *)
			iStepResetHardware:=iStepResetHardware + 1;
		9:	IF (NOT(T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xExecute) AND (T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xDone
			OR T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xErr))
			AND (NOT(T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.xExecute) AND (T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.xDone
			OR T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.xErr)) THEN
				iStepResetHardware:=iStepResetHardware + 1;
			END_IF;
		10:	T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xExecute:=TRUE;
			T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.iFunction:=27;	(* Resetten des AX5000 Servo *)
			T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.xExecute:=(T_ExchgParam.bToolSpindleActive <> 1);		(* Nur ausführen wenn nicht Maxon Spindel aktiv ist *)
			T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.iFunction:=27;	(* Resetten des AX5000 Servo *)
			iStepResetHardware:=iStepResetHardware + 1;
		11:	IF NOT(T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xExecute) AND T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xDone
			AND NOT(T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.xExecute) AND T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.xDone THEN
				T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xExecute:=TRUE;
				T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.iFunction:=1;	(* Resetten der NC Ebene *)
				T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.xExecute:=TRUE;
				T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.iFunction:=1;	(* Resetten der NC Ebene *)
				iStepResetHardware:=iStepResetHardware + 1;
			END_IF;
		12:	IF NOT(T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xExecute) AND T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xDone
			OR NOT(T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.xExecute) AND T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.xDone THEN
				IF T_Station_Work.TControl.xResetHardwareActivateCurrent AND NOT(T_TwinSafe_Status_Z_Axis.xSTO) THEN
					T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xExecute:=TRUE;
					T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.iFunction:=3;	(* Current ON *)
				END_IF;
				iStepResetHardware:=iStepResetHardware + 1;
			END_IF;
		13:	IF NOT(T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xExecute) AND T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xDone THEN
				iStepResetHardware:=1;
				IF NOT(xHardwareActive) THEN
					T_Station_Work.TControl.xActiveHardware:=FALSE;
				END_IF;
				T_Station_Work.TControl.xResetHardware:=FALSE;
			END_IF;
	END_CASE;
	TONWaitTimeOut(IN:=TRUE,PT:=T#3s);
	IF TONWaitTimeOut.Q THEN
		TONWaitTimeOut(IN:=FALSE);
		iStepResetHardware:=1;
		T_Station_Work.TControl.xResetHardware:=FALSE;
		T_Station_Work.THWWorkStation.TAxisZ.T_CtrleSingle.xReset:=TRUE;
		T_Station_Work.THWWorkStation.TAxisS.T_CtrleSingle.xReset:=TRUE;
		T_TwinSafe_Ctrle_Z_Axis.xError:=FALSE;
		T_TwinSafe_Ctrle_S2_Axis.xError:=FALSE;
		T_TwinSafe_Ctrle_S3_Axis.xError:=FALSE;
	END_IF;
ELSE
	TONWaitTimeOut(IN:=FALSE);
	iStepResetHardware:=1;
	T_Station_Work.TControl.xResetHardwareActivateCurrent:=FALSE;
END_IF;
IF T_Station_Work.TControl.xActiveHardware AND NOT(T_Station_Work.TControl.xResetHardware) THEN
	IF T_TwinSafe_Status_Z_Axis.xError OR ((T_TwinSafe_Status_S2_Axis.xError OR T_TwinSafe_Status_S3_Axis.xError) AND (T_ExchgParam.bToolSpindleActive <> 1)) THEN	(* Z Achse oder nur wenn nicht Maxon Spindel aktiv ist *)
		T_Station_Work.TControl.xResetHardware:=TRUE;
	END_IF;
END_IF;
xActiveHWStation:=T_Station_Work.TControl.xActiveHardware;
xActiveStation:=T_Station_Work.xActive;
RisingEdgeHWConfig(CLK:=xHardwareConfigError);
IF RisingEdgeHWConfig.Q THEN
	T_Station_Work.TControl.diErrorNr:=0;
	T_Station_Work.TControl.xError:=FALSE;
END_IF;

IF NOT(T_Station_Work.TControl.xActiveHardware) THEN
	T_Station_Work.TControl.xHWAxesActive:=TRUE;
	xHardwareConfigError:=FALSE;
	TONTickTime(IN:=FALSE);
	T_Station_Work.TControl.xActiveMovement:=FALSE;
	A01_AX5000_Parametrization;
	RETURN;
ELSE
	T_Station_Work.THWWorkStation.TAxisZ.T_DriveState:=stZDriveState;
	(* Zuweisung der Datenstrukturen der Aktuatoren als Pointer *)
	ptrTAxisZ:=ADR(T_Station_Work.THWWorkStation.TAxisZ);
	ptrTAxisS:=ADR(T_Station_Work.THWWorkStation.TAxisS);
	ptrTCylToolDeflection:=ADR(T_Station_Work.THWWorkStation.TCylToolDeflection);
	ptrTSensorTorque:=ADR(T_Station_Work.THWWorkStation.TSensorTorque);
	ptrTSensorTorqueOverload:=ADR(T_Station_Work.THWWorkStation.TSensorTorqueOverload);
	ptrTCylBrakeReleaseZAxis:=ADR(T_Station_Work.THWWorkStation.TCylBrakeReleaseZAxis);
	ptrTCylToolTorqueHC:=ADR(T_Station_Work.THWWorkStation.TCylToolTorqueHC);
	ptrTCylToolTorqueOverload:=ADR(T_Station_Work.THWWorkStation.TCylToolTorqueOverload);
	ptrTTorqueSensorMeasRange:=ADR(T_Station_Work.THWWorkStation.TTorqueSensorMeasRange);
	ptrTTorqueSensorControl:=ADR(T_Station_Work.THWWorkStation.TTorqueSensorControl);
	ptrTCylWorkpieceClamp:=ADR(T_Station_Work.THWWorkStation.TCylWorkpieceClamp);
	ptrTValveAirTable:=ADR(T_Station_Work.THWWorkStation.TValveAirTable);
	ptrTValveVacuumTable:=ADR(T_Station_Work.THWWorkStation.TValveVacuumTable);
	ptrTValveCleanNozzle:=ADR(T_Station_Work.THWWorkStation.TValveCleanNozzle);
	ptrTAxisBubbler:=ADR(T_Station_Work.THWWorkStation.TAxisBubbler);
	ptrTAxisFeedPump:=ADR(T_Station_Work.THWWorkStation.TAxisFeedPump);
	xEnableMasterModul:=TRUE;
	A01_DefineParameter;
	A01_InitParam;
END_IF;
(******************************************************************************************************************************************)
(****************************				         Check if Axis Active                                              *****************************)
(******************************************************************************************************************************************)
IF ptrTAxisZ^.T_CtrleSingle.xDone AND ptrTAxisS^.T_CtrleSingle.xDone THEN
	T_Station_Work.TControl.xHWAxesActive:=FALSE;
ELSE
	T_Station_Work.TControl.xHWAxesActive:=TRUE;
END_IF;
(******************************************************************************************************************************************)
(****************************	                        Check if Axis and Cylinder are Active                         *****************************)
(******************************************************************************************************************************************)
xCkeckAcitveMovement:=	(NOT(ptrTAxisZ^.T_CtrleSingle.xDone) AND NOT(ptrTAxisZ^.T_CtrleSingle.xErr))
						OR (NOT(ptrTAxisS^.T_CtrleSingle.xDone) AND NOT(ptrTAxisS^.T_CtrleSingle.xErr))
						OR (NOT(ptrTCylToolDeflection^.T_CtrleCyl.xDone) AND NOT(ptrTCylToolDeflection^.T_CtrleCyl.xErr))
						OR (NOT(ptrTCylToolTorqueHC^.T_CtrleCyl.xDone) AND NOT(ptrTCylToolTorqueHC^.T_CtrleCyl.xErr))
						OR (NOT(ptrTCylToolTorqueOverload^.T_CtrleCyl.xDone) AND NOT(ptrTCylToolTorqueOverload^.T_CtrleCyl.xErr))
						OR (NOT(ptrTTorqueSensorMeasRange^.T_CtrleCyl.xDone) AND NOT(ptrTTorqueSensorMeasRange^.T_CtrleCyl.xErr))
						OR (NOT(ptrTTorqueSensorControl^.T_CtrleCyl.xDone) AND NOT(ptrTTorqueSensorControl^.T_CtrleCyl.xErr))
						OR (NOT(ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xDone) AND NOT(ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xErr))
						OR (NOT(ptrTCylWorkpieceClamp^.T_CtrleCyl.xDone) AND NOT(ptrTCylWorkpieceClamp^.T_CtrleCyl.xErr))
						OR (NOT(ptrTValveAirTable^.T_CtrleCyl.xDone) AND NOT(ptrTValveAirTable^.T_CtrleCyl.xErr))
						OR (NOT(ptrTValveVacuumTable^.T_CtrleCyl.xDone) AND NOT(ptrTValveVacuumTable^.T_CtrleCyl.xErr))
						OR (NOT(ptrTValveCleanNozzle^.T_CtrleCyl.xDone) AND NOT(ptrTValveCleanNozzle^.T_CtrleCyl.xErr))
						OR (NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xDone) AND NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xErr))
						OR (NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xDone) AND NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xErr));
IF NOT(xCkeckAcitveMovement) THEN
	IF NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) AND ptrTAxisZ^.T_CtrleSingle.xPower AND NOT(ptrTAxisZ^.T_CtrleSingle.xErr) THEN
		xCkeckAcitveMovement:=TRUE;
	END_IF;
	IF NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) AND ptrTAxisS^.T_CtrleSingle.xPower AND NOT(ptrTAxisS^.T_CtrleSingle.xErr) THEN
		xCkeckAcitveMovement:=TRUE;
	END_IF;
END_IF;
T_Station_Work.TControl.xActiveMovement:=xCkeckAcitveMovement;
(* HW Axis and Cylinder *)
HW_Axis_DC;	(* IGS3 *)
HW_AxisZ;
HW_AxisS;
HW_CylToolDeflection;
CASE T_ExchgParam.bToolSpindleActive OF
1:	(* Maxon Spindel *)
	HW_ToolTorqueHC;
	HW_ToolTorqueOverload;
	HW_TorqueSensor;
2,3:	(* Beckhoff Spindel *)
	HW_TorqueSensor2;
	HW_TorqueOverloadSensor;
END_CASE;
HW_TorqueSensorMeasureRange;
HW_TorqueSensorControl;
(* Beckhoff Spindel L = 0-2000(500)mNm	Beckhoff Spindel M = 0-500(100)mNm		-> nur Spindel M wird der kleine Bereich eingesetzt *)
IF (T_ExchgParam.bToolSpindleActive = 3) AND NOT(ptrTTorqueSensorMeasRange^.T_CtrleCyl.xExecute) AND ptrTTorqueSensorMeasRange^.T_CtrleCyl.xDone AND NOT(ptrTTorqueSensorMeasRange^.T_CtrleCyl.T_Standard.xActivOn) THEN
	ptrTTorqueSensorMeasRange^.T_CtrleCyl.iFunction:=2;
	ptrTTorqueSensorMeasRange^.T_CtrleCyl.xExecute:=TRUE;
END_IF;
HW_CylBrakeReleaseZAxis;
HW_CylWorkpieceClamp;
HW_ValveAirTable;
HW_ValveVacuumTable;
HW_ValveCleanNozzle; 	(* BEF *)
HW_TSensorToolSpindle_L_Connect;
(******************************************************************************************************************************************)
(****************************				                Reset Flags                                                           *****************************)
(******************************************************************************************************************************************)
ptrTAxisZ^.T_CtrleSingle.xReset:=FALSE;
ptrTAxisZ^.T_CtrleSingle.xExecute:=FALSE;
ptrTAxisS^.T_CtrleSingle.xReset:=FALSE;
ptrTAxisS^.T_CtrleSingle.xExecute:=FALSE;
ptrTCylToolDeflection^.T_CtrleCyl.xReset:=FALSE;
ptrTCylToolDeflection^.T_CtrleCyl.xExecute:=FALSE;
ptrTCylToolTorqueHC^.T_CtrleCyl.xReset:=FALSE;
ptrTCylToolTorqueHC^.T_CtrleCyl.xExecute:=FALSE;
ptrTCylToolTorqueOverload^.T_CtrleCyl.xReset:=FALSE;
ptrTCylToolTorqueOverload^.T_CtrleCyl.xExecute:=FALSE;
IF  (T_ExchgParam.bToolSpindleActive <> 1) THEN			(* diese Zylinder immer xDone schalten wenn nicht Maxon Spindel aktiv ist *)
	ptrTCylToolTorqueHC^.T_CtrleCyl.xDone:=TRUE;
	ptrTCylToolTorqueOverload^.T_CtrleCyl.xDone:=TRUE;
END_IF;
ptrTSensorTorque^.T_CtrleCyl.xReset:=FALSE;
ptrTSensorTorque^.T_CtrleCyl.xExecute:=FALSE;
ptrTSensorTorqueOverload^.T_CtrleCyl.xReset:=FALSE;
ptrTSensorTorqueOverload^.T_CtrleCyl.xExecute:=FALSE;
ptrTTorqueSensorMeasRange^.T_CtrleCyl.xReset:=FALSE;
ptrTTorqueSensorMeasRange^.T_CtrleCyl.xExecute:=FALSE;
ptrTTorqueSensorControl^.T_CtrleCyl.xReset:=FALSE;
ptrTTorqueSensorControl^.T_CtrleCyl.xExecute:=FALSE;
ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xReset:=FALSE;
ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xExecute:=FALSE;
ptrTCylWorkpieceClamp^.T_CtrleCyl.xReset:=FALSE;
ptrTCylWorkpieceClamp^.T_CtrleCyl.xExecute:=FALSE;
ptrTValveAirTable^.T_CtrleCyl.xReset:=FALSE;
ptrTValveAirTable^.T_CtrleCyl.xExecute:=FALSE;
ptrTValveVacuumTable^.T_CtrleCyl.xReset:=FALSE;
ptrTValveVacuumTable^.T_CtrleCyl.xExecute:=FALSE;
ptrTValveCleanNozzle^.T_CtrleCyl.xReset:=FALSE;
ptrTValveCleanNozzle^.T_CtrleCyl.xExecute:=FALSE;
ptrTAxisBubbler^.T_CtrleDCAxis.xReset:=FALSE;
ptrTAxisBubbler^.T_CtrleDCAxis.xExecute:=FALSE;
ptrTAxisFeedPump^.T_CtrleDCAxis.xReset:=FALSE;
ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute:=FALSE;

END_FUNCTION_BLOCK
ACTION	A01_AX5000_Parametrization:
IF T_ExchgParam.xWriteSoEParameter THEN
	CASE iStepWriteSoEParameter OF
	0:	CASE T_ExchgParam.bToolSpindleActive OF
		2:	iStepWriteSoEParameter:=iStepWriteSoEParameter + 1;
		3:	iStepWriteSoEParameter:=11;
		END_CASE;


	1:	fbGetAmsNetID(	sNetId:= '',
						iAxisId:= DWORD_TO_UINT(stS2RefIn.nAxisId),
						bExecute := TRUE);
		IF NOT fbGetAmsNetID.bBusy AND NOT fbGetAmsNetID.bError THEN
			fbGetAmsNetID.AxisNetId;
			sEtherCATNetId 	:= fbGetAmsNetID.AxisNetId;
			fbGetAmsNetID(	sNetId:= '',
							iAxisId:= DWORD_TO_UINT(stS2RefIn.nAxisId),
							bExecute := FALSE);
			iStepWriteSoEParameter:=iStepWriteSoEParameter + 1;
		ELSIF fbGetAmsNetID.bError THEN
			iStepWriteSoEParameter:=99;
		END_IF

	(* AX5000 in PreOP Mode setzen *)
	2:	fbSetSlaveState(	sNetId:= sEtherCATNetId,
						nSlaveAddr:= iSlaveAddr_AxisS,
						bExecute:= TRUE,
						tTimeout:= T#10s,
						reqState:= EC_DEVICE_STATE_PREOP);
		IF NOT(fbSetSlaveState.bBusy) OR fbSetSlaveState.bError THEN
			fbSetSlaveState(bExecute:=FALSE);
			iStepWriteSoEParameter:=iStepWriteSoEParameter + 1;
		END_IF;
	3:	fbGetSlaveState(	sNetId:=sEtherCATNetId,
						nSlaveAddr:=iSlaveAddr_AxisS,
						bExecute:=TRUE ,
						tTimeout:= t#10s,
						bBusy=> ,
						bError=> ,
						nErrId=> ,
						state=> );
		IF NOT fbGetSlaveState.bBusy AND NOT fbGetSlaveState.bError AND fbGetSlaveState.state.deviceState = fbSetSlaveState.reqState THEN
			fbGetSlaveState(bExecute:=FALSE);
			iStepWriteSoEParameter:=iStepWriteSoEParameter + 1;
		ELSIF fbGetSlaveState.bError THEN
			iStepWriteSoEParameter:=99;
		END_IF;

	(* P-0-0061 schreiben von Achse S2 *)
	4:	fbSoEWrite(	sNetId:=sEtherCATNetId,
					nSlaveAddr:= iSlaveAddr_AxisS,
					nIdn:=P_0_IDN + 61 ,
					nElement:=16#40 ,
					pSrcBuf:=ADR(T_Station_Parameter.T_AxisS2.uiP61) ,
					cbBufLen:=SIZEOF(T_Station_Parameter.T_AxisS2.uiP61) ,
					bExecute:=TRUE ,
					tTimeout:=t#10s ,
					nDriveNo:=0);		(* 0=Kanal A, 1=Kanal B *)
		IF NOT  fbSoEWrite.bBusy AND NOT fbSoEWrite.bError THEN
			fbSoEWrite(bExecute:=FALSE);
			iStepWriteSoEParameter:=iStepWriteSoEParameter + 1;
		ELSIF fbSoEWrite.bError THEN
			iStepWriteSoEParameter:=99;
		END_IF;

	(* P-0-0150 schreiben von Achse S2 *)
	5:	fbSoEWrite(	sNetId:=sEtherCATNetId,
					nSlaveAddr:= iSlaveAddr_AxisS,
					nIdn:=P_0_IDN + 150 ,
					nElement:=16#40 ,
					pSrcBuf:=ADR(T_Station_Parameter.T_AxisS2.bP150) ,
					cbBufLen:=SIZEOF(T_Station_Parameter.T_AxisS2.bP150) ,
					bExecute:=TRUE ,
					tTimeout:=t#10s ,
					nDriveNo:=0);		(* 0=Kanal A, 1=Kanal B *)
		IF NOT  fbSoEWrite.bBusy AND NOT fbSoEWrite.bError THEN
			fbSoEWrite(bExecute:=FALSE);
			iStepWriteSoEParameter:=iStepWriteSoEParameter + 1;
		ELSIF fbSoEWrite.bError THEN
			iStepWriteSoEParameter:=99;
		END_IF;

	(* AX5000 in OP Mode setzen *)
	6:	fbSetSlaveState(	sNetId:= sEtherCATNetId,
						nSlaveAddr:= iSlaveAddr_AxisS,
						bExecute:= TRUE,
						tTimeout:= T#10s,
						reqState:= EC_DEVICE_STATE_OP);
		IF NOT(fbSetSlaveState.bBusy) OR fbSetSlaveState.bError THEN
			fbSetSlaveState(bExecute:=FALSE);
			iStepWriteSoEParameter:=iStepWriteSoEParameter + 1;
		END_IF;
	7:	fbGetSlaveState(	sNetId:=sEtherCATNetId,
						nSlaveAddr:=iSlaveAddr_AxisS,
						bExecute:=TRUE ,
						tTimeout:= t#10s,
						bBusy=> ,
						bError=> ,
						nErrId=> ,
						state=> );
		IF NOT fbGetSlaveState.bBusy AND NOT fbGetSlaveState.bError AND (fbGetSlaveState.state.deviceState = fbSetSlaveState.reqState) THEN
			fbGetSlaveState(bExecute:=FALSE);
			T_ExchgParam.xWriteSoEParameter:=FALSE;
		ELSIF fbGetSlaveState.bError THEN
			iStepWriteSoEParameter:=99;
		ELSIF NOT fbGetSlaveState.bBusy AND NOT fbGetSlaveState.bError AND (fbGetSlaveState.state.deviceState = 82) THEN	(* deviceState = 82 => ERR_PREOP *)
			T_Station_Work.TControl.diErrorNr:=11;	(* Achsen MasterModul2 konnte den Spindelkopf L Kanal 1 nicht finden *)
			T_Station_Work.TControl.xError:=TRUE;
		END_IF;



	11:	fbGetAmsNetID(	sNetId:= '',
						iAxisId:= DWORD_TO_UINT(stS3RefIn.nAxisId),
						bExecute := TRUE);
		IF NOT fbGetAmsNetID.bBusy AND NOT fbGetAmsNetID.bError THEN
			fbGetAmsNetID.AxisNetId;
			sEtherCATNetId 	:= fbGetAmsNetID.AxisNetId;
			fbGetAmsNetID(	sNetId:= '',
							iAxisId:= DWORD_TO_UINT(stS3RefIn.nAxisId),
							bExecute := FALSE);
			iStepWriteSoEParameter:=iStepWriteSoEParameter + 1;
		ELSIF fbGetAmsNetID.bError THEN
			iStepWriteSoEParameter:=99;
		END_IF

	(* AX5000 in PreOP Mode setzen *)
	12:	fbSetSlaveState(	sNetId:= sEtherCATNetId,
						nSlaveAddr:= iSlaveAddr_AxisS,
						bExecute:= TRUE,
						tTimeout:= T#10s,
						reqState:= EC_DEVICE_STATE_PREOP);
		IF NOT(fbSetSlaveState.bBusy) OR fbSetSlaveState.bError THEN
			fbSetSlaveState(bExecute:=FALSE);
			iStepWriteSoEParameter:=iStepWriteSoEParameter + 1;
		END_IF;
	13:	fbGetSlaveState(	sNetId:=sEtherCATNetId,
						nSlaveAddr:=iSlaveAddr_AxisS,
						bExecute:=TRUE ,
						tTimeout:= t#10s,
						bBusy=> ,
						bError=> ,
						nErrId=> ,
						state=> );
		IF NOT fbGetSlaveState.bBusy AND NOT fbGetSlaveState.bError AND fbGetSlaveState.state.deviceState = fbSetSlaveState.reqState THEN
			fbGetSlaveState(bExecute:=FALSE);
			iStepWriteSoEParameter:=iStepWriteSoEParameter + 1;
		ELSIF fbGetSlaveState.bError THEN
			iStepWriteSoEParameter:=99;
		END_IF;

	(* P-0-0061 schreiben von Achse S3 *)
	14:	fbSoEWrite(	sNetId:=sEtherCATNetId,
					nSlaveAddr:= iSlaveAddr_AxisS,
					nIdn:=P_0_IDN + 61 ,
					nElement:=16#40 ,
					pSrcBuf:=ADR(T_Station_Parameter.T_AxisS3.uiP61) ,
					cbBufLen:=SIZEOF(T_Station_Parameter.T_AxisS3.uiP61) ,
					bExecute:=TRUE ,
					tTimeout:=t#10s ,
					nDriveNo:=1);		(* 0=Kanal A, 1=Kanal B *)
		IF NOT  fbSoEWrite.bBusy AND NOT fbSoEWrite.bError THEN
			fbSoEWrite(bExecute:=FALSE);
			iStepWriteSoEParameter:=iStepWriteSoEParameter + 1;
		ELSIF fbSoEWrite.bError THEN
			iStepWriteSoEParameter:=99;
		END_IF;

	(* P-0-0150 schreiben von Achse S2 *)
	15:	fbSoEWrite(	sNetId:=sEtherCATNetId,
					nSlaveAddr:= iSlaveAddr_AxisS,
					nIdn:=P_0_IDN + 150 ,
					nElement:=16#40 ,
					pSrcBuf:=ADR(T_Station_Parameter.T_AxisS3.bP150) ,
					cbBufLen:=SIZEOF(T_Station_Parameter.T_AxisS3.bP150) ,
					bExecute:=TRUE ,
					tTimeout:=t#10s ,
					nDriveNo:=1);		(* 0=Kanal A, 1=Kanal B *)
		IF NOT  fbSoEWrite.bBusy AND NOT fbSoEWrite.bError THEN
			fbSoEWrite(bExecute:=FALSE);
			iStepWriteSoEParameter:=iStepWriteSoEParameter + 1;
		ELSIF fbSoEWrite.bError THEN
			iStepWriteSoEParameter:=99;
		END_IF;

	(* AX5000 in OP Mode setzen *)
	16:	fbSetSlaveState(	sNetId:= sEtherCATNetId,
						nSlaveAddr:= iSlaveAddr_AxisS,
						bExecute:= TRUE,
						tTimeout:= T#10s,
						reqState:= EC_DEVICE_STATE_OP);
		IF NOT(fbSetSlaveState.bBusy) OR fbSetSlaveState.bError THEN
			fbSetSlaveState(bExecute:=FALSE);
			iStepWriteSoEParameter:=iStepWriteSoEParameter + 1;
		END_IF;
	17:	fbGetSlaveState(	sNetId:=sEtherCATNetId,
						nSlaveAddr:=iSlaveAddr_AxisS,
						bExecute:=TRUE ,
						tTimeout:= t#10s,
						bBusy=> ,
						bError=> ,
						nErrId=> ,
						state=> );
		IF NOT fbGetSlaveState.bBusy AND NOT fbGetSlaveState.bError AND (fbGetSlaveState.state.deviceState = fbSetSlaveState.reqState) THEN
			fbGetSlaveState(bExecute:=FALSE);
			T_ExchgParam.xWriteSoEParameter:=FALSE;
		ELSIF fbGetSlaveState.bError THEN
			iStepWriteSoEParameter:=99;
		ELSIF NOT fbGetSlaveState.bBusy AND NOT fbGetSlaveState.bError AND (fbGetSlaveState.state.deviceState = 82) THEN	(* deviceState = 82 => ERR_PREOP *)
			T_Station_Work.TControl.diErrorNr:=12;	(* Achsen MasterModul2 konnte den Spindelkopf M Kanal 2 nicht finden *)
			T_Station_Work.TControl.xError:=TRUE;
		END_IF;
	ELSE

		fbGetAmsNetID(bExecute:=FALSE);
		fbSetSlaveState(bExecute:=FALSE);
		fbGetSlaveState(bExecute:=FALSE);
		fbSoEWrite(bExecute:=FALSE);
		iStepWriteSoEParameter:=0;
		T_Station_Work.TControl.diErrorNr:=10;	(* AX5000 Parameter konnte nicht erfolgreich geschrieben werden *)
		T_Station_Work.TControl.xError:=TRUE;

	END_CASE
ELSE
	iStepWriteSoEParameter:=0;
END_IF



IF xReadSoEParameter THEN
	CASE iStepReadSoEParameter OF
	0:	fbGetAmsNetID(	sNetId:= '',
						iAxisId:= DWORD_TO_UINT(stS2RefIn.nAxisId),
						bExecute := TRUE);
		IF NOT fbGetAmsNetID.bBusy AND NOT fbGetAmsNetID.bError THEN
			fbGetAmsNetID.AxisNetId;
			sEtherCATNetId 	:= fbGetAmsNetID.AxisNetId;
			fbGetAmsNetID(	sNetId:= '',
							iAxisId:= DWORD_TO_UINT(stS2RefIn.nAxisId),
							bExecute := FALSE);
			iStepReadSoEParameter:=iStepReadSoEParameter + 1;
		END_IF

	(* P-0-0061 lesen von Achse S2 *)
	1:	fbSoERead(	sNetId:=sEtherCATNetId,
					nSlaveAddr:= iSlaveAddr_AxisS,
					nIdn:=P_0_IDN + 61 ,
					nElement:=16#40 ,
					pDstBuf:=ADR(T_Station_Parameter.T_AxisS2.uiP61) ,
					cbBufLen:=SIZEOF(T_Station_Parameter.T_AxisS2.uiP61) ,
					bExecute:=TRUE ,
					tTimeout:=t#10s ,
					nDriveNo:=0);		(* 0=Kanal A, 1=Kanal B *)
		IF NOT  fbSoERead.bBusy AND NOT fbSoERead.bError THEN
			FBSoERead(bExecute:=FALSE);
			iStepReadSoEParameter:=iStepReadSoEParameter + 1;
		ELSIF fbSoERead.bError THEN
			;
		END_IF;

	(* P-0-0150 lesen von Achse S2 *)
	2:	fbSoERead(	sNetId:=sEtherCATNetId,
					nSlaveAddr:= iSlaveAddr_AxisS,
					nIdn:=P_0_IDN + 150 ,
					nElement:=16#40 ,
					pDstBuf:=ADR(T_Station_Parameter.T_AxisS2.bP150) ,
					cbBufLen:=SIZEOF(T_Station_Parameter.T_AxisS2.bP150) ,
					bExecute:=TRUE ,
					tTimeout:=t#10s ,
					nDriveNo:=0);		(* 0=Kanal A, 1=Kanal B *)
		IF NOT  fbSoERead.bBusy AND NOT fbSoERead.bError THEN
			FBSoERead(bExecute:=FALSE);
			iStepReadSoEParameter:=10;
		ELSIF fbSoERead.bError THEN
			;
		END_IF;

	10:	fbGetAmsNetID(	sNetId:= '',
						iAxisId:= DWORD_TO_UINT(stS3RefIn.nAxisId),
						bExecute := TRUE);
		IF NOT fbGetAmsNetID.bBusy AND NOT fbGetAmsNetID.bError THEN
			fbGetAmsNetID.AxisNetId;
			sEtherCATNetId 	:= fbGetAmsNetID.AxisNetId;
			fbGetAmsNetID(	sNetId:= '',
							iAxisId:= DWORD_TO_UINT(stS3RefIn.nAxisId),
							bExecute := FALSE);
			iStepReadSoEParameter:=iStepReadSoEParameter + 1;
		END_IF

	(* P-0-0061 lesen von Achse S3 *)
	11:	fbSoERead(	sNetId:=sEtherCATNetId,
					nSlaveAddr:= iSlaveAddr_AxisS,
					nIdn:=P_0_IDN + 61 ,
					nElement:=16#40 ,
					pDstBuf:=ADR(T_Station_Parameter.T_AxisS3.uiP61) ,
					cbBufLen:=SIZEOF(T_Station_Parameter.T_AxisS3.uiP61) ,
					bExecute:=TRUE ,
					tTimeout:=t#10s ,
					nDriveNo:=1);		(* 0=Kanal A, 1=Kanal B *)
		IF NOT  fbSoERead.bBusy AND NOT fbSoERead.bError THEN
			FBSoERead(bExecute:=FALSE);
			iStepReadSoEParameter:=iStepReadSoEParameter + 1;
		ELSIF fbSoERead.bError THEN
			;
		END_IF;

	(* P-0-0150 lesen von Achse S3 *)
	12:	fbSoERead(	sNetId:=sEtherCATNetId,
					nSlaveAddr:= iSlaveAddr_AxisS,
					nIdn:=P_0_IDN + 150 ,
					nElement:=16#40 ,
					pDstBuf:=ADR(T_Station_Parameter.T_AxisS3.bP150) ,
					cbBufLen:=SIZEOF(T_Station_Parameter.T_AxisS3.bP150) ,
					bExecute:=TRUE ,
					tTimeout:=t#10s ,
					nDriveNo:=1);		(* 0=Kanal A, 1=Kanal B *)
		IF NOT  fbSoERead.bBusy AND NOT fbSoERead.bError THEN
			FBSoERead(bExecute:=FALSE);
			xReadSoEParameter:=FALSE;
		ELSIF fbSoERead.bError THEN
			;
		END_IF;
	END_CASE
ELSE
	iStepReadSoEParameter:=0;
END_IF
END_ACTION

ACTION	A01_DefineParameter:
(*Define Constant Axis Param Working Station*)
	gcarAxisConfig[gciAxisZ_St1].rIncFast				:=T_ExchgParam.T_TeachIn.arTeachSelStep[gciAxisZ_St1];
	gcarAxisConfig[gciAxisZ_St1].rIncSlow			:=T_ExchgParam.T_TeachIn.arTeachSelStep[gciAxisZ_St1];
	gcarAxisConfig[gciAxisZ_St1].rPositionSpeed		:=30.0;
	gcarAxisConfig[gciAxisZ_St1].rRefPosition			:=T_Station_Parameter.T_AxisState.rPositionReferenceZAxis;
	gcarAxisConfig[gciAxisZ_St1].rRefSpeed			:=20.0;
	gcarAxisConfig[gciAxisZ_St1].rVelFast				:=T_ExchgParam.T_TeachIn.arTeachSelVel[gciAxisZ_St1];
	gcarAxisConfig[gciAxisZ_St1].rVelSlow			:=T_ExchgParam.T_TeachIn.arTeachSelVel[gciAxisZ_St1];
	gcarAxisConfig[gciAxisZ_St1].rAcceleration		:=80000.0;	(* 88000 *)
	gcarAxisConfig[gciAxisZ_St1].rDeceleration		:=80000.0;	(* 88000 *)
	gcarAxisConfig[gciAxisZ_St1].rJerk				:=30000.0;	(* 88000 *)
	ptrTAxisZ^.T_Config_Gen.wPosLimitSwitchBit	:=8;
	ptrTAxisZ^.T_Config_Gen.wNegLimitSwitchBit	:=16;

	gcarAxisConfig[gciAxisS_St1].rIncFast				:=T_ExchgParam.T_TeachIn.arTeachSelStep[gciAxisS_St1];
	gcarAxisConfig[gciAxisS_St1].rIncSlow			:=T_ExchgParam.T_TeachIn.arTeachSelStep[gciAxisS_St1];
	gcarAxisConfig[gciAxisS_St1].rPositionSpeed		:=0.0;
	gcarAxisConfig[gciAxisS_St1].rRefPosition			:=0.0;
	gcarAxisConfig[gciAxisS_St1].rRefSpeed			:=0.0;
	gcarAxisConfig[gciAxisS_St1].rVelFast				:=T_ExchgParam.T_TeachIn.arTeachSelVel[gciAxisS_St1];
	gcarAxisConfig[gciAxisS_St1].rVelSlow			:=T_ExchgParam.T_TeachIn.arTeachSelVel[gciAxisS_St1];
	gcarAxisConfig[gciAxisS_St1].rAcceleration		:=200000.0;
	gcarAxisConfig[gciAxisS_St1].rDeceleration		:=200000.0;
	gcarAxisConfig[gciAxisS_St1].rJerk				:=200000.0;
	CASE T_ExchgParam.bToolSpindleActive OF
	1:	(* Maxon Spindel *)
		T_Station_Work.THWWorkStation.TCtrlWork.rMaxToolSpindleSpeed:=grMaxSAxis_Speed_SM * T_Station_Parameter.T_TorqueSystem.rGearRatioGearBox;
	2:	(* Beckhoff Spindel L *)
		T_Station_Work.THWWorkStation.TCtrlWork.rMaxToolSpindleSpeed:=grMaxSAxis_Speed_L;
	3:	(* Beckhoff Spindel M *)
		T_Station_Work.THWWorkStation.TCtrlWork.rMaxToolSpindleSpeed:=grMaxSAxis_Speed_M;
	END_CASE;
END_ACTION

ACTION	A01_InitParam:
(* Axis Z *)
ptrTAxisZ^.T_Config_Gen.iTyp													:=1;
ptrTAxisZ^.T_Config_Setting.xSoftwareLimitNeg									:=FALSE;
ptrTAxisZ^.T_Config_Setting.xSoftwareLimitPos									:=FALSE;
ptrTAxisZ^.T_Config_Setting.xHardwareLimitNeg									:=TRUE;
ptrTAxisZ^.T_Config_Setting.xHardwareLimitPos									:=TRUE;
ptrTAxisZ^.T_CtrleSingle.xMoveAwayFromHWLimitSwitchActive						:=TRUE;
ptrTAxisZ^.T_CtrleSingle.xAX5000Active											:=TRUE;
ptrTAxisZ^.T_Config_Setting.xAbsoluteEncoder									:=TRUE;
ptrTAxisZ^.T_CtrleSingle.xKL2541Active											:=FALSE;
ptrTAxisZ^.T_CtrleSingle.lrAcceleration											:=gcarAxisConfig[gciAxisZ_St1].rAcceleration;
ptrTAxisZ^.T_CtrleSingle.lrDecceleration											:=gcarAxisConfig[gciAxisZ_St1].rDeceleration;
ptrTAxisZ^.T_CtrleSingle.lrJerk													:=gcarAxisConfig[gciAxisZ_St1].rJerk;

(* Axis S *)
ptrTAxisS^.T_Config_Gen.iTyp													:=2;
ptrTAxisS^.T_Config_Setting.xSoftwareLimitNeg									:=FALSE;
ptrTAxisS^.T_Config_Setting.xSoftwareLimitPos									:=FALSE;
ptrTAxisS^.T_Config_Setting.xHardwareLimitNeg									:=FALSE;
ptrTAxisS^.T_Config_Setting.xHardwareLimitPos									:=FALSE;
ptrTAxisS^.T_CtrleSingle.xMoveAwayFromHWLimitSwitchActive						:=FALSE;
ptrTAxisS^.T_CtrleSingle.xAX5000Active											:=FALSE;
ptrTAxisS^.T_Config_Setting.xAbsoluteEncoder									:=FALSE;
ptrTAxisS^.T_CtrleSingle.xKL2541Active											:=FALSE;
ptrTAxisS^.T_CtrleSingle.lrAcceleration											:=gcarAxisConfig[gciAxisS_St1].rAcceleration;
ptrTAxisS^.T_CtrleSingle.lrDecceleration											:=gcarAxisConfig[gciAxisS_St1].rDeceleration;
ptrTAxisS^.T_CtrleSingle.lrJerk													:=gcarAxisConfig[gciAxisS_St1].rJerk;

(* Config Cyl ToolDeflection *)
ptrTCylToolDeflection^.iCylinderTpye											:=1;
ptrTCylToolDeflection^.T_CtrleCyl.xFBActiv										:=T_Station_Work.TControl.xEnable;
ptrTCylToolDeflection^.T_Config.xActivState										:=TRUE;
ptrTCylToolDeflection^.T_Config.xCtrlePosOff										:=FALSE;
ptrTCylToolDeflection^.T_Config.xCtrlePosOn										:=FALSE;
ptrTCylToolDeflection^.T_Config.tTimeOut										:=T#0s;
ptrTCylToolDeflection^.T_Config.tDelayOff										:=ptrTCylToolDeflection^.T_Config.tDelayOff;
ptrTCylToolDeflection^.T_Config.tDelayOn										:=ptrTCylToolDeflection^.T_Config.tDelayOn;
ptrTCylToolDeflection^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff					:=ptrTCylToolDeflection^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff;
ptrTCylToolDeflection^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn					:=ptrTCylToolDeflection^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn;
ptrTCylToolDeflection^.T_CtrleCyl.T_Standard.tDelayActiv							:=T#0s;
ptrTCylToolDeflection^.T_Config.tDelayPreOff										:=T#0s;
ptrTCylToolDeflection^.T_Config.tDelayPreOn										:=T#0s;

(* Config Cyl ToolTorqueHC *)
ptrTCylToolTorqueHC^.iCylinderTpye											:=2;
ptrTCylToolTorqueHC^.T_CtrleCyl.xFBActiv										:=T_Station_Work.TControl.xEnable;
ptrTCylToolTorqueHC^.T_Config.xActivState										:=TRUE;
ptrTCylToolTorqueHC^.T_Config.xCtrlePosOff										:=FALSE;
ptrTCylToolTorqueHC^.T_Config.xCtrlePosOn										:=FALSE;
ptrTCylToolTorqueHC^.T_Config.tTimeOut										:=T#0s;
ptrTCylToolTorqueHC^.T_Config.tDelayOff										:=ptrTCylToolTorqueHC^.T_Config.tDelayOff;
ptrTCylToolTorqueHC^.T_Config.tDelayOn										:=ptrTCylToolTorqueHC^.T_Config.tDelayOn;
ptrTCylToolTorqueHC^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff					:=ptrTCylToolTorqueHC^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff;
ptrTCylToolTorqueHC^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn					:=ptrTCylToolTorqueHC^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn;
ptrTCylToolTorqueHC^.T_CtrleCyl.T_Standard.tDelayActiv							:=T#0s;
ptrTCylToolTorqueHC^.T_Config.tDelayPreOff										:=T#0s;
ptrTCylToolTorqueHC^.T_Config.tDelayPreOn										:=T#0s;

(* Config Cyl ToolTorqueOverload *)
ptrTCylToolTorqueOverload^.iCylinderTpye										:=3;
ptrTCylToolTorqueOverload^.T_CtrleCyl.xFBActiv									:=T_Station_Work.TControl.xEnable;
ptrTCylToolTorqueOverload^.T_Config.xActivState									:=TRUE;
ptrTCylToolTorqueOverload^.T_Config.xCtrlePosOff								:=FALSE;
ptrTCylToolTorqueOverload^.T_Config.xCtrlePosOn								:=FALSE;
ptrTCylToolTorqueOverload^.T_Config.tTimeOut									:=T#0s;
ptrTCylToolTorqueOverload^.T_Config.tDelayOff									:=ptrTCylToolTorqueOverload^.T_Config.tDelayOff;
ptrTCylToolTorqueOverload^.T_Config.tDelayOn									:=ptrTCylToolTorqueOverload^.T_Config.tDelayOn;
ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff				:=ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff;
ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn				:=ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn;
ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Standard.tDelayActiv						:=T#0s;
ptrTCylToolTorqueOverload^.T_Config.tDelayPreOff								:=T#0s;
ptrTCylToolTorqueOverload^.T_Config.tDelayPreOn								:=T#0s;

(* Config Cyl BrakeReleaseZAxis *)
ptrTCylBrakeReleaseZAxis^.iCylinderTpye										:=4;
ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xFBActiv									:=T_Station_Work.TControl.xEnable;
ptrTCylBrakeReleaseZAxis^.T_Config.xActivState									:=TRUE;
ptrTCylBrakeReleaseZAxis^.T_Config.xCtrlePosOff									:=FALSE;
ptrTCylBrakeReleaseZAxis^.T_Config.xCtrlePosOn									:=FALSE;
ptrTCylBrakeReleaseZAxis^.T_Config.tTimeOut									:=REAL_TO_TIME(T_Station_Parameter.TCylBrakeReleaseZAxis.rTimeOutError * 1000.0);
ptrTCylBrakeReleaseZAxis^.T_Config.tDelayOff									:=REAL_TO_TIME(T_Station_Parameter.TCylBrakeReleaseZAxis.rTimeDelayOFF * 1000.0);
ptrTCylBrakeReleaseZAxis^.T_Config.tDelayOn									:=REAL_TO_TIME(T_Station_Parameter.TCylBrakeReleaseZAxis.rTimeDelayON * 1000.0);
ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff				:=REAL_TO_TIME(T_Station_Parameter.TCylBrakeReleaseZAxis.rTimeAfterSensorOFF * 1000.0);
ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn				:=REAL_TO_TIME(T_Station_Parameter.TCylBrakeReleaseZAxis.rTimeAfterSensorON * 1000.0);
ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.T_Standard.tDelayActiv						:=T#0s;
ptrTCylBrakeReleaseZAxis^.T_Config.tDelayPreOff									:=T#0s;
ptrTCylBrakeReleaseZAxis^.T_Config.tDelayPreOn								:=T#0s;

(* Config Cyl WorkpieceClamp *)
ptrTCylWorkpieceClamp^.iCylinderTpye											:=5;
ptrTCylWorkpieceClamp^.T_CtrleCyl.xFBActiv										:=T_Station_Work.TControl.xEnable;
ptrTCylWorkpieceClamp^.T_Config.xActivState									:=TRUE;
ptrTCylWorkpieceClamp^.T_Config.xCtrlePosOff									:=FALSE;
ptrTCylWorkpieceClamp^.T_Config.xCtrlePosOn									:=FALSE;
ptrTCylWorkpieceClamp^.T_Config.tTimeOut										:=ptrTCylWorkpieceClamp^.T_Config.tTimeOut;
ptrTCylWorkpieceClamp^.T_Config.tDelayOff										:=ptrTCylWorkpieceClamp^.T_Config.tDelayOff;
ptrTCylWorkpieceClamp^.T_Config.tDelayOn										:=ptrTCylWorkpieceClamp^.T_Config.tDelayOn;
ptrTCylWorkpieceClamp^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff				:=ptrTCylWorkpieceClamp^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff;
ptrTCylWorkpieceClamp^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn				:=ptrTCylWorkpieceClamp^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn;
ptrTCylWorkpieceClamp^.T_CtrleCyl.T_Standard.tDelayActiv						:=T#0s;
ptrTCylWorkpieceClamp^.T_Config.tDelayPreOff									:=T#0s;
ptrTCylWorkpieceClamp^.T_Config.tDelayPreOn									:=T#0s;

(* Config Valve AirTable *)
ptrTValveAirTable^.iCylinderTpye												:=6;
ptrTValveAirTable^.T_CtrleCyl.xFBActiv											:=T_Station_Work.TControl.xEnable;
ptrTValveAirTable^.T_Config.xActivState											:=TRUE;
ptrTValveAirTable^.T_Config.xCtrlePosOff											:=FALSE;
ptrTValveAirTable^.T_Config.xCtrlePosOn										:=FALSE;
ptrTValveAirTable^.T_Config.tTimeOut											:=ptrTValveAirTable^.T_Config.tTimeOut;
ptrTValveAirTable^.T_Config.tDelayOff											:=ptrTValveAirTable^.T_Config.tDelayOff;
ptrTValveAirTable^.T_Config.tDelayOn											:=ptrTValveAirTable^.T_Config.tDelayOn;
ptrTValveAirTable^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff						:=ptrTValveAirTable^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff;
ptrTValveAirTable^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn						:=ptrTValveAirTable^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn;
ptrTValveAirTable^.T_CtrleCyl.T_Standard.tDelayActiv								:=T#0s;
ptrTValveAirTable^.T_Config.tDelayPreOff										:=T#0s;
ptrTValveAirTable^.T_Config.tDelayPreOn										:=T#0s;

(* Config Valve VacuumTable *)
ptrTValveVacuumTable^.iCylinderTpye											:=7;
ptrTValveVacuumTable^.T_CtrleCyl.xFBActiv										:=T_Station_Work.TControl.xEnable;
ptrTValveVacuumTable^.T_Config.xActivState										:=TRUE;
ptrTValveVacuumTable^.T_Config.xCtrlePosOff									:=FALSE;
ptrTValveVacuumTable^.T_Config.xCtrlePosOn									:=FALSE;
ptrTValveVacuumTable^.T_Config.tTimeOut										:=ptrTValveVacuumTable^.T_Config.tTimeOut;
ptrTValveVacuumTable^.T_Config.tDelayOff										:=ptrTValveVacuumTable^.T_Config.tDelayOff;
ptrTValveVacuumTable^.T_Config.tDelayOn										:=ptrTValveVacuumTable^.T_Config.tDelayOn;
ptrTValveVacuumTable^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff					:=ptrTValveVacuumTable^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff;
ptrTValveVacuumTable^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn					:=ptrTValveVacuumTable^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn;
ptrTValveVacuumTable^.T_CtrleCyl.T_Standard.tDelayActiv							:=T#0s;
ptrTValveVacuumTable^.T_Config.tDelayPreOff									:=T#0s;
ptrTValveVacuumTable^.T_Config.tDelayPreOn									:=T#0s;

(* Config Valve Cleaning nozzle  *)
ptrTValveCleanNozzle^.iCylinderTpye											:=8;
ptrTValveCleanNozzle^.T_CtrleCyl.xFBActiv										:=T_Station_Work.TControl.xEnable;
ptrTValveCleanNozzle^.T_Config.xActivState										:=TRUE;
ptrTValveCleanNozzle^.T_Config.xCtrlePosOff										:=FALSE;
ptrTValveCleanNozzle^.T_Config.xCtrlePosOn										:=FALSE;
ptrTValveCleanNozzle^.T_Config.tTimeOut										:=ptrTValveCleanNozzle^.T_Config.tTimeOut;
ptrTValveCleanNozzle^.T_Config.tDelayOff										:=ptrTValveCleanNozzle^.T_Config.tDelayOff;
ptrTValveCleanNozzle^.T_Config.tDelayOn										:=ptrTValveCleanNozzle^.T_Config.tDelayOn;
ptrTValveCleanNozzle^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff					:=ptrTValveCleanNozzle^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff;
ptrTValveCleanNozzle^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn					:=ptrTValveCleanNozzle^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn;
ptrTValveCleanNozzle^.T_CtrleCyl.T_Standard.tDelayActiv							:=T#0s;
ptrTValveCleanNozzle^.T_Config.tDelayPreOff										:=T#0s;
ptrTValveCleanNozzle^.T_Config.tDelayPreOn										:=T#0s;

(* Config SensorTorque *)
ptrTSensorTorque^.iCylinderTpye												:=20;
ptrTSensorTorque^.T_CtrleCyl.xFBActiv											:=T_Station_Work.TControl.xEnable;
ptrTSensorTorque^.T_Config.xActivState											:=TRUE;
ptrTSensorTorque^.T_Config.xCtrlePosOff											:=FALSE;
ptrTSensorTorque^.T_Config.xCtrlePosOn										:=FALSE;
ptrTSensorTorque^.T_Config.tTimeOut											:=T#0s;
ptrTSensorTorque^.T_Config.tDelayOff											:=ptrTSensorTorque^.T_Config.tDelayOff;
ptrTSensorTorque^.T_Config.tDelayOn											:=ptrTSensorTorque^.T_Config.tDelayOn;
ptrTSensorTorque^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff						:=ptrTSensorTorque^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff;
ptrTSensorTorque^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn						:=ptrTSensorTorque^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn;
ptrTSensorTorque^.T_CtrleCyl.T_Standard.tDelayActiv								:=T#0s;
ptrTSensorTorque^.T_Config.tDelayPreOff										:=T#0s;
ptrTSensorTorque^.T_Config.tDelayPreOn										:=T#0s;

(* Config SensorTorqueOverload *)
ptrTSensorTorqueOverload^.iCylinderTpye										:=21;
ptrTSensorTorqueOverload^.T_CtrleCyl.xFBActiv									:=T_Station_Work.TControl.xEnable;
ptrTSensorTorqueOverload^.T_Config.xActivState									:=TRUE;
ptrTSensorTorqueOverload^.T_Config.xCtrlePosOff									:=FALSE;
ptrTSensorTorqueOverload^.T_Config.xCtrlePosOn								:=FALSE;
ptrTSensorTorqueOverload^.T_Config.tTimeOut									:=T#0s;
ptrTSensorTorqueOverload^.T_Config.tDelayOff									:=ptrTSensorTorqueOverload^.T_Config.tDelayOff;
ptrTSensorTorqueOverload^.T_Config.tDelayOn									:=ptrTSensorTorqueOverload^.T_Config.tDelayOn;
ptrTSensorTorqueOverload^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff				:=ptrTSensorTorqueOverload^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff;
ptrTSensorTorqueOverload^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn				:=ptrTSensorTorqueOverload^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn;
ptrTSensorTorqueOverload^.T_CtrleCyl.T_Standard.tDelayActiv						:=T#0s;
ptrTSensorTorqueOverload^.T_Config.tDelayPreOff								:=T#0s;
ptrTSensorTorqueOverload^.T_Config.tDelayPreOn								:=T#0s;

(* Config Sensor TorqueSensorMeasRange *)
ptrTTorqueSensorMeasRange^.iCylinderTpye									:=22;
ptrTTorqueSensorMeasRange^.T_CtrleCyl.xFBActiv								:=T_Station_Work.TControl.xEnable;
ptrTTorqueSensorMeasRange^.T_Config.xActivState								:=TRUE;
ptrTTorqueSensorMeasRange^.T_Config.xCtrlePosOff								:=FALSE;
ptrTTorqueSensorMeasRange^.T_Config.xCtrlePosOn								:=FALSE;
ptrTTorqueSensorMeasRange^.T_Config.tTimeOut									:=T#0s;
ptrTTorqueSensorMeasRange^.T_Config.tDelayOff								:=ptrTTorqueSensorMeasRange^.T_Config.tDelayOff;
ptrTTorqueSensorMeasRange^.T_Config.tDelayOn								:=T#100ms;
ptrTTorqueSensorMeasRange^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff			:=ptrTTorqueSensorMeasRange^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff;
ptrTTorqueSensorMeasRange^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn			:=ptrTTorqueSensorMeasRange^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn;
ptrTTorqueSensorMeasRange^.T_CtrleCyl.T_Standard.tDelayActiv					:=ptrTTorqueSensorMeasRange^.T_CtrleCyl.T_Standard.tDelayActiv;
ptrTTorqueSensorMeasRange^.T_Config.tDelayPreOff								:=T#0s;
ptrTTorqueSensorMeasRange^.T_Config.tDelayPreOn								:=T#0s;

(* Config Sensor TorqueSensorControl *)
ptrTTorqueSensorControl^.iCylinderTpye											:=23;
ptrTTorqueSensorControl^.T_CtrleCyl.xFBActiv									:=T_Station_Work.TControl.xEnable;
ptrTTorqueSensorControl^.T_Config.xActivState									:=TRUE;
ptrTTorqueSensorControl^.T_Config.xCtrlePosOff									:=FALSE;
ptrTTorqueSensorControl^.T_Config.xCtrlePosOn									:=FALSE;
ptrTTorqueSensorControl^.T_Config.tTimeOut										:=T#0s;
ptrTTorqueSensorControl^.T_Config.tDelayOff										:=ptrTTorqueSensorControl^.T_Config.tDelayOff;
ptrTTorqueSensorControl^.T_Config.tDelayOn										:=T#100ms;
ptrTTorqueSensorControl^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff				:=ptrTTorqueSensorControl^.T_CtrleCyl.T_Standard.tDelayAfterSensorOff;
ptrTTorqueSensorControl^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn				:=ptrTTorqueSensorControl^.T_CtrleCyl.T_Standard.tDelayAfterSensorOn;
ptrTTorqueSensorControl^.T_CtrleCyl.T_Standard.tDelayActiv						:=ptrTTorqueSensorControl^.T_CtrleCyl.T_Standard.tDelayActiv;
ptrTTorqueSensorControl^.T_Config.tDelayPreOff									:=T#0s;
ptrTTorqueSensorControl^.T_Config.tDelayPreOn									:=T#0s;

(* Config Bubbler Axis *)
ptrTAxisBubbler^.T_Config_Gen.iTyp:=5; (* Bubbler Axis-->DC-Achse für Rührwerk *)
ptrTAxisBubbler^.T_Config_Gen.sDeviceFileName:='EC-MAX2611W_Bubbler_St1_KL2552';
(* Config Feedpump Axis *)
ptrTAxisFeedPump^.T_Config_Gen.iTyp:=6; (* Feedpump Axis-->DC-Achse für Förderpumpe *)
ptrTAxisFeedPump^.T_Config_Gen.sDeviceFileName:='EC-MAX2611W_Feedpump_St1_KL2552';



END_ACTION

ACTION	HW_Axis_DC:
(******************************************************************************************************************************************)
(****************************				            Axis Bubbler Motion                                                *****************************)
(******************************************************************************************************************************************)
fbBubbler(	T_Axis_DC:= ptrTAxisBubbler^,
			usiStatusWord:= stBubblerDataIN.usiStatusWord,
			usiControlWord:= stBubblerDataOUT.usiControlWord,
			iDataOut:= stBubblerDataOUT.iDataOut,
			iDataIn:= stBubblerDataIN.iDataIn,
			T_HDD:= T_HDD);
(******************************************************************************************************************************************)
(****************************				            Axis Feedpump Motion                                          *****************************)
(******************************************************************************************************************************************)
fbFeedpump(	T_Axis_DC:= ptrTAxisFeedPump^,
			usiStatusWord:= stFeedpumpINData.usiStatusWord,
			usiControlWord:= stFeedpumpOUTData.usiControlWord,
			iDataOut:= stFeedpumpOUTData.iDataOut,
			iDataIn:= stFeedpumpINData.iDataIn,
			T_HDD:= T_HDD);



END_ACTION

ACTION	HW_AxisS:
(******************************************************************************************************************************************)
(****************************			            Axis Tool Spindle Live Values                                     *****************************)
(******************************************************************************************************************************************)
CASE T_ExchgParam.bToolSpindleActive OF
1:	(* Maxon Spindel *)
	IF (T_Station_Parameter.T_TorqueSystem.rGearRatioGearBox <> 0.0) AND (T_Station_Parameter.T_TorqueSystem.rGearRatioSpindleMotor <> 0.0) THEN
		ptrTAxisS^.T_CtrleSingle.lrScaleFactor:=	1.0/ T_Station_Parameter.T_TorqueSystem.rGearRatioSpindleMotor / T_Station_Parameter.T_TorqueSystem.rGearRatioGearBox;
	ELSE
		ptrTAxisS^.T_CtrleSingle.lrScaleFactor:=1.8315;	(* Gilt für 60W Motoren *)
	END_IF;
	fbAxisToolSpindleSLiveValues(	uiActualTorque:= IuiActualTorqueAxisS,
								arxDigitalInput:= ,
								T_Axis:= ptrTAxisS^,
								T_AxisRefIn:= stSRefIn);
2:	(* Beckhoff Spindel L *)
	ptrTAxisS^.T_CtrleSingle.lrScaleFactor:=6.0;
	fbAxisToolSpindleSLiveValues(	uiActualTorque:= IuiActualTorqueAxisS,
								arxDigitalInput:= ,
								T_Axis:= ptrTAxisS^,
								T_AxisRefIn:= stS2RefIn);
3:	(* Beckhoff Spindel M *)
	ptrTAxisS^.T_CtrleSingle.lrScaleFactor:=6.0;
	fbAxisToolSpindleSLiveValues(	uiActualTorque:= IuiActualTorqueAxisS,
								arxDigitalInput:= ,
								T_Axis:= ptrTAxisS^,
								T_AxisRefIn:= stS3RefIn);
END_CASE;
(******************************************************************************************************************************************)
(****************************		                           Axis Tool Spindle Motion                                          *****************************)
(******************************************************************************************************************************************)
CASE T_ExchgParam.bToolSpindleActive OF
1:	(* Maxon Spindel *)
	fbAxisToolSpindleS(	xHWLimitPos:= FALSE,
						xHWLimitNeg:= FALSE,
						xRefHoming:= FALSE,
						wInputState:=IwInputState_S1_Axis,
						wPosLimitSwitchBit:=0,
						wNegLimitSwitchBit:=0,
						lrNullPointOffset:=0.0,
						IxSoftLimitMaxMonitoring:=,
						T_Axis:= ptrTAxisS^,
						T_AxisRefIn:= stSRefIn,
						T_AxisRefOut:= stSRefOut,
						T_HDD:= T_HDD);
2:	(* Beckhoff Spindel L *)
	fbAxisToolSpindleS(	xHWLimitPos:= FALSE,
						xHWLimitNeg:= FALSE,
						xRefHoming:= FALSE,
						wInputState:=IwInputState_S2_Axis,
						wPosLimitSwitchBit:=0,
						wNegLimitSwitchBit:=0,
						lrNullPointOffset:=0.0,
						IxSoftLimitMaxMonitoring:=,
						T_Axis:= ptrTAxisS^,
						T_AxisRefIn:= stS2RefIn,
						T_AxisRefOut:= stS2RefOut,
						T_HDD:= T_HDD);
3:	(* Beckhoff Spindel M *)
	fbAxisToolSpindleS(	xHWLimitPos:= FALSE,
						xHWLimitNeg:= FALSE,
						xRefHoming:= FALSE,
						wInputState:=IwInputState_S3_Axis,
						wPosLimitSwitchBit:=0,
						wNegLimitSwitchBit:=0,
						lrNullPointOffset:=0.0,
						IxSoftLimitMaxMonitoring:=,
						T_Axis:= ptrTAxisS^,
						T_AxisRefIn:= stS3RefIn,
						T_AxisRefOut:= stS3RefOut,
						T_HDD:= T_HDD);
END_CASE;
(******************************************************************************************************************************************)
(****************************		             Count Rotation Time of the Spindel                                     *****************************)
(******************************************************************************************************************************************)
CASE T_ExchgParam.bToolSpindleActive OF
1:	(* Maxon Spindel *)
	IF NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) AND NOT(ptrTAxisS^.T_CtrleSingle.xErr) THEN
		TONTickTime(IN:=TRUE,PT:=T#1s);
		IF TONTickTime.Q THEN
			TONTickTime(IN:=FALSE);
			T_Station_Work.THWWorkStation.TCtrlWork.tSpindelActiveRotationTime:=T_Station_Work.THWWorkStation.TCtrlWork.tSpindelActiveRotationTime + T#1s;
			IF T_Station_Work.THWWorkStation.TCtrlWork.tSpindelActiveRotationTime >= T#86400s THEN
				IF (T_Station_Work.THWWorkStation.TCtrlWork.iSpindelActiveRotationDay < 32767) THEN
					T_Station_Work.THWWorkStation.TCtrlWork.iSpindelActiveRotationDay:=T_Station_Work.THWWorkStation.TCtrlWork.iSpindelActiveRotationDay + 1;
				END_IF;
				T_Station_Work.THWWorkStation.TCtrlWork.tSpindelActiveRotationTime:=T#0s;
			END_IF;
		END_IF;
	ELSE
		TONTickTime(IN:=FALSE);
	END_IF;
2:	(* Beckhoff Spindel L *)
	IF NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) AND NOT(ptrTAxisS^.T_CtrleSingle.xErr) THEN
		TONTickTime(IN:=TRUE,PT:=T#1s);
		IF TONTickTime.Q THEN
			TONTickTime(IN:=FALSE);
			T_Station_Work.THWWorkStation.TCtrlWork.tSpindel2ActiveRotationTime:=T_Station_Work.THWWorkStation.TCtrlWork.tSpindel2ActiveRotationTime + T#1s;
			IF T_Station_Work.THWWorkStation.TCtrlWork.tSpindel2ActiveRotationTime >= T#86400s THEN
				IF (T_Station_Work.THWWorkStation.TCtrlWork.iSpindel2ActiveRotationDay < 32767) THEN
					T_Station_Work.THWWorkStation.TCtrlWork.iSpindel2ActiveRotationDay:=T_Station_Work.THWWorkStation.TCtrlWork.iSpindel2ActiveRotationDay + 1;
				END_IF;
				T_Station_Work.THWWorkStation.TCtrlWork.tSpindel2ActiveRotationTime:=T#0s;
			END_IF;
		END_IF;
	ELSE
		TONTickTime(IN:=FALSE);
	END_IF;
3:	(* Beckhoff Spindel M *)
	IF NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) AND NOT(ptrTAxisS^.T_CtrleSingle.xErr) THEN
		TONTickTime(IN:=TRUE,PT:=T#1s);
		IF TONTickTime.Q THEN
			TONTickTime(IN:=FALSE);
			T_Station_Work.THWWorkStation.TCtrlWork.tSpindel3ActiveRotationTime:=T_Station_Work.THWWorkStation.TCtrlWork.tSpindel3ActiveRotationTime + T#1s;
			IF T_Station_Work.THWWorkStation.TCtrlWork.tSpindel3ActiveRotationTime >= T#86400s THEN
				IF (T_Station_Work.THWWorkStation.TCtrlWork.iSpindel3ActiveRotationDay < 32767) THEN
					T_Station_Work.THWWorkStation.TCtrlWork.iSpindel3ActiveRotationDay:=T_Station_Work.THWWorkStation.TCtrlWork.iSpindel3ActiveRotationDay + 1;
				END_IF;
				T_Station_Work.THWWorkStation.TCtrlWork.tSpindel3ActiveRotationTime:=T#0s;
			END_IF;
		END_IF;
	ELSE
		TONTickTime(IN:=FALSE);
	END_IF;
END_CASE;
END_ACTION

ACTION	HW_AxisZ:
(******************************************************************************************************************************************)
(*******************************				         Axis Z Live Values                                              *********************************)
(******************************************************************************************************************************************)
fbAxisZLiveValues(	uiActualTorque:= IuiActualTorqueAxisZ,
					arxDigitalInput:= ,
					T_Axis:= ptrTAxisZ^,
					T_AxisRefIn:= stZRefIn);
(******************************************************************************************************************************************)
(*********************************				            Axis Z Motion                                            ********************************)
(******************************************************************************************************************************************)

(*******************************            START: Manuelle Schleppabstandsüberwachung, da mit dem neuen Regler keine Überwachung mehr in der NC Ebene steht        ************************************************)
lrCtrlSpeed:=ABS(DINT_TO_LREAL(T_Z_St1_Ctrle.diVelocityCommandValue)/558349.25);	(* Soll Geschwindigkeit *)
lrActualSpeed:=ABS(ptrTAxisZ^.T_LiveValue.lrActualVelocity);								(* Ist Geschwindigkeit *)
lrCheckSpeed:=0.0;
IF (lrCtrlSpeed <= 1.0) AND (lrCtrlSpeed <> 0.0) THEN
	lrCheckSpeed:=0.5;
ELSIF (lrCtrlSpeed <= 10.0) AND (lrCtrlSpeed <> 0.0) THEN
	lrCheckSpeed:=2.0;
ELSIF (lrCtrlSpeed <= 100.0) AND (lrCtrlSpeed <> 0.0) THEN
	lrCheckSpeed:=10.0;
ELSIF (lrCtrlSpeed > 100.0) AND (lrCtrlSpeed <> 0.0) THEN
	lrCheckSpeed:=20.0;
END_IF;
lrCalcSpeed:=lrCtrlSpeed - lrActualSpeed;
IF (lrCheckSpeed <> 0.0) THEN
	IF (lrCalcSpeed >= lrCheckSpeed) THEN
		xZMovementNOK:=TRUE;
	ELSE
		xZMovementNOK:=FALSE;
	END_IF;
ELSE
	xZMovementNOK:=FALSE;
END_IF;
TONCheckMovement(IN:=xZMovementNOK,PT:=T#0.5s);
IF TONCheckMovement.Q THEN	(* Überwachen falls um diese Zeit die Geschwindigkeitsänderung zwischen Soll und Ist ansteht, dann muss der Schleppabstandsfehler erscheinen *)
	diCounterTest:=diCounterTest + 1;
	IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND (ptrTAxisZ^.T_CtrleSingle.iFunction <> 5) THEN
		ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
		ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
		gxZFollowDistanceError:=TRUE;
	END_IF;
END_IF;
(*******************************            ENDE: Manuelle Schleppabstandsüberwachung, da mit dem neuen Regler keine Überwachung mehr in der NC Ebene steht        ************************************************)

fbAxisZ(		xHWLimitPos:= FALSE,
			xHWLimitNeg:= FALSE,
			xRefHoming:= T_Station_Parameter.T_AxisState.xReferencedZAxis, (* Absolut Encoder, daher kein Ref.Sensor *)
			wInputState:=IwInputState_Z_Axis,
			wPosLimitSwitchBit:=ptrTAxisZ^.T_Config_Gen.wPosLimitSwitchBit,
			wNegLimitSwitchBit:=ptrTAxisZ^.T_Config_Gen.wNegLimitSwitchBit,
			lrNullPointOffset:=0.0,
			IxSoftLimitMaxMonitoring:=FALSE,
			T_Axis:= ptrTAxisZ^,
			T_AxisRefIn:= stZRefIn,
			T_AxisRefOut:= stZRefOut,
			T_HDD:= T_HDD);
END_ACTION

ACTION	HW_CylBrakeReleaseZAxis:
(******************************************************************************************************************************************)
(********************************   		      Ventil für Bremse lösen der Z Achse                  ********************************)
(******************************************************************************************************************************************)
fbCylTBrakeReleaseZAxis(	xCtrlePosOn:= IxBrakeReleaseZAxis,
							xCtrlePosOff:=  FALSE,
							T_Cylinder:= ptrTCylBrakeReleaseZAxis^);
QxCylBrakeReleaseZAxis_Open:=fbCylTBrakeReleaseZAxis.xCylinderOn;	(* Ventil QxCylBrakeReleaseZ1Axis_Open-->Ventil für Bremszylinder der Z Achse für Bremse lösen *)
QxCylBrakeReleaseZAxis_Close:=fbCylTBrakeReleaseZAxis.xCylinderOff;	(* Ventil QxCylBrakeReleaseZ1Axis_Close-->Ventil für Bremszylinder der Z Achse für Bremse Aktivieren *)
END_ACTION

ACTION	HW_CylToolDeflection:
(******************************************************************************************************************************************)
(****************************				          Cylinder Tool Deflection                                       *****************************)
(******************************************************************************************************************************************)
CASE T_ExchgParam.bToolSpindleActive OF
	1:	(* Maxon Spindel *)
	FBCalcSpindleForce(	rForcePistonIn:= ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceIn + T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1],
						rPistonDiameterD1:= T_Station_Parameter.T_SpindleSystem.rPistonDiameterD1,
						rPistonDiameterD2:= T_Station_Parameter.T_SpindleSystem.rPistonDiameterD2,
						rMaxAirpressure:= T_Station_Parameter.T_SpindleSystem.rMaxServoAirPressure,
						rMaxServoVoltage:=T_Station_Parameter.T_SpindleSystem.rMaxServoVoltage);
	T_Station_Parameter.T_SpindleSystem.rMaxDeflectionForce:=FBCalcSpindleForce.rSetMaxForce - T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1];
	ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.iAnalogIN:=FBCalcSpindleForce.iAnalogOutput;
	ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceOut:=FBCalcSpindleForce.rForcePistonOut;
	fbCylToolDeflection(	xCtrlePosOn:=IxToolDeflection,
						xCtrlePosOff:= FALSE,
						iAnalogIn:= ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.iAnalogIN,
						T_Cylinder:= ptrTCylToolDeflection^);
	QiAToolDeflection_SM:=fbCylToolDeflection.iAnalogOut;	(* Servoventil QiAToolDeflection_SM_St1 (2Bar) *)
	ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.iAnalogOut:=fbCylToolDeflection.iAnalogOut;
2:	(* Beckhoff Spindel L *)
	FBCalcSpindleForce(	rForcePistonIn:= ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceIn + T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1],
						rPistonDiameterD1:= T_Station_Parameter.T_SpindleSystem_L.rPistonDiameterD1,
						rPistonDiameterD2:= T_Station_Parameter.T_SpindleSystem_L.rPistonDiameterD2,
						rMaxAirpressure:= T_Station_Parameter.T_SpindleSystem_L.rMaxServoAirPressure,
						rMaxServoVoltage:=T_Station_Parameter.T_SpindleSystem_L.rMaxServoVoltage);
	T_Station_Parameter.T_SpindleSystem_L.rMaxDeflectionForce:=FBCalcSpindleForce.rSetMaxForce - T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1];
	ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.iAnalogIN:=FBCalcSpindleForce.iAnalogOutput;
	ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceOut:=FBCalcSpindleForce.rForcePistonOut;
	fbCylToolDeflection(	xCtrlePosOn:=IxToolDeflection,
						xCtrlePosOff:= FALSE,
						iAnalogIn:= ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.iAnalogIN,
						T_Cylinder:= ptrTCylToolDeflection^);
	QiAToolTorqueOverload_SM:=fbCylToolDeflection.iAnalogOut;	(* Servoventil QiAToolTorqueOverload_SM_St1 (8Bar) *)
	ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.iAnalogOut:=fbCylToolDeflection.iAnalogOut;
	QiAToolDeflection_SM:=0;
3:	(* Beckhoff Spindel M *)
	FBCalcSpindleForce(	rForcePistonIn:= ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceIn + T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1],
						rPistonDiameterD1:= T_Station_Parameter.T_SpindleSystem_M.rPistonDiameterD1,
						rPistonDiameterD2:= T_Station_Parameter.T_SpindleSystem_M.rPistonDiameterD2,
						rMaxAirpressure:= T_Station_Parameter.T_SpindleSystem_M.rMaxServoAirPressure,
						rMaxServoVoltage:=T_Station_Parameter.T_SpindleSystem_M.rMaxServoVoltage);
	T_Station_Parameter.T_SpindleSystem_M.rMaxDeflectionForce:=FBCalcSpindleForce.rSetMaxForce - T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1];
	ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.iAnalogIN:=FBCalcSpindleForce.iAnalogOutput;
	ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceOut:=FBCalcSpindleForce.rForcePistonOut;
	fbCylToolDeflection(	xCtrlePosOn:=IxToolDeflection,
						xCtrlePosOff:= FALSE,
						iAnalogIn:= ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.iAnalogIN,
						T_Cylinder:= ptrTCylToolDeflection^);
	QiAToolDeflection_SM:=fbCylToolDeflection.iAnalogOut;	(* Servoventil QiAToolDeflection_SM_St1 (2Bar) *)
	ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.iAnalogOut:=fbCylToolDeflection.iAnalogOut;
	QiAToolTorqueOverload_SM:=0;
END_CASE;
END_ACTION

ACTION	HW_CylWorkpieceClamp:
(******************************************************************************************************************************************)
(********************************   		       Ventil für Werkstückfxierungszylinder                  ********************************)
(******************************************************************************************************************************************)
fbCylWorkpieceClamp(	xCtrlePosOn:= 	IxUpperToolGuide_WorkpieceClamped, 	(* Sensor für Überwachung der Werkstückfixierung *)
						xCtrlePosOff:=  FALSE,
						T_Cylinder:= ptrTCylWorkpieceClamp^);
QxCylWorkpieceClamp_Close:=fbCylWorkpieceClamp.xCylinderOn;	(* Ventil QxCylWorkpieceClamp_Close-->Ventil für Werkstückfixierzylinder schliessen *)
QxCylWorkpieceClamp_Open:=fbCylWorkpieceClamp.xCylinderOff;	(* Ventil QxCylWorkpieceClamp_Open-->Ventil für Werkstückfixierzylinder öffnen *)
END_ACTION

ACTION	HW_ToolTorqueHC:
(******************************************************************************************************************************************)
(****************************				          Cylinder Torque HC                                                  *****************************)
(******************************************************************************************************************************************)
CASE T_ExchgParam.bToolSpindleActive OF
1:	(* Maxon Spindel *)
	FBTorqueLevelAirPressureAnalog_HC(	xActiveWorkProcess:= T_Station_Work.THWWorkStation.TCtrlWork.xActiveProcess_CylToolTorqueHC,
										xBlockOutput:= T_Station_Work.THWWorkStation.TCtrlWork.xBlockOutput_CylToolTorqueHC,
										rForceIn:= ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.rForceIn + T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1],
										T_Station_Parameter:= T_Station_Parameter,
										lrZ1ActualPosition:= ptrTAxisZ^.T_LiveValue.lrActualPosition,
										xCylHCActive:=TRUE,
										TCylTorque:= ptrTCylToolTorqueHC^,
										iAnalogOutput=> ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.iAnalogIN,
										rForceOut=> ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.rForceOut);
	T_Station_Parameter.T_TorqueSystem.rMaxTorque_HC:=FBTorqueLevelAirPressureAnalog_HC.rMaxTorque - T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1];

	fbCylToolTorqueHC(	xCtrlePosOn:=ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn,
						xCtrlePosOff:= FALSE,
						iAnalogIn:= ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.iAnalogIN,
						T_Cylinder:= ptrTCylToolTorqueHC^);
	QiAToolTorqueHC_SM:=fbCylToolTorqueHC.iAnalogOut;
	ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.iAnalogOut:=fbCylToolTorqueHC.iAnalogOut;
2,3:	(* Beckhoff Spindel *)
	QiAToolTorqueHC_SM:=0;
	ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.iAnalogOut:=0;
END_CASE;

END_ACTION

ACTION	HW_ToolTorqueOverload:
(******************************************************************************************************************************************)
(****************************				    Cylinder Torque Overload                                           *****************************)
(******************************************************************************************************************************************)
CASE T_ExchgParam.bToolSpindleActive OF
1:	(* Maxon Spindel *)
	rCalcForceIn:=ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Analog.rForceIn - ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.rForceIn + T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1];
	IF (rCalcForceIn < 0.0) THEN
		rCalcForceIn:=0.0;
	END_IF;
	FBTorqueLevelAirPressureAnalog_Overload(	xActiveWorkProcess:= FALSE,
											xBlockOutput:= FALSE,
											rForceIn:= rCalcForceIn,
											T_Station_Parameter:= T_Station_Parameter,
											lrZ1ActualPosition:= ptrTAxisZ^.T_LiveValue.lrActualPosition,
											xCylHCActive:=FALSE,
											TCylTorque:= ptrTCylToolTorqueOverload^,
											iAnalogOutput=> ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Analog.iAnalogIN,
											rForceOut=> ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Analog.rForceOut);
	T_Station_Parameter.T_TorqueSystem.rMaxTorque_HCOver:=FBTorqueLevelAirPressureAnalog_Overload.rMaxTorque - T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1] +
														     ((T_Station_Parameter.T_OnlineChange.rTorqueLevelHC + T_Station_Parameter.T_OnlineChange.rTorqueLevelHC) /2.0);
	fbCylToolTorqueOverload(	xCtrlePosOn:=ptrTCylToolTorqueOverload^.T_CtrleCyl.xStatePosOn,
							xCtrlePosOff:= FALSE,
							iAnalogIn:= ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Analog.iAnalogIN,
							T_Cylinder:= ptrTCylToolTorqueOverload^);
	QiAToolTorqueOverload_SM:=fbCylToolTorqueOverload.iAnalogOut;
	ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Analog.iAnalogOut:=fbCylToolTorqueOverload.iAnalogOut;
2,3:	(* Beckhoff Spindel *)
	QiAToolTorqueOverload_SM:=0;
	ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Analog.iAnalogOut:=0;
END_CASE;
END_ACTION

ACTION	HW_TorqueOverloadSensor:
(******************************************************************************************************************************************)
(****************************  		       Sensor für Drehmomentüberlastdetektion                  ********************************)
(******************************************************************************************************************************************)
IF NOT(xInitState) THEN
	xInitState:=TRUE;
	udiTorqueOverloadCounterValue:=gudiTorqueOverloadCounterValueSt1;
END_IF;
TOFSetOutput(IN:=(udiTorqueOverloadCounterValue<>gudiTorqueOverloadCounterValueSt1),PT:=T#2s);
IF (udiTorqueOverloadCounterValue<>gudiTorqueOverloadCounterValueSt1) THEN
	xInitState:=FALSE;
END_IF;
ptrTSensorTorqueOverload^.T_CtrleCyl.xStatePosOn:=IxTorqueOverload OR TOFSetOutput.Q;
ptrTSensorTorqueOverload^.T_CtrleCyl.xDone:=TRUE;
END_ACTION

ACTION	HW_TorqueSensor:
(******************************************************************************************************************************************)
(****************************  		       Analog Sensor für Drehmomentdetektion                  ********************************)
(******************************************************************************************************************************************)
CASE T_ExchgParam.bToolSpindleActive OF
1:	(* Maxon Spindel *)
	IF (T_Station_Parameter.T_TorqueSystem.rTorqueScaleFactor <> 0.0) THEN
		T_Station_Work.THWWorkStation.TSensorTorque.T_CtrleCyl.T_Analog.rPosIn:=	(INT_TO_REAL(IiAToolTorque) /
																				T_Station_Parameter.T_TorqueSystem.rTorqueScaleFactor)
																				* T_Station_Parameter.T_TorqueSystem.rMeasureDistance;
	ELSE
		T_Station_Work.THWWorkStation.TSensorTorque.T_CtrleCyl.T_Analog.rPosIn:=	INT_TO_REAL(IiAToolTorque);
	END_IF;

	ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn:=	T_Station_Work.THWWorkStation.TSensorTorque.T_CtrleCyl.T_Analog.rPosIn >
												T_Station_Parameter.T_TorqueSystem.rTorquePosition_HC;

	ptrTCylToolTorqueOverload^.T_CtrleCyl.xStatePosOn:=	T_Station_Work.THWWorkStation.TSensorTorque.T_CtrleCyl.T_Analog.rPosIn >
													T_Station_Parameter.T_TorqueSystem.rTorquePosition_HCOverload;
END_CASE;

IF (ii <= 0) THEN
	ii:=1;
END_IF;
IF TStation_Work_St1.THWWorkStation.TAxisS.T_CtrleSingle.xExecute AND TStation_Work_St1.THWWorkStation.TCylToolTorqueHC.T_CtrleCyl.T_Analog.xActiv THEN
	rDefaultValue:=TStation_Work_St1.THWWorkStation.TSensorTorque.T_CtrleCyl.T_Analog.rPosIn * 25.4;
END_IF;
garRockerMeasureValue[ii]:=TStation_Work_St1.THWWorkStation.TSensorTorque.T_CtrleCyl.T_Analog.rPosIn * 25.4;
ii:=ii+1;
IF (ii > 200) THEN
	grRockerMinValue:=garRockerMeasureValue[1];
	grRockerMaxValue:=garRockerMeasureValue[1];
	rQualitySum:=0;
	FOR jj:=1 TO 200 DO
		IF (garRockerMeasureValue[jj] < grRockerMinValue) THEN
			grRockerMinValue:=garRockerMeasureValue[jj];
		END_IF;
		IF (garRockerMeasureValue[jj] > grRockerMaxValue) THEN
			grRockerMaxValue:=garRockerMeasureValue[jj];
		END_IF;
		rQualitySum:=rQualitySum + garRockerMeasureValue[jj];
	END_FOR;
	rQualityArea:=200.0 * grRockerMaxValue;
	IF (rQualityArea <> 0.0) THEN
		rQuality:=100.0/rQualityArea*rQualitySum;
	ELSE
		rQuality:=100.0;
	END_IF;
	IF (rQuality < 0.0) THEN
		rQuality:=0.0;
	ELSIF (rQuality > 100.0) THEN
		rQuality:=100.0;
	END_IF;
	ii:=1;
END_IF;
grRockerQuality:=rQuality;
grRockerAmplitude:=(100.0 / ((T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_TorqueSystem.rTorquePosition_HC * 25.4) - rDefaultValue)) * (grRockerMaxValue - rDefaultValue);
IF (grRockerAmplitude < 0.0) THEN
	grRockerAmplitude:=0.0;
ELSIF (grRockerAmplitude > 100.0) THEN
	grRockerAmplitude:=100.0;
END_IF;
IF NOT(TStation_Work_St1.THWWorkStation.TAxisS.T_CtrleSingle.xNotMoving) THEN
	TONWaitCycle(IN:=TRUE,PT:=T#2s);
	IF NOT(xFirstTime) AND TONWaitCycle.Q THEN
		xFirstTime:=TRUE;
		grRockerAmplitudeMin:=grRockerAmplitude;
		grRockerAmplitudeMax:=grRockerAmplitude;
		grRockerQualityMin:=grRockerQuality;
		grRockerQualityMax:=grRockerQuality;
	END_IF;
	IF TONWaitCycle.Q THEN
		IF (grRockerAmplitude < grRockerAmplitudeMin) THEN
			grRockerAmplitudeMin:=grRockerAmplitude;
		END_IF;
		IF (grRockerAmplitude > grRockerAmplitudeMax) THEN
			grRockerAmplitudeMax:=grRockerAmplitude;
		END_IF;
		IF (grRockerQuality < grRockerQualityMin) THEN
			grRockerQualityMin:=grRockerQuality;
		END_IF;
		IF (grRockerQuality > grRockerQualityMax) THEN
			grRockerQualityMax:=grRockerQuality;
		END_IF;
	ELSE
		grRockerAmplitudeMin:=0;
		grRockerAmplitudeMax:=0;
		grRockerQualityMin:=0;
		grRockerQualityMax:=0;
		gdiRockerCountHC:=0;
		gdiRockerCountHCTime:=0;
	END_IF;
ELSE
	TONWaitCycle(IN:=FALSE);
	xFirstTime:=FALSE;
END_IF;
TONCalcImpuls(IN:=ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn,PT:=T#99999s);
IF ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn THEN
	IF NOT(xInitCountHC) THEN
		xInitCountHC:=TRUE;
		gdiRockerCountHC:=gdiRockerCountHC+1;
	END_IF;
	gdiRockerCountHCTime:=TIME_TO_DINT(TONCalcImpuls.ET);
	xTorqueActive:=TRUE;
ELSE
	xInitCountHC:=FALSE;
	IF xTorqueActive THEN
		xTorqueActive:=FALSE;
		IF (gdiRockerCountHCTime = 0) THEN
			gdiRockerCountHCTime:=2;
		END_IF;
	END_IF;
END_IF;
grRockerPosition:=(100.0 / ((T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_TorqueSystem.rTorquePosition_HC * 25.4) - rDefaultValue)) *
				((TStation_Work_St1.THWWorkStation.TSensorTorque.T_CtrleCyl.T_Analog.rPosIn * 25.4) - rDefaultValue);
IF (grRockerPosition < 0.0) THEN
	grRockerPosition:=0.0;
ELSIF (grRockerPosition > 100.0) THEN
	grRockerPosition:=100.0;
END_IF;
T_ExchgParam.T_StationCommon.rRockerAmplitude:=grRockerAmplitude;
T_ExchgParam.T_StationCommon.rRockerAmplitudeMin:=grRockerAmplitudeMin;
T_ExchgParam.T_StationCommon.rRockerAmplitudeMax:=grRockerAmplitudeMax;
T_ExchgParam.T_StationCommon.rRockerQuality:=grRockerQuality;
T_ExchgParam.T_StationCommon.rRockerQualityMin:=grRockerQualityMin;
T_ExchgParam.T_StationCommon.rRockerQualityMax:=grRockerQualityMax;
T_ExchgParam.T_StationCommon.rRockerPosition:=grRockerPosition;
T_ExchgParam.T_StationCommon.diRockerCountHC:=gdiRockerCountHC;
T_ExchgParam.T_StationCommon.diRockerCountHCTime:=gdiRockerCountHCTime;
END_ACTION

ACTION	HW_TorqueSensor2:
(******************************************************************************************************************************************)
(****************************  		       Analog Sensor für Drehmomentdetektion                  ********************************)
(******************************************************************************************************************************************)
ptrTSensorTorque^.T_CtrleCyl.T_Analog.rPosIn:= ((INT_TO_REAL(IiAToolTorque2)/32767.0)*2000.0) - T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1];	(* Messbereich 0 - 2Nm-->2000mNm *)
IF (ptrTSensorTorque^.T_CtrleCyl.T_Analog.rPosIn <= 0.0) THEN
	ptrTSensorTorque^.T_CtrleCyl.T_Analog.rPosIn:=0.0;
END_IF;
ptrTSensorTorque^.T_CtrleCyl.xDone:=TRUE;

(* Drehmoment für Bearbeitung *)
ptrTSensorTorque^.T_CtrleCyl.xStatePosOn:=		ptrTSensorTorque^.T_CtrleCyl.T_Analog.rPosIn >=
												T_Station_Parameter.T_OnlineChange.rTorqueLevelHC;

(* Drehmoment für Ausfunken *)
ptrTSensorTorque^.T_CtrleCyl.xStatePosOn1:= 	ptrTSensorTorque^.T_CtrleCyl.T_Analog.rPosIn >=
												((T_Station_Parameter.T_OnlineChange.rTorqueLevelHC/100.0)*T_Station_Parameter.T_StProcess.rSparkOutTorqueLevel);

(* Drehmoment für Regler *)
ptrTSensorTorque^.T_CtrleCyl.xStatePosOff:=		(ptrTSensorTorque^.T_CtrleCyl.T_Analog.rPosIn >= 0.5);

CASE T_ExchgParam.bToolSpindleActive OF
2:	T_Station_Parameter.T_TorqueSystem_L.rActual_Torque:=	ptrTSensorTorque^.T_CtrleCyl.T_Analog.rPosIn;
3:	T_Station_Parameter.T_TorqueSystem_M.rActual_Torque:=	ptrTSensorTorque^.T_CtrleCyl.T_Analog.rPosIn;
END_CASE;

END_ACTION

ACTION	HW_TorqueSensorControl:
(******************************************************************************************************************************************)
(****************************  		   Drehmomentsensor Überprüfung Funktionalität             ********************************)
(******************************************************************************************************************************************)
fbTorqueSensorControl(	xCtrlePosOn:= FALSE,
						xCtrlePosOff:= FALSE,
						T_Cylinder:= ptrTTorqueSensorControl^);
QxControlTorqueSensor:=fbTorqueSensorControl.xCylinder;
END_ACTION

ACTION	HW_TorqueSensorMeasureRange:
(******************************************************************************************************************************************)
(****************************  		     Drehmomentsensor Messbreicheinstellung                  ********************************)
(******************************************************************************************************************************************)
fbTorqueSensorMeasRange(	xCtrlePosOn:= FALSE,
							xCtrlePosOff:= FALSE,
							T_Cylinder:= ptrTTorqueSensorMeasRange^);
QxMeasRangeTorqueSensor:=fbTorqueSensorMeasRange.xCylinder;
END_ACTION

ACTION	HW_TSensorToolSpindle_L_Connect:
(******************************************************************************************************************************************)
(************************  		       Digitaler Sensor für Spindelkopf L angeschlossen                         ***************************)
(******************************************************************************************************************************************)
T_Station_Work.THWWorkStation.TSensorToolSpindle_L_Connect.T_CtrleCyl.xStatePosOff:=(IbTooSpindleActive = 1);
T_Station_Work.THWWorkStation.TSensorToolSpindle_L_Connect.T_CtrleCyl.xStatePosOn:=(IbTooSpindleActive = 2);
T_Station_Work.THWWorkStation.TSensorToolSpindle_L_Connect.T_CtrleCyl.xStatePosOn1:=(IbTooSpindleActive = 3);
END_ACTION

ACTION	HW_ValveAirTable:
(******************************************************************************************************************************************)
(********************************   		               Ventil für Luft des Tisches                           ********************************)
(******************************************************************************************************************************************)
fbValveAirTable(		xCtrlePosOn:= FALSE,
					xCtrlePosOff:= FALSE,
					T_Cylinder:= ptrTValveAirTable^);
QxAirTable:=fbValveAirTable.xCylinder;	(* Ventil QxAirTable-->Ventil für die Luft des Tisches *)
END_ACTION

ACTION	HW_ValveCleanNozzle:
(******************************************************************************************************************************************)
(******************************** 					 Ventil fuer die Reinigungsduese 			 ********************************)
(******************************************************************************************************************************************)
fbValveCleanNozzle(	xCtrlePosOn:= FALSE,
					xCtrlePosOff:= FALSE,
					T_Cylinder:= ptrTValveCleanNozzle^);
QxValveCleanNozzle:=fbValveCleanNozzle.xCylinder;	(* Ventil QxValveCleanNozzle-->Ventil fuer die Reinigungsduese *)
END_ACTION

ACTION	HW_ValveVacuumTable:
(******************************************************************************************************************************************)
(********************************   		        Ventil fuer das Vakuum des Tisches                    ********************************)
(******************************************************************************************************************************************)
fbValveVacuumTable(		xCtrlePosOn:= FALSE,
							xCtrlePosOff:= FALSE,
							T_Cylinder:= ptrTValveVacuumTable^);
QxVacuumTable:=fbValveVacuumTable.xCylinder;	(* Ventil QxVacuumTable-->Ventil fuer das Vakuum des Tisches *)
END_ACTION























(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER2_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_HW_GENERAL
VAR
(* CPU *)
	(* function bloc *)
	(* IO connection *)
(* Fieldbus *)
	(* function bloc *)
	(* IO connection *)
	FBHWHdd: FBHW_HDD;
	fbNovRam: FBHW_NOVRAM;
	fbProfileFile:FB_PROFILE_FILE;
	FBPassword:FB_PASSWORD;
	FBProcessData_St1: FB_PROCESSDATA;
	fbGetUPSStatus: FB_GetUPSStatus;
	xValid: BOOL;
	xError: BOOL;
	udiErrorNr: UDINT;
	FBControlLamp: FB_ControlLamp;
	FBHW_MachineLamp: FBHW_CYL_STANDARD;
END_VAR
(* @END_DECLARATION := '0' *)
_FBD_BODY
_NETWORKS : 17
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERATOR
_BOX_EXPR : 6
_OPERAND
_EXPRESSION
_NEGATIV
TProcess.T_Ctrle.xExecute
_OPERAND
_EXPRESSION
_NEGATIV
TProcess.T_Ctrle.xDone
_OPERAND
_EXPRESSION
_NEGATIV
TProcess.T_Ctrle.xError
_OPERAND
_EXPRESSION
_POSITIV
TProcess.T_Ctrle.xRdy
_OPERAND
_EXPRESSION
_POSITIV
TProcess.T_Ctrle.xReferenced
_OPERATOR
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
TProcess.T_Ctrle.iFunctNr
_OPERAND
_EXPRESSION
_POSITIV
2
_EXPRESSION
_POSITIV
EQ
_EXPRESSION
_POSITIV
AND
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
gxMachineAutomodeActive_St1St2
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_FUNCTIONBLOCK
fbGetUPSStatus
_BOX_EXPR : 3
_OPERAND
_EXPRESSION
_POSITIV
''
_OPERAND
_EXPRESSION
_POSITIV
_EMPTY
_OPERAND
_EXPRESSION
_POSITIV
TRUE
_EXPRESSION
_POSITIV
FB_GetUPSStatus
_OUTPUTS : 3
_OUTPUT
_POSITIV
_NO_SET
xError
_OUTPUT
_POSITIV
_NO_SET
udiErrorNr
_OUTPUT
_POSITIV
_NO_SET
TStatusUPS
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
xValid
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
xValid
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
T_CtrleUPS.xUPSReady
_NETWORK

_COMMENT
''
_END_COMMENT
_JUMP
_EXPRESSION
_POSITIV
DeactivateLamp
_OPERAND
_EXPRESSION
_POSITIV
T_ExchgParam.T_SafetyCtrl.xDeactivateLamp
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_FUNCTIONBLOCK
FBControlLamp
_BOX_EXPR : 6
_OPERAND
_EXPRESSION
_POSITIV
T_StartUp.T_State.xCompleted
_OPERAND
_EXPRESSION
_POSITIV
T_ExchgParam.T_Visu.T_Message.iState
_OPERAND
_EXPRESSION
_POSITIV
gT_SafetyStatus.xSetupOperateModeActive
_OPERAND
_EXPRESSION
_POSITIV
gT_PreWarning.xPreWarningActive
_OPERAND
_EXPRESSION
_POSITIV
TProcess
_OPERAND
_EXPRESSION
_POSITIV
T_CtrlePanel
_EXPRESSION
_POSITIV
FB_ControlLamp
_OUTPUTS : 2
_OUTPUT
_POSITIV
_NO_SET
QxSignalLampRed
_OUTPUT
_POSITIV
_NO_SET
QxSignalLampYellow
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
QxSignalLampGreen
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_FUNCTIONBLOCK
FBHW_MachineLamp
_BOX_EXPR : 3
_OPERAND
_EXPRESSION
_POSITIV
FALSE
_OPERAND
_EXPRESSION
_POSITIV
FALSE
_OPERAND
_EXPRESSION
_POSITIV
TMachineLamp
_EXPRESSION
_POSITIV
FBHW_CYL_STANDARD
_OUTPUTS : 0
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
QxMachineLamp
_NETWORK
DeactivateLamp
_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
FALSE
_EXPRESSION
_POSITIV
_OUTPUTS : 2
_OUTPUT
_POSITIV
_NO_SET
TMachineLamp.T_CtrleCyl.xReset
_OUTPUT
_POSITIV
_NO_SET
TMachineLamp.T_CtrleCyl.xExecute
_NETWORK

_COMMENT
''
_END_COMMENT
_FUNCTIONBLOCK
FBHWHdd
_BOX_EXPR : 1
_OPERAND
_EXPRESSION
_POSITIV
T_HDD
_EXPRESSION
_POSITIV
FBHW_HDD
_OUTPUTS : 0
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
FALSE
_EXPRESSION
_POSITIV
_OUTPUTS : 2
_OUTPUT
_POSITIV
_NO_SET
T_HDD.T_Ctrle.xExecute
_OUTPUT
_POSITIV
_NO_SET
T_HDD.T_Ctrle.xReset
_NETWORK

_COMMENT
''
_END_COMMENT
_FUNCTIONBLOCK
fbNovRam
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
5
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam
_EXPRESSION
_POSITIV
FBHW_NOVRAM
_OUTPUTS : 0
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
FALSE
_EXPRESSION
_POSITIV
_OUTPUTS : 2
_OUTPUT
_POSITIV
_NO_SET
T_NovRam.T_Ctrle.xReset
_OUTPUT
_POSITIV
_NO_SET
T_NovRam.T_Ctrle.xExecute
_NETWORK

_COMMENT
''
_END_COMMENT
_FUNCTIONBLOCK
fbProfileFile
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
T_Profile
_OPERAND
_EXPRESSION
_POSITIV
T_HDD
_EXPRESSION
_POSITIV
FB_PROFILE_FILE
_OUTPUTS : 0
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
FALSE
_EXPRESSION
_POSITIV
_OUTPUTS : 2
_OUTPUT
_POSITIV
_NO_SET
T_Profile.T_Ctrle.xReset
_OUTPUT
_POSITIV
_NO_SET
T_Profile.T_Ctrle.xExecute
_NETWORK

_COMMENT
''
_END_COMMENT
_FUNCTIONBLOCK
FBPassword
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
T_Password
_OPERAND
_EXPRESSION
_POSITIV
T_HDD
_EXPRESSION
_POSITIV
FB_PASSWORD
_OUTPUTS : 0
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
FALSE
_EXPRESSION
_POSITIV
_OUTPUTS : 2
_OUTPUT
_POSITIV
_NO_SET
T_Password.T_Ctrle.xReset
_OUTPUT
_POSITIV
_NO_SET
T_Password.T_Ctrle.xExecute
_NETWORK

_COMMENT
''
_END_COMMENT
_FUNCTIONBLOCK
FBProcessData_St1
_BOX_EXPR : 3
_OPERAND
_EXPRESSION
_POSITIV
T_ProcessData_St1
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1]
_OPERAND
_EXPRESSION
_POSITIV
T_HDD
_EXPRESSION
_POSITIV
FB_PROCESSDATA
_OUTPUTS : 0
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
FALSE
_EXPRESSION
_POSITIV
_OUTPUTS : 2
_OUTPUT
_POSITIV
_NO_SET
T_ProcessData_St1.T_Ctrle.xReset
_OUTPUT
_POSITIV
_NO_SET
T_ProcessData_St1.T_Ctrle.xExecute

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER2_HARDWARE' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_HW_WORK_ST1
VAR
	FBHWStationWork_St1: FBHW_STATION_WORK;
(* Axis value *)
	IuiActualTorqueAxisZ_St1 AT %I*:UINT;
	IwInputState_Z_Axis_St1 AT %I*:WORD;
	IuiActualTorqueAxisS_St1 AT %I*:UINT;
	IwInputState_S1_Axis_St1 AT %I*:WORD;
	IwInputState_S2_Axis_St1 AT %I*:WORD;									(* IGS *)
	IwInputState_S3_Axis_St1 AT %I*:WORD;									(* IGS *)

(* Axis structure *)
	stZRefIn_St1 AT %I* :NCTOPLC_AXLESTRUCT;
	stZRefOut_St1 AT %Q* :PLCTONC_AXLESTRUCT;
	stZDriveState_St1 AT %I*:ST_AXIS_DRIVESTATE;
	stSRefIn_St1 AT %I* :NCTOPLC_AXLESTRUCT;
	stSRefOut_St1 AT %Q* :PLCTONC_AXLESTRUCT;
	stS2RefIn_St1 AT %I* :NCTOPLC_AXLESTRUCT;		(* Beckhoff Spindel L *)	(* IGS *)
	stS2RefOut_St1 AT %Q* :PLCTONC_AXLESTRUCT;	(* Beckhoff Spindel L *)	(* IGS *)
	stS3RefIn_St1 AT %I* :NCTOPLC_AXLESTRUCT;		(* Beckhoff Spindel M *)	(* IGS *)
	stS3RefOut_St1 AT %Q* :PLCTONC_AXLESTRUCT;	(* Beckhoff Spindel M *)	(* IGS *)

(* Axis DC structure *)
	stBubblerDataINSt1 AT %I*  : ST_COMM_IN_DCAXIS;			(* IGS3 *)
	stBubblerDataOUTSt1 AT %Q*  : ST_COMM_OUT_DCAXIS;		(* IGS3 *)
	stFeedpumpINDataSt1 AT %I*  : ST_COMM_IN_DCAXIS;		(* IGS3 *)
	stFeedpumpOUTDataSt1 AT %Q*  : ST_COMM_OUT_DCAXIS;	(* IGS3 *)

(* FB Output *)
	xActiveHWWork_St1 : BOOL;
	xActiveStationWork_St1 : BOOL;
	wState_Z_Axis_St1: WORD;

	xStationPowerON_St1:BOOL;

(* Drehmomentüberlast *)
	IudiTorqueOverloadCounterValue_St1			AT%I*:UDINT;	(* Clock-->Signal induktiver Sensor für Drehmomentüberlast *)		(* IGS *)
END_VAR
(* @END_DECLARATION := '0' *)
_FBD_BODY
_NETWORKS : 8
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERATOR
_BOX_EXPR : 3
_OPERAND
_EXPRESSION
_POSITIV
gT_SafetyStatus.xEnergyONNormalMode
_OPERAND
_EXPRESSION
_POSITIV
gT_SafetyStatus.xEnergyONSetupModeASt1
_OPERAND
_EXPRESSION
_POSITIV
gT_SafetyStatus.xEnergyONSetupModeBSt1
_EXPRESSION
_POSITIV
OR
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
xStationPowerON_St1
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
IudiTorqueOverloadCounterValue_St1
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
gudiTorqueOverloadCounterValueSt1
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERATOR
_BOX_EXPR : 3
_OPERATOR
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
gxHardwareOFF
_OPERAND
_EXPRESSION
_POSITIV
gxAxisOFF
_EXPRESSION
_POSITIV
OR
_OPERAND
_EXPRESSION
_POSITIV
IwInputState_Z_Axis_St1
_OPERAND
_EXPRESSION
_POSITIV
24
_EXPRESSION
_POSITIV
SEL
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
wState_Z_Axis_St1
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_FUNCTIONBLOCK
FBHWStationWork_St1
_BOX_EXPR : 39
_OPERAND
_EXPRESSION
_POSITIV
1
_OPERAND
_EXPRESSION
_POSITIV
xStationPowerON_St1
_OPERAND
_EXPRESSION
_POSITIV
IxToolDeflection_St1
_OPERAND
_EXPRESSION
_POSITIV
IiAToolTorque_St1
_OPERAND
_EXPRESSION
_POSITIV
IiAToolTorque2_St1
_OPERAND
_EXPRESSION
_POSITIV
IxBrakeReleaseZ1Axis_St1
_OPERAND
_EXPRESSION
_POSITIV
IxUpperToolGuide_WorkpieceClamped_St1
_OPERAND
_EXPRESSION
_POSITIV
T_ExchgParam.bToolSpindleActive
_OPERAND
_EXPRESSION
_POSITIV
1001
_OPERAND
_EXPRESSION
_POSITIV
1003
_OPERAND
_EXPRESSION
_POSITIV
IxTorqueOverload_St1
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Parameter.T_StationWork[gciStationSt1]
_OPERAND
_EXPRESSION
_POSITIV
TStation_Work_St1
_OPERAND
_EXPRESSION
_POSITIV
IuiActualTorqueAxisZ_St1
_OPERAND
_EXPRESSION
_POSITIV
wState_Z_Axis_St1
_OPERAND
_EXPRESSION
_POSITIV
IuiActualTorqueAxisS_St1
_OPERAND
_EXPRESSION
_POSITIV
IwInputState_S1_Axis_St1
_OPERAND
_EXPRESSION
_POSITIV
IwInputState_S2_Axis_St1
_OPERAND
_EXPRESSION
_POSITIV
IwInputState_S3_Axis_St1
_OPERAND
_EXPRESSION
_POSITIV
stZRefIn_St1
_OPERAND
_EXPRESSION
_POSITIV
stZRefOut_St1
_OPERAND
_EXPRESSION
_POSITIV
stZDriveState_St1
_OPERAND
_EXPRESSION
_POSITIV
stSRefIn_St1
_OPERAND
_EXPRESSION
_POSITIV
stSRefOut_St1
_OPERAND
_EXPRESSION
_POSITIV
stS2RefIn_St1
_OPERAND
_EXPRESSION
_POSITIV
stS2RefOut_St1
_OPERAND
_EXPRESSION
_POSITIV
stS3RefIn_St1
_OPERAND
_EXPRESSION
_POSITIV
stS3RefOut_St1
_OPERAND
_EXPRESSION
_POSITIV
T_HDD
_OPERAND
_EXPRESSION
_POSITIV
T_TwinSafe_Ctrle_Z_Axis_St1
_OPERAND
_EXPRESSION
_POSITIV
T_TwinSafe_Status_Z_Axis_St1
_OPERAND
_EXPRESSION
_POSITIV
T_TwinSafe_Ctrle_S2_Axis_St1
_OPERAND
_EXPRESSION
_POSITIV
T_TwinSafe_Status_S2_Axis_St1
_OPERAND
_EXPRESSION
_POSITIV
T_TwinSafe_Ctrle_S3_Axis_St1
_OPERAND
_EXPRESSION
_POSITIV
T_TwinSafe_Status_S3_Axis_St1
_OPERAND
_EXPRESSION
_POSITIV
stBubblerDataINSt1
_OPERAND
_EXPRESSION
_POSITIV
stBubblerDataOUTSt1
_OPERAND
_EXPRESSION
_POSITIV
stFeedpumpINDataSt1
_OPERAND
_EXPRESSION
_POSITIV
stFeedpumpOUTDataSt1
_EXPRESSION
_POSITIV
FBHW_STATION_WORK
_OUTPUTS : 13
_OUTPUT
_POSITIV
_NO_SET
xActiveStationWork_St1
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
QiAToolDeflection_SM_St1
_OUTPUT
_POSITIV
_NO_SET
QiAToolTorqueHC_SM_St1
_OUTPUT
_POSITIV
_NO_SET
QiAToolTorqueOverload_SM_St1
_OUTPUT
_POSITIV
_NO_SET
QxCylBrakeReleaseZAxis_Open_St1
_OUTPUT
_POSITIV
_NO_SET
QxCylBrakeReleaseZAxis_Close_St1
_OUTPUT
_POSITIV
_NO_SET
_EMPTY
_OUTPUT
_POSITIV
_NO_SET
QxCylWorkpieceClamp_St1
_OUTPUT
_POSITIV
_NO_SET
QxAirTable
_OUTPUT
_POSITIV
_NO_SET
QxVacuumTable
_OUTPUT
_POSITIV
_NO_SET
QxMeasRangeTorqueSensor_St1
_OUTPUT
_POSITIV
_NO_SET
QxControlTorqueSensor_St1
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
xActiveHWWork_St1
_NETWORK

_COMMENT
''
_END_COMMENT
_JUMP
_EXPRESSION
_POSITIV
ResetOutput_WORK
_OPERAND
_EXPRESSION
_NEGATIV
TStation_Work_St1.TControl.xActiveHardware
_NETWORK

_COMMENT
''
_END_COMMENT
_RET
_EXPRESSION
_POSITIV
_OPERAND
_EXPRESSION
_POSITIV
TRUE
_NETWORK
ResetOutput_WORK
_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
FALSE
_EXPRESSION
_POSITIV
_OUTPUTS : 7
_OUTPUT
_POSITIV
_NO_SET
QxCylBrakeReleaseZAxis_Open_St1
_OUTPUT
_POSITIV
_NO_SET
QxCylBrakeReleaseZAxis_Close_St1
_OUTPUT
_POSITIV
_NO_SET
QxCylWorkpieceClamp_St1
_OUTPUT
_POSITIV
_NO_SET
QxAirTable
_OUTPUT
_POSITIV
_NO_SET
QxVacuumTable
_OUTPUT
_POSITIV
_NO_SET
QxMeasRangeTorqueSensor_St1
_OUTPUT
_POSITIV
_NO_SET
QxControlTorqueSensor_St1
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
0
_EXPRESSION
_POSITIV
_OUTPUTS : 3
_OUTPUT
_POSITIV
_NO_SET
QiAToolDeflection_SM_St1
_OUTPUT
_POSITIV
_NO_SET
QiAToolTorqueHC_SM_St1
_OUTPUT
_POSITIV
_NO_SET
QiAToolTorqueOverload_SM_St1

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER3_STATION\/FBSTATIONEN' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_STATION_WORK
VAR_INPUT
	xSafetyCircuitOn:BOOL;
	xAxisBrakeBlock:BOOL;		(* Blockieren der automatischen überwachung der Achsenbremsen *)
	xProcessDone:BOOL;
END_VAR
VAR_IN_OUT
	T_Station_Parameter: ST_RETAIN_DATA_STATIONWORK;
	T_Station_Work : ST_STATION;
END_VAR
VAR_OUTPUT
	xActive : BOOL :=FALSE;
	xStatusRdy : BOOL := FALSE;
	xStatusEnd : BOOL := FALSE;
	xStatusStop : BOOL := FALSE;
	xStatusRef : BOOL := FALSE;
	xError : BOOL := FALSE;
	iErrorNr : DINT :=0;
	iStatusFctNr : INT := 0;
END_VAR
VAR
(* Pointer auf Actuatoren *)
	ptrTAxisZ 							:POINTER TO ST_AXIS;		(* Achse für die Hubachse *)
	ptrTAxisS 							:POINTER TO ST_AXIS;		(* Achse für die Werkzeugspindel *)
	ptrTCylToolDeflection					:POINTER TO ST_CYLINDER;	(* Servoventil für das bestimmen der vertikalen Auslenkraft *)
	ptrTCylToolTorqueHC 					:POINTER TO ST_CYLINDER;	(* Drehmomentueberwachung HC *)
	ptrTCylToolTorqueOverload 			:POINTER TO ST_CYLINDER;	(* Drehmomentueberwachung Ueberlast *)
	ptrTTorqueSensorMeasRange			:POINTER TO ST_CYLINDER;	(* Controlling fuer den Drehmomentsensor, Einstellung des Drehmomentbereiches *)	(* IGS *)
	ptrTTorqueSensorControl				:POINTER TO ST_CYLINDER;	(* Controlling fuer den Drehmomentsensor, Ueberprüfung auf Funktionalitaet *)			(* IGS *)
	ptrTSensorTorque 					:POINTER TO ST_CYLINDER;	(* Analoger Sensor für Drehmoment detektion *)								(* IGS *)
	ptrTSensorTorqueOverload 			:POINTER TO ST_CYLINDER;	(* Digitaler Sensor für Drehmoment Ueberlast detektion *)							(* IGS *)
	ptrTCylBrakeReleaseZAxis 				:POINTER TO ST_CYLINDER;	(* Zylinder für lösen der Bremse bei der Z Achse *)
	ptrTCylWorkpieceClamp				:POINTER TO ST_CYLINDER;	(* Ventil fuer Werkstueckfixierzylinder *)
	ptrTValveAirTable						:POINTER TO ST_CYLINDER;	(* Ventil fuer die Luft des Tisches *)
	ptrTValveVacuumTable				:POINTER TO ST_CYLINDER;	(* Ventil fuer Vacuum des Tisches *)
	ptrTValveCleanNozzle					:POINTER TO ST_CYLINDER;	(* Ventil fuer die Reinigungsduese*)											(* BEF *)
	ptrTAxisBubbler						:POINTER TO ST_DC_AXIS;	(* Ruehrwerk fuer Suspension *)												(* IGS3 *)
	ptrTAxisFeedPump					:POINTER TO ST_DC_AXIS;	(* Foerderpumpe fuer Suspension *)											(* IGS3 *)

	TDeleteStationStruct : ST_STATION;
	xTmpStopFunction: BOOL := FALSE;
	iStationFunctionNr: INT := 0;
(* Trigger *)
	fbFTrig: F_TRIG;
	fbRTrig: R_TRIG;
	xInitDelEnable: BOOL := FALSE;
	xReadyChkError: BOOL;
	xDontDeleteErrorFlag: BOOL;
	xInitStep: BOOL := FALSE;
	xInitSetEnable: BOOL := FALSE;
	xRdyDisableStation: BOOL;
	iStepEnable: INT := 0;
	xStartFunction: BOOL := FALSE;
	iMaxFunctionNr:INT:=10;
	xTmp: BOOL;
	xSetEnd: BOOL := FALSE;
	xSetError: BOOL;
	diErrorNumber: DINT;
	iCountCycle: INT;
	TONCheckAxisVoltagBooting: TON;
	xStartTimer: BOOL;
	xWaitAxisVoltageBooting: BOOL;
	TONWaitAxisCurrentSwitchON: TON;
	xSecurityCircuitOn: BOOL;
	xSecurityCircuitOff: BOOL;
	iStepSecCircuit: INT;
	xInitSecCircuit: BOOL;
	TONCheckError: TON;
	xStationError: BOOL := FALSE;
	xForceHWError: BOOL;
	xForceResetAxis: BOOL;
	xInitError: BOOL := FALSE;
	iSettledErrFromFunction: INT;
	xTmpStationError: BOOL;
	xAxisErrorActive: BOOL;
	TONWaitReset: TON;
	xStepError: BOOL;
	xReadyToQuitErr: BOOL;
	xTmpStart: BOOL := FALSE;
	xInitStart: BOOL := FALSE;
	xInitStop: BOOL := FALSE;
	xCheckAxisCurrent: BOOL;
	xStFct_Reset: BOOL;
	xStFct_SetEnd: BOOL;
	xStFct_End: BOOL;
	xStFct_Stop: BOOL;
	xStFct_Start: BOOL;
	xStFct_StartMainPrc: BOOL;
	iStFct_StepError: INT;
	xStFct_InitError: BOOL;
	xStFct_HardwareError: BOOL;
	diStFct_ErrorNr: DINT;
	diStFct_TmpErrorNr: DINT;
	xStFct_Error: BOOL;
	xStFct_QuitErr: BOOL;
	xStFct_Abord: BOOL;
	xStFct_ErrorActuator: BOOL;
	xStFct_ExecuteActuator: BOOL;
	xStFct_StartMainCtr: BOOL;
	xStFct_InitMainCtr: BOOL;
	iStFct_StepPrc: INT;
	xStFct_InitStep: BOOL;
	wStFct_Status: WORD;
	xStFct_TmpStop: BOOL;
	iStFct_TmpStopStep: INT;
	xStFct_Freeze: BOOL;
	xStFct_StartPrc_Parallel: BOOL;
	iStFct_StepPrc_Parallel: INT;
	xStFct_InitStep_Parallel: BOOL;
	xStFct_StopSlide: BOOL;
	fbStFct_CalcCuttingSpeed:FB_CalcCuttingSpeed;
	fbStFct_SparkOutProcess:FB_SparkOutProcess;
	xStFct_CapturePosition: BOOL;
	xStFct_ResetCalcCutSpeed: BOOL;
	xStFct_TmpActiveFirstHC: BOOL;
	xStFct_StartProcessTimer: BOOL;
	fbStFct_TONProcessMinTime: TON;
	xStFct_MinTimeProcessReady: BOOL;
	fbStFct_TONProcessMaxTime: TON;
	xStFct_TmpStopProcess: BOOL;
	xStFct_InitStopProcess: BOOL;
	iStFct_StopProcess: INT;
	xStFct_StartSparkOutProcess: BOOL;
	xStFct_ResetSparkOutProcess: BOOL;
	rStFct_TmpDiffOverLimitPosition: REAL;
	rStFct_StopPosition: REAL;
	iStFct_TmpHCStartPosCounter: INT;
	iStFct_TmpNumberTryInfeed: INT;
	rStFct_ForceDeflection: REAL;
	rStFct_ForceTorque: REAL;
	TONTimeOutEnablePart: TON;
	xStFct_PositionOutRange_Z: BOOL;
	iStFct_PosErrorNr: INT;
	xStFct_DeflCalibError: BOOL;
	xStFct_TorqueCalibError: BOOL;
	xStFct_ForceStationError: BOOL;
	iStFct_StepCollision: INT;
	xFirstBooting: BOOL;
	TONStFct_WaitAxisReady: TON;
	lrStFct_SaveAxisPosition: LREAL;
	xStFct_ForceSetSpeedZAxis: BOOL;
	xStFct_ForceSetSpeedTorqueZAxis: BOOL;
	xStFct_BlockWorking2: BOOL;
	xStFct_InitialCalcProcWork: BOOL;
	rStFct_ZSavePosition: REAL;
	rStFct_ZCalcDistance: REAL;
	diStFct_Counter: DINT;
	rStFct_CalcWorkForce: REAL;
	iStFct_StepMaxProcWork: INT;
	xStFct_ForceHC: BOOL;
	iStFct_StepZWorkSpeedRegulator: INT;
	rStFct_AddWorkForce: REAL;
	rStFct_CheckZSavePosition: REAL;
	iStFct_StepCheckToolBlock: INT;
	xStFct_HCActivated: BOOL;
	iStFct_StepCheckTorque: INT;
	iStFct_DataInputNr: INT;
	xStFct_ToolDeflectionActiveStopProcess: BOOL;
	xStFct_ToolClampInactiveStopProcess: BOOL;
	iStFct_StepWPRotate: INT;
	xStFct_WPRotated: BOOL;
	xStFct_ForceRotate: BOOL;
	iStFct_NumberWPRotate: INT;
	xStFct_Overload_StopProcess: BOOL;
	iStFct_Overload_StopProcess: INT;
	TONWorkTime: TON;
	iStFct_StepStartToolSpindle: INT;
	xStFct_InitStepStartToolSpindle: BOOL;
	iStFct_StepStopToolSpindle: INT;
	xStFct_InitStepStopToolSpindle: BOOL;
	rStFct_TmpOffsetDeflection: REAL;
	rStFct_TmpOffsetTorque: REAL;
	xStFct_TmpSaveOffset: BOOL;
	xStFct_SetForceToolDeflection: BOOL;
	iStFct_StepSetForceToolDeflection: INT;
	TONStFct_DeflectionSensorON: TON;
	TONStFct_DeflectionSensorOFF: TON;
	xStFct_DeflectionSensorON: BOOL;
	iStFct_ii: INT;
	xStFct_FirstTime: BOOL;
	tStFct_MaxTimeActiveFunction: TIME;
	fbStFct_TONChkMaxTimeActive: TON;
	fbStFct_TONWaitCycle: TON;
	tStFct_TimeSpindleActive: TIME;
	tStFct_TimeSpindleInactive: TIME;
	xSetSlowToFastSpeed: BOOL;
	rStFct_SetZHCPosition:REAL;
	xStFct_ToolDeflectionActiv: BOOL;
	xStFct_InitAxialSensor: BOOL;
	xStFct_CheckAxialSensor: BOOL;
	lrStFct_ActualPosition: LREAL;
	xStFct_ZAxisBrakeBlocked: BOOL;
	xMaxTorqueActive: BOOL;
	xPartDiscNotInPosition: BOOL;
	TONWaitCheckCylinder: TON;
	TONStFct_TorqueSensorOFF: TON;
	TONStFct_TorqueSensorON: TON;
	xStFct_TorqueSensorON: BOOL;
	xStFct_ToolTorqueCheckedOK: BOOL;
	xStFct_CheckState1: BOOL;
	xStFct_CheckState2: BOOL;
	xStFct_CheckActive1: BOOL;
	xStFct_CheckActive2: BOOL;
	xStFct_FirstTimeTorque: BOOL;
	xStFct_SetForceToolTorque: BOOL;
	iStFct_StepSetForceToolTorque: INT;
	xBlockCheckLimitSwitch: BOOL;
	TONCalcMinTimeEnable: TON;

	rTorquePercent: REAL;							(* IGS *)


	TONWaitReady:TON;							(* IGS *)
	rStFct_V1:REAL;								(* IGS *)
	rStFct_V2:REAL;								(* IGS *)
	rStFct_S1:REAL;								(* IGS *)
	rStFct_S2:REAL;								(* IGS *)
	rStFct_M:REAL;								(* IGS *)
	rTorqueForce:REAL;							(* IGS *)
	rActTorque:REAL;								(* IGS *)
	rTorqueMax:REAL;							(* IGS *)
	rTorqueMax_Max:REAL;						(* IGS *)
	rTorqueMin:REAL;								(* IGS *)
	rTorqueMin_Min:REAL;							(* IGS *)
	rStFct_CalcZSpeed:REAL;						(* IGS *)

	(* Progressiv Stroke *)
	xProgressStrokeReady:BOOL;					(* BEF *)
	xProgressStrokeRunning:BOOL;					(* BEF *)
	iStepProgressStroke:INT;						(* BEF *)
	rStFct_ProgressStrokePosition:REAL;			(* BEF *)


	(* .HW_Axis_DC *)
(*	iStepBubbler:INT;															(* IGS3 *)
	iStepFeeder:INT;															(* IGS3 *)*)

	(* .StationFunction_Fct_07_Calibration2 *)
	TONStFct_WaitMeasure:TON;					(* IGS *)
	iStFct_MeasuringStep:INT;						(* IGS *)
	arStFct_NullPointToolTorque:ARRAY [1..20] OF REAL;	(* Durchschnittswert von 20 Messwerten wird der Nullpunkt bestimmt *)		(* IGS *)
	rStFct_NullPointToolTorque: REAL;				(* IGS *)
	TONWaitHCActive: TON;
	TONWaitHCInactive: TON;
	lrActualPositionSave: LREAL;
	lrZ1HCMinPosition: LREAL;
	lrZ1HCMaxPosition: LREAL;
	diHCCheckCounter: DINT;
	lrActualPositionSaveSwitchZSpeed: LREAL;
	TONWaitStopOAxis: TON;
	xZFastSpeedSettled: BOOL;

	TONCalcTorque: TON;
	diStepCount: DINT;
	rTorqueSpindleSensorSave: REAL;
	rTorqueSpindleSensor: REAL;
	rOutMaxLimit: REAL;
	rOutMinLimit: REAL;
	T_CtrlPara: ST_CTRL_PID_PARAM;
	FBPIDCTRL: FB_PID_CONTROL;
	T_CtrlPara_D: ST_CTRL_PID_PARAM;
	rActualValue: REAL;
	FBDCONTROL: FB_D_CONTROL;
	rStFct_CalcZSpeed_D: REAL;
	TONWaitMovement: TON;
	RisingEdgeCountHC: R_TRIG;
	rOutfeedStrokeAxisSpeed: REAL;
	xBlockSetFastVelZAxis: BOOL;
	lrStartRecordMaxTorque: LREAL;
	lrZCheckPosition: LREAL;
	xSetDefaultSpeedS: BOOL;
	lrSaveSSpeed: LREAL;
	xBlockActivateOAxis: BOOL;
	xEndPosReachZylindricalProcess: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                 This Functionblock manage all the station funtion and synchronizing of the Hardware                           ************)
(****************************************************************************************************************************************************)
xActive:=T_Station_Work.TControl.xActiveStation;
IF NOT(T_Station_Work.TControl.xActiveStation) THEN
	IF T_Station_Work.xActive THEN
		T_Station_Work:=TDeleteStationStruct;
	END_IF;
	T_Station_Work.xActive:=FALSE;
	RETURN;
ELSE
	(* Zuweisung der Datenstrukturen der Aktuatoren als Pointer *)
	ptrTAxisZ:=ADR(T_Station_Work.THWWorkStation.TAxisZ);
	ptrTAxisS:=ADR(T_Station_Work.THWWorkStation.TAxisS);
	ptrTCylToolDeflection:=ADR(T_Station_Work.THWWorkStation.TCylToolDeflection);
	ptrTCylToolTorqueHC:=ADR(T_Station_Work.THWWorkStation.TCylToolTorqueHC);
	ptrTCylToolTorqueOverload:=ADR(T_Station_Work.THWWorkStation.TCylToolTorqueOverload);
	ptrTTorqueSensorMeasRange:=ADR(T_Station_Work.THWWorkStation.TTorqueSensorMeasRange);
	ptrTTorqueSensorControl:=ADR(T_Station_Work.THWWorkStation.TTorqueSensorControl);
	ptrTSensorTorque:=ADR(T_Station_Work.THWWorkStation.TSensorTorque);
	ptrTSensorTorqueOverload:=ADR(T_Station_Work.THWWorkStation.TSensorTorqueOverload);
	ptrTCylBrakeReleaseZAxis:=ADR(T_Station_Work.THWWorkStation.TCylBrakeReleaseZAxis);
	ptrTCylWorkpieceClamp:=ADR(T_Station_Work.THWWorkStation.TCylWorkpieceClamp);
	ptrTValveAirTable:=ADR(T_Station_Work.THWWorkStation.TValveAirTable);
	ptrTValveVacuumTable:=ADR(T_Station_Work.THWWorkStation.TValveVacuumTable);
	ptrTValveCleanNozzle:=ADR(T_Station_Work.THWWorkStation.TValveCleanNozzle);
	ptrTAxisBubbler:=ADR(T_Station_Work.THWWorkStation.TAxisBubbler);
	ptrTAxisFeedPump:=ADR(T_Station_Work.THWWorkStation.TAxisFeedPump);
END_IF;
(******************************************************************************************************************************************)
(****************************				                  Status Part                                                            *****************************)
(******************************************************************************************************************************************)
T_Station_Work.xActive:=TRUE;
xStatusRdy:=T_Station_Work.TControl.xRdy;
xStatusEnd:=T_Station_Work.TControl.xDone;
xStatusStop:=xTmpStopFunction;
xStatusRef:=T_Station_Work.TControl.xReferenced;
xError:= T_Station_Work.TControl.xError;
iErrorNr := T_Station_Work.TControl.diErrorNr;
iStatusFctNr:=iStationFunctionNr;
(******************************************************************************************************************************************)
(****************************				                Enable Part                                                            *****************************)
(******************************************************************************************************************************************)
(* Check Active of the Axis Drives *)
xTmp:=	(NOT(ptrTAxisZ^.T_CtrleSingle.xErr) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone)) OR
		(NOT(ptrTAxisS^.T_CtrleSingle.xErr) AND NOT(ptrTAxisS^.T_CtrleSingle.xDone));
CtrlDisableStation;
CtrlEnableStation;
(******************************************************************************************************************************************)
(****************************				       Security Circuit Switch ON/OFF                                          *****************************)
(******************************************************************************************************************************************)
CtrlSafetySwitch_ON_OFF;
(******************************************************************************************************************************************)
(****************************				         Error Controlling Part                                                  *****************************)
(******************************************************************************************************************************************)
CtrlErrorStation;
(******************************************************************************************************************************************)
(****************************				         Main Controlling Part                                                  *****************************)
(******************************************************************************************************************************************)
CtrlMainStation;
(******************************************************************************************************************************************)
(****************************				            Spindel controlling                                                  *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_ToolSpindle;
(******************************************************************************************************************************************)
(****************************				Überwachung Achsenbremse                                        *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_AxisBrake;
(*****************************************************************************************************************************************)
(****************************				DC Motoren (Suspension)                                        *****************************)
(******************************************************************************************************************************************)
CtrlDCMotors;
(******************************************************************************************************************************************)
(****************************				              Funktionen                                                               *****************************)
(******************************************************************************************************************************************)
xCheckAxisCurrent:=	xSafetyCircuitOn;
IF xStartFunction AND NOT(xSetEnd) AND NOT(xStFct_ForceStationError) THEN
	IF (iStationFunctionNr = 1) THEN
		StationFunction_Fct_01_Referencing;
		T_Station_Work.TControl.wStatus:=wStFct_Status;
	END_IF;
	IF (iStationFunctionNr = 2) THEN
		StationFunction_Fct_02_InitialState;
	END_IF;
	IF (iStationFunctionNr = 3) THEN
		StationFunction_Fct_03_ToolRotationON;
	END_IF;
	IF (iStationFunctionNr = 4) THEN
		StationFunction_Fct_04_InfeedWorking;
		T_Station_Work.TControl.wStatus:=wStFct_Status;
	END_IF;
	IF (iStationFunctionNr = 5) THEN
		StationFunction_Fct_05_Working;
		T_Station_Work.TControl.wStatus:=wStFct_Status;
	END_IF;
	IF (iStationFunctionNr = 6) THEN
		StationFunction_Fct_06_ToolRotationOFF;
	END_IF;
	IF (iStationFunctionNr = 7) THEN
		CASE T_ExchgParam.bToolSpindleActive OF
		1:	(* Maxon Spindel *)
			StationFunction_Fct_07_Calibration;
		2,3:	(* Beckhoff Spindel *)
			StationFunction_Fct_07_Calibration2;
		END_CASE;
	END_IF;
	IF (iStationFunctionNr = 8) THEN
		StationFunction_Fct_08_SpindleBurnIn;
	END_IF;
	IF (iStationFunctionNr = 9) THEN
		StationFunction_Fct_09_Initial_Z_Axis;
	END_IF;
	IF (iStationFunctionNr = 10) THEN
		StationFunction_Fct_10_CheckAxisBreak;
	END_IF;
	IF (iStationFunctionNr = 11) THEN
		StationFunction_Fct_11_Centring;
		T_Station_Work.TControl.wStatus:=wStFct_Status;
	END_IF;
	IF (iStationFunctionNr <> 5) THEN
		T_Z_St1_Ctrle.diVelocityCommandValue:=(T_Z_St1_Ctrle.nOutData2[1] * 65536) + T_Z_St1_Ctrle.nOutData2[0];
		gxZAxisVelocityCtrlActive:=FALSE;
	END_IF;
ELSE
	T_Z_St1_Ctrle.diVelocityCommandValue:=(T_Z_St1_Ctrle.nOutData2[1] * 65536) + T_Z_St1_Ctrle.nOutData2[0];
	gxZAxisVelocityCtrlActive:=FALSE;
END_IF;
(******************************************************************************************************************************************)
(****************************				         Init / Reset Hardware                                                 *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xStationError:=FALSE;
	xInitError:=FALSE;
	xInitStart:=FALSE;
	xInitStop:=FALSE;
	xInitStep:=FALSE;
	xSetEnd:=FALSE;
	xTmpStart:=FALSE;
	T_Station_Work.TControl.xExecute:=FALSE;
	T_Station_Work.TControl.xStop:=FALSE;
	T_Station_Work.TControl.xStopCycle:=FALSE;
	T_Station_Work.TControl.xAbord:=FALSE;
	IF NOT(xDontDeleteErrorFlag) THEN
		T_Station_Work.TControl.xDone:=TRUE;
		T_Station_Work.TControl.xError:=FALSE;
		T_Station_Work.TControl.diErrorNr:=0;
	END_IF;
	xDontDeleteErrorFlag:=FALSE;
	xStartFunction:=FALSE;
	xStepError:=FALSE;
	xTmpStationError:=FALSE;
	diErrorNumber:=0;
	xSetError:=FALSE;
	xReadyToQuitErr:=FALSE;
	xStFct_Error:=FALSE;
	T_Station_Work.THWWorkStation.TCtrlWork.xBlockCheckAxisBrake:=FALSE;
END_IF;
IF T_Station_Work.TControl.xRdy THEN
	IF IxJoystick_WorkpieceClamp_ON_St1 THEN
		IF NOT(ptrTCylWorkpieceClamp^.T_CtrleCyl.T_Standard.xActivOn) AND NOT(ptrTCylWorkpieceClamp^.T_CtrleCyl.xExecute) AND ptrTCylWorkpieceClamp^.T_CtrleCyl.xDone THEN
			ptrTCylWorkpieceClamp^.T_CtrleCyl.iFunction:=2;
			ptrTCylWorkpieceClamp^.T_CtrleCyl.xExecute:=TRUE;
		END_IF;
		IF NOT(T_TwinSafeOut.QxContactor24VCh1) OR NOT(T_TwinSafeOut.QxContactor24VCh2) THEN
			T_ExchgParam.T_Visu.T_Message.iState:=230;	(* Warnung: Zuerst die Energieversorgung einschalten ! *)
		END_IF;
	ELSE
		IF ptrTCylWorkpieceClamp^.T_CtrleCyl.T_Standard.xActivOn AND NOT(ptrTCylWorkpieceClamp^.T_CtrleCyl.xExecute) AND ptrTCylWorkpieceClamp^.T_CtrleCyl.xDone THEN
			ptrTCylWorkpieceClamp^.T_CtrleCyl.iFunction:=1;
			ptrTCylWorkpieceClamp^.T_CtrleCyl.xExecute:=TRUE;
		END_IF;
	END_IF;
	IF IxJoystick_AirTable_ON THEN
		IF NOT(ptrTValveAirTable^.T_CtrleCyl.T_Standard.xActivOn) AND NOT(ptrTValveAirTable^.T_CtrleCyl.xExecute) AND ptrTValveAirTable^.T_CtrleCyl.xDone THEN
			ptrTValveAirTable^.T_CtrleCyl.iFunction:=2;
			ptrTValveAirTable^.T_CtrleCyl.xExecute:=TRUE;
		END_IF;
		IF NOT(T_TwinSafeOut.QxContactor24VCh1) OR NOT(T_TwinSafeOut.QxContactor24VCh2) THEN
			T_ExchgParam.T_Visu.T_Message.iState:=230;	(* Warnung: Zuerst die Energieversorgung einschalten ! *)
		END_IF;
	ELSE
		IF ptrTValveAirTable^.T_CtrleCyl.T_Standard.xActivOn AND NOT(ptrTValveAirTable^.T_CtrleCyl.xExecute) AND ptrTValveAirTable^.T_CtrleCyl.xDone THEN
			ptrTValveAirTable^.T_CtrleCyl.iFunction:=1;
			ptrTValveAirTable^.T_CtrleCyl.xExecute:=TRUE;
		END_IF;
	END_IF;
	IF IxJoystick_VaccumTable_ON THEN
		IF NOT(ptrTValveVacuumTable^.T_CtrleCyl.T_Standard.xActivOn) AND NOT(ptrTValveVacuumTable^.T_CtrleCyl.xExecute) AND ptrTValveVacuumTable^.T_CtrleCyl.xDone THEN
			ptrTValveVacuumTable^.T_CtrleCyl.iFunction:=2;
			ptrTValveVacuumTable^.T_CtrleCyl.xExecute:=TRUE;
		END_IF;
		IF NOT(T_TwinSafeOut.QxContactor24VCh1) OR NOT(T_TwinSafeOut.QxContactor24VCh2) THEN
			T_ExchgParam.T_Visu.T_Message.iState:=230;	(* Warnung: Zuerst die Energieversorgung einschalten ! *)
		END_IF;
	ELSE
		IF ptrTValveVacuumTable^.T_CtrleCyl.T_Standard.xActivOn AND NOT(ptrTValveVacuumTable^.T_CtrleCyl.xExecute) AND ptrTValveVacuumTable^.T_CtrleCyl.xDone THEN
			ptrTValveVacuumTable^.T_CtrleCyl.iFunction:=1;
			ptrTValveVacuumTable^.T_CtrleCyl.xExecute:=TRUE;
		END_IF;
	END_IF;
END_IF;

(* Drehmoment Ausgabe *)	(* IGS *)
rStFct_V1:=		T_Station_Parameter.T_OnlineChange.rWorkingSpeedForward;
rStFct_S1:=		0.5;
rStFct_S2:=		T_Station_Parameter.T_OnlineChange.rTorqueLevelHC;
CASE T_ExchgParam.bToolSpindleActive OF
1:	(* Maxon Spindel *)
	rStFct_M:=	T_Station_Parameter.T_TorqueSystem.rActual_Torque;			(* Maxon Spindel ist aktiv *)
	T_ExchgParam.T_StationCommon.rActual_Torque:=T_Station_Parameter.T_TorqueSystem.rActual_Torque;	(* für MMI *)
	T_ExchgParam.T_StationCommon.rMaxTorque:=T_Station_Parameter.T_TorqueSystem.rMaxTorque;			(* für MMI *)
2:	(* Beckhoff Spindel L *)
	rStFct_M:=	T_Station_Parameter.T_TorqueSystem_L.rActual_Torque;		(* Beckhoff Spindel ist aktiv *)
	T_ExchgParam.T_StationCommon.rActual_Torque:=T_Station_Parameter.T_TorqueSystem_L.rActual_Torque;	(* für MMI *)
	T_ExchgParam.T_StationCommon.rMaxTorque:=T_Station_Parameter.T_TorqueSystem_L.rMaxTorque;		(* für MMI *)
3:	(* Beckhoff Spindel M *)
	rStFct_M:=	T_Station_Parameter.T_TorqueSystem_M.rActual_Torque;		(* Beckhoff Spindel ist aktiv *)
	T_ExchgParam.T_StationCommon.rActual_Torque:=T_Station_Parameter.T_TorqueSystem_M.rActual_Torque;	(* für MMI *)
	T_ExchgParam.T_StationCommon.rMaxTorque:=T_Station_Parameter.T_TorqueSystem_M.rMaxTorque;		(* für MMI *)
END_CASE;
IF NOT(xStartFunction) THEN
	(* Regelung mit Override Funktion und mit Parabelfunktion und mit prozentualer Angabe der Regelungssteigung mit oder ohne konstante Geschwindigkeit *)
	T_Station_Work.THWWorkStation.TCtrlWork.rSpeedZ_V1:=rStFct_V1;
	T_Station_Work.THWWorkStation.TCtrlWork.rTorqueZ_S4:=rStFct_S2;
END_IF;
T_Station_Work.THWWorkStation.TCtrlWork.rSpeedZ_V3:=rStFct_V1/100.0;
T_Station_Work.THWWorkStation.TCtrlWork.rTorqueZ_S1:=rStFct_S1;
T_Station_Work.THWWorkStation.TCtrlWork.rTorqueHC:=rStFct_S2;
T_Station_Parameter.T_InfoProcess.rTorqueHC:=T_Station_Work.THWWorkStation.TCtrlWork.rTorqueHC;
(***************************************************************************************************************************************************)
(* Ausgabe Drehmoment für Progressbalken *)
IF (T_Station_Work.THWWorkStation.TCtrlWork.rTorqueHC <> 0.0) THEN
	T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_Torque:=REAL_TO_INT(100.0/T_Station_Work.THWWorkStation.TCtrlWork.rTorqueHC*rStFct_M);
ELSE
	T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_Torque:=0;
END_IF;
IF (T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_Torque < 0) THEN
	T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_Torque:=0;
END_IF;
(***************************************************************************************************************************************************)
(* Ausgabe Z Position und Geschwindigkeit für Progressbalken *)

	IF ((garPositionEndProcCalc[1] - T_Station_Parameter.T_StProcess.rPositionStartProc) <> 0.0) AND (T_Station_Parameter.T_OnlineChange.rWorkingSpeedForward <> 0.0) THEN
		T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_ZPos:=		REAL_TO_INT(100.0/(garPositionEndProcCalc[1] - T_Station_Parameter.T_StProcess.rPositionStartProc)
																			*(ptrTAxisZ^.T_LiveValue.lrActualPosition - T_Station_Parameter.T_StProcess.rPositionStartProc));
		T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_ZVel:=	REAL_TO_INT((100.0/T_Station_Parameter.T_OnlineChange.rWorkingSpeedForward)*ptrTAxisZ^.T_LiveValue.lrActualVelocity);
	ELSE
		T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_ZPos:=	0;
		T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_ZVel:=	0;
	END_IF;
	IF (T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_ZPos < 0) THEN
		T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_ZPos:=0;
	END_IF;
	IF (T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_ZVel < 0) THEN
		T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_ZVel:=0;
	END_IF;
(***************************************************************************************************************************************************)
(* Drehmoment Min-Max Werte oberhalb eines HC *)
rActTorque:=T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_Torque;
IF xStartFunction AND (iStationFunctionNr = 5) THEN
	IF (iStFct_StepPrc = 3) OR (iStFct_StepPrc = 4) THEN
		IF (rActTorque >= rTorqueMax) THEN
			rTorqueMax:=rActTorque;
		END_IF;
		IF (rActTorque >= rTorqueMin) THEN
			rTorqueMin:=rActTorque;
		END_IF;
	ELSE
		IF (T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterTorque >= 1) THEN
			IF (rTorqueMin <= rTorqueMin_Min) AND (rTorqueMin <> 0.0) AND (rTorqueMin >= 100.0)THEN
				rTorqueMin_Min:=rTorqueMin;
			END_IF;
			rTorqueMin:=0.0;
			IF (rTorqueMin_Min <> 99999.0) THEN
				T_Station_Work.THWWorkStation.TCtrlWork.rTorqueAfterHC_Min:=rTorqueMin_Min;
			END_IF;
		END_IF;
	END_IF;
	IF (rTorqueMax >= rTorqueMax_Max) THEN
		rTorqueMax_Max:=rTorqueMax;
	END_IF;
	T_Station_Work.THWWorkStation.TCtrlWork.rTorqueAfterHC_Max:=rTorqueMax_Max;
	IF (T_Station_Work.THWWorkStation.TCtrlWork.rTorqueAfterHC_Min <> 0.0) AND (T_Station_Work.THWWorkStation.TCtrlWork.rTorqueAfterHC_Min < 100.0) THEN
		T_Station_Work.THWWorkStation.TCtrlWork.rTorqueAfterHC_Min:=100.0;
	END_IF;
ELSE
	rTorqueMin:=0;
	rTorqueMax:=rActTorque;
	rTorqueMax_Max:=0;
	rTorqueMin_Min:=99999.0;
END_IF;
IF (T_Station_Work.THWWorkStation.TCtrlWork.rTorqueAfterHC_Min >= T_Station_Parameter.T_StProcess.iMaxTorque) THEN
	T_Station_Work.THWWorkStation.TCtrlWork.xTorqueAfterHC_Min_Overlimit:=TRUE;
ELSE
	T_Station_Work.THWWorkStation.TCtrlWork.xTorqueAfterHC_Min_Overlimit:=FALSE;
END_IF;
IF (T_Station_Work.THWWorkStation.TCtrlWork.rTorqueAfterHC_Max >= T_Station_Parameter.T_StProcess.iMaxTorque) THEN
	T_Station_Work.THWWorkStation.TCtrlWork.xTorqueAfterHC_Max_Overlimit:=TRUE;
ELSE
	T_Station_Work.THWWorkStation.TCtrlWork.xTorqueAfterHC_Max_Overlimit:=FALSE;
END_IF;
(***************************************************************************************************************************************************)
(* Ausgabe des Cursor für Progressbalken der Z Position für HC *)
IF xStartFunction AND (iStationFunctionNr = 5) AND (iStFct_StepPrc = 3) THEN
	IF T_Station_Work.THWWorkStation.TCtrlWork.xTorqueLastHC THEN
		IF (garPositionEndProcCalc[1] <> 0.0) THEN
			T_Station_Work.THWWorkStation.TCtrlWork.iHCTorquePos:=	REAL_TO_INT(100.0/(garPositionEndProcCalc[1] - T_Station_Parameter.T_StProcess.rPositionStartProc) *
																		(rStFct_SetZHCPosition - T_Station_Parameter.T_StProcess.rPositionStartProc) * 3.2);
		ELSE
			T_Station_Work.THWWorkStation.TCtrlWork.iHCTorquePos:=	0;
		END_IF;
	END_IF;
	IF T_Station_Work.THWWorkStation.TCtrlWork.xDeflectionLastHC THEN
		IF (garPositionEndProcCalc[1] <> 0.0) THEN
			T_Station_Work.THWWorkStation.TCtrlWork.iHCDeflectionPos:=	REAL_TO_INT(100.0/(garPositionEndProcCalc[1] - T_Station_Parameter.T_StProcess.rPositionStartProc) *
																			(rStFct_SetZHCPosition - T_Station_Parameter.T_StProcess.rPositionStartProc) * 3.2);
		ELSE
			T_Station_Work.THWWorkStation.TCtrlWork.iHCDeflectionPos:=0;
		END_IF;
	END_IF;
END_IF;
(***************************************************************************************************************************************************)
(* Auffangen HC beim ausfunken *)
IF xStartFunction AND (iStationFunctionNr = 5) AND (iStFct_StepPrc = 9) AND ptrTAxisZ^.T_CtrleSingle.xMovingForward THEN
	IF ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn THEN
		T_Station_Work.THWWorkStation.TCtrlWork.xHCSparkOut:=TRUE;
	END_IF;
END_IF;
(***************************************************************************************************************************************************)
END_FUNCTION_BLOCK
ACTION	CtrlDCMotors:
(******************************************************************************************************************************************)
(* DC Motoren starten *)
(******************************************************************************************************************************************)
IF gxSuspensionONOFF AND (T_Station_Parameter.T_StProcess.rSuspensionBubblerSpeed <> 0) AND (gT_SafetyStatus.xEnergyONNormalMode OR gT_SafetyStatus.xEnergyONSetupModeASt1) THEN
	IF NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xExecute) AND ptrTAxisBubbler^.T_CtrleDCAxis.xDone THEN
		IF NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xReady) THEN
			ptrTAxisBubbler^.T_CtrleDCAxis.iFunction:=1;
			ptrTAxisBubbler^.T_CtrleDCAxis.xExecute:=TRUE;
		ELSIF NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xPower) THEN
			ptrTAxisBubbler^.T_CtrleDCAxis.iFunction:=3;
			ptrTAxisBubbler^.T_CtrleDCAxis.xExecute:=TRUE;
		ELSIF ptrTAxisBubbler^.T_CtrleDCAxis.xNotMoving THEN
			ptrTAxisBubbler^.T_CtrleDCAxis.iFunction:=6;
			ptrTAxisBubbler^.T_CtrleDCAxis.lrVelocity:=T_Station_Parameter.T_StProcess.rSuspensionBubblerSpeed;				(* max 400.0 *)
			ptrTAxisBubbler^.T_CtrleDCAxis.tAcceleration:=T#0s;
			(*ptrTAxisBubbler^.T_CtrleDCAxis.tAcceleration:=T#500ms;
			ptrTAxisBubbler^.T_CtrleDCAxis.tDeceleration:=T#500ms;*)
			ptrTAxisBubbler^.T_CtrleDCAxis.xExecute:=TRUE;
		END_IF
	END_IF
ELSE
	IF NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xExecute) AND ptrTAxisBubbler^.T_CtrleDCAxis.xDone THEN
		IF NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xReady) THEN
			ptrTAxisBubbler^.T_CtrleDCAxis.iFunction:=1;
			ptrTAxisBubbler^.T_CtrleDCAxis.xExecute:=TRUE;
		ELSIF NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xNotMoving) THEN
			ptrTAxisBubbler^.T_CtrleDCAxis.iFunction:=5;
			ptrTAxisBubbler^.T_CtrleDCAxis.xExecute:=TRUE;
		ELSIF ptrTAxisBubbler^.T_CtrleDCAxis.xPower THEN
			ptrTAxisBubbler^.T_CtrleDCAxis.iFunction:=4;
			ptrTAxisBubbler^.T_CtrleDCAxis.xExecute:=TRUE;
		END_IF
	END_IF
END_IF


IF gxSuspensionONOFF AND (T_Station_Parameter.T_StProcess.rSuspensionFeederSpeed <> 0) AND (gT_SafetyStatus.xEnergyONNormalMode OR gT_SafetyStatus.xEnergyONSetupModeASt1) THEN
	IF NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute) AND ptrTAxisFeedPump^.T_CtrleDCAxis.xDone THEN
		IF NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xReady) THEN
			ptrTAxisFeedPump^.T_CtrleDCAxis.iFunction:=1;
			ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute:=TRUE;
		ELSIF NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xPower) THEN
			ptrTAxisFeedPump^.T_CtrleDCAxis.iFunction:=3;
			ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute:=TRUE;
		ELSIF NOT(IxSuspenstionFilled) AND NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xNotMoving) THEN
			ptrTAxisFeedPump^.T_CtrleDCAxis.iFunction:=5;
			ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute:=TRUE;
		ELSIF ptrTAxisFeedPump^.T_CtrleDCAxis.xNotMoving THEN
			ptrTAxisFeedPump^.T_CtrleDCAxis.iFunction:=6;
			ptrTAxisFeedPump^.T_CtrleDCAxis.lrVelocity:=T_Station_Parameter.T_StProcess.rSuspensionFeederSpeed;			(* max 90.0 *)
			ptrTAxisFeedPump^.T_CtrleDCAxis.tAcceleration:=T#0s;
			(*ptrTAxisFeedPump^.T_CtrleDCAxis.tAcceleration:=T#500ms;
			ptrTAxisFeedPump^.T_CtrleDCAxis.tDeceleration:=T#500ms;*)
			ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute:=TRUE;
		END_IF
	END_IF
ELSE
	IF NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute) AND ptrTAxisFeedPump^.T_CtrleDCAxis.xDone THEN
		IF NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xNotMoving) THEN
			(*ptrTAxisFeedPump^.T_CtrleDCAxis.iFunction:=5;		funktioniert leider nicht, also über reset un iFunction:=1
			ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute:=TRUE;*)
			ptrTAxisFeedPump^.T_CtrleDCAxis.xReset:=TRUE;
		ELSIF ptrTAxisFeedPump^.T_CtrleDCAxis.xPower THEN
			ptrTAxisFeedPump^.T_CtrleDCAxis.iFunction:=4;
			ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute:=TRUE;
		ELSIF NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xReady) THEN
			ptrTAxisFeedPump^.T_CtrleDCAxis.iFunction:=1;
			ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute:=TRUE;
		END_IF
	END_IF
END_IF


END_ACTION

ACTION	CtrlDisableStation:
fbFTrig(CLK:=T_Station_Work.TControl.xEnable);
IF fbFTrig.Q THEN
	xInitSetEnable:=FALSE;
	xInitDelEnable:=FALSE;
	xRdyDisableStation:=FALSE;
END_IF;
IF (fbFTrig.Q OR xInitDelEnable) THEN
	IF NOT(xInitDelEnable) OR fbFTrig.Q THEN
		xReadyChkError:=FALSE;
		T_Station_Work.TControl.xDone:=FALSE;
		T_Station_Work.TControl.xError:=FALSE;
		xInitDelEnable:=TRUE;
		T_Station_Work.TControl.xRdy:=FALSE;
		iStepEnable:=100;
		iStationFunctionNr:=1;
		xInitStep:=FALSE;
	END_IF;
	CASE iStepEnable OF
		100:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				xStartFunction:=TRUE;
				xStFct_Reset:=TRUE;
			END_IF;
			IF NOT(xStFct_Reset) AND xStFct_End THEN
				(* Alle Funktionen Resetten *)
				IF (iStationFunctionNr < iMaxFunctionNr) THEN
					iStationFunctionNr:=iStationFunctionNr + 1;
					xStFct_Reset:=TRUE;
				ELSE
					xInitStep:=FALSE;
					xStartFunction:=FALSE;
					iStepEnable:=110;
				END_IF;
			(* Controlling für OnlineChange *)
				T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolDeflectionForce:=TRUE;
				T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedBackward:=TRUE;
				T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedForward:=TRUE;
				T_Station_Work.TCtrlOnlineChange.xLockChange_S_WorkSpindleSpeed:=TRUE;
				T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolTorqueLevel:=TRUE;
			END_IF;
		110:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				T_Station_Work.TControl.xResetHardware:=TRUE;
			END_IF;
			IF NOT(T_Station_Work.TControl.xResetHardware) THEN
				xInitStep:=FALSE;
				iStepEnable:=200;
			END_IF;
		200:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF T_Station_Work.TControl.xHardwareConfigError THEN
					T_Station_Work.TControl.xHardwareConfigError:=FALSE;
					T_Station_Work.TControl.xActiveHardware:=FALSE;
				ELSE
					xInitStep:=FALSE;
					iStepEnable:=300;
				END_IF;
				RETURN;
			END_IF;
			IF NOT(T_Station_Work.TControl.xError) OR xDontDeleteErrorFlag THEN
				T_Station_Work.TControl.xActiveHardware:=TRUE;
				xInitStep:=FALSE;
				iStepEnable:=300;
				RETURN;
			END_IF;
		300:	IF NOT(xInitStep) THEN	(* Alle Hardware Bausteine resetten *)
				xInitStep:=TRUE;
				ptrTAxisZ^.T_CtrleSingle.xReset:=TRUE;
				ptrTAxisS^.T_CtrleSingle.xReset:=TRUE;
				ptrTAxisBubbler^.T_CtrleDCAxis.xReset:=TRUE;
				ptrTAxisFeedPump^.T_CtrleDCAxis.xReset:=TRUE;
			END_IF;
			IF xTmp THEN
				RETURN;	(* Wait until all Drives finished *)
			END_IF;
			IF (NOT(ptrTAxisZ^.T_CtrleSingle.xReset) AND ptrTAxisZ^.T_CtrleSingle.xErr)
			OR (NOT(ptrTAxisS^.T_CtrleSingle.xReset) AND ptrTAxisS^.T_CtrleSingle.xErr)
			OR (NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xReset) AND ptrTAxisBubbler^.T_CtrleDCAxis.xErr)
			OR (NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xReset) AND ptrTAxisFeedPump^.T_CtrleDCAxis.xErr) THEN
				xInitStep:=FALSE;
				iStepEnable:=400;
			END_IF;
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xReset) AND ptrTAxisZ^.T_CtrleSingle.xDone
			AND NOT(ptrTAxisS^.T_CtrleSingle.xReset) AND ptrTAxisS^.T_CtrleSingle.xDone
			AND NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xReset) AND ptrTAxisBubbler^.T_CtrleDCAxis.xDone
			AND NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xReset) AND ptrTAxisFeedPump^.T_CtrleDCAxis.xDone THEN
				T_Station_Work.TControl.xActiveHardware:=FALSE;
				xInitStep:=FALSE;
				xInitDelEnable:=FALSE;
				xSetEnd:=TRUE;
				xRdyDisableStation:=TRUE;
				IF xDontDeleteErrorFlag THEN
					T_Station_Work.TControl.xError:=TRUE;
				END_IF;
			END_IF;
		400:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				ptrTAxisZ^.T_CtrleSingle.iFunction:=1;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=ptrTAxisZ^.T_CtrleSingle.xErr;
				ptrTAxisS^.T_CtrleSingle.iFunction:=1;
				ptrTAxisS^.T_CtrleSingle.xExecute:=ptrTAxisS^.T_CtrleSingle.xErr;
			END_IF;
			IF xTmp THEN
				RETURN;	(* Wait until all Drives finished *)
			END_IF;
			IF (NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xErr) OR
			    (NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xErr) THEN
				xInitStep:=FALSE;
				iStepEnable:=500;
			END_IF;
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone OR
			    NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone THEN
				T_Station_Work.TControl.xActiveHardware:=FALSE;
				xInitStep:=FALSE;
				xInitDelEnable:=FALSE;
				xSetEnd:=TRUE;
				xRdyDisableStation:=TRUE;
				IF xDontDeleteErrorFlag THEN
					T_Station_Work.TControl.xError:=TRUE;
				END_IF;
			END_IF;
		500:	T_Station_Work.TControl.xActiveHardware:=FALSE;
			T_Station_Work.TControl.diErrorNr:=1000000 + 16#F220;	(* Fehler / Error während disable (Ausschalten) der Station  *)
			T_Station_Work.TControl.xError:=TRUE;
			xDontDeleteErrorFlag:=TRUE;
			xInitStep:=FALSE;
			xInitDelEnable:=FALSE;
			xSetEnd:=TRUE;
			xRdyDisableStation:=TRUE;
	END_CASE;
END_IF;
END_ACTION

ACTION	CtrlEnableStation:
fbRTrig(CLK:=T_Station_Work.TControl.xEnable);
IF fbRTrig.Q THEN
	xInitSetEnable:=FALSE;
	xInitDelEnable:=FALSE;
END_IF;
TONTimeOutEnablePart(IN:=T_Station_Work.TControl.xEnable AND xInitSetEnable,PT:=T#60s);
TONCalcMinTimeEnable(IN:=TRUE,PT:=T#9999s);
IF TONTimeOutEnablePart.Q THEN
	T_Station_Work.TControl.xEnable:=FALSE;
END_IF;
IF (fbRTrig.Q OR xInitSetEnable) THEN
	IF NOT(fbRTrig.Q) AND xReadyChkError THEN
		IF xSetError OR ptrTAxisZ^.T_CtrleSingle.xErr THEN
			IF (xTmp) AND NOT(xSetError) THEN
				RETURN;	(* Wait until all Actuators are not working *)
			END_IF;
			IF xSetError THEN
				xSetError:=FALSE;
				T_Station_Work.TControl.diErrorNr:=1000000 + diErrorNumber;
			ELSE
				ptrTAxisZ^.T_CtrleSingle.xReset:=ptrTAxisZ^.T_CtrleSingle.xErr;
				ptrTAxisS^.T_CtrleSingle.xReset:=ptrTAxisS^.T_CtrleSingle.xErr;
				ptrTAxisBubbler^.T_CtrleDCAxis.xReset:=ptrTAxisBubbler^.T_CtrleDCAxis.xErr;
				ptrTAxisFeedPump^.T_CtrleDCAxis.xReset:=ptrTAxisFeedPump^.T_CtrleDCAxis.xErr;
				IF ptrTAxisZ^.T_CtrleSingle.xErr THEN T_Station_Work.TControl.diErrorNr:=20000000 + ptrTAxisZ^.T_CtrleSingle.udiErrorID; END_IF;
				IF ptrTAxisS^.T_CtrleSingle.xErr THEN T_Station_Work.TControl.diErrorNr:=24000000 + ptrTAxisS^.T_CtrleSingle.udiErrorID; END_IF;
				IF ptrTAxisBubbler^.T_CtrleDCAxis.xErr THEN T_Station_Work.TControl.diErrorNr:=7000000 + ptrTAxisBubbler^.T_CtrleDCAxis.udiErrorID; END_IF;
				IF ptrTAxisFeedPump^.T_CtrleDCAxis.xErr THEN T_Station_Work.TControl.diErrorNr:=8000000 + ptrTAxisFeedPump^.T_CtrleDCAxis.udiErrorID; END_IF;
			END_IF;
			T_Station_Work.TControl.xEnable:=FALSE;
			xDontDeleteErrorFlag:=TRUE;
			RETURN;
		END_IF;
	END_IF;
	IF NOT(xInitSetEnable) OR fbRTrig.Q THEN
		xSetEnd:=FALSE;
		xInitSetEnable:=TRUE;
		T_Station_Work.TControl.xRdy:=FALSE;
		T_Station_Work.TControl.xDone:=FALSE;
		T_Station_Work.TControl.xError:=FALSE;
		T_Station_Work.TControl.diErrorNr:=0;
		iStepEnable:=100;
		iStationFunctionNr:=1;
		xInitStep:=FALSE;
		TONCalcMinTimeEnable(IN:=FALSE);
		RETURN;
	END_IF;
	CASE iStepEnable OF
		100:	IF NOT(xRdyDisableStation) AND NOT(gxHardwareOFF) AND NOT(gxAxisOFF) THEN
				iStepEnable:=110;
				RETURN;
			END_IF;
			IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				xStartFunction:=TRUE;
				xStFct_Reset:=TRUE;
				(* Initialisierung der HW *)
				T_Station_Work.TControl.xActiveHardware:=TRUE;
			(* Controlling für OnlineChange *)
				T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolDeflectionForce:=FALSE;
				T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedBackward:=TRUE;
				T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedForward:=TRUE;
				T_Station_Work.TCtrlOnlineChange.xLockChange_S_WorkSpindleSpeed:=TRUE;
				T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolTorqueLevel:=FALSE;
			END_IF;
			IF NOT(xStFct_Reset) AND xStFct_End THEN
				(* Alle Funktionen Resetten *)
				IF (iStationFunctionNr < iMaxFunctionNr) THEN
					iStationFunctionNr:=iStationFunctionNr + 1;
					xStFct_Reset:=TRUE;
				ELSE
					xInitStep:=FALSE;
					xStartFunction:=FALSE;
					iStepEnable:=200;
				END_IF;
			END_IF;
		110:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF T_Station_Work.TControl.xHardwareConfigError THEN
					T_Station_Work.TControl.xHardwareConfigError:=FALSE;
					T_Station_Work.TControl.xActiveHardware:=FALSE;
				ELSE
					xRdyDisableStation:=TRUE;
					xInitStep:=FALSE;
					iStepEnable:=100;
				END_IF;
				RETURN;
			END_IF;
			IF NOT(T_Station_Work.TControl.xError) THEN
				T_Station_Work.TControl.xActiveHardware:=TRUE;
				xRdyDisableStation:=TRUE;
				xInitStep:=FALSE;
				iStepEnable:=100;
				RETURN;
			END_IF;
		200:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				ptrTCylToolDeflection^.T_CtrleCyl.xReset:=TRUE;
				ptrTCylToolTorqueHC^.T_CtrleCyl.xReset:=TRUE;
				ptrTCylToolTorqueOverload^.T_CtrleCyl.xReset:=TRUE;
				ptrTTorqueSensorMeasRange^.T_CtrleCyl.xReset:=TRUE;
				ptrTTorqueSensorControl^.T_CtrleCyl.xReset:=TRUE;
				ptrTCylWorkpieceClamp^.T_CtrleCyl.xReset:=TRUE;
				ptrTValveAirTable^.T_CtrleCyl.xReset:=TRUE;
				ptrTValveVacuumTable^.T_CtrleCyl.xReset:=TRUE;
				ptrTValveCleanNozzle^.T_CtrleCyl.xReset:=TRUE;
				ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xReset:=TRUE;
				ptrTAxisZ^.T_CtrleSingle.xReset:=TRUE;
				ptrTAxisS^.T_CtrleSingle.xReset:=TRUE;
				ptrTAxisBubbler^.T_CtrleDCAxis.xReset:=TRUE;
				ptrTAxisFeedPump^.T_CtrleDCAxis.xReset:=TRUE;
			END_IF;
			IF NOT(ptrTCylToolDeflection^.T_CtrleCyl.xReset) AND NOT(ptrTCylToolTorqueHC^.T_CtrleCyl.xReset)
			AND NOT(ptrTCylToolTorqueOverload^.T_CtrleCyl.xReset) AND NOT(ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xReset)
			AND NOT(ptrTTorqueSensorMeasRange^.T_CtrleCyl.xReset) AND NOT(ptrTTorqueSensorControl^.T_CtrleCyl.xReset)
			AND NOT(ptrTCylWorkpieceClamp^.T_CtrleCyl.xReset) AND NOT(ptrTValveAirTable^.T_CtrleCyl.xReset)
			AND NOT(ptrTValveVacuumTable^.T_CtrleCyl.xReset)  AND NOT(ptrTValveCleanNozzle^.T_CtrleCyl.xReset)
			AND NOT(ptrTAxisZ^.T_CtrleSingle.xReset) AND ptrTAxisZ^.T_CtrleSingle.xDone
			AND NOT(ptrTAxisS^.T_CtrleSingle.xReset) AND ptrTAxisS^.T_CtrleSingle.xDone
			AND NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xReset) AND ptrTAxisBubbler^.T_CtrleDCAxis.xDone
			AND NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xReset) AND ptrTAxisFeedPump^.T_CtrleDCAxis.xDone THEN
				xInitStep:=FALSE;
				IF NOT(gxHardwareOFF) AND NOT(gxAxisOFF) THEN
					iStepEnable:=299;
				ELSE
					iStepEnable:=1100;
				END_IF;
			END_IF;
		299:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				ptrTAxisZ^.T_CtrleSingle.iFunction:=27;	(* Resetten des AX5000 Servo *)
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
				xInitStep:=FALSE;
				iStepEnable:=300;
			END_IF;
		300:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				ptrTAxisZ^.T_CtrleSingle.iFunction:=1;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisS^.T_CtrleSingle.iFunction:=1;
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisBubbler^.T_CtrleDCAxis.iFunction:=1;		(* Reset Axis *)
				ptrTAxisBubbler^.T_CtrleDCAxis.xExecute:=TRUE;
				ptrTAxisFeedPump^.T_CtrleDCAxis.iFunction:=1;	(* Reset Axis *)
				ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute:=TRUE;
				iCountCycle:=0;
			END_IF;
			iCountCycle:=iCountCycle + 1;
			IF (iCountCycle >= 50) THEN
				xReadyChkError:=TRUE;	(* 50 SPS Zyklen warten bis die Übewachung der HW Error freigeschaltet werden kann *)
			END_IF;
			IF xTmp THEN
				RETURN;	(* Wait until all Drives finished *)
			END_IF;
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone
			AND NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone
			AND NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xExecute) AND ptrTAxisBubbler^.T_CtrleDCAxis.xDone
			AND NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute) AND ptrTAxisFeedPump^.T_CtrleDCAxis.xDone THEN
				xReadyChkError:=TRUE;
				xInitStep:=FALSE;
				iStepEnable:=400;
			END_IF;
		400:	IF NOT(xInitStep) THEN	(* Read Axis Parameter File-->wird nicht mehr gebraucht *)
				xInitStep:=TRUE;
				ptrTAxisZ^.T_CtrleSingle.sDeviceName:='Beckhoff';
				ptrTAxisS^.T_CtrleSingle.sDeviceName:='Maxon';
				ptrTAxisBubbler^.T_CtrleDCAxis.iFunction:=2;			(* Read Axis File *)
				ptrTAxisBubbler^.T_CtrleDCAxis.xExecute:=TRUE;
				ptrTAxisFeedPump^.T_CtrleDCAxis.iFunction:=2;		(* Read Axis File *)
				ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone
			AND NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone
			AND NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xExecute) AND ptrTAxisBubbler^.T_CtrleDCAxis.xDone
			AND NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute) AND ptrTAxisFeedPump^.T_CtrleDCAxis.xDone THEN
				xInitStep:=FALSE;
				iStepEnable:=500;
			END_IF;
		500:	IF NOT(xInitStep) THEN	(* Send Axis Parameter File-->wird nicht mehr gebraucht *)
				xInitStep:=TRUE;
				IF ptrTAxisBubbler^.T_CtrleDCAxis.xErr OR NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xDone) THEN
					ptrTAxisBubbler^.T_CtrleDCAxis.iFunction:=1;
					ptrTAxisBubbler^.T_CtrleDCAxis.xExecute:=TRUE;
				END_IF;
				IF ptrTAxisFeedPump^.T_CtrleDCAxis.xErr OR NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xDone) THEN
					ptrTAxisFeedPump^.T_CtrleDCAxis.iFunction:=1;
					ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xExecute) AND ptrTAxisBubbler^.T_CtrleDCAxis.xDone
			AND NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute) AND ptrTAxisFeedPump^.T_CtrleDCAxis.xDone THEN
				xInitStep:=FALSE;
				iStepEnable:=600;
			END_IF;
		600:	IF NOT(xInitStep) THEN	(* Keine BoxId mehr *)
				xInitStep:=TRUE;
				ptrTAxisBubbler^.T_CtrleDCAxis.iFunction:=1;			(* Reset Axis *)
				ptrTAxisBubbler^.T_CtrleDCAxis.xExecute:=TRUE;
				ptrTAxisFeedPump^.T_CtrleDCAxis.iFunction:=1;		(* Reset Axis *)
				ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xExecute) AND ptrTAxisBubbler^.T_CtrleDCAxis.xDone
			AND NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute) AND ptrTAxisFeedPump^.T_CtrleDCAxis.xDone THEN
				xInitStep:=FALSE;
				iStepEnable:=700;
			END_IF
		700:	IF NOT(xInitStep) THEN	(* Keine Konfigurationsfehler mehr *)
				xInitStep:=TRUE;
			END_IF;
			xInitStep:=FALSE;
			iStepEnable:=800;
		800:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF xSafetyCircuitOn THEN
					ptrTAxisZ^.T_CtrleSingle.iFunction:=3;
					ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone AND (ptrTAxisZ^.T_CtrleSingle.xPower OR NOT(xSafetyCircuitOn)) THEN
				iStepEnable:=900;
				xInitStep:=FALSE;
			END_IF;
		900:	IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				ptrTAxisZ^.T_CtrleSingle.iFunction:=1;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisS^.T_CtrleSingle.iFunction:=1;
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisBubbler^.T_CtrleDCAxis.iFunction:=21;			(* Axisparameter senden *)
				ptrTAxisBubbler^.T_CtrleDCAxis.xExecute:=TRUE;
				ptrTAxisFeedPump^.T_CtrleDCAxis.iFunction:=21;		(* Axisparameter senden *)
				ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute:=TRUE;
			END_IF;
			IF xTmp THEN
				RETURN;	(* Wait until all Drives finished *)
			END_IF;
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone
			AND NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone
			AND NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xExecute) AND ptrTAxisBubbler^.T_CtrleDCAxis.xDone
			AND NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute) AND ptrTAxisFeedPump^.T_CtrleDCAxis.xDone THEN
				xInitStep:=FALSE;
				iStepEnable:=1000;
			END_IF;
		1000:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				IF T_Station_Parameter.T_AxisState.xReferencedZAxis THEN
					IF NOT(xFirstBooting) THEN
						ptrTAxisZ^.T_CtrleSingle.rSetPosition:=	ptrTAxisZ^.T_LiveValue.lrActualPosition -
																T_Station_Parameter.T_AxisState.rPositionReferenceZAxis;
						ptrTAxisZ^.T_CtrleSingle.iFunction:=11;		(* Position setzen *)
						ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				END_IF;
				xFirstBooting:=TRUE;
			END_IF;
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
				iStepEnable:=1100;
				xInitStep:=FALSE;
			END_IF;
		1100:IF NOT(xInitStep) THEN
				xInitStep:=TRUE;
				(* Zylinder für Auslenkung-->mit Workauslenkkraft *)
				ptrTCylToolDeflection^.T_CtrleCyl.iFunction:=2;
				ptrTCylToolDeflection^.T_Config.tDelayOn:=T#0.3s;
				ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_OnlineChange.rForceDeflection;
				ptrTCylToolDeflection^.T_CtrleCyl.xExecute:=TRUE;
				IF  (T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1] <= 0.0) THEN
					T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=6.0;
				END_IF;
				IF  (T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1] <= 0.0) THEN
					T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]:=6.0;
				END_IF;
			END_IF;
			IF NOT(ptrTCylToolDeflection^.T_CtrleCyl.xExecute) AND ptrTCylToolDeflection^.T_CtrleCyl.xDone THEN
				iStepEnable:=1101;
				xInitStep:=FALSE;
			END_IF;
		1101:IF (TONCalcMinTimeEnable.ET >= T#3.5s) THEN	(* Mindestens diese Zeit muss eingehalten werden, damit bei unterschidlichen Laufzeiten von Maschinen der Progressbalken beim auftsarten in etwa immer gleich dauert *)
				iStepEnable:=1200;
				xInitStep:=FALSE;
				xWaitAxisVoltageBooting:=FALSE;
			END_IF;
		1200:xReadyChkError:=FALSE;
			xInitStep:=FALSE;
			xInitSetEnable:=FALSE;
			T_Station_Work.TControl.xRdy:=TRUE;
			xSetEnd:=TRUE;
			xStFct_ForceStationError:=FALSE;
	END_CASE;
END_IF;
END_ACTION

ACTION	CtrlErrorStation:
IF (xStationError OR xForceHWError OR xStFct_ForceStationError OR (xStFct_Error AND T_Station_Work.TControl.xRdy AND NOT(xSetEnd))) AND NOT(T_Station_Work.TControl.xSecurityCircuitOff) THEN
	IF NOT(xInitError) THEN
		IF xForceHWError THEN
			T_Station_Work.TControl.diErrorNr:=0;
			xForceHWError:=FALSE;
		END_IF;
		iSettledErrFromFunction:=iStationFunctionNr;
		xStationError:=TRUE;
		xTmpStationError:=TRUE;
		xInitError:=TRUE;
		xAxisErrorActive:=FALSE;
		T_Station_Work.TControl.diErrorNr:=0;
		xStFct_ForceStationError:=FALSE;
		IF ptrTAxisZ^.T_CtrleSingle.xErr THEN
			IF (T_Station_Work.TControl.diErrorNr = 0) THEN
				T_Station_Work.TControl.diErrorNr:=20000000 + ptrTAxisZ^.T_CtrleSingle.udiErrorID;
			END_IF;
			ptrTAxisZ^.T_CtrleSingle.xReset:=TRUE;
			xAxisErrorActive:=TRUE;
		END_IF;
		IF ptrTAxisS^.T_CtrleSingle.xErr THEN
			IF (T_Station_Work.TControl.diErrorNr = 0) THEN
				T_Station_Work.TControl.diErrorNr:=24000000 + ptrTAxisS^.T_CtrleSingle.udiErrorID;
			END_IF;
			ptrTAxisS^.T_CtrleSingle.xReset:=TRUE;
			xAxisErrorActive:=TRUE;
		END_IF;
		IF ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xErr THEN
			IF (T_Station_Work.TControl.diErrorNr = 0) THEN
				T_Station_Work.TControl.diErrorNr:=42000000 + ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.udiErrorID;
			END_IF;
			ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xReset:=TRUE;
		END_IF;
		IF (T_Station_Work.TControl.diErrorNr = 0) THEN	(* General Error-->No Hardware Error  1000000 - 1999999*)
			T_Station_Work.TControl.diErrorNr:=1000000 + diStFct_ErrorNr;
		END_IF;
		xStFct_QuitErr:=NOT(xStFct_End) AND xStFct_Error;
		IF NOT(xStFct_QuitErr) AND NOT(xStFct_End) THEN
			xForceResetAxis:=TRUE;
			xStFct_Reset:=TRUE;
			xStFct_SetEnd:=TRUE;
			StationFunction_Ctrl_End;
		END_IF;
		TONWaitReset(IN:=FALSE);
	END_IF;
	xStFct_QuitErr:=NOT(xStFct_End) AND xStFct_Error;
	IF (xStFct_End OR xForceResetAxis) AND xTmpStationError THEN
		xStartFunction:=FALSE;
		TONWaitReset(IN:=TRUE,PT:=T#500ms);
		IF TONWaitReset.Q THEN
			xStepError:=FALSE;
			xTmpStationError:=FALSE;
			xReadyToQuitErr:=TRUE;
			T_Station_Work.TControl.xError:=TRUE;
			T_Station_Work.TControl.xDone:=FALSE;
			xForceResetAxis:=FALSE;
		END_IF;
	END_IF;
	IF T_Station_Work.TControl.xQuitError AND NOT(xStFct_QuitErr) AND xReadyToQuitErr THEN
		xInitError:=FALSE;
		T_Station_Work.TControl.xQuitError:=FALSE;
		xSetEnd:=TRUE;
	END_IF;
ELSE
	(* Gilt für Fehler die ausserhalb der Station gesetzt werden und diese zurücksetzen zu können *)
	IF T_Station_Work.TControl.xQuitError THEN
		T_Station_Work.TControl.xQuitError:=FALSE;
		xSetEnd:=TRUE;
	END_IF;
	(* Überwachung Drehmoment Überlast *)
	IF (iStationFunctionNr <> 4) AND (iStationFunctionNr <> 5) THEN
		IF ptrTCylToolTorqueOverload^.T_CtrleCyl.xStatePosOn OR ptrTSensorTorqueOverload^.T_CtrleCyl.xStatePosOn THEN
			IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) AND ptrTAxisS^.T_CtrleSingle.xDone THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=5;
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
				gxSpindleOverloadError:=TRUE;
			END_IF;
		END_IF;
	END_IF;
END_IF;
END_ACTION

ACTION	CtrlMainStation:
IF T_Station_Work.TControl.xRdy THEN
	T_Station_Work.TControl.xReferenced:=T_Station_Parameter.T_AxisState.xReferencedZAxis;
END_IF;
IF (T_Station_Work.TControl.xExecute OR xTmpStart) AND T_Station_Work.TControl.xRdy AND NOT(xSetEnd) THEN
	IF NOT(xInitStart) THEN
		xInitStart:=TRUE;
		xTmpStart:=TRUE;
		T_Station_Work.TControl.xExecute:=FALSE;
		T_Station_Work.TControl.xDone:=FALSE;
		xStFct_Start:=TRUE;
		xStartFunction:=TRUE;
		iStationFunctionNr:=T_Station_Work.TControl.iFunctNr;
		T_Station_Work.TControl.xAbord:=FALSE;
		xStFct_HardwareError:=xStFct_ErrorActuator:=xStFct_InitError:=FALSE;
		xStFct_ForceSetSpeedZAxis:=FALSE;
		xStFct_ForceSetSpeedTorqueZAxis:=FALSE;
		T_Station_Work.THWWorkStation.TCtrlWork.xToolInfeeded:=FALSE;
		xMaxTorqueActive:=FALSE;
		xPartDiscNotInPosition:=FALSE;
	END_IF;
	IF T_Station_Work.TControl.xStop THEN
		IF NOT(xInitStop) THEN
			xInitStop:=TRUE;
			xStFct_Stop:=TRUE;
		END_IF;
		IF NOT(xStFct_Stop) THEN
			xInitStop:=FALSE;
			T_Station_Work.TControl.xStop:=FALSE;
			xTmpStopFunction:=TRUE;
		END_IF;
	END_IF;
	IF T_Station_Work.TControl.xExecute AND xTmpStopFunction AND NOT(xStFct_Abord) THEN
		T_Station_Work.TControl.xExecute:=FALSE;
		xTmpStopFunction:=FALSE;
		xStFct_Start:=TRUE;
	END_IF;
	IF T_Station_Work.TControl.xAbord AND xTmpStopFunction THEN
		T_Station_Work.TControl.xAbord:=FALSE;
		xTmpStopFunction:=FALSE;
		xStFct_Start:=FALSE;
		xStFct_Abord:=TRUE;
	END_IF;
	IF NOT(xStFct_Start) AND xStFct_End AND NOT(xStationError) THEN
		xTmpStart:=FALSE;
		xInitStart:=FALSE;
		xSetEnd:=TRUE;
	END_IF;
END_IF;
END_ACTION

ACTION	CtrlSafetySwitch_ON_OFF:
TONCheckAxisVoltagBooting(IN:=xStartTimer,PT:=T#60s);
IF NOT(T_TwinSafeOut.QxContactorMasterModul400VCh1) OR NOT(T_TwinSafeOut.QxContactorMasterModul400VCh2) THEN
	xStartTimer:=TRUE;
ELSE
	xStartTimer:=FALSE;
END_IF;
IF TONCheckAxisVoltagBooting.Q THEN
	xWaitAxisVoltageBooting:=TRUE;
END_IF;
TONWaitCheckCylinder(IN:=TRUE,PT:=T#1s);
IF (T_Station_Work.TControl.xSecurityCircuitOn OR T_Station_Work.TControl.xSecurityCircuitOff OR xSecurityCircuitOn OR xSecurityCircuitOff) AND NOT(xInitSetEnable) AND NOT(xInitDelEnable) AND NOT(xStationError) THEN
	TONWaitCheckCylinder(IN:=FALSE);
	T_Station_Work.TControl.xBlockCheckZylinder:=TRUE;
	IF NOT(xSecurityCircuitOn) AND NOT(xSecurityCircuitOff) THEN
		xSecurityCircuitOn:=T_Station_Work.TControl.xSecurityCircuitOn;
		xSecurityCircuitOff:=T_Station_Work.TControl.xSecurityCircuitOff;
		iStepSecCircuit:=1;
		xInitSecCircuit:=FALSE;
		T_Station_Work.TControl.xDone:=FALSE;
		TONCheckError(IN:=FALSE);
	END_IF;
	IF xSecurityCircuitOn THEN
		IF T_Station_Work.TControl.xSecurityCircuitOff THEN
			T_Station_Work.TControl.xSecurityCircuitOn:=FALSE;
			xSecurityCircuitOn:=FALSE;
		END_IF;
	END_IF;
	IF xSecurityCircuitOff THEN
		IF T_Station_Work.TControl.xSecurityCircuitOn THEN
			T_Station_Work.TControl.xSecurityCircuitOff:=FALSE;
			xSecurityCircuitOff:=FALSE;
		END_IF;
	END_IF;
	CASE iStepSecCircuit OF
	1:	IF gxHardwareOFF OR gxAxisOFF THEN
			xInitSecCircuit:=FALSE;
			iStepSecCircuit:=60;
			RETURN;
		END_IF;
		IF xSecurityCircuitOff THEN
			TONCheckError(IN:=TRUE,PT:=T#50ms);
			IF TONCheckError.Q THEN
				TONCheckError(IN:=FALSE);
				iStepSecCircuit:=iStepSecCircuit + 1;
			END_IF;
		ELSE
			iStepSecCircuit:=iStepSecCircuit + 1;
		END_IF;
		ptrTAxisZ^.T_CtrleSingle.xReset:=TRUE;
		(* Controlling für OnlineChange *)
		IF xSecurityCircuitOn THEN
			T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolDeflectionForce:=FALSE;
			T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedBackward:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedForward:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChange_S_WorkSpindleSpeed:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolTorqueLevel:=FALSE;
		ELSE
			T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolDeflectionForce:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedBackward:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedForward:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChange_S_WorkSpindleSpeed:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolTorqueLevel:=TRUE;
		END_IF;
	2:	T_Station_Work.TControl.xRdy:=FALSE;
		IF NOT(xInitSecCircuit) THEN
			xInitSecCircuit:=TRUE;
			xStFct_Reset:=TRUE;
			iStationFunctionNr:=1;
			xStartFunction:=TRUE;
		END_IF;
		IF NOT(xStFct_Reset) AND xStFct_End THEN
			(* Alle Funktionen Resetten *)
			xInitSecCircuit:=FALSE;
			iStepSecCircuit:=10;
			xStartFunction:=FALSE;
		END_IF;
	10:	IF NOT(xInitSecCircuit) THEN
			xInitSecCircuit:=TRUE;
			T_Station_Work.TControl.xResetHardware:=TRUE;
			ptrTAxisBubbler^.T_CtrleDCAxis.xReset:=TRUE;
			ptrTAxisFeedPump^.T_CtrleDCAxis.xReset:=TRUE;
		END_IF;
		IF NOT(T_Station_Work.TControl.xResetHardware)
		AND NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xReset) AND NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xReset) THEN
			xInitSecCircuit:=FALSE;
			iStepSecCircuit:=20;
		END_IF;
	20:	IF NOT(xInitSecCircuit) THEN
			xInitSecCircuit:=TRUE;
			ptrTAxisBubbler^.T_CtrleDCAxis.iFunction:=1;					(* Reset Axis *)
			ptrTAxisBubbler^.T_CtrleDCAxis.xExecute:=TRUE;
			ptrTAxisFeedPump^.T_CtrleDCAxis.iFunction:=1;					(* Reset Axis *)
			ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute:=TRUE;
		END_IF;
		IF (NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xExecute) AND (ptrTAxisBubbler^.T_CtrleDCAxis.xDone OR ptrTAxisBubbler^.T_CtrleDCAxis.xErr))
		AND (NOT(ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute) AND (ptrTAxisFeedPump^.T_CtrleDCAxis.xDone OR ptrTAxisFeedPump^.T_CtrleDCAxis.xErr)) THEN
			xInitSecCircuit:=FALSE;
			iStepSecCircuit:=30;
		END_IF;
	30:	IF NOT(xInitSecCircuit) THEN
			xInitSecCircuit:=TRUE;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=4;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			ptrTAxisS^.T_CtrleSingle.iFunction:=4;
			ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF (NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND (ptrTAxisZ^.T_CtrleSingle.xDone OR ptrTAxisZ^.T_CtrleSingle.xErr)) AND
		    (NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND (ptrTAxisS^.T_CtrleSingle.xDone OR ptrTAxisS^.T_CtrleSingle.xErr)) THEN
			IF ptrTAxisZ^.T_CtrleSingle.xErr THEN
				xInitSecCircuit:=FALSE;
				iStepSecCircuit:=10;
			ELSE
				xInitSecCircuit:=FALSE;
				iStepSecCircuit:=40;
			END_IF;
		END_IF;
	40:	IF NOT(xInitSecCircuit) THEN
			xInitSecCircuit:=TRUE;
			(* Resetten der Aktuatoren *)
			ptrTCylToolDeflection^.T_CtrleCyl.xReset:=TRUE;
			ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xReset:=TRUE;
			ptrTCylToolTorqueHC^.T_CtrleCyl.xReset:=TRUE;
			ptrTCylToolTorqueOverload^.T_CtrleCyl.xReset:=TRUE;

(*			ptrTCylWorkpieceClamp^.T_CtrleCyl.xReset:=TRUE;
			ptrTValveAirTable^.T_CtrleCyl.xReset:=TRUE;
			ptrTValveVacuumTable^.T_CtrleCyl.xReset:=TRUE;*)
		END_IF;
		IF NOT(ptrTCylToolDeflection^.T_CtrleCyl.xReset) AND NOT(ptrTCylToolTorqueHC^.T_CtrleCyl.xReset) AND
		     NOT(ptrTCylToolTorqueOverload^.T_CtrleCyl.xReset) AND NOT(ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xReset) AND
		     NOT(ptrTCylWorkpieceClamp^.T_CtrleCyl.xReset) AND NOT(ptrTValveAirTable^.T_CtrleCyl.xReset) AND
		     NOT(ptrTValveVacuumTable^.T_CtrleCyl.xReset) THEN
			xInitSecCircuit:=FALSE;
			IF xWaitAxisVoltageBooting AND (xSafetyCircuitOn) THEN
				iStepSecCircuit:=45;
			ELSE
				iStepSecCircuit:=50;
			END_IF;
		END_IF;
	45:	IF NOT(xInitSecCircuit) THEN
			xInitSecCircuit:=TRUE;
			TONWaitAxisCurrentSwitchON(IN:=FALSE);
		END_IF;
		TONWaitAxisCurrentSwitchON(IN:=TRUE,PT:=T#2s);
		IF TONWaitAxisCurrentSwitchON.Q THEN	(* Warten bis Zwischenkreisspannung aufgebaut ist, da es mehr als 1 Minute ausgeschaltet war *)
			xWaitAxisVoltageBooting:=FALSE;
			xInitSecCircuit:=FALSE;
			iStepSecCircuit:=50;
		END_IF;
	50:	IF NOT(xInitSecCircuit) THEN
			xInitSecCircuit:=TRUE;
			IF xSafetyCircuitOn THEN
				ptrTAxisZ^.T_CtrleSingle.iFunction:=3;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
				ptrTCylToolDeflection^.T_CtrleCyl.iFunction:=2;
				ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_OnlineChange.rForceDeflection;
				ptrTCylToolDeflection^.T_CtrleCyl.xExecute:=TRUE;
				ptrTCylToolTorqueHC^.T_CtrleCyl.iFunction:=2;
				ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_OnlineChange.rTorqueLevelHC;
				ptrTCylToolTorqueHC^.T_CtrleCyl.xExecute:=TRUE;
				ptrTCylToolTorqueOverload^.T_CtrleCyl.iFunction:=2;
				ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_StProcess.rTorqueLevel_Overload;
				ptrTCylToolTorqueOverload^.T_CtrleCyl.xExecute:=TRUE;
				ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.iFunction:=1;
				ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xExecute:=TRUE;
(*				ptrTCylWorkpieceClamp^.T_CtrleCyl.iFunction:=1;
				ptrTCylWorkpieceClamp^.T_CtrleCyl.xExecute:=TRUE;
				ptrTValveAirTable^.T_CtrleCyl.iFunction:=1;
				ptrTValveAirTable^.T_CtrleCyl.xExecute:=TRUE;
				ptrTValveVacuumTable^.T_CtrleCyl.iFunction:=1;
				ptrTValveVacuumTable^.T_CtrleCyl.xExecute:=TRUE;*)
			END_IF;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xInitSecCircuit:=FALSE;
			iStepSecCircuit:=60;
			IF  (T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1] <= 0.0) THEN
				T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=6.0;
			END_IF;
			IF (T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1] <= 0.0) THEN
				T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]:=3.0;
			END_IF;
		END_IF;
	60:	T_Station_Work.TControl.xRdy:=TRUE;
		T_Station_Work.TControl.xSecurityCircuitOn:=FALSE;
		T_Station_Work.TControl.xSecurityCircuitOff:=FALSE;
		xSecurityCircuitOn:=FALSE;
		xSecurityCircuitOff:=FALSE;
		iStepSecCircuit:=1;
		xInitSecCircuit:=FALSE;
		xSetEnd:=TRUE;
		xStFct_ForceStationError:=FALSE;
	END_CASE;
ELSE
	T_Station_Work.TControl.xSecurityCircuitOn:=FALSE;
	T_Station_Work.TControl.xSecurityCircuitOff:=FALSE;
	xSecurityCircuitOn:=FALSE;
	xSecurityCircuitOff:=FALSE;
	iStepSecCircuit:=1;
	xInitSecCircuit:=FALSE;
	TONCheckError(IN:=FALSE);
	IF TONWaitCheckCylinder.Q THEN
		T_Station_Work.TControl.xBlockCheckZylinder:=FALSE;
		IF ptrTAxisBubbler^.T_CtrleDCAxis.xErr THEN
			ptrTAxisBubbler^.T_CtrleDCAxis.iFunction:=1;
			ptrTAxisBubbler^.T_CtrleDCAxis.xExecute:=TRUE;
		END_IF;
		IF ptrTAxisFeedPump^.T_CtrleDCAxis.xErr THEN
			ptrTAxisFeedPump^.T_CtrleDCAxis.iFunction:=1;
			ptrTAxisFeedPump^.T_CtrleDCAxis.xExecute:=TRUE;
		END_IF;
	END_IF;
END_IF;
END_ACTION

ACTION	StationFunction_CheckOverload:
(* Überwachung Drehmoment Überlast *)
IF gxHardwareOFF THEN
	RETURN;
END_IF;
CASE T_ExchgParam.bToolSpindleActive OF
1:	(* Maxon Spindel *)
	IF ptrTCylToolTorqueOverload^.T_CtrleCyl.xStatePosOn THEN
		xStFct_Overload_StopProcess:=TRUE;
	END_IF;
	IF xStFct_Overload_StopProcess THEN
		CASE iStFct_Overload_StopProcess OF
		1:	T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedForward:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedBackward:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChange_S_WorkSpindleSpeed:=TRUE;
			IF (NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) OR NOT(ptrTAxisZ^.T_CtrleSingle.xDone)) AND
	     		    NOT((ptrTAxisZ^.T_CtrleSingle.iFunction = 5) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone)) THEN
				ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
				iStFct_Overload_StopProcess:=iStFct_Overload_StopProcess + 1;
			ELSE
				iStFct_Overload_StopProcess:=iStFct_Overload_StopProcess + 1;
			END_IF;
			IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=5;
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			RETURN;
		2:	IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone AND
			    NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone THEN
				T_Station_Work.THWWorkStation.TCtrlWork.xWorkingFinished:=TRUE;
				T_Station_Work.THWWorkStation.TCtrlWork.bPartQuality:=8;(* < Bearb. abgbr. > *)
				xStFct_HardwareError:=TRUE;
				diStFct_TmpErrorNr:=15;		(* Wz Drehmoment Überlast Aktiv *)
			END_IF;
			RETURN;
		END_CASE;
	END_IF;
2,3:	(* Beckhoff Spindel *)
	IF (T_Station_Parameter.T_StProcess.iWorkControlType <= 1) THEN
		IF (T_Station_Parameter.T_OnlineChange.rTorqueLevelHC <> 0.0) THEN
			CASE T_ExchgParam.bToolSpindleActive OF
			2:	(* Beckhoff Spindel L *)
				rTorquePercent:=REAL_TO_INT(100.0/T_Station_Parameter.T_OnlineChange.rTorqueLevelHC*T_Station_Parameter.T_TorqueSystem_L.rActual_Torque);
			3:	(* Beckhoff Spindel M *)
				rTorquePercent:=REAL_TO_INT(100.0/T_Station_Parameter.T_OnlineChange.rTorqueLevelHC*T_Station_Parameter.T_TorqueSystem_M.rActual_Torque);
			END_CASE;
		END_IF;
	END_IF;

	IF (T_Station_Parameter.T_StProcess.iWorkControlType = 2) THEN
		IF (T_Station_Parameter.T_StProcess.rZ_PID_Torque <> 0.0) THEN
			rTorquePercent:=REAL_TO_INT(100.0/T_Station_Parameter.T_StProcess.rZ_PID_Torque*rTorqueSpindleSensor);
		END_IF;
	END_IF

	IF (T_Station_Parameter.T_StProcess.iWorkControlType = 3) THEN
		IF (T_Station_Parameter.T_OnlineChange.rTorqueLevelHC <> 0.0) THEN
			rTorquePercent:=REAL_TO_INT(100.0/T_Station_Parameter.T_OnlineChange.rTorqueLevelHC*rTorqueSpindleSensor);
		END_IF;
	END_IF;

	IF (rTorquePercent >= T_Station_Parameter.T_StProcess.iMaxTorque) THEN
		IF (rTorqueMax < T_Station_Parameter.T_StProcess.iMaxTorque) THEN
			rTorqueMax:=T_Station_Parameter.T_StProcess.iMaxTorque;
		END_IF;
		xMaxTorqueActive:=TRUE;
	END_IF;

	IF ptrTSensorTorqueOverload^.T_CtrleCyl.xStatePosOn OR xMaxTorqueActive THEN
		xStFct_Overload_StopProcess:=TRUE;
	END_IF;
	IF xStFct_Overload_StopProcess THEN
		CASE iStFct_Overload_StopProcess OF
		1:	T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedForward:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedBackward:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChange_S_WorkSpindleSpeed:=TRUE;
			IF (NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) OR NOT(ptrTAxisZ^.T_CtrleSingle.xDone)) AND
	     		    NOT((ptrTAxisZ^.T_CtrleSingle.iFunction = 5) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone)) THEN
				ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=5;
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			iStFct_Overload_StopProcess:=iStFct_Overload_StopProcess + 1;
			RETURN;
		2:	IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone
			AND NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone THEN
				T_Station_Work.THWWorkStation.TCtrlWork.xWorkingFinished:=TRUE;
				T_Station_Work.THWWorkStation.TCtrlWork.bPartQuality:=8;(* < Bearb. abgbr. > *)
				xStFct_HardwareError:=TRUE;
				IF xMaxTorqueActive THEN
					diStFct_TmpErrorNr:=16;		(* Wz Drehmoment Max überschritten *)
				ELSE
					diStFct_TmpErrorNr:=15;		(* Wz Drehmoment Überlast Aktiv *)
				END_IF;
			END_IF;
			RETURN;
		END_CASE;
	END_IF;
END_CASE;
END_ACTION

ACTION	StationFunction_Ctrl_AxisBrake:
IF NOT(xAxisBrakeBlock) THEN
	IF NOT(ptrTAxisZ^.T_CtrleSingle.xPower) THEN
		IF NOT(ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.T_Standard.xActivOff) AND NOT(ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xExecute) AND ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xDone THEN
			ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.iFunction:=1;
			ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xExecute:=TRUE;
		END_IF;
	ELSE
		IF NOT(ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.T_Standard.xActivOn) AND NOT(ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xExecute) AND ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xDone THEN
			ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.iFunction:=2;
			ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xExecute:=TRUE;
		END_IF;
	END_IF;

END_IF;
END_ACTION

ACTION	StationFunction_Ctrl_CalcProcWork:
(* Berechnung der Bearbeitungsarbeit *)
IF (iStFct_StepPrc = 3) THEN
	IF ptrTAxisZ^.T_CtrleSingle.xMovingForward AND NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) THEN
		CASE T_ExchgParam.bToolSpindleActive OF
		1:	(* Maxon Spindel *)
			rTorqueForce:=T_Station_Parameter.T_TorqueSystem.rActual_Torque;		(* Maxon Spindel ist aktiv *)
		2:	(* Beckhoff Spindel L *)
			rTorqueForce:=T_Station_Parameter.T_TorqueSystem_L.rActual_Torque;		(* Beckhoff Spindel ist aktiv *)
		3:	(* Beckhoff Spindel M *)
			rTorqueForce:=T_Station_Parameter.T_TorqueSystem_M.rActual_Torque;		(* Beckhoff Spindel ist aktiv *)
		END_CASE;
		IF (rTorqueForce < 0.0) THEN
			rTorqueForce:=0.0;
		END_IF;
		IF NOT(xStFct_InitialCalcProcWork) THEN
			xStFct_InitialCalcProcWork:=TRUE;
			rStFct_ZSavePosition:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
		END_IF;
		rStFct_ZCalcDistance:=rStFct_ZCalcDistance + (ptrTAxisZ^.T_LiveValue.lrActualPosition - rStFct_ZSavePosition);
		rStFct_ZSavePosition:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
		diStFct_Counter:=diStFct_Counter + 1;
		rStFct_AddWorkForce:=(rStFct_AddWorkForce + rTorqueForce);
		rStFct_CalcWorkForce:=rStFct_AddWorkForce / DINT_TO_REAL(diStFct_Counter);
	END_IF;
ELSE
	xStFct_InitialCalcProcWork:=FALSE;
END_IF;
T_Station_Work.THWWorkStation.TCtrlWork.rProcessWork:=rStFct_CalcWorkForce * (rStFct_ZCalcDistance/1000.0);	(* Arbeit=Kraft(N)*Weg(m) *)
END_ACTION

ACTION	StationFunction_Ctrl_CheckPos_Z:
xStFct_PositionOutRange_Z:=FALSE;
iStFct_PosErrorNr:=0;
IF (grZ_LoadPos > T_Station_Parameter.T_StProcess.rPositionEndMech) THEN
	iStFct_PosErrorNr:=27;	(* Z LadePos > Z Mech EndPos *)
ELSIF (grZ_WorkStartPos > T_Station_Parameter.T_StProcess.rPositionEndMech) THEN
	iStFct_PosErrorNr:=28;	(* Z Bearb StartPos > Z Mech EndPos *)
ELSIF (garPositionEndProcCalc[1] > T_Station_Parameter.T_StProcess.rPositionEndMech) THEN
	iStFct_PosErrorNr:=29;	(* Z Bearb EndPos > Z Mech EndPos *)
ELSIF (garCentringEndProcCalc[1] > T_Station_Parameter.T_StProcess.rPositionEndMech) THEN
	iStFct_PosErrorNr:=37;	(* Z ZentrierPos berechn. > Z Mech EndPos *)
ELSIF (T_Station_Parameter.T_StProcess.rZPositionCylindricalArea > T_Station_Parameter.T_StProcess.rPositionEndMech) THEN
	iStFct_PosErrorNr:=43;	(* Z WzZylinder Pos > Z Mech EndPos *)
ELSIF (T_Station_Parameter.T_StProcess.rPositionToolChange > T_Station_Parameter.T_StProcess.rPositionEndMech) THEN
	iStFct_PosErrorNr:=34;	(* Z WzWechsel Pos > Z Mech EndPos *)
ELSIF (grZ_LoadPos > grZ_WorkStartPos) AND
		(grZ_LoadPos > garPositionEndProcCalc[1]) THEN
	iStFct_PosErrorNr:=31;	(* Z LadePos: Stimmt nicht mit anderen Positionen überein *)
ELSIF (grZ_WorkStartPos < grZ_LoadPos) AND
		(grZ_WorkStartPos > garPositionEndProcCalc[1]) THEN
	iStFct_PosErrorNr:=32;	(* Z Bearb StartPos: Stimmt nicht mit anderen Positionen überein *)
ELSIF (garPositionEndProcCalc[1] < grZ_LoadPos) AND
		(garPositionEndProcCalc[1] < grZ_WorkStartPos) THEN
	iStFct_PosErrorNr:=33;	(* Z Bearb EndPos: Stimmt nicht mit anderen Positionen überein *)
END_IF;
IF (iStFct_PosErrorNr <> 0) THEN
	xStFct_PositionOutRange_Z:=TRUE;
END_IF;
END_ACTION

ACTION	StationFunction_Ctrl_CleanNozzle:
IF NOT(ptrTValveCleanNozzle^.T_CtrleCyl.xExecute) AND ptrTValveCleanNozzle^.T_CtrleCyl.xDone THEN
	CASE T_Station_Parameter.T_StProcess.iCleanNozzleMode OF
		0: 	(* Disable cleaning nozzle *)
			IF ptrTValveCleanNozzle^.T_CtrleCyl.T_Standard.xActivOn THEN
				ptrTValveCleanNozzle^.T_CtrleCyl.iFunction:=1;
				ptrTValveCleanNozzle^.T_CtrleCyl.xExecute:=TRUE;
			END_IF
		1: 	(* Cleaning nozzle on Z axis forward *)
			IF ptrTAxisZ^.T_CtrleSingle.xMovingForward AND ptrTValveCleanNozzle^.T_CtrleCyl.T_Standard.xActivOff  THEN
				ptrTValveCleanNozzle^.T_CtrleCyl.iFunction:=2;
				ptrTValveCleanNozzle^.T_CtrleCyl.xExecute:=TRUE;
			ELSIF NOT(ptrTAxisZ^.T_CtrleSingle.xMovingForward) AND ptrTValveCleanNozzle^.T_CtrleCyl.T_Standard.xActivOn THEN
				ptrTValveCleanNozzle^.T_CtrleCyl.iFunction:=1;
				ptrTValveCleanNozzle^.T_CtrleCyl.xExecute:=TRUE;
			END_IF
		2: 	(* Cleaning nozzle on Z axis backward *)
			IF ptrTAxisZ^.T_CtrleSingle.xMovingBackwards AND ptrTValveCleanNozzle^.T_CtrleCyl.T_Standard.xActivOff  THEN
				ptrTValveCleanNozzle^.T_CtrleCyl.iFunction:=2;
				ptrTValveCleanNozzle^.T_CtrleCyl.xExecute:=TRUE;
			ELSIF NOT(ptrTAxisZ^.T_CtrleSingle.xMovingBackwards) AND ptrTValveCleanNozzle^.T_CtrleCyl.T_Standard.xActivOn THEN
				ptrTValveCleanNozzle^.T_CtrleCyl.iFunction:=1;
				ptrTValveCleanNozzle^.T_CtrleCyl.xExecute:=TRUE;
			END_IF
		3: 	(* Cleaning nozzle on Z axis moving *)
			IF (ptrTAxisZ^.T_CtrleSingle.xMovingForward  OR ptrTAxisZ^.T_CtrleSingle.xMovingBackwards) AND ptrTValveCleanNozzle^.T_CtrleCyl.T_Standard.xActivOff THEN
				ptrTValveCleanNozzle^.T_CtrleCyl.iFunction:=2;
				ptrTValveCleanNozzle^.T_CtrleCyl.xExecute:=TRUE;
			ELSIF ptrTAxisZ^.T_CtrleSingle.xNotMoving AND ptrTValveCleanNozzle^.T_CtrleCyl.T_Standard.xActivOn THEN
				ptrTValveCleanNozzle^.T_CtrleCyl.iFunction:=1;
				ptrTValveCleanNozzle^.T_CtrleCyl.xExecute:=TRUE;
			END_IF
	END_CASE
ELSE
	ptrTValveCleanNozzle^.T_CtrleCyl.xExecute:=FALSE;
END_IF




END_ACTION

ACTION	StationFunction_Ctrl_Controller_1:
(* Geschwindigkeitsregelung der Z1 Achse mittels der Kraftmessdose--> Konventioneller Regler *)
IF ptrTAxisZ^.T_CtrleSingle.xMovingForward THEN
	(* Konventionelle Regelung aber mit Override Funktion *)
	rStFct_V1:=	T_Station_Parameter.T_OnlineChange.rWorkingSpeedForward;
	rStFct_V2:=	T_Station_Parameter.T_OnlineChange.rWorkingSpeedForward/100.0;
	rStFct_S1:=	0.5;
	rStFct_S2:=	T_Station_Parameter.T_OnlineChange.rTorqueLevelHC;
	CASE T_ExchgParam.bToolSpindleActive OF
	1:	(* Maxon Spindel *)
		rStFct_M:=	T_Station_Parameter.T_TorqueSystem.rActual_Torque;		(* Maxon Spindel ist aktiv *)
	2:	(* Beckhoff Spindel L *)
		rStFct_M:=	T_Station_Parameter.T_TorqueSystem_L.rActual_Torque;	(* Beckhoff Spindel ist aktiv *)
	3:	(* Beckhoff Spindel M *)
		rStFct_M:=	T_Station_Parameter.T_TorqueSystem_M.rActual_Torque;	(* Beckhoff Spindel ist aktiv *)
	END_CASE;
	IF ((rStFct_S2 - rStFct_S1) <> 0.0) THEN
		rStFct_CalcZSpeed:=	rStFct_V1 -
							((rStFct_V1 - rStFct_V2) * ((rStFct_M - rStFct_S1)/(rStFct_S2 - rStFct_S1)));
	END_IF;
	IF ptrTSensorTorque^.T_CtrleCyl.xStatePosOff THEN
		IF (((rStFct_CalcZSpeed / rStFct_V1) *100.0) >= 0) THEN
			ptrTAxisZ^.T_CtrleSingle.dwOverride:=REAL_TO_DWORD((rStFct_CalcZSpeed / rStFct_V1) *100.0);
		ELSE
			ptrTAxisZ^.T_CtrleSingle.dwOverride:=1;
		END_IF;
	ELSE
		ptrTAxisZ^.T_CtrleSingle.dwOverride:=100;
	END_IF;
	IF (ptrTAxisZ^.T_CtrleSingle.dwOverride > 100) THEN
		ptrTAxisZ^.T_CtrleSingle.dwOverride:=100;
	ELSIF (ptrTAxisZ^.T_CtrleSingle.dwOverride < 1) THEN
		ptrTAxisZ^.T_CtrleSingle.dwOverride:=1;
	END_IF;
	ptrTAxisZ^.T_CtrleSingle.dwOverride:=REAL_TO_DWORD((DWORD_TO_REAL(ptrTAxisZ^.T_CtrleSingle.dwOverride)/100.0) * BYTE_TO_REAL(T_ExchgParam.byOverride));	(* Einstellung der Geschwindigkeit über das Poti *)
	IF (ptrTAxisZ^.T_CtrleSingle.dwOverride > 100) THEN
		ptrTAxisZ^.T_CtrleSingle.dwOverride:=100;
	ELSIF (ptrTAxisZ^.T_CtrleSingle.dwOverride < 1) THEN
		ptrTAxisZ^.T_CtrleSingle.dwOverride:=1;
	END_IF;
END_IF;
END_ACTION

ACTION	StationFunction_Ctrl_Controller_2:
(* Geschwindigkeitsregelung der Z1 Achse mittels der Kraftmessdose--> Adaptive Vorschubssteuerung mit PID Regler für aufrecht erhaltene Drehmomentvorgabe *)
IF (iStFct_StepPrc = 3) THEN
	TONCalcTorque(IN:=TRUE,PT:=REAL_TO_TIME(INT_TO_REAL(T_Station_Parameter.T_StProcess.iZ_PID_FilterM)));
	diStepCount:=diStepCount + 1;
	rTorqueSpindleSensorSave:=rTorqueSpindleSensorSave + ptrTSensorTorque^.T_CtrleCyl.T_Analog.rPosIn;
	IF TONCalcTorque.Q THEN
		TONCalcTorque(IN:=FALSE);
		rTorqueSpindleSensor:=rTorqueSpindleSensorSave / DINT_TO_REAL(diStepCount);
		diStepCount:=0;
		rTorqueSpindleSensorSave:=0.0;
	END_IF;
	rOutMaxLimit:=(T_Station_Parameter.T_StProcess.rZ_PID_MaxSpeed/100.0) * BYTE_TO_REAL(T_ExchgParam.byOverride);	(* Einstellung der Geschwindigkeit über das Poti *)
	rOutMinLimit:=(T_Station_Parameter.T_StProcess.rZ_PID_MinSpeed/100.0) * BYTE_TO_REAL(T_ExchgParam.byOverride);		(* Einstellung der Geschwindigkeit über das Poti *)
	T_CtrlPara.rCtrlCycleTime:=0.001;
	T_CtrlPara.rKd:=T_Station_Parameter.T_StProcess.rZ_PID_Kd;
	T_CtrlPara.rKi:=T_Station_Parameter.T_StProcess.rZ_PID_Ki;
	T_CtrlPara.rKp:=T_Station_Parameter.T_StProcess.rZ_PID_Kp;
	T_CtrlPara.rOutMaxLimit:=rOutMaxLimit;
	T_CtrlPara.rOutMinLimit:=rOutMinLimit;
	FBPIDCTRL(	rSetpointValue:=T_Station_Parameter.T_StProcess.rZ_PID_Torque ,
						rActualValue:=rTorqueSpindleSensor ,
						T_CtrlPara:=T_CtrlPara);
	rStFct_CalcZSpeed:=FBPIDCTRL.rOut;
	T_Z_St1_Ctrle.diVelocityCommandValue:=LREAL_TO_DINT(rStFct_CalcZSpeed * -558349.25) ; (* 11166985 --> 20mm/s --> 1mm/s = 558349.25 *)
	RisingEdgeCountHC(CLK:=(ptrTAxisZ^.T_LiveValue.lrActualVelocity < 0));
	IF RisingEdgeCountHC.Q THEN
		wStFct_Status:=2;	(* 2 = < Wz Drehmom. HC> *)
		rStFct_SetZHCPosition:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
		xStFct_CapturePosition:=TRUE;	(* Berechnung der Schnittgeschwindigkeit *)
		IF (rStFct_TmpDiffOverLimitPosition <> 0) THEN
			T_Station_Work.THWWorkStation.TCtrlWork.rDiffOverLimitPosition:=ptrTAxisZ^.T_LiveValue.lrActualPosition - T_Station_Work.THWWorkStation.TCtrlWork.rLastOverLimitPosition;
		END_IF;
		T_Station_Work.THWWorkStation.TCtrlWork.rLastOverLimitPosition:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
		rStFct_TmpDiffOverLimitPosition:=T_Station_Work.THWWorkStation.TCtrlWork.rLastOverLimitPosition;
		T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterTorque:=T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterTorque + 1;
	END_IF;
ELSE
	diStepCount:=0;
	rTorqueSpindleSensorSave:=0.0;
	T_CtrlPara.xReset_I_Anteil:=TRUE;	(* Aufsummierter I-Anteil muss wieder zurückgesetzt werden, weil sonst dieser Wert mitgenommen wird *)
	FBPIDCTRL(	rSetpointValue:=T_Station_Parameter.T_StProcess.rZ_PID_Torque ,
				rActualValue:=rTorqueSpindleSensor ,
				T_CtrlPara:=T_CtrlPara);
	rTorqueSpindleSensor:=rTorqueSpindleSensorSave + ptrTSensorTorque^.T_CtrleCyl.T_Analog.rPosIn;
END_IF;
END_ACTION

ACTION	StationFunction_Ctrl_Controller_3:
(* Geschwindigkeitsregelung der Z1 Achse mittels der Kraftmessdose--> Konventioneller Regler mit D Anteil und schnellerer Reaktionszeit so wie beim PID *)
IF (iStFct_StepPrc = 3) THEN
	TONCalcTorque(IN:=TRUE,PT:=REAL_TO_TIME(INT_TO_REAL(T_Station_Parameter.T_StProcess.iZ_D_FilterM)));
	diStepCount:=diStepCount + 1;
	rTorqueSpindleSensorSave:=rTorqueSpindleSensorSave + ptrTSensorTorque^.T_CtrleCyl.T_Analog.rPosIn;
	IF TONCalcTorque.Q THEN
		TONCalcTorque(IN:=FALSE);
		rTorqueSpindleSensor:=rTorqueSpindleSensorSave / DINT_TO_REAL(diStepCount);
		diStepCount:=0;
		rTorqueSpindleSensorSave:=0.0;
	END_IF;
	IF (T_Station_Parameter.T_StProcess.iWorkControlType = 3) THEN
		(* Konventionelle Regelung mit D-Regler mit Override Funktion *)
		rStFct_V1:=	(T_Station_Parameter.T_OnlineChange.rWorkingSpeedForward/100.0) * BYTE_TO_REAL(T_ExchgParam.byOverride);	(* Einstellung der Geschwindigkeit über das Poti *)
		rStFct_V2:=	T_Station_Parameter.T_OnlineChange.rWorkingSpeedForward/100.0;
		rStFct_S1:=	0.5;
		rStFct_S2:=	T_Station_Parameter.T_OnlineChange.rTorqueLevelHC;
		CASE T_ExchgParam.bToolSpindleActive OF
		1:	(* Maxon Spindel *)
			rStFct_M:=	T_Station_Parameter.T_TorqueSystem.rActual_Torque;		(* Maxon Spindel ist aktiv *)
		2:	(* Beckhoff Spindel L *)
			rStFct_M:=	T_Station_Parameter.T_TorqueSystem_L.rActual_Torque;	(* Beckhoff Spindel ist aktiv *)
		3:	(* Beckhoff Spindel M *)
			rStFct_M:=	T_Station_Parameter.T_TorqueSystem_M.rActual_Torque;	(* Beckhoff Spindel ist aktiv *)
		END_CASE;
		T_CtrlPara_D.rCtrlCycleTime:=0.001;
		T_CtrlPara_D.rKd:=T_Station_Parameter.T_StProcess.rZ_D_Kd;
		T_CtrlPara_D.rOutMaxLimit:=rStFct_V1;
		T_CtrlPara_D.rOutMinLimit:=rStFct_V2;
		rActualValue:=(rStFct_V1/rStFct_S2)*rTorqueSpindleSensor;		(* Drehmoment skalieren auf die Geschwindigkeit *)
		FBDCONTROL(	rActualValue:= rActualValue,
								T_CtrlPara:= T_CtrlPara_D);				
		
		IF ((rStFct_S2 - rStFct_S1) <> 0.0) THEN
			rStFct_CalcZSpeed_D:=	rStFct_V1 -
								((rStFct_V1 - rStFct_V2) * ((rStFct_M - rStFct_S1)/(rStFct_S2 - rStFct_S1)));
		END_IF;
		rStFct_CalcZSpeed:=rStFct_CalcZSpeed_D - FBDCONTROL.rOut;
		IF (rStFct_CalcZSpeed <= rStFct_V2) THEN
			rStFct_CalcZSpeed:=rStFct_V2;
		END_IF
		IF (rStFct_CalcZSpeed >= rStFct_V1) THEN
			rStFct_CalcZSpeed:=rStFct_V1;
		END_IF
		T_Z_St1_Ctrle.diVelocityCommandValue:=LREAL_TO_DINT(rStFct_CalcZSpeed * -558349.25) ;
	END_IF;
ELSE
	diStepCount:=0;
	rTorqueSpindleSensorSave:=0.0;
	rTorqueSpindleSensor:=rTorqueSpindleSensorSave + ptrTSensorTorque^.T_CtrleCyl.T_Analog.rPosIn;
END_IF;
END_ACTION

ACTION	StationFunction_Ctrl_Controller_O:
(* Zweipunkte Regler der O Achse mittels der Kraftmessdose--> Hier wird nur ein oder ausgeschaltet der O Achse *)
IF ptrTAxisZ^.T_CtrleSingle.xMovingForward AND (T_Station_Parameter.T_StProcess.rO_Ctrl_HystereseOffset <> 0) AND (T_Station_Parameter.T_StProcess.rWorkingSpeedOscillation > 0.0) THEN
	IF ptrTSensorTorque^.T_CtrleCyl.xStatePosOff THEN
		IF (T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_Torque > T_Station_Parameter.T_StProcess.rO_Ctrl_TorquePercent_OFF) AND QxFastStrokeOn_St1 AND NOT(xBlockActivateOAxis) THEN
			QxFastStrokeOn_St1:=FALSE;		(* Schwellwert überschritten und deshalb muss ausgeschaltet werden *)
			xBlockActivateOAxis:=TRUE;
		ELSE
			IF (T_Station_Parameter.T_StProcess.rO_Ctrl_HystereseOffset > 0) THEN
				(* Hystere ist Positiv eingestellt und deshalb muss das Drehmoment um diesen Hysteresoffset steigen damit der Schnellhub wieder eingeschaltet wird *)
				IF (T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_Torque > (T_Station_Parameter.T_StProcess.rO_Ctrl_TorquePercent_OFF + T_Station_Parameter.T_StProcess.rO_Ctrl_HystereseOffset)) THEN
					QxFastStrokeOn_St1:=TRUE;		(* Schnellhub kann wieder eingeschaltet werden *)
				END_IF;
				IF (T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_Torque < T_Station_Parameter.T_StProcess.rO_Ctrl_TorquePercent_OFF) THEN
					(* Bei positiver Hysteres muss es zuerst wieder den Schwellwert unterschreiten bis es wider freigeben kann um es dann wieder zu deaktivierren *)
					xBlockActivateOAxis:=FALSE;
				END_IF;
			ELSE
				(* Hystere ist Negativ eingestellt und deshalb muss das Drehmoment um diesen Hysteresoffset sinken damit der Schnellhub wieder eingeschaltet wird *)
				IF (T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_Torque < (T_Station_Parameter.T_StProcess.rO_Ctrl_TorquePercent_OFF - ABS(T_Station_Parameter.T_StProcess.rO_Ctrl_HystereseOffset))) THEN
					QxFastStrokeOn_St1:=TRUE;		(* Schnellhub kann wieder eingeschaltet werden *)
					xBlockActivateOAxis:=FALSE;
				END_IF;
			END_IF;
		END_IF;
	END_IF;
ELSE
	xBlockActivateOAxis:=FALSE;
END_IF;



END_ACTION

ACTION	StationFunction_Ctrl_Controller_S:
(* Drehzahlregler der S Achse  mittels der Kraftmessdose--> Konventioneller Regler aber ohne Override da das Override nicht grösser werden darf als 100
   Den Min Max Wert kann man hier auch als Max definieren, d.h. bei ansteigendem Drehmoment wird die Drehzahl höher und deshalb funktioniert das Override nicht *)
IF ptrTAxisZ^.T_CtrleSingle.xMovingForward AND (T_Station_Parameter.T_StProcess.rWorkingSpindleSpeedMinMax <> 0.0) THEN
	(* Konventionelle Regelung aber ohne Override Funktion *)
	rStFct_V1:=	T_Station_Parameter.T_OnlineChange.rWorkingSpindleSpeed;
	rStFct_V2:=	T_Station_Parameter.T_StProcess.rWorkingSpindleSpeedMinMax;
	rStFct_S1:=	0.5;
	rStFct_S2:=	T_Station_Parameter.T_OnlineChange.rTorqueLevelHC;
	CASE T_ExchgParam.bToolSpindleActive OF
	1:	(* Maxon Spindel *)
		rStFct_M:=	T_Station_Parameter.T_TorqueSystem.rActual_Torque;		(* Maxon Spindel ist aktiv *)
	2:	(* Beckhoff Spindel L *)
		rStFct_M:=	T_Station_Parameter.T_TorqueSystem_L.rActual_Torque;	(* Beckhoff Spindel ist aktiv *)
	3:	(* Beckhoff Spindel M *)
		rStFct_M:=	T_Station_Parameter.T_TorqueSystem_M.rActual_Torque;	(* Beckhoff Spindel ist aktiv *)
	END_CASE;
	IF ((rStFct_S2 - rStFct_S1) <> 0.0) THEN
		rStFct_CalcZSpeed:=	rStFct_V1 -
							((rStFct_V1 - rStFct_V2) * ((rStFct_M - rStFct_S1)/(rStFct_S2 - rStFct_S1)));
	END_IF;
	IF (rStFct_CalcZSpeed > 0) THEN
		IF ptrTSensorTorque^.T_CtrleCyl.xStatePosOff THEN
			IF (ABS(lrSaveSSpeed - rStFct_CalcZSpeed) > 20) THEN	(* Geschwindigkeitsübergabe nur wenn Änderung grösser ist als 20min-1 *)
				IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND
				     NOT(ptrTAxisS^.T_CtrleSingle.xErr) AND NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) THEN
					xSetDefaultSpeedS:=FALSE;
					lrSaveSSpeed:=rStFct_CalcZSpeed;
					ptrTAxisS^.T_CtrleSingle.iFunction:=12;
					ptrTAxisS^.T_CtrleSingle.lrVelocity:=rStFct_CalcZSpeed;
					ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
		ELSE
			IF NOT(xSetDefaultSpeedS) THEN
				IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND
				     NOT(ptrTAxisS^.T_CtrleSingle.xErr) AND NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) THEN
					xSetDefaultSpeedS:=TRUE;
					ptrTAxisS^.T_CtrleSingle.iFunction:=12;
					ptrTAxisS^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_OnlineChange.rWorkingSpindleSpeed;
					ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
		END_IF;
	END_IF;
ELSE
	xSetDefaultSpeedS:=FALSE;
END_IF;


END_ACTION

ACTION	StationFunction_Ctrl_End:
IF xStFct_SetEnd THEN
	xStFct_End:=TRUE;
	xStFct_InitStep:=FALSE;
	xStFct_SetEnd:=FALSE;
	xStFct_Stop:=FALSE;
	xStFct_StartMainPrc:=FALSE;
	xStFct_InitMainCtr:=FALSE;
	xStFct_StartMainCtr:=FALSE;
	xStFct_Start:=FALSE;
	xStFct_HardwareError:=FALSE;
	xStFct_QuitErr:=FALSE;
	xStFct_Error:=FALSE;
	diStFct_ErrorNr:=0;
	xStFct_InitError:=FALSE;
	xStFct_Freeze:=FALSE;
	xStFct_Abord:=FALSE;
	xStFct_Reset:=FALSE;
	xStFct_StartPrc_Parallel:=FALSE;
	iStFct_StepPrc_Parallel:=1;
	xStFct_InitStep_Parallel:=FALSE;
	xStFct_ToolDeflectionActiveStopProcess:=FALSE;
	xStFct_ToolClampInactiveStopProcess:=FALSE;
	T_Station_Work.TCtrlOnlineChange.xLockChange_S_WorkSpindleSpeed:=TRUE;
	xStFct_DeflCalibError:=FALSE;
	xStFct_TorqueCalibError:=FALSE;
	xStFct_InitStopProcess:=FALSE;
	IF (iStationFunctionNr = 4) OR (iStationFunctionNr = 5) THEN
		T_Station_Work.THWWorkStation.TCtrlWork.xWorkingFinished:=FALSE;
	END_IF;
	IF xSecurityCircuitOn THEN
		T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolDeflectionForce:=FALSE;
		T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolTorqueLevel:=FALSE;
	END_IF;
	T_Station_Work.THWWorkStation.TCtrlWork.xSparkOutActive:=FALSE;
	gxWP_Analyse_ActiveWork:=FALSE;
	gxWP_Analyse_ActiveInfeed:=FALSE;
	gxWP_Analyse_ActiveCentering:=FALSE;
	IF xStFct_TmpSaveOffset THEN
		(* Im Fehlerfall oder die Funktion gestoppt wird muss der alte Wert wieder übergeben werden *)
		xStFct_TmpSaveOffset:=FALSE;
		IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolDeflection THEN
			T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=rStFct_TmpOffsetDeflection;
		END_IF;
		IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolTorque THEN
			T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]:=rStFct_TmpOffsetTorque;
		END_IF;
		IF xSafetyCircuitOn THEN
			(* Zylinder für Auslenkung-->mit Workauslenkkraft *)
			IF ptrTCylToolDeflection^.T_CtrleCyl.xDone THEN
				ptrTCylToolDeflection^.T_CtrleCyl.iFunction:=2;
				ptrTCylToolDeflection^.T_Config.tDelayOn:=T#0s;
				ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_OnlineChange.rForceDeflection;
				ptrTCylToolDeflection^.T_CtrleCyl.xExecute:=TRUE;
			END_IF;
		END_IF;
	END_IF;
	xBlockCheckLimitSwitch:=FALSE;
	xBlockSetFastVelZAxis:=FALSE;
	xProgressStrokeReady:=FALSE;
	xProgressStrokeRunning:=FALSE;
	iStepProgressStroke:=1;
END_IF;
END_ACTION

ACTION	StationFunction_Ctrl_Error:
xStFct_ErrorActuator:=	ptrTAxisZ^.T_CtrleSingle.xErr OR ptrTAxisS^.T_CtrleSingle.xErr;
xStFct_ExecuteActuator:=	NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisS^.T_CtrleSingle.xExecute);

IF (xStFct_HardwareError OR (xStFct_ErrorActuator AND xStartFunction)) AND NOT(xStFct_SetEnd) THEN
	IF xStFct_ExecuteActuator THEN
		IF NOT(xStFct_InitError) THEN
			T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedForward:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedBackward:=TRUE;
			iStFct_StepError:=1;
			xStFct_InitError:=TRUE;
			IF xStFct_HardwareError THEN
				diStFct_ErrorNr:=diStFct_TmpErrorNr;
			ELSE
				xStFct_HardwareError:=TRUE;	(* Hardware Error *)
			END_IF;
		END_IF;
		CASE iStFct_StepError OF
		(* Achsen/Zylinder Bewegungen müssen gestoppt werden *)
		1:	IF (iStationFunctionNr = 4) THEN
				T_Station_Work.THWWorkStation.TCtrlWork.bPartQuality:=8;	(* < Bearb. abgbr. > *)
			END_IF;
			IF (iStationFunctionNr = 5) THEN
				T_Station_Work.THWWorkStation.TCtrlWork.xWorkingFinished:=TRUE;
				T_Station_Work.THWWorkStation.TCtrlWork.bPartQuality:=8;	(* < Bearb. abgbr. > *)
			END_IF;
			IF (NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) OR NOT(ptrTAxisZ^.T_CtrleSingle.xDone)) AND
		    	   NOT((ptrTAxisZ^.T_CtrleSingle.iFunction = 5) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone)) AND NOT(ptrTAxisZ^.T_CtrleSingle.xErr) THEN
				ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF (NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) OR NOT(ptrTAxisS^.T_CtrleSingle.xDone)) AND
			     NOT((ptrTAxisS^.T_CtrleSingle.iFunction = 5) AND NOT(ptrTAxisS^.T_CtrleSingle.xDone)) AND NOT(ptrTAxisS^.T_CtrleSingle.xErr) THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=5;
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			iStFct_StepError:=iStFct_StepError + 1;
		2:	IF ((ptrTAxisZ^.T_CtrleSingle.xNotMoving AND (ptrTAxisZ^.T_CtrleSingle.xDone)) OR ptrTAxisZ^.T_CtrleSingle.xErr) THEN
				iStFct_StepError:=iStFct_StepError + 1;
			ELSE
				iStFct_StepError:=1;
			END_IF;
		3:	IF TRUE THEN
				iStFct_StepError:=iStFct_StepError + 1;
			END_IF;
		4:	IF TRUE THEN
				iStFct_StepError:=0;
				xStFct_Error:=TRUE;
				T_Station_Work.THWWorkStation.TCtrlWork.bPartQuality:=8;	(* < Bearb. abgbr. > *)
			END_IF;
		END_CASE;
		IF xStFct_QuitErr THEN
			xStFct_SetEnd:=TRUE;
		END_IF;
	END_IF;
END_IF;
(* Überwachung der Endschalter für die Z-Achse*)
xTmp:=	(ptrTAxisZ^.T_CtrleSingle.xStateHWLimitNeg OR ptrTAxisZ^.T_CtrleSingle.xStateHWLimitPos) OR
		 ptrTAxisZ^.T_CtrleSingle.xStateSWLimitNeg OR ptrTAxisZ^.T_CtrleSingle.xStateSWLimitPos;
IF xTmp AND xStFct_StartMainPrc AND NOT(xStFct_HardwareError) AND ((iStationFunctionNr = 2) OR (iStationFunctionNr = 4) OR (iStationFunctionNr = 5)) AND NOT(xBlockCheckLimitSwitch) THEN	(* Funktion 5-->Nur bei der Bearbeitung wird überprüft ob es auf dem Endschalter liegt *)
	xStFct_HardwareError:=TRUE;
	IF ptrTAxisZ^.T_CtrleSingle.xStateHWLimitNeg THEN
		diStFct_TmpErrorNr:=1;	(* Z Achse-->Negativer HW Endschalter Aktiv *)
	END_IF;
	IF ptrTAxisZ^.T_CtrleSingle.xStateHWLimitPos THEN
		diStFct_TmpErrorNr:=2;	(* Z Achse-->Positiver HW Endschalter Aktiv *)
	END_IF;
END_IF;
END_ACTION

ACTION	StationFunction_Ctrl_Main:
IF (xStFct_Start OR xStFct_StartMainCtr) AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) THEN
	IF NOT (xStFct_InitMainCtr) THEN
		iStFct_StepPrc:=1;
		xStFct_InitStep:=FALSE;
		xStFct_InitMainCtr:=TRUE;
		xStFct_StartMainCtr:=TRUE;
		xStFct_Start:=FALSE;
		xStFct_End:=FALSE;
		xStFct_Abord:=FALSE;
		wStFct_Status:=0;
		xStFct_TmpStop:=FALSE;
		xStFct_StartProcessTimer:=FALSE;
		xStFct_TmpStopProcess:=FALSE;
		iStFct_StopProcess:=1;
		xStFct_Overload_StopProcess:=FALSE;
		iStFct_Overload_StopProcess:=1;
		xStFct_TmpActiveFirstHC:=FALSE;
		IF (iStationFunctionNr = 5) THEN
			T_Station_Work.THWWorkStation.TCtrlWork.rLastOverLimitPosition:=0.0;
			T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounter:=0;
			T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterTorque:=0;
			T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterSpeed:=0;
			xStFct_ResetCalcCutSpeed:=TRUE;
			T_Station_Work.THWWorkStation.TCtrlWork.xDeflectionLastHC:=FALSE;
			T_Station_Work.THWWorkStation.TCtrlWork.xTorqueLastHC:=FALSE;
			T_Station_Work.THWWorkStation.TCtrlWork.rTorqueAfterHC_Min:=0.0;
			T_Station_Work.THWWorkStation.TCtrlWork.rTorqueAfterHC_Max:=0.0;
			T_Station_Work.THWWorkStation.TCtrlWork.iHCTorquePos:=0;
			T_Station_Work.THWWorkStation.TCtrlWork.iHCDeflectionPos:=0;
			T_Station_Work.THWWorkStation.TCtrlWork.xHCSparkOut:=FALSE;
			T_Station_Parameter.T_InfoProcess.rTorqueMaxAfterWork:=0.0;
			T_Station_Parameter.T_InfoProcess.rTorqueMaxAfterWorkZPos:=0.0;
			T_Station_Parameter.T_StProcess.rZPositionCylindricalAreaStop:=0.0;
			T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rZPositionCylindricalAreaStop:=0.0;
		END_IF;
		IF (iStationFunctionNr = 11) THEN
			T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterCentering:=0;
		ELSE
			IF NOT(gxCentringActive) AND NOT(gxOnlyCentringActive) THEN
				T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterCentering:=0;
			END_IF;
		END_IF;
		IF NOT(gxBlockSetQuality) THEN
			IF (iStationFunctionNr = 4) OR (iStationFunctionNr = 5) OR (iStationFunctionNr = 11) THEN
				T_Station_Work.THWWorkStation.TCtrlWork.bPartQuality:=7;	(* < in Bearbeitung > *)
			ELSE
				T_Station_Work.THWWorkStation.TCtrlWork.bPartQuality:=0;
				gxWP_Analyse_ResetCentCountValue:=TRUE;
			END_IF;
		END_IF;
		rStFct_ForceDeflection:=0.0;
		rStFct_ForceTorque:=0.0;
		iStFct_StepCollision:=1;
		xStFct_InitialCalcProcWork:=FALSE;
		rStFct_ZSavePosition:=0.0;
		rStFct_ZCalcDistance:=0.0;
		iStFct_StepZWorkSpeedRegulator:=1;
		diStFct_Counter:=0;
		rStFct_CalcWorkForce:=0.0;
		rStFct_AddWorkForce:=0.0;
		iStFct_StepMaxProcWork:=1;
		xStFct_ForceHC:=FALSE;
		iStFct_StepZWorkSpeedRegulator:=1;
		rStFct_CheckZSavePosition:=-999.0;
		iStFct_StepCheckToolBlock:=1;
		xStFct_HCActivated:=FALSE;
		iStFct_StepCheckTorque:=1;
		iStFct_DataInputNr:=1;
		iStFct_StepWPRotate:=1;
		xStFct_BlockWorking2:=FALSE;
		xStFct_WPRotated:=FALSE;
		iStFct_NumberWPRotate:=0;
		xStFct_ForceRotate:=FALSE;
		xSetSlowToFastSpeed:=FALSE;
		rStFct_SetZHCPosition:=0.0;
		xStFct_ResetSparkOutProcess:=TRUE;
		fbStFct_SparkOutProcess(	xStart:= xStFct_StartSparkOutProcess,
									xReset:= xStFct_ResetSparkOutProcess,
									TCylToolDeflection:=ptrTCylToolDeflection^,
									TAxisZ:= ptrTAxisZ^);
		xBlockCheckLimitSwitch:=FALSE;
		rTorqueSpindleSensor:=0.0;
		xBlockSetFastVelZAxis:=FALSE;
		xBlockActivateOAxis:=FALSE;
		xSetDefaultSpeedS:=FALSE;
		xProgressStrokeReady:=FALSE;
		xProgressStrokeRunning:=FALSE;
		iStepProgressStroke:=1;
	END_IF;
	IF xStFct_Stop AND NOT(xStFct_TmpStop) THEN
		xStFct_TmpStop:=TRUE;
		iStFct_TmpStopStep:=1;
		RETURN;
	END_IF;
	IF xStFct_Freeze THEN
		IF xStFct_Start AND NOT(xStFct_Abord) THEN
			xStFct_Freeze:=FALSE;
			xStFct_Start:=FALSE;
		END_IF;
		IF xStFct_Abord THEN
			xStFct_Abord:=FALSE;
			xStFct_Freeze:=FALSE;
			xStFct_Start:=FALSE;
			xStFct_SetEnd:=TRUE;
		END_IF;
		RETURN;
	END_IF;
	IF NOT(xStFct_StartMainPrc) AND NOT(xStFct_SetEnd) THEN
		xStFct_StartMainPrc:=TRUE;
	END_IF;
END_IF;
END_ACTION

ACTION	StationFunction_Ctrl_ProgressStrokeType1:
(* Disable progressive stroke behaviour *)
IF T_Station_Parameter.T_StProcess.iWorkControlType > 1
	OR T_Station_Parameter.T_StProcess.rDistProgressStroke < 1.0
	OR T_Station_Parameter.T_StProcess.iProgressStrokeStartTorque = 0 THEN
	xProgressStrokeReady:=FALSE;
	xProgressStrokeRunning:=FALSE;
	iStepProgressStroke:=1;
	RETURN;
END_IF

(* Progressive stroke only active in step 3 *)
IF (iStFct_StepPrc <> 3) THEN
	xProgressStrokeRunning:=FALSE;
	iStepProgressStroke:=1;
	RETURN;
END_IF

(* Enable entire progressive stroke function -> first return stroke *)
IF NOT(xProgressStrokeReady) AND ptrTAxisS^.T_LiveValue.diActualTorqueCalc > (T_Station_Parameter.T_StProcess.iProgressStrokeStartTorque*T_Station_Parameter.T_OnlineChange.rTorqueLevelHC) THEN
	xProgressStrokeReady:=TRUE;
	xProgressStrokeRunning:=TRUE;
	iStepProgressStroke:=1;
(* Process with special stroke function *)
ELSIF xProgressStrokeReady THEN
	(* Start new return stroke if current position in limits *)
	IF NOT(xProgressStrokeRunning)
		AND ptrTAxisZ^.T_LiveValue.lrActualPosition > (rStFct_ProgressStrokePosition + ABS(T_Station_Parameter.T_StProcess.rDistProgressStroke))
		AND ptrTAxisZ^.T_LiveValue.lrActualPosition < (garPositionEndProcCalc[1] - ABS(T_Station_Parameter.T_StProcess.rDistProgressStroke)/2.0) THEN
		xProgressStrokeRunning:=TRUE;
		iStepProgressStroke:=1;
	ELSIF xProgressStrokeRunning THEN
		CASE iStepProgressStroke OF
		1: 	(* Stop Z axis motion *)
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone) AND
		   		 NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) AND (ptrTAxisZ^.T_CtrleSingle.iFunction <> 12) THEN (* BEF: braucht es diese Konditionen??? was wenn FALSE? *)
				ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
				iStepProgressStroke:=iStepProgressStroke + 1;
			END_IF
		2: 	(* Waiting until Z axis stopped *)
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
				(* init. variable *)
				rStFct_ProgressStrokePosition:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
				(*xStFct_StartMainPrc:=FALSE;*) (* BEF: Wofür ist diese Variable gut???  *)
				xStFct_InitStep:=FALSE;
				iStepProgressStroke:=iStepProgressStroke + 1;
			END_IF;
		3:	(* Pull back Z axis, make sure to stay within the start and end position  *)
			IF NOT(xStFct_InitStep) THEN
				xStFct_InitStep:=TRUE;
				IF ((ptrTAxisZ^.T_LiveValue.lrActualPosition - ABS(T_Station_Parameter.T_StProcess.rCentringBackStrokeOffsetAfterFirstHC)) >= grZ_WorkStartPos) THEN
					ptrTAxisZ^.T_CtrleSingle.iFunction:=8;
					ptrTAxisZ^.T_CtrleSingle.lrDistance:=T_Station_Parameter.T_StProcess.rCentringBackStrokeOffsetAfterFirstHC;
					ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rCentringBackStrokeSpeed;
				ELSE
					ptrTAxisZ^.T_CtrleSingle.iFunction:=7;
					ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_WorkStartPos;
					ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rCentringBackStrokeSpeed;
				END_IF;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
				(*xStFct_StartMainPrc:=FALSE;*)
				xStFct_InitStep:=FALSE;
				iStepProgressStroke:=iStepProgressStroke + 1;
			END_IF;
		4: 	(* Move Z axis to last stroke position point with offset at fast speed *)
			IF NOT(xStFct_InitStep) THEN
				xStFct_InitStep:=TRUE;
				ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut mouvement *)
				ptrTAxisZ^.T_CtrleSingle.lrPosition:=rStFct_ProgressStrokePosition - ABS(T_Station_Parameter.T_StProcess.rCentringOffsetBeforeLastHC);	(* Z1 axis to last strok position minus den Offset *)
				ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rCentringPosSpeedFastZ1Axis;							(* With fast speed  *)
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
				(* Die Z Achse kann wieder weiterfahren im Langsamgang *)
				(*xStFct_StartMainPrc:=FALSE;*)
				xStFct_InitStep:=FALSE;
				iStepProgressStroke:=iStepProgressStroke+1;
			END_IF;
		5: 	(* Move Z axis to last saved stroke position at slow speed *)
			IF NOT(xStFct_InitStep) THEN
				xStFct_InitStep:=TRUE;
				ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut mouvement *)
				ptrTAxisZ^.T_CtrleSingle.lrPosition:=rStFct_ProgressStrokePosition;			(* Z1 axis to last stroke position  *)
				ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rCentringPosSpeedSlowZ1Axis;	(* With slow speed *)
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
				(*xStFct_StartMainPrc:=FALSE;*)
				xStFct_InitStep:=FALSE;
				iStepProgressStroke:=iStepProgressStroke + 1;
			END_IF;
		6: 	(* Start absolut movement of Z axis at working speed *)
			ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut mouvement *)
			IF NOT(gxProcessCylindricalAreaActive) THEN
				ptrTAxisZ^.T_CtrleSingle.lrPosition:=garPositionEndProcCalc[1];	(* AxisSlide auf EndPosition setzen *)
			ELSE
				(* Das ist der neue Ablauf wo man einen Zylindrische Position definieren kann und aber dieser Position wenn das Drehmoment einem definierten Schwellwert unterschritten wird, dann ist dies das Prozessende. Wird aber diese unten übergebene Position erreicht, dann wertet es als Fehler *)
				ptrTAxisZ^.T_CtrleSingle.lrPosition:=T_Station_Parameter.T_StProcess.rPositionEndProcMaxInc;
			END_IF;
			ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_OnlineChange.rWorkingSpeedForward;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			iStepProgressStroke:=10;
		10: 	(* Finish procress *)
			xProgressStrokeRunning:=FALSE;
			iStepProgressStroke:=1;
		END_CASE
	ELSE
		xProgressStrokeRunning:=FALSE;
		iStepProgressStroke:=1;
	END_IF
ELSE
	xProgressStrokeReady:=FALSE;
	xProgressStrokeRunning:=FALSE;
	iStepProgressStroke:=1;
END_IF;
END_ACTION

ACTION	StationFunction_Ctrl_Reset:
IF xStFct_Reset AND NOT(xStFct_SetEnd) THEN
	xStFct_End:=FALSE;
	xStFct_SetEnd:=TRUE;
END_IF;
END_ACTION

ACTION	StationFunction_Ctrl_Stop:
IF xStFct_TmpStop AND NOT(xStFct_SetEnd) THEN
	CASE iStFct_TmpStopStep OF
		1:	IF gxHardwareOFF OR gxAxisOFF THEN
				iStFct_TmpStopStep:=9;
				RETURN;
			END_IF;
			IF (NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) OR NOT(ptrTAxisZ^.T_CtrleSingle.xDone)) AND
			     NOT((ptrTAxisZ^.T_CtrleSingle.iFunction = 5) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone)) THEN
				ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF (iStationFunctionNr = 5) AND ((iStFct_StepPrc = 3) OR (iStFct_StepPrc = 40)) THEN
				IF (T_Station_Parameter.T_StProcess.iWorkControlType > 1) THEN
					T_Z_St1_Ctrle.diVelocityCommandValue:=0;
					gxZAxisVelocityCtrlActive:=TRUE;
					ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
					ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			IF (NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) OR NOT(ptrTAxisS^.T_CtrleSingle.xDone)) AND
			     NOT((ptrTAxisS^.T_CtrleSingle.iFunction = 5) AND NOT(ptrTAxisS^.T_CtrleSingle.xDone)) THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=5;
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			iStFct_TmpStopStep:=iStFct_TmpStopStep + 1;
			T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedForward:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedBackward:=TRUE;
			QxCoolant_St1:=FALSE;
			QxFastStrokeOn_St1:=FALSE;
		2:	IF ptrTAxisZ^.T_CtrleSingle.xNotMoving AND ptrTAxisS^.T_CtrleSingle.xNotMoving AND NOT(gxZAxisVelocityCtrlActive) THEN
				iStFct_TmpStopStep:=iStFct_TmpStopStep + 1;
			ELSE
				IF NOT(gxZAxisVelocityCtrlActive) THEN
					iStFct_TmpStopStep:=1;
				ELSE
					iStFct_TmpStopStep:=10;
				END_IF;
			END_IF;
		3:	IF TRUE THEN
				IF (iStationFunctionNr = 4) OR (iStationFunctionNr = 5) THEN
					iStFct_TmpStopStep:=iStFct_TmpStopStep + 1;
				ELSE
					iStFct_TmpStopStep:=iStFct_TmpStopStep + 6;
				END_IF;
			END_IF;
		4:	T_Station_Work.THWWorkStation.TCtrlWork.xWorkingFinished:=TRUE;
			IF (T_Station_Work.THWWorkStation.TCtrlWork.bPartQuality = 7) THEN
				T_Station_Work.THWWorkStation.TCtrlWork.bPartQuality:=8;	(* < Bearb. abgbr. > *)
			END_IF;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut Bewegung *)
			ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_LoadPos;	(* AxisSlide auf LadePosition setzen *)
			ptrTAxisZ^.T_CtrleSingle.lrVelocity:=rOutfeedStrokeAxisSpeed;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			(* Spindel mit Ausfahrgeschwindigkeit *)
			IF ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=6;	(* Move Velocity *)
			ELSE
				ptrTAxisS^.T_CtrleSingle.iFunction:=12;	(* Move Velocity *)
			END_IF;
			ptrTAxisS^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rOutfeedSpindleSpeed;
			ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			IF NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xNotMoving) THEN
				(* Abstreifer ZU *)
				QxCylStripperClose_St1:=TRUE;
				QxCylStripperOpen_St1:=FALSE;
			END_IF
			iStFct_TmpStopStep:=iStFct_TmpStopStep + 1;
		5:	IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone AND
			     NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone THEN
				iStFct_TmpStopStep:=iStFct_TmpStopStep + 1;
			END_IF;
		6:	IF TRUE THEN
				iStFct_TmpStopStep:=iStFct_TmpStopStep + 1;
			END_IF;
		7:	iStFct_TmpStopStep:=iStFct_TmpStopStep + 1;
		8:	IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
				iStFct_TmpStopStep:=iStFct_TmpStopStep + 1;
			END_IF;
		9:	IF TRUE THEN
				xStFct_TmpStop:=FALSE;
				iStFct_TmpStopStep:=1;
				xStFct_SetEnd:=TRUE;
				(* Abstreifer AUF *)
				QxCylStripperClose_St1:=FALSE;
				QxCylStripperOpen_St1:=TRUE;
				QxCylWPUnfix_St1:=FALSE;
				gxSuspensionONOFF:=FALSE;
			END_IF;
		10:	IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone AND ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
				gxZAxisVelocityCtrlActive:=FALSE;
				iStFct_TmpStopStep:=3;
			END_IF;
	END_CASE;
END_IF;
END_ACTION

ACTION	StationFunction_Ctrl_ToolSpindle:
IF NOT(xSafetyCircuitOn) THEN
	T_Station_Work.THWWorkStation.TCtrlWork.xWorkStartToolRotation:=FALSE;
	T_Station_Work.THWWorkStation.TCtrlWork.xWorkStopToolRotation:=FALSE;
END_IF;
IF T_Station_Work.THWWorkStation.TCtrlWork.xWorkStartToolRotation AND NOT(T_Station_Work.THWWorkStation.TCtrlWork.xWorkStopToolRotation) THEN
	CASE iStFct_StepStartToolSpindle OF
	1:	IF NOT(xStFct_InitStepStartToolSpindle) THEN
			IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisS^.T_CtrleSingle.xPower) AND ptrTAxisS^.T_CtrleSingle.xDone THEN
				xStFct_InitStepStartToolSpindle:=TRUE;
				ptrTAxisS^.T_CtrleSingle.iFunction:=3;	(* Strom einschalten *)
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND ptrTAxisS^.T_CtrleSingle.xPower THEN
			xStFct_InitStepStartToolSpindle:=FALSE;
			iStFct_StepStartToolSpindle:=iStFct_StepStartToolSpindle + 1;
		END_IF;
	2:	IF NOT(xStFct_InitStepStartToolSpindle) THEN
			xStFct_InitStepStartToolSpindle:=TRUE;
			(* Neu-->Hier wird die Spindel nicht mehr mittels der Einfädelgeschwindigkeit gestartet, sondern nur direkt über die Stationseinfädelfunktion *)
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone THEN
			xStFct_InitStepStartToolSpindle:=FALSE;
			iStFct_StepStartToolSpindle:=iStFct_StepStartToolSpindle + 1;
		END_IF;
	(* Abwarten bis Einfädeln Bearbeitungsfunktion gestartet hat *)
	3:	IF xStartFunction AND (iStationFunctionNr = 4) THEN
			xStFct_InitStepStartToolSpindle:=FALSE;
			iStFct_StepStartToolSpindle:=iStFct_StepStartToolSpindle + 1;
		END_IF;
	(* Abwarten bis Bearbeitungsfunktion beendet hat *)
	4:	IF NOT(xStartFunction) AND (iStationFunctionNr = 5) THEN
			xStFct_InitStepStartToolSpindle:=FALSE;
			iStFct_StepStartToolSpindle:=iStFct_StepStartToolSpindle + 1;	(* Neu-->Spindel wird gestoppt, und dann erst wieder gestartet direkt über die Stationseinfädelfunktion *)
		END_IF;
	5:	IF NOT(xStFct_InitStepStartToolSpindle) THEN
			IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) AND
			     ptrTAxisS^.T_CtrleSingle.xDone AND (ptrTAxisS^.T_CtrleSingle.iFunction <> 5) THEN
				xStFct_InitStepStartToolSpindle:=TRUE;
				ptrTAxisS^.T_CtrleSingle.iFunction:=5;	(* Rotation stoppen *)
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
			xStFct_InitStepStartToolSpindle:=FALSE;
			iStFct_StepStartToolSpindle:=1;
		ELSE
			xStFct_InitStepStartToolSpindle:=FALSE;
		END_IF;
	END_CASE;
ELSE
	iStFct_StepStartToolSpindle:=1;
	xStFct_InitStepStartToolSpindle:=FALSE;
END_IF;
IF T_Station_Work.THWWorkStation.TCtrlWork.xWorkStopToolRotation THEN
	T_Station_Work.THWWorkStation.TCtrlWork.xWorkStartToolRotation:=FALSE;
	CASE iStFct_StepStopToolSpindle OF
	1:	IF NOT(xStFct_InitStepStopToolSpindle) THEN
			IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) AND
			     ptrTAxisS^.T_CtrleSingle.xDone AND (ptrTAxisS^.T_CtrleSingle.iFunction <> 5) THEN
				xStFct_InitStepStopToolSpindle:=TRUE;
				ptrTAxisS^.T_CtrleSingle.iFunction:=5;	(* Rotation stoppen *)
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
			xStFct_InitStepStopToolSpindle:=FALSE;
			iStFct_StepStopToolSpindle:=iStFct_StepStopToolSpindle + 1;
		ELSE
			xStFct_InitStepStopToolSpindle:=FALSE;
		END_IF;
	2:	IF NOT(xStFct_InitStepStopToolSpindle) THEN
			IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xPower AND ptrTAxisS^.T_CtrleSingle.xDone THEN
				xStFct_InitStepStopToolSpindle:=TRUE;
				ptrTAxisS^.T_CtrleSingle.iFunction:=4;	(* Stromlos schalten *)
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND NOT(ptrTAxisS^.T_CtrleSingle.xPower) THEN
			xStFct_InitStepStopToolSpindle:=FALSE;
			iStFct_StepStopToolSpindle:=1;
			T_Station_Work.THWWorkStation.TCtrlWork.xWorkStopToolRotation:=FALSE;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) THEN
			xStFct_InitStepStopToolSpindle:=FALSE;
			iStFct_StepStopToolSpindle:=1;
		END_IF;
	END_CASE;
ELSE
	iStFct_StepStopToolSpindle:=1;
	xStFct_InitStepStopToolSpindle:=FALSE;
END_IF;
END_ACTION

ACTION	StationFunction_Fct_01_Referencing:
(******************************************************************************************************************************************)
(****************************				           Reset Stationsfunktion                                            *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Reset;
(******************************************************************************************************************************************)
(****************************			        Stationsfunktion Fehler Controller                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Error;
(******************************************************************************************************************************************)
(****************************				    Stationsfunktion Haupt Controller                               *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Main;
(******************************************************************************************************************************************)
(****************************			         Stationsfunktion sofort Unterbrechung                           *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Stop;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Hauptablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartMainPrc AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) AND NOT(xStFct_TmpStop) THEN
	CASE iStFct_StepPrc OF
	1:	xStFct_StartMainPrc:=FALSE;
		xStFct_InitStep:=FALSE;
		iStFct_StepPrc:=1;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Parallelablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartPrc_Parallel AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) THEN
	CASE iStFct_StepPrc_Parallel OF
	1:	iStFct_StepPrc_Parallel:=1;
		xStFct_InitStep_Parallel:=FALSE;
		xStFct_StartPrc_Parallel:=FALSE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				     Stationsfunktion Endprozedur                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_End;
END_ACTION

ACTION	StationFunction_Fct_02_InitialState:
(******************************************************************************************************************************************)
(****************************				           Reset Stationsfunktion                                            *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Reset;
(******************************************************************************************************************************************)
(****************************			        Stationsfunktion Fehler Controller                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Error;
(******************************************************************************************************************************************)
(****************************				    Stationsfunktion Haupt Controller                               *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Main;
(******************************************************************************************************************************************)
(****************************			         Stationsfunktion sofort Unterbrechung                           *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Stop;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Hauptablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartMainPrc AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) AND NOT(xStFct_TmpStop) THEN
(***************************************************************************************************************************************************)
	CASE iStFct_StepPrc OF
	1:	wStFct_Status:=0;
		xBlockCheckLimitSwitch:=TRUE;
		IF gxHardwareOFF OR gxAxisOFF THEN
			iStFct_StepPrc:=12;
			RETURN;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xRef) THEN	(* Z Achse muss referenziert sein *)
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=12;	(* Z Achse muss referenziert sein *)
			RETURN;
		END_IF;
		(* Überprüfe alle Positionen der Z Achse *)
		StationFunction_Ctrl_CheckPos_Z;
		IF xStFct_PositionOutRange_Z THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=iStFct_PosErrorNr;
			RETURN;
		END_IF;
		IF NOT(xStFct_InitStep) THEN
			(* Falls Z Achse sich bewegt, dann wird der Motor gestoppt *)
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) THEN
				xStFct_InitStep:=TRUE;
				ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone AND ptrTAxisZ^.T_CtrleSingle.xNotMoving THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	2:	IF NOT(xStFct_InitStep) THEN
			(* Falls Z Achse nicht bestromt ist, dann wird der Motorstrom eingeschaltet *)
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xPower) THEN
				xStFct_InitStep:=TRUE;
				ptrTAxisZ^.T_CtrleSingle.iFunction:=3;	(* Strom einschalten *)
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			QxCylStripperClose_St1:=FALSE;
			QxCylStripperOpen_St1:=TRUE;
			QxCylWPUnfix_St1:=FALSE;
			gxSuspensionONOFF:=FALSE;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone AND ptrTAxisZ^.T_CtrleSingle.xPower THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	3:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			(* Zylinder für Auslenkung-->mit Workauslenkkraft *)
			ptrTCylToolDeflection^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolDeflection^.T_Config.tDelayOn:=T#0.4s;
			ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_OnlineChange.rForceDeflection;
			ptrTCylToolDeflection^.T_CtrleCyl.xExecute:=TRUE;
			(* Zylinder für Drehmoment HC-->mit Schwellwert Startposition *)
			ptrTCylToolTorqueHC^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolTorqueHC^.T_Config.tDelayOn:=T#0.2s;
			ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_OnlineChange.rTorqueLevelHC;
			ptrTCylToolTorqueHC^.T_CtrleCyl.xExecute:=TRUE;
			(* Zylinder für Überlast Drehmoment *)
			ptrTCylToolTorqueOverload^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolTorqueOverload^.T_Config.tDelayOn:=T#0.2s;
			ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_StProcess.rTorqueLevel_Overload;
			ptrTCylToolTorqueOverload^.T_CtrleCyl.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTCylToolDeflection^.T_CtrleCyl.xExecute) AND ptrTCylToolDeflection^.T_CtrleCyl.xDone AND
		    NOT(ptrTCylToolTorqueHC^.T_CtrleCyl.xExecute) AND ptrTCylToolTorqueHC^.T_CtrleCyl.xDone AND
		    NOT(ptrTCylToolTorqueOverload^.T_CtrleCyl.xExecute) AND ptrTCylToolTorqueOverload^.T_CtrleCyl.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xStateHWLimitNeg) AND NOT(ptrTAxisZ^.T_CtrleSingle.xStateHWLimitPos) THEN
				iStFct_StepPrc:=iStFct_StepPrc + 4;
			ELSE
				IF ptrTAxisZ^.T_CtrleSingle.xStateHWLimitNeg AND ptrTAxisZ^.T_CtrleSingle.xStateHWLimitPos THEN
					xStFct_HardwareError:=TRUE;
					diStFct_TmpErrorNr:=3;	(* Z Achse-->Positiver + Negativer HW Endschalter Aktiv *)
					RETURN;
				ELSIF ptrTAxisZ^.T_CtrleSingle.xStateHWLimitNeg THEN
					iStFct_StepPrc:=iStFct_StepPrc + 1;
				ELSE
					iStFct_StepPrc:=iStFct_StepPrc + 2;
				END_IF;
			END_IF;
		END_IF;
	(* Wegfahren vom negativen Endschalters *)
	4:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=6;	(* Geschwindigkeits Bewegung *)
			ptrTAxisZ^.T_CtrleSingle.lrVelocity:=1.0;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xStateHWLimitNeg) THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 2;
		END_IF;
		IF ptrTAxisZ^.T_CtrleSingle.xStateHWLimitNeg AND ptrTAxisZ^.T_CtrleSingle.xStateHWLimitPos THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=3;	(* Z Achse-->Positiver + Negativer HW Endschalter Aktiv *)
		END_IF;
	(* Wegfahren vom positiven Endschalters *)
	5:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=6;	(* Geschwindigkeits Bewegung *)
			ptrTAxisZ^.T_CtrleSingle.lrVelocity:=-1.0;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xStateHWLimitPos) THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
		IF ptrTAxisZ^.T_CtrleSingle.xStateHWLimitNeg AND ptrTAxisZ^.T_CtrleSingle.xStateHWLimitPos THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=3;	(* Z Achse-->Positiver + Negativer HW Endschalter Aktiv *)
		END_IF;
	(* Stoppen der Bewegung *)
	6:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	(* Aktuatoren in Ausgangslage bringen *)
	7:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			xBlockCheckLimitSwitch:=FALSE;
		END_IF;
		IF TRUE THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	8:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			IF (ptrTAxisZ^.T_LiveValue.lrActualPosition > grZ_LoadPos) THEN
				ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut Bewegung *)
				ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_LoadPos;	(* AxisSlide auf LadePosition setzen *)
				ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rOutfeedStrokeAxisSpeed;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	(* Aktuatoren in Ausgangslage bringen *)
	9:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	(* Aktuatoren in Ausgangslage bringen *)
	10:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	11:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	12:	xStFct_StartMainPrc:=FALSE;
		xStFct_InitStep:=FALSE;
		iStFct_StepPrc:=0;
		xStFct_SetEnd:=TRUE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Parallelablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartPrc_Parallel AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) THEN
	CASE iStFct_StepPrc_Parallel OF
	1:	iStFct_StepPrc_Parallel:=1;
		xStFct_InitStep_Parallel:=FALSE;
		xStFct_StartPrc_Parallel:=FALSE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				     Stationsfunktion Endprozedur                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_End;
END_ACTION

ACTION	StationFunction_Fct_03_ToolRotationON:
;(******************************************************************************************************************************************)
(****************************				           Reset Stationsfunktion                                            *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Reset;
(******************************************************************************************************************************************)
(****************************			        Stationsfunktion Fehler Controller                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Error;
(******************************************************************************************************************************************)
(****************************				    Stationsfunktion Haupt Controller                               *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Main;
(******************************************************************************************************************************************)
(****************************			         Stationsfunktion sofort Unterbrechung                           *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Stop;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Hauptablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartMainPrc AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) AND NOT(xStFct_TmpStop) THEN
	IF T_Station_Work.THWWorkStation.TCtrlWork.xWorkStopToolRotation THEN
		xStFct_StartMainPrc:=FALSE;
		xStFct_InitStep:=FALSE;
		iStFct_StepPrc:=0;
		xStFct_SetEnd:=TRUE;
	END_IF;
	CASE iStFct_StepPrc OF
	1:	IF NOT(xStFct_InitStep) THEN
			(* Falls die Spindel nicht bestromt ist, dann wird der Motorstrom eingeschaltet *)
			IF NOT(ptrTAxisS^.T_CtrleSingle.xPower) THEN
				xStFct_InitStep:=TRUE;
				ptrTAxisS^.T_CtrleSingle.iFunction:=3;	(* Strom einschalten *)
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND ptrTAxisS^.T_CtrleSingle.xPower THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	2:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			(* Zylinder für Auslenkung-->mit Workauslenkkraft *)
			ptrTCylToolDeflection^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolDeflection^.T_Config.tDelayOn:=T#0.3s;
			ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_OnlineChange.rForceDeflection;
			ptrTCylToolDeflection^.T_CtrleCyl.xExecute:=TRUE;
			(* Zylinder für Drehmoment HC-->mit Schwellwert Startposition *)
			ptrTCylToolTorqueHC^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolTorqueHC^.T_Config.tDelayOn:=T#0.2s;
			ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_OnlineChange.rTorqueLevelHC;
			ptrTCylToolTorqueHC^.T_CtrleCyl.xExecute:=TRUE;
			(* Zylinder für Überlast Drehmoment *)
			ptrTCylToolTorqueOverload^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolTorqueOverload^.T_Config.tDelayOn:=T#0.2s;
			ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_StProcess.rTorqueLevel_Overload;
			ptrTCylToolTorqueOverload^.T_CtrleCyl.xExecute:=TRUE;
			IF ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=6;	(* Move Velocity *)
			ELSE
				ptrTAxisS^.T_CtrleSingle.iFunction:=12;	(* Move Velocity with new velocity *)
			END_IF;
			ptrTAxisS^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_OnlineChange.rWorkingSpindleSpeed;
			ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTCylToolDeflection^.T_CtrleCyl.xExecute) AND ptrTCylToolDeflection^.T_CtrleCyl.xDone AND
		     NOT(ptrTCylToolTorqueHC^.T_CtrleCyl.xExecute) AND ptrTCylToolTorqueHC^.T_CtrleCyl.xDone AND
		     NOT(ptrTCylToolTorqueOverload^.T_CtrleCyl.xExecute) AND ptrTCylToolTorqueOverload^.T_CtrleCyl.xDone AND
		     NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) AND
		     ptrTAxisS^.T_CtrleSingle.xConstantVel THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=0;
			xStFct_SetEnd:=TRUE;
		END_IF;
		IF NOT(ptrTCylToolDeflection^.T_CtrleCyl.xExecute) AND ptrTCylToolDeflection^.T_CtrleCyl.xDone AND
		     NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=1;
		END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Parallelablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartPrc_Parallel AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) THEN
	CASE iStFct_StepPrc_Parallel OF
	1:	iStFct_StepPrc_Parallel:=1;
		xStFct_InitStep_Parallel:=FALSE;
		xStFct_StartPrc_Parallel:=FALSE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				     Stationsfunktion Endprozedur                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_End;
END_ACTION

ACTION	StationFunction_Fct_04_InfeedWorking:
(******************************************************************************************************************************************)
(****************************				           Reset Stationsfunktion                                            *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Reset;
(******************************************************************************************************************************************)
(****************************			        Stationsfunktion Fehler Controller                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Error;
(******************************************************************************************************************************************)
(****************************				    Stationsfunktion Haupt Controller                               *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Main;
(******************************************************************************************************************************************)
(****************************			         Stationsfunktion sofort Unterbrechung                           *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Stop;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Hauptablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartMainPrc AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) AND NOT(xStFct_TmpStop) THEN
(***************************************************************************************************************************************************)
(* Überwachung Drehmoment Überlast *)
	StationFunction_CheckOverload;
	IF xStFct_Overload_StopProcess THEN
		RETURN;
	END_IF;
(***************************************************************************************************************************************************)
(* Überwachung auf die Axiale Auslenkung *)
	IF xStFct_ToolDeflectionActiv THEN
		IF NOT(ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn) THEN
			xStFct_ToolDeflectionActiv:=FALSE;
			xStFct_InitAxialSensor:=FALSE;
			xStFct_CheckAxialSensor:=FALSE;
		END_IF;
	END_IF;
	IF (ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn OR xStFct_CheckAxialSensor) AND NOT(xStFct_ToolDeflectionActiv) THEN
		IF NOT(xStFct_InitAxialSensor) THEN
			xStFct_InitAxialSensor:=TRUE;
			xStFct_CheckAxialSensor:=TRUE;
			lrStFct_ActualPosition:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
		END_IF;
		IF NOT(ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn) THEN
			xStFct_InitAxialSensor:=FALSE;
			xStFct_CheckAxialSensor:=FALSE;
			xStFct_ToolDeflectionActiv:=FALSE;
		END_IF;
		IF (ABS(ptrTAxisZ^.T_LiveValue.lrActualPosition - lrStFct_ActualPosition) >= T_Station_Parameter.T_StProcess.rDeflectionSensorOffset) AND ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn THEN
			xStFct_ToolDeflectionActiv:=TRUE;
		END_IF;
	END_IF;
(***************************************************************************************************************************************************)
(* Hauptablauf für die Bearbeitung *)
	CASE iStFct_StepPrc OF
	1:	(* Überprüfmechanismen die bestehen müssen, damit diese Funktion gestartet werden kann *)
		IF gxHardwareOFF OR gxAxisOFF THEN
			iStFct_StepPrc:=9;
			xStFct_InitStep:=FALSE;
			RETURN;
		END_IF;
		gxWP_Analyse_ActiveInfeed:=TRUE;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xRef) THEN	(* Z Achse muss referenziert sein *)
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=9;	(* Z Achse muss referenziert sein *)
			RETURN;
		END_IF;
		(* Überprüfe alle Positionen der Z Achse *)
		StationFunction_Ctrl_CheckPos_Z;
		IF xStFct_PositionOutRange_Z THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=iStFct_PosErrorNr;
			RETURN;
		END_IF;
		IF (garPositionEndProcCalc[1] > T_Station_Parameter.T_StProcess.rPositionEndMech) THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=12;		(* Hubprozesslänge > Z Mech EndPos *)
			RETURN;
		END_IF;
		IF (garCentringEndProcCalc[1] > T_Station_Parameter.T_StProcess.rPositionEndMech) THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=18;		(* Zentrier EndPos > Z Mech EndPos *)
			RETURN;
		END_IF;
		IF (T_Station_Parameter.T_StProcess.iSparkOutStrokeCount <> 0) AND
		     ((T_Station_Parameter.T_StProcess.rSparkOutStrokeLength + garPositionEndProcCalc[1]) > T_Station_Parameter.T_StProcess.rPositionEndMech) THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=13;		(* Ausfunkhub > Z Mech EndPos *)
			RETURN;
		END_IF;
		IF ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=25;		(* Beim starten der Bearbeitung darf AuslenkSensor nicht ON sein *)
			RETURN;
		END_IF;
		IF ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn OR ptrTSensorTorque^.T_CtrleCyl.xStatePosOn THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=26;		(* Beim starten der Bearbeitung darf DrehmSensorHC nicht ON sein *)
			RETURN;
		END_IF;
		IF ptrTCylToolTorqueOverload^.T_CtrleCyl.xStatePosOn OR ptrTSensorTorqueOverload^.T_CtrleCyl.xStatePosOn THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=11;		(* Beim starten der Bearbeitung darf DrehmSensorHCÜberlast nicht ON sein *)
			RETURN;
		END_IF;
		iStFct_TmpHCStartPosCounter:=0;
		iStFct_TmpNumberTryInfeed:=0;
		iStFct_StepPrc:=iStFct_StepPrc + 1;
	2:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolDeflectionForce:=TRUE;
			IF NOT(ptrTAxisS^.T_CtrleSingle.xPower) THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=3;	(* Strom einschalten *)
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			(* Zylinder für Auslenkung-->mit Einfädelkraft *)
			ptrTCylToolDeflection^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolDeflection^.T_Config.tDelayOn:=T#0.3s;
			ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_StProcess.rInfeedForceDeflection;
			ptrTCylToolDeflection^.T_CtrleCyl.xExecute:=TRUE;
			(* Zylinder für Drehmoment HC-->mit Schwellwert Startposition *)
			ptrTCylToolTorqueHC^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolTorqueHC^.T_Config.tDelayOn:=T#0.2s;
			ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_OnlineChange.rTorqueLevelHC;
			ptrTCylToolTorqueHC^.T_CtrleCyl.xExecute:=TRUE;
			(* Zylinder für Überlast Drehmoment *)
			ptrTCylToolTorqueOverload^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolTorqueOverload^.T_Config.tDelayOn:=T#0.2s;
			ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_StProcess.rTorqueLevel_Overload;
			ptrTCylToolTorqueOverload^.T_CtrleCyl.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND ptrTAxisS^.T_CtrleSingle.xPower AND
		     NOT(ptrTCylToolDeflection^.T_CtrleCyl.xExecute) AND ptrTCylToolDeflection^.T_CtrleCyl.xDone AND
		     NOT(ptrTCylToolTorqueHC^.T_CtrleCyl.xExecute) AND ptrTCylToolTorqueHC^.T_CtrleCyl.xDone AND
		     NOT(ptrTCylToolTorqueOverload^.T_CtrleCyl.xExecute) AND ptrTCylToolTorqueOverload^.T_CtrleCyl.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	(* Einfädelgeschwindigkeit setzen *)
	3:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut Bewegung *)
			ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_WorkStartPos;	(* Z auf StartPosition setzen *)
			ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rInfeedZAxisSpeed;	(* Mit Einfädelgeschwindigkeit *)
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			(* Spindel mit Einfädelgeschwindigkeit *)
			IF ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=6;	(* Move Velocity *)
			ELSE
				ptrTAxisS^.T_CtrleSingle.iFunction:=12;	(* Move Velocity *)
			END_IF;
			ptrTAxisS^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rInfeedSpindleSpeed;
			ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF TRUE THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	(* Überwachung ob Auslenkung während dem Einfädeln eintrifft *)
	4:	IF xStFct_ToolDeflectionActiv AND NOT(xStFct_StopSlide) THEN
			xStFct_StopSlide:=TRUE;
			wStFct_Status:=1;	(* 1 = < Wz Auslenk. Sensor > *)
			IF xProcessDone THEN
				T_Station_Work.THWWorkStation.TCtrlWork.bPartQuality:=5;	(* < niO kein Einf. > *)
			END_IF;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			(* Wz konnte erfolgreich eingefädelt werden *)
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=7;
			RETURN;
		END_IF;
		IF xStFct_StopSlide AND NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone) AND
		    NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) AND (ptrTAxisZ^.T_CtrleSingle.iFunction <> 12) THEN
			ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			(* init. variable *)
			xStFct_StopSlide:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
			xStFct_InitStep:=FALSE;
		END_IF;
	5:	(* Abwarten bis die HubAchse stillsteht *)
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	6:	(* Z Achse um einen Offset zurücksetzen *)
		IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			IF ((ptrTAxisZ^.T_LiveValue.lrActualPosition - ABS(T_Station_Parameter.T_StProcess.rInfeedOffsetBackward)) >= grZ_LoadPos) AND NOT(T_Station_Work.THWWorkStation.TCtrlWork.xLastTryInfeed) THEN
				ptrTAxisZ^.T_CtrleSingle.iFunction:=8;
				ptrTAxisZ^.T_CtrleSingle.lrDistance:=T_Station_Parameter.T_StProcess.rInfeedOffsetBackward;
				ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rOutfeedStrokeAxisSpeed;
			ELSE
				ptrTAxisZ^.T_CtrleSingle.iFunction:=7;
				ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_LoadPos;
				ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rOutfeedStrokeAxisSpeed;
			END_IF;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			(* Wz konnte nicht eingefädelt werden *)
			wStFct_Status:=99;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 2;
			T_Station_Work.THWWorkStation.TCtrlWork.xLastTryInfeed:=FALSE;
		END_IF;
	7:	xStFct_StartMainPrc:=FALSE;
		xStFct_InitStep:=FALSE;
		(* Bearbeitungsstation steht nun Bereit um mit der Bearbeitung zu starten *)
		wStFct_Status:=0;
		T_Station_Work.THWWorkStation.TCtrlWork.xToolInfeeded:=TRUE;
		iStFct_StepPrc:=iStFct_StepPrc + 1;
		IF xProcessDone THEN
			T_Station_Work.THWWorkStation.TCtrlWork.bPartQuality:=2;	(* < Go No HC > *)
		END_IF;
	8:	xStFct_StartMainPrc:=FALSE;
		xStFct_InitStep:=FALSE;
		iStFct_StepPrc:=0;
		xStFct_SetEnd:=TRUE;
		T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolDeflectionForce:=FALSE;
		IF xProcessDone THEN
			IF (NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) OR NOT(ptrTAxisS^.T_CtrleSingle.xDone))
			AND NOT((ptrTAxisS^.T_CtrleSingle.iFunction = 5) AND NOT(ptrTAxisS^.T_CtrleSingle.xDone)) AND NOT(ptrTAxisS^.T_CtrleSingle.xErr) THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=5;
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
	(* Gilt nur für falls HW ausgeschaltet ist *)
	9:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			TONWorkTime(IN:=FALSE);
		END_IF;
		TONWorkTime(IN:=TRUE,PT:=T#2.0s);
		IF TONWorkTime.Q THEN
			TONWorkTime(IN:=FALSE);
			T_Station_Work.THWWorkStation.TCtrlWork.xToolInfeeded:=TRUE;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=0;
			xStFct_SetEnd:=TRUE;
			wStFct_Status:=0;
		END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Parallelablauf                                       *****************************)
(******************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				     Stationsfunktion Endprozedur                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_End;
END_ACTION

ACTION	StationFunction_Fct_05_Working:
(******************************************************************************************************************************************)
(****************************				           Reset Stationsfunktion                                            *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Reset;
(******************************************************************************************************************************************)
(****************************			        Stationsfunktion Fehler Controller                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Error;
(******************************************************************************************************************************************)
(****************************				    Stationsfunktion Haupt Controller                               *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Main;
(******************************************************************************************************************************************)
(****************************			         Stationsfunktion sofort Unterbrechung                           *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Stop;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Hauptablauf                                       *****************************)
(******************************************************************************************************************************************)
IF ((iStFct_StepPrc <> 3) AND (iStFct_StepPrc <> 51)) OR (T_Station_Parameter.T_StProcess.iWorkControlType <= 1) OR xStFct_TmpStop THEN
	T_Z_St1_Ctrle.diVelocityCommandValue:=(T_Z_St1_Ctrle.nOutData2[1] * 65536) + T_Z_St1_Ctrle.nOutData2[0];
END_IF;
(* Überwachung für langsame oder schnelle Geschwindigkeit für das zurückfahren nach dem Prozessende *)
IF (ptrTAxisZ^.T_LiveValue.lrActualPosition > T_Station_Parameter.T_StProcess.rZ1AxisPosSwitchFastVel) AND (T_Station_Parameter.T_StProcess.rZ1AxisPosSwitchFastVel <> 0.0) THEN
	(* Langsame Geschwindigkeit ist aktiviert für das zurückfahren nach dem Prozessende *)
	rOutfeedStrokeAxisSpeed:=T_Station_Parameter.T_StProcess.rOutfeedStrokeAxisSpeedSlow;
ELSE
	rOutfeedStrokeAxisSpeed:=T_Station_Parameter.T_StProcess.rOutfeedStrokeAxisSpeed;
	IF (T_Station_Parameter.T_StProcess.rZ1AxisPosSwitchFastVel <> 0.0) AND NOT(xBlockSetFastVelZAxis) THEN
		IF (ptrTAxisZ^.T_CtrleSingle.lrPosition = grZ_LoadPos) THEN
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone) AND NOT(ptrTAxisZ^.T_CtrleSingle.xErr) THEN
				ptrTAxisZ^.T_CtrleSingle.lrVelocity:=rOutfeedStrokeAxisSpeed;
				ptrTAxisZ^.T_CtrleSingle.iFunction:=12;	(* Z Achse kann nun fliegend auf die schnelle Geschwindigkeit umgestellt werden *)
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
				xBlockSetFastVelZAxis:=TRUE;
			END_IF;
		END_IF;
	END_IF;
END_IF;
IF T_Station_Work.THWWorkStation.TCtrlWork.xWorkingFinished AND xStFct_StartMainPrc THEN
	(* Aufzeichnung des max Drehmomentes für wenn die Bearbeitung beendet hat und die Achse zurückfährt *)
	IF (rActTorque >= T_Station_Parameter.T_InfoProcess.rTorqueMaxAfterWork) AND (rActTorque <> 0.0) AND (ptrTAxisZ^.T_LiveValue.lrActualPosition <= lrStartRecordMaxTorque) THEN
		T_Station_Parameter.T_InfoProcess.rTorqueMaxAfterWork:=rActTorque;
		T_Station_Parameter.T_InfoProcess.rTorqueMaxAfterWorkZPos:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
	END_IF;
ELSE
	lrStartRecordMaxTorque:=ptrTAxisZ^.T_LiveValue.lrActualPosition + T_Station_Parameter.T_StProcess.rZ1AxisOffsetStartRecordTorque;
END_IF;
IF xStFct_StartMainPrc AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) AND NOT(xStFct_TmpStop) THEN
	IF T_Station_Work.THWWorkStation.TCtrlWork.xWorkingFinished THEN
		gxWP_Analyse_ActiveWork:=FALSE;
		gxWP_Analyse_ActiveInfeed:=FALSE;
	END_IF;
(***************************************************************************************************************************************************)
(* Abhandlung von Progressivhub  *)
IF (T_Station_Parameter.T_StProcess.iWorkControlType <= 1) THEN
	StationFunction_Ctrl_ProgressStrokeType1;
END_IF;
(***************************************************************************************************************************************************)
(* Abhandlung der Reinigungsduese *)
	StationFunction_Ctrl_CleanNozzle;
(***************************************************************************************************************************************************)
(* Berechnung der Bearbeitungsarbeit *)
	StationFunction_Ctrl_CalcProcWork;
(***************************************************************************************************************************************************)
(* Regler für die Bearbeitung *)
IF (T_Station_Parameter.T_StProcess.iWorkControlType <= 1) THEN
	StationFunction_Ctrl_Controller_1;
ELSIF (T_Station_Parameter.T_StProcess.iWorkControlType = 2) THEN
	StationFunction_Ctrl_Controller_2;
ELSE
	StationFunction_Ctrl_Controller_3;
END_IF;
StationFunction_Ctrl_Controller_S;
StationFunction_Ctrl_Controller_O;
(***************************************************************************************************************************************************)
(* Berechnung der Schnittgeschwindigkeit *)
	fbStFct_CalcCuttingSpeed(	rActualPosition:=ptrTAxisZ^.T_LiveValue.lrActualPosition,
								iCountStep:=10,
								xCapturePosition:=xStFct_CapturePosition,
								xReset:=xStFct_ResetCalcCutSpeed);
	T_Station_Work.THWWorkStation.TCtrlWork.rCuttingSpeed:=fbStFct_CalcCuttingSpeed.rCuttingSpeed;
(***************************************************************************************************************************************************)
(* Auffangen des ersten HC *)
	IF NOT(xStFct_TmpActiveFirstHC) THEN
		IF (iStFct_StepPrc = 1) THEN
			T_Station_Work.THWWorkStation.TCtrlWork.rLastFirstContactPosition:=T_Station_Work.THWWorkStation.TCtrlWork.rActualFirstContactPosition;
		END_IF;
		T_Station_Work.THWWorkStation.TCtrlWork.rActualFirstContactPosition:=0.0;
		IF (T_Station_Work.THWWorkStation.TCtrlWork.rLastOverLimitPosition <> 0.0) THEN
			xStFct_TmpActiveFirstHC:=TRUE;
			T_Station_Work.THWWorkStation.TCtrlWork.rActualFirstContactPosition:=T_Station_Work.THWWorkStation.TCtrlWork.rLastOverLimitPosition;
			T_Station_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ReadyToReadData:=TRUE;
		END_IF;
	END_IF;
(***************************************************************************************************************************************************)
(* Überwachung der minimalen Prozesszeit *)
	fbStFct_TONProcessMinTime(IN:=xStFct_StartProcessTimer,PT:=REAL_TO_TIME(T_Station_Parameter.T_StProcess.rProcessMinTime * 1000.0));
	IF fbStFct_TONProcessMinTime.Q THEN
		xStFct_MinTimeProcessReady:=TRUE;
	ELSE
		xStFct_MinTimeProcessReady:=FALSE;
	END_IF;
(***************************************************************************************************************************************************)
(* Überwachung Drehmoment Überlast *)
	StationFunction_CheckOverload;
	IF xStFct_Overload_StopProcess THEN
		RETURN;
	END_IF;
(***************************************************************************************************************************************************)
(* Überwachung der maximalen Prozesszeit *)
	fbStFct_TONProcessMaxTime(IN:=xStFct_StartProcessTimer,PT:=REAL_TO_TIME(T_Station_Parameter.T_StProcess.rProcessMaxTime * 1000.0));
	IF fbStFct_TONProcessMaxTime.Q AND NOT(xStFct_TmpStopProcess) THEN
		xStFct_TmpStopProcess:=TRUE;
	END_IF;
	IF xStFct_TmpStopProcess THEN
		IF NOT(xStFct_InitStopProcess) THEN
			IF ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn OR ptrTSensorTorque^.T_CtrleCyl.xStatePosOn OR xStFct_ToolDeflectionActiv THEN
				xStFct_InitStopProcess:=TRUE;
				iStFct_StopProcess:=1;
			END_IF;
		END_IF;
		IF xStFct_InitStopProcess THEN
			T_Station_Work.THWWorkStation.TCtrlWork.bPartQuality:=4;	(* < niO max Zeit > *)
			T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedForward:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedBackward:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChange_S_WorkSpindleSpeed:=TRUE;
			CASE iStFct_StopProcess OF
				1:	IF (T_Station_Parameter.T_StProcess.iWorkControlType <= 1) THEN
						IF (NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) OR NOT(ptrTAxisZ^.T_CtrleSingle.xDone)) AND
				     		    NOT((ptrTAxisZ^.T_CtrleSingle.iFunction = 5) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone)) THEN
							ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
							ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
							iStFct_StopProcess:=iStFct_StopProcess + 1;
						ELSE
							iStFct_StopProcess:=iStFct_StopProcess + 1;
						END_IF;
					ELSE
						T_Z_St1_Ctrle.diVelocityCommandValue:=0;
						gxZAxisVelocityCtrlActive:=TRUE;
						ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
						ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
						iStFct_StopProcess:=iStFct_StopProcess + 1;
					END_IF;
				2:	IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone AND NOT(gxZAxisVelocityCtrlActive) THEN
						T_Station_Work.THWWorkStation.TCtrlWork.xWorkingFinished:=TRUE;
						ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut Bewegung *)
						ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_LoadPos;	(* AxisSlide auf BearbStartPosition setzen *)
						ptrTAxisZ^.T_CtrleSingle.lrVelocity:=rOutfeedStrokeAxisSpeed;
						ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
						(* Spindel mit Ausfahrgeschwindigkeit *)
						IF ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
							ptrTAxisS^.T_CtrleSingle.iFunction:=6;	(* Move Velocity *)
						ELSE
							ptrTAxisS^.T_CtrleSingle.iFunction:=12;	(* Move Velocity *)
						END_IF;
						ptrTAxisS^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rOutfeedSpindleSpeed;
						ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
						iStFct_StopProcess:=iStFct_StopProcess + 1;
					ELSE
						IF NOT(gxZAxisVelocityCtrlActive) THEN
							iStFct_StopProcess:=1;
						ELSE
							iStFct_StopProcess:=5;
						END_IF;
					END_IF;
				3:	IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone AND
		     			     NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone THEN
						ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut Bewegung *)
						ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_LoadPos;	(* AxisSlide auf LadePosition setzen *)
						ptrTAxisZ^.T_CtrleSingle.lrVelocity:=rOutfeedStrokeAxisSpeed;
						ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
						iStFct_StopProcess:=iStFct_StopProcess + 1;
					END_IF;
				4:	IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
						xStFct_SetEnd:=TRUE;
						IF xProcessDone THEN
							IF (NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) OR NOT(ptrTAxisS^.T_CtrleSingle.xDone)) AND
							     NOT((ptrTAxisS^.T_CtrleSingle.iFunction = 5) AND NOT(ptrTAxisS^.T_CtrleSingle.xDone)) AND NOT(ptrTAxisS^.T_CtrleSingle.xErr) THEN
								ptrTAxisS^.T_CtrleSingle.iFunction:=5;
								ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
							END_IF;
						END_IF;
						RETURN;
						xStFct_TmpStopProcess:=FALSE;
					END_IF;
				5:	IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
						gxZAxisVelocityCtrlActive:=FALSE;
						iStFct_StopProcess:=2;
					END_IF;
			END_CASE;
			RETURN;
		END_IF;
	END_IF;
(***************************************************************************************************************************************************)
(* Prozessende Ausfunkprozedur *)
	fbStFct_SparkOutProcess(	lrHubLength:= T_Station_Parameter.T_StProcess.rSparkOutStrokeLength,
								iCountHub:= T_Station_Parameter.T_StProcess.iSparkOutStrokeCount,
								T_Station_Parameter:= T_Station_Parameter,
								xStart:= xStFct_StartSparkOutProcess,
								xReset:= xStFct_ResetSparkOutProcess,
								xToolDeflection:= ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn OR IxToolDeflection2_St1,
								xToolTorqueHC:=ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn OR ptrTSensorTorque^.T_CtrleCyl.xStatePosOn,
								xToolTorqueSparkOut:=ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn1 OR ptrTSensorTorque^.T_CtrleCyl.xStatePosOn1,
								TCylToolDeflection:=ptrTCylToolDeflection^,
								TAxisZ:= ptrTAxisZ^);
(***************************************************************************************************************************************************)
(* Überwachung auf die Axiale Auslenkung *)
	IF xStFct_ToolDeflectionActiv THEN
		IF NOT(ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn) AND NOT(IxToolDeflection2_St1) THEN
			xStFct_ToolDeflectionActiv:=FALSE;
			xStFct_InitAxialSensor:=FALSE;
			xStFct_CheckAxialSensor:=FALSE;
		END_IF;
	END_IF;
	IF (ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn OR IxToolDeflection2_St1 OR xStFct_CheckAxialSensor) AND NOT(xStFct_ToolDeflectionActiv) THEN
		IF NOT(xStFct_InitAxialSensor) THEN
			xStFct_InitAxialSensor:=TRUE;
			xStFct_CheckAxialSensor:=TRUE;
			lrStFct_ActualPosition:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
		END_IF;
		IF NOT(ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn) AND NOT(IxToolDeflection2_St1) THEN
			xStFct_InitAxialSensor:=FALSE;
			xStFct_CheckAxialSensor:=FALSE;
			xStFct_ToolDeflectionActiv:=FALSE;
		END_IF;
		IF (ABS(ptrTAxisZ^.T_LiveValue.lrActualPosition - lrStFct_ActualPosition) >= T_Station_Parameter.T_StProcess.rDeflectionSensorOffset) AND (ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn OR IxToolDeflection2_St1) THEN
			xStFct_ToolDeflectionActiv:=TRUE;
		END_IF;
	END_IF;
(***************************************************************************************************************************************************)
	IF (T_Station_Parameter.T_StProcess.iWorkControlType <= 1) OR (T_Station_Parameter.T_StProcess.iWorkControlType = 2) THEN
		TONWaitReady(IN:=ptrTAxisZ^.T_CtrleSingle.xMovingForward AND ptrTAxisZ^.T_CtrleSingle.xConstantVel,PT:=T#0.02s);
	ELSE
		TONWaitReady(IN:=(iStFct_StepPrc = 3) AND NOT(xStFct_StopSlide) AND (ptrTAxisZ^.T_LiveValue.lrActualVelocity <= T_Station_Parameter.T_StProcess.rSpeedZAxisForBackward),PT:=T#0.1s);
	END_IF;
(* Hauptablauf für die Bearbeitung *)
	CASE iStFct_StepPrc OF
	1:	xEndPosReachZylindricalProcess:=FALSE;
		IF gxHardwareOFF OR gxAxisOFF THEN
			IF (garPositionEndProcCalc[1] > T_Station_Parameter.T_StProcess.rPositionEndProcMaxInc) AND (T_Station_Parameter.T_StProcess.xPositionEndProcIncOnOff OR gxProcessCylindricalAreaActive) THEN
				xStFct_HardwareError:=TRUE;
				diStFct_TmpErrorNr:=17;		(* Z Bearb EndPos Berechn. > Z Bearb EndPos Max *)
				RETURN;
			END_IF;
			IF (garCentringEndProcCalc[1] > T_Station_Parameter.T_StProcess.rPositionEndProcMaxInc) AND T_Station_Parameter.T_StProcess.xCentringEndProcIncOnOff THEN
				xStFct_HardwareError:=TRUE;
				diStFct_TmpErrorNr:=19;			(* Z ZentrierPos berechn. > Z Bearb EndPos Max *)
				RETURN;
			END_IF;
			gxWP_Analyse_ActiveWork:=TRUE;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=14;
			RETURN;
		END_IF;
		gxWP_Analyse_ActiveWork:=TRUE;
		(* Überprüfmechanismen die bestehen müssen, damit diese Funktion gestartet werden kann *)
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xRef) THEN	(* Z Achse muss referenziert sein *)
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=9;	(* Z Achse muss referenziert sein *)
			RETURN;
		END_IF;
		(* Überprüfe alle Positionen der Z Achse *)
		StationFunction_Ctrl_CheckPos_Z;
		IF xStFct_PositionOutRange_Z THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=iStFct_PosErrorNr;
			RETURN;
		END_IF;
		IF (garPositionEndProcCalc[1] > T_Station_Parameter.T_StProcess.rPositionEndMech) THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=12;		(* Hubprozesslänge > Z Mech EndPos *)
			RETURN;
		END_IF;
		IF (garCentringEndProcCalc[1] > T_Station_Parameter.T_StProcess.rPositionEndMech) THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=18;		(* Zentrier EndPos > Z Mech EndPos *)
			RETURN;
		END_IF;
		IF (garPositionEndProcCalc[1] > T_Station_Parameter.T_StProcess.rPositionEndProcMaxInc) AND (T_Station_Parameter.T_StProcess.xPositionEndProcIncOnOff OR gxProcessCylindricalAreaActive) THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=17;		(* Z Bearb EndPos Berechn. > Z Bearb EndPos Max *)
			RETURN;
		END_IF;
		IF (garCentringEndProcCalc[1] > T_Station_Parameter.T_StProcess.rPositionEndProcMaxInc) AND T_Station_Parameter.T_StProcess.xCentringEndProcIncOnOff THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=19;			(* Z ZentrierPos berechn. > Z Bearb EndPos Max *)
			RETURN;
		END_IF;
		IF (T_Station_Parameter.T_StProcess.iSparkOutStrokeCount <> 0) AND
		     ((T_Station_Parameter.T_StProcess.rSparkOutStrokeLength + garPositionEndProcCalc[1]) > T_Station_Parameter.T_StProcess.rPositionEndMech) THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=13;		(* Ausfunkhub > Z Mech EndPos *)
			RETURN;
		END_IF;
		IF ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn OR IxToolDeflection2_St1 THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=25;		(* Beim starten der Bearbeitung darf AuslenkSensor nicht ON sein *)
			RETURN;
		END_IF;
		IF ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn OR ptrTSensorTorque^.T_CtrleCyl.xStatePosOn THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=26;		(* Beim starten der Bearbeitung darf DrehmSensorHC nicht ON sein *)
			RETURN;
		END_IF;
		IF ptrTCylToolTorqueOverload^.T_CtrleCyl.xStatePosOn OR ptrTSensorTorqueOverload^.T_CtrleCyl.xStatePosOn THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=11;		(* Beim starten der Bearbeitung darf DrehmSensorHCÜberlast nicht ON sein *)
			RETURN;
		END_IF;
		(* Überprüfe ob Wz im Wstk eingefädelt ist *)
		IF NOT(ptrTAxisZ^.T_LiveValue.lrActualPosition >= (grZ_WorkStartPos - 0.1)) THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=14;		(* Werkzeug ist nicht im Werkstück eingefädelt *)
			RETURN;
		END_IF;
		(* Zylinder für Auslenkung-->mit Bearbeitungskraft *)
		ptrTCylToolDeflection^.T_CtrleCyl.iFunction:=2;
		ptrTCylToolDeflection^.T_Config.tDelayOn:=T#0.3s;
		ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_OnlineChange.rForceDeflection;
		ptrTCylToolDeflection^.T_CtrleCyl.xExecute:=TRUE;
		(* Zylinder für Drehmoment HC-->mit Schwellwert Startposition *)
		ptrTCylToolTorqueHC^.T_CtrleCyl.iFunction:=2;
		ptrTCylToolTorqueHC^.T_Config.tDelayOn:=T#0.2s;
		ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_OnlineChange.rTorqueLevelHC;
		ptrTCylToolTorqueHC^.T_CtrleCyl.xExecute:=TRUE;
		(* Zylinder für Überlast Drehmoment *)
		ptrTCylToolTorqueOverload^.T_CtrleCyl.iFunction:=2;
		ptrTCylToolTorqueOverload^.T_Config.tDelayOn:=T#0.2s;
		ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_StProcess.rTorqueLevel_Overload;
		ptrTCylToolTorqueOverload^.T_CtrleCyl.xExecute:=TRUE;
		iStFct_TmpHCStartPosCounter:=0;
		iStFct_TmpNumberTryInfeed:=0;
		iStFct_StepPrc:=iStFct_StepPrc + 1;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xPower) THEN
			ptrTAxisS^.T_CtrleSingle.iFunction:=3;	(* Strom einschalten *)
			ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
	2:	IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND ptrTAxisS^.T_CtrleSingle.xPower THEN
			IF NOT(xStFct_InitStep) THEN
				xStFct_InitStep:=TRUE;
				IF (T_Station_Parameter.T_StProcess.iWorkControlType <= 1) THEN
					ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut Bewegung *)
					IF NOT(gxProcessCylindricalAreaActive) THEN
						ptrTAxisZ^.T_CtrleSingle.lrPosition:=garPositionEndProcCalc[1];	(* AxisSlide auf EndPosition setzen *)
					ELSE
						(* Das ist der neue Ablauf wo man einen Zylindrische Position definieren kann und aber dieser Position wenn das Drehmoment einem definierten Schwellwert unterschritten wird, dann ist dies das Prozessende. Wird aber diese unten übergebene Position erreicht, dann wertet es als Fehler *)
						ptrTAxisZ^.T_CtrleSingle.lrPosition:=T_Station_Parameter.T_StProcess.rPositionEndProcMaxInc;
					END_IF;
					ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_OnlineChange.rWorkingSpeedForward;
					ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				IF ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
					ptrTAxisS^.T_CtrleSingle.iFunction:=6;	(* Move Velocity *)
				ELSE
					ptrTAxisS^.T_CtrleSingle.iFunction:=12;	(* Move Velocity *)
				END_IF;
				ptrTAxisS^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_OnlineChange.rWorkingSpindleSpeed;
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
				xStFct_StartProcessTimer:=TRUE;	(*Min und Max Timer starten*)
				T_Station_Work.THWWorkStation.TCtrlWork.xWorkingStarted:=TRUE;
				IF (T_Station_Parameter.T_StProcess.rWorkingSpeedOscillation > 0.0) THEN
					QxFastStrokeOn_St1:=TRUE;
					QiAFastStroke:=REAL_TO_INT(32757 / 50.0 * T_Station_Parameter.T_StProcess.rWorkingSpeedOscillation);		(* 32767digits / 50Hz * Param Hz *)
				ELSE
					QxFastStrokeOn_St1:=FALSE;
					QiAFastStroke:=0;
				END_IF;
			END_IF;
			IF (T_Station_Parameter.T_StProcess.iWorkControlType <= 1) THEN
				IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND (NOT(ptrTAxisZ^.T_CtrleSingle.xDone) OR ptrTAxisZ^.T_CtrleSingle.xNotMoving) AND
				     NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone THEN
					T_Station_Work.TCtrlOnlineChange.xLockChange_S_WorkSpindleSpeed:=FALSE;
					xStFct_StartMainPrc:=FALSE;
					xStFct_InitStep:=FALSE;
					iStFct_StepPrc:=iStFct_StepPrc + 1;
					RETURN;
				END_IF;
				(* Überwachung falls während der Zeit dass die Bearbeitungsparameter übergeben werden ein HC eintreffen sollte *)
				IF xStFct_ToolDeflectionActiv OR ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn OR ptrTSensorTorque^.T_CtrleCyl.xStatePosOn THEN
					T_Station_Work.TCtrlOnlineChange.xLockChange_S_WorkSpindleSpeed:=FALSE;
					xStFct_StartMainPrc:=FALSE;
					xStFct_InitStep:=FALSE;
					iStFct_StepPrc:=iStFct_StepPrc + 1;
				END_IF;
			ELSE
				IF  NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone THEN
					xStFct_StartMainPrc:=FALSE;
					xStFct_InitStep:=FALSE;
					iStFct_StepPrc:=iStFct_StepPrc + 1;
				END_IF;
			END_IF;
		END_IF;
	3:	(* Bearbeitungsprozess ist nun Aktiv-->Wstk wird effektiv bearbeitet *)
		T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedForward:=FALSE;	(* OnlineChange Parameter kann für die HubAchse Vorwärtsgeschw. aktiviert werden *)
		IF gxProcessCylindricalAreaActive AND NOT(xEndPosReachZylindricalProcess) THEN
			(* Beim neuen Ablauf sobald der Zylindrische Bereich erreicht wird, dann muss die Überwachung des Drehmomentschwellwertes aktiviert werden und wenn dieser unterschritten wird, dann gilt dies als EndPosition der Bearbeitung *)
			IF (ptrTAxisZ^.T_LiveValue.lrActualPosition >= garPositionEndProcCalc[1]) THEN		(* Beachte die Position garPositionEndProcCalc[1] bei neuem Ablauf ist mit dem Zylindrischen Bereich verknüpft inklusiv Inkrementierung *)
				IF (T_Station_Work.THWWorkStation.TCtrlWork.iProgressBar_Torque < T_Station_Parameter.T_StProcess.rZMinThresholdTroqueEndProcess) THEN
					(* Man befindet sich im zylindrischen Bereich und das Drehmoment wurde vom vorgegebenen Schwellwert unterschritten und gilt als Prozessende *)
					IF (T_Station_Parameter.T_StProcess.iWorkControlType <= 1) THEN
						IF (NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone) AND NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) AND (ptrTAxisZ^.T_CtrleSingle.iFunction <> 12)) THEN
							ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
							ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
							xEndPosReachZylindricalProcess:=TRUE;
						END_IF;
					ELSE
						xEndPosReachZylindricalProcess:=TRUE;
					END_IF;
					T_Station_Parameter.T_StProcess.rZPositionCylindricalAreaStop:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
					T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rZPositionCylindricalAreaStop:=T_Station_Parameter.T_StProcess.rZPositionCylindricalAreaStop;
				END_IF;
			END_IF;
		END_IF;
		IF (T_Station_Parameter.T_StProcess.iWorkControlType <> 2) THEN
			IF xStFct_ToolDeflectionActiv AND NOT(ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn) AND NOT(ptrTSensorTorque^.T_CtrleCyl.xStatePosOn) AND NOT(xStFct_StopSlide) AND NOT(xEndPosReachZylindricalProcess) THEN
				xStFct_StopSlide:=TRUE;
				wStFct_Status:=1;	(* 1 = < Wz Auslenk. Sensor > *)
				T_Station_Work.THWWorkStation.TCtrlWork.xDeflectionLastHC:=TRUE;
				T_Station_Work.THWWorkStation.TCtrlWork.xTorqueLastHC:=FALSE;
			END_IF;
			IF (ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn OR ptrTSensorTorque^.T_CtrleCyl.xStatePosOn) AND NOT(xStFct_ToolDeflectionActiv) AND NOT(xStFct_StopSlide) AND NOT(xEndPosReachZylindricalProcess) THEN
				xStFct_StopSlide:=TRUE;
				wStFct_Status:=2;	(* 2 = < Wz Drehmom. HC> *)
				T_Station_Work.THWWorkStation.TCtrlWork.xDeflectionLastHC:=FALSE;
				T_Station_Work.THWWorkStation.TCtrlWork.xTorqueLastHC:=TRUE;
			END_IF
			IF xStFct_ToolDeflectionActiv AND (ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn OR  ptrTSensorTorque^.T_CtrleCyl.xStatePosOn) AND NOT(xStFct_StopSlide) AND NOT(xEndPosReachZylindricalProcess) THEN
				xStFct_StopSlide:=TRUE;
				wStFct_Status:=3;	(* 3 = < Wz Auslenk.+Wz Drehm.HC > *)
				T_Station_Work.THWWorkStation.TCtrlWork.xDeflectionLastHC:=TRUE;
				T_Station_Work.THWWorkStation.TCtrlWork.xTorqueLastHC:=TRUE;
			END_IF;
			IF (ptrTAxisZ^.T_LiveValue.lrActualVelocity <= T_Station_Parameter.T_StProcess.rSpeedZAxisForBackward) AND NOT(xStFct_StopSlide) AND TONWaitReady.Q AND NOT(xEndPosReachZylindricalProcess) THEN
				xStFct_StopSlide:=TRUE;
				wStFct_Status:=4;	(* 4 = < Z min Geschw. > *)
				T_Station_Work.THWWorkStation.TCtrlWork.xDeflectionLastHC:=TRUE;
				T_Station_Work.THWWorkStation.TCtrlWork.xTorqueLastHC:=TRUE;
			END_IF;
		ELSE
			IF xStFct_ToolDeflectionActiv AND NOT(ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn) AND NOT(ptrTSensorTorque^.T_CtrleCyl.xStatePosOn) AND NOT(xStFct_StopSlide) AND NOT(xEndPosReachZylindricalProcess) THEN
				xStFct_StopSlide:=TRUE;
				wStFct_Status:=1;	(* 1 = < Wz Auslenk. Sensor > *)
				T_Station_Work.THWWorkStation.TCtrlWork.xDeflectionLastHC:=TRUE;
				T_Station_Work.THWWorkStation.TCtrlWork.xTorqueLastHC:=FALSE;
			END_IF;
		END_IF;
		IF xStFct_StopSlide AND ((NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone) AND
		    NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) AND (ptrTAxisZ^.T_CtrleSingle.iFunction <> 12)) OR
 		    (T_Station_Parameter.T_StProcess.iWorkControlType = 2) OR (T_Station_Parameter.T_StProcess.iWorkControlType = 3)) THEN
			T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedForward:=TRUE;
			IF (T_Station_Parameter.T_StProcess.iWorkControlType <= 1) THEN
				ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			rStFct_SetZHCPosition:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
			xStFct_CapturePosition:=TRUE;	(* Berechnung der Schnittgeschwindigkeit *)
			xStFct_HCActivated:=TRUE;	(* Überwachung für das Einfressen des Wz im Wstk *)
			IF NOT(xStFct_ForceHC) THEN
				IF (rStFct_TmpDiffOverLimitPosition <> 0) THEN
					T_Station_Work.THWWorkStation.TCtrlWork.rDiffOverLimitPosition:=ptrTAxisZ^.T_LiveValue.lrActualPosition - T_Station_Work.THWWorkStation.TCtrlWork.rLastOverLimitPosition;
				END_IF;
				T_Station_Work.THWWorkStation.TCtrlWork.rLastOverLimitPosition:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
				rStFct_TmpDiffOverLimitPosition:=T_Station_Work.THWWorkStation.TCtrlWork.rLastOverLimitPosition;
				IF (wStFct_Status = 1) OR (wStFct_Status = 3) THEN
					T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounter:=T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounter + 1;
				END_IF;
				IF (wStFct_Status = 2) OR (wStFct_Status = 3) THEN
					T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterTorque:=T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterTorque + 1;
				END_IF;
				IF (wStFct_Status = 4) THEN
					T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterSpeed:=T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterSpeed + 1;
				END_IF;
			END_IF;
			xStFct_ForceHC:=FALSE;
			(* init. variable *)
			xStFct_StopSlide:=FALSE;
			IF (T_Station_Parameter.T_StProcess.iWorkControlType <= 1) THEN
				iStFct_StepPrc:=iStFct_StepPrc + 1;
			ELSE
				rStFct_StopPosition:=LREAL_TO_REAL(ptrTAxisZ^.T_LiveValue.lrActualPosition);
				iStFct_StepPrc:=40;
			END_IF;
			xStFct_InitStep:=FALSE;
			RETURN;
		END_IF;
		IF (T_Station_Parameter.T_StProcess.iWorkControlType <= 1) THEN
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
				IF NOT(gxProcessCylindricalAreaActive) OR xEndPosReachZylindricalProcess THEN
					(* Endposition erreicht-->Ausfunkprozedur starten *)
					T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedForward:=TRUE;
					xStFct_StopSlide:=FALSE;
					iStFct_StepPrc:=9;
					xStFct_InitStep:=FALSE;
				ELSE
					(* Beim neuen Ablauf darf die Max Endposition nicht erreicht werden *)
					xStFct_StopSlide:=FALSE;
					iStFct_StepPrc:=50;
					xStFct_InitStep:=FALSE;
				END_IF;
			END_IF;
		ELSE
			IF ((ptrTAxisZ^.T_LiveValue.lrActualPosition >= garPositionEndProcCalc[1]) AND NOT(gxProcessCylindricalAreaActive)) OR (xEndPosReachZylindricalProcess AND gxProcessCylindricalAreaActive) THEN
				xStFct_StartMainPrc:=FALSE;
				xStFct_InitStep:=FALSE;
				iStFct_StepPrc:=30;
			END_IF;
		END_IF;
	4:	(* Abwarten bis die HubAchse stillsteht *)
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			(* init. variable *)
			rStFct_StopPosition:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	5:	(* HubAchse zurück auf StartPos setzen um den Rückwärts-Offset abzufahren *)
		ptrTAxisZ^.T_CtrleSingle.iFunction:=7;
		ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_WorkStartPos;
		ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_OnlineChange.rWorkingSpeedBackward;
		ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
		iStFct_StepPrc:=iStFct_StepPrc + 1;
	6:	(* HubAchse fährt mindestens den Rückwärts-Offset zurück und wird gestoppt sobald die HC Sensoren nicht mehr bedämpft sind *)
		T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedBackward:=ptrTAxisZ^.T_CtrleSingle.xNotMoving;
		IF ptrTAxisZ^.T_LiveValue.lrActualPosition < (rStFct_StopPosition + T_Station_Parameter.T_OnlineChange.rWorkingOffsetBackward) THEN
			IF NOT(xStFct_ToolDeflectionActiv) AND NOT(ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn) AND NOT(ptrTSensorTorque^.T_CtrleCyl.xStatePosOn) THEN
				xStFct_StopSlide:=TRUE;
			END_IF;
			IF xStFct_StopSlide AND NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone) AND
			    NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) AND (ptrTAxisZ^.T_CtrleSingle.iFunction <> 12) THEN
				T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedBackward:=TRUE;
				ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
				(* init. variable *)
				xStFct_StopSlide:=FALSE;
				iStFct_StepPrc:=iStFct_StepPrc + 1;
				RETURN;
			END_IF
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedBackward:=TRUE;
			IF (iStFct_TmpHCStartPosCounter >= T_Station_Parameter.T_StProcess.iHCStartProcPosCounter) THEN	(* Counter bestimmt wie oft die Startposition erreicht werden darf, bis der Prozess abgebrochen wird *)
			(* end *)
				T_Station_Work.THWWorkStation.TCtrlWork.xWorkingFinished:=TRUE;
				(* Startposition mit max Anzahl zu erreichender StartPosition erreicht-->Prozess abgebrochen-->NoGo Part *)
				T_Station_Work.THWWorkStation.TCtrlWork.bPartQuality:=5;	(* < niO kein Einf. > *)
				xStFct_StartMainPrc:=FALSE;
				xStFct_InitStep:=FALSE;
				iStFct_StepPrc:=12;	(* Hubachse wieder auf LadePos setzen *)
			ELSE
				iStFct_TmpHCStartPosCounter:=iStFct_TmpHCStartPosCounter + 1;
				(* init. variable *)
				iStFct_StepPrc:=iStFct_StepPrc + 1;	(* HubAchse hat StartPosition erreicht, Vorwärtsbewegung muss wieder aktiviert werden *)
			END_IF;
		END_IF
	7:	(* Abwarten bis Achse gestoppt hat *)
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF
	8:	(* Vorwärtsbewegung wieder starten *)
		IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut Bewegung *)
			IF NOT(gxProcessCylindricalAreaActive) THEN
				ptrTAxisZ^.T_CtrleSingle.lrPosition:=garPositionEndProcCalc[1];	(* AxisSlide auf EndPosition setzen *)
			ELSE
				(* Das ist der neue Ablauf wo man einen Zylindrische Position definieren kann und aber dieser Position wenn das Drehmoment einem definierten Schwellwert unterschritten wird, dann ist dies das Prozessende. Wird aber diese unten übergebene Position erreicht, dann wertet es als Fehler *)
				ptrTAxisZ^.T_CtrleSingle.lrPosition:=T_Station_Parameter.T_StProcess.rPositionEndProcMaxInc;
			END_IF;
			ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_OnlineChange.rWorkingSpeedForward;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone) THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=3;
		END_IF;
	9:	(* Vorwärtsbewegung wieder starten *)
		IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			xStFct_StartSparkOutProcess:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChange_S_WorkSpindleSpeed:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolDeflectionForce:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolTorqueLevel:=TRUE;
			T_Station_Work.THWWorkStation.TCtrlWork.xSparkOutActive:=TRUE;
		END_IF;
		IF NOT(xStFct_StartSparkOutProcess) AND fbStFct_SparkOutProcess.xEnd AND NOT(fbStFct_SparkOutProcess.xBlockProcess) AND NOT(fbStFct_SparkOutProcess.xRepeatProcess) THEN
			T_Station_Work.THWWorkStation.TCtrlWork.xSparkOutActive:=FALSE;
			T_Station_Work.TCtrlOnlineChange.xLockChange_S_WorkSpindleSpeed:=TRUE;
			T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolDeflectionForce:=FALSE;
			T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolTorqueLevel:=FALSE;
			IF ((T_Station_Parameter.T_OnlineChange.rWorkingSpindleSpeed > 0) AND (T_Station_Parameter.T_StProcess.rOutfeedSpindleSpeed < 0))
			OR ((T_Station_Parameter.T_OnlineChange.rWorkingSpindleSpeed < 0) AND (T_Station_Parameter.T_StProcess.rOutfeedSpindleSpeed > 0)) THEN
			(*IF (T_Station_Parameter.T_StProcess.rOutfeedSpindleSpeed > 0) THEN	*)	(* IGS1 neu mit umgekehrter Geschwindigkeit ausfahren zuerst Spindel stoppen, geht nicht anders, mit Dave besprochen *)
				iStFct_StepPrc:=20;
			ELSE
				iStFct_StepPrc:=iStFct_StepPrc + 1;
			END_IF;
			xStFct_InitStep:=FALSE;
			RETURN;
		END_IF;
		IF NOT(xStFct_StartSparkOutProcess) AND fbStFct_SparkOutProcess.xEnd AND fbStFct_SparkOutProcess.xRepeatProcess THEN
			T_Station_Work.THWWorkStation.TCtrlWork.xSparkOutActive:=FALSE;
			T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolDeflectionForce:=FALSE;
			T_Station_Work.TCtrlOnlineChange.xLockChangeCylToolTorqueLevel:=FALSE;
			wStFct_Status:=fbStFct_SparkOutProcess.wStatus;
			IF (rStFct_TmpDiffOverLimitPosition <> 0) THEN
				T_Station_Work.THWWorkStation.TCtrlWork.rDiffOverLimitPosition:=ptrTAxisZ^.T_LiveValue.lrActualPosition - T_Station_Work.THWWorkStation.TCtrlWork.rLastOverLimitPosition;
			END_IF;
			rStFct_SetZHCPosition:=fbStFct_SparkOutProcess.rLastOverLimitPosition;
			T_Station_Work.THWWorkStation.TCtrlWork.rLastOverLimitPosition:=fbStFct_SparkOutProcess.rLastOverLimitPosition;
			rStFct_TmpDiffOverLimitPosition:=T_Station_Work.THWWorkStation.TCtrlWork.rLastOverLimitPosition;
			T_Station_Work.THWWorkStation.TCtrlWork.xDeflectionLastHC:=FALSE;
			T_Station_Work.THWWorkStation.TCtrlWork.xTorqueLastHC:=FALSE;
			IF (wStFct_Status = 1) OR (wStFct_Status = 3) THEN
				T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounter:=T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounter + 1;
				T_Station_Work.THWWorkStation.TCtrlWork.xDeflectionLastHC:=TRUE;
			END_IF;
			IF (wStFct_Status = 2) OR (wStFct_Status = 3) THEN
				T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterTorque:=T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterTorque + 1;
				T_Station_Work.THWWorkStation.TCtrlWork.xTorqueLastHC:=TRUE;
			END_IF;
			iStFct_StepPrc:=4;
			xStFct_InitStep:=FALSE;
		END_IF;
	10:	(* Prozess beendet, HubAchse kann wieder auf LadePosition gesetzt *)
		IF (T_Station_Parameter.T_StProcess.rZ1AxisPosSwitchOAxisOff >= garPositionEndProcCalc[1])
		OR ((ptrTAxisZ^.T_LiveValue.lrActualPosition <= T_Station_Parameter.T_StProcess.rZ1AxisPosSwitchOAxisOff)
		OR (ABS(ptrTAxisZ^.T_LiveValue.lrActualPosition - T_Station_Parameter.T_StProcess.rPositionLoad) <= 10.0)) THEN
			QxFastStrokeOn_St1:=FALSE;
		END_IF;
		IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			T_Station_Work.THWWorkStation.TCtrlWork.xWorkingFinished:=TRUE;
			(* Auswertung der Qualität des Teiles *)
			IF NOT(xStFct_MinTimeProcessReady) THEN
				(* Prozess hat Mindest Zeit nicht überschritten *)
				T_Station_Work.THWWorkStation.TCtrlWork.bPartQuality:=3;	(* < niO min Zeit > *)
			ELSIF (T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounter = 0) AND (T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterTorque = 0) THEN
				(* Bearbeitungsprozess hatte keinen Ausschlag, MindestZeit wurde aber überschritten *)
				T_Station_Work.THWWorkStation.TCtrlWork.bPartQuality:=2;	(* < iO kein HC > *)
				IF T_Station_Parameter.T_StProcess.xPositionEndProcIncOnOff THEN
					garPositionEndProcCalc[1]:=garPositionEndProcCalc[1] + T_Station_Parameter.T_StProcess.rPositionEndProInc;	(* EndPos Inkrementieren *)
				END_IF;
			ELSIF (T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounter <> 0) OR (T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterTorque <> 0) THEN
				(* Bearbeitungsprozess hatte mindestens einen Ausschlag, MindestZeit wurde aber überschritten *)
				T_Station_Work.THWWorkStation.TCtrlWork.bPartQuality:=1;	(* < iO HC > *)
				IF T_Station_Parameter.T_StProcess.xPositionEndProcIncOnOff THEN
					garPositionEndProcCalc[1]:=garPositionEndProcCalc[1] + T_Station_Parameter.T_StProcess.rPositionEndProInc;	(* EndPos Inkrementieren *)
				END_IF;
			END_IF;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut Bewegung *)
			ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_LoadPos;	(* AxisSlide auf BearbStartPosition setzen *)
			ptrTAxisZ^.T_CtrleSingle.lrVelocity:=rOutfeedStrokeAxisSpeed;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			(* Spindel mit Ausfahrgeschwindigkeit *)
			IF ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=6;	(* Move Velocity *)
			ELSE
				ptrTAxisS^.T_CtrleSingle.iFunction:=12;	(* Move Velocity *)
			END_IF;
			ptrTAxisS^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rOutfeedSpindleSpeed;
			ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			IF NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xNotMoving) THEN
				(* Abstreifer ZU *)
				QxCylStripperClose_St1:=TRUE;
				QxCylStripperOpen_St1:=FALSE;
			END_IF
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone AND
		     NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	11:	(* Prozess beendet, HubAchse kann wieder auf LadePosition gesetzt *)
		IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut Bewegung *)
			ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_LoadPos;	(* AxisSlide auf LadePosition setzen *)
			ptrTAxisZ^.T_CtrleSingle.lrVelocity:=rOutfeedStrokeAxisSpeed;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			IF NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xNotMoving) THEN
				(* Abstreifer ZU *)
				QxCylStripperClose_St1:=TRUE;
				QxCylStripperOpen_St1:=FALSE;
			END_IF
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=0;
			xStFct_SetEnd:=TRUE;
			IF xProcessDone THEN
				IF (NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) OR NOT(ptrTAxisS^.T_CtrleSingle.xDone)) AND
				     NOT((ptrTAxisS^.T_CtrleSingle.iFunction = 5) AND NOT(ptrTAxisS^.T_CtrleSingle.xDone)) AND NOT(ptrTAxisS^.T_CtrleSingle.xErr) THEN
					ptrTAxisS^.T_CtrleSingle.iFunction:=5;
					ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			(* Abstreifer AUF *)
			QxCylStripperClose_St1:=FALSE;
			QxCylStripperOpen_St1:=TRUE;
		END_IF;
	12:	(* Bei max. erreicht Startposition-->HubAchse wieder auf LadePosition gesetzt *)
		IF (T_Station_Parameter.T_StProcess.rZ1AxisPosSwitchOAxisOff >= garPositionEndProcCalc[1])
		OR ((ptrTAxisZ^.T_LiveValue.lrActualPosition <= T_Station_Parameter.T_StProcess.rZ1AxisPosSwitchOAxisOff)
		OR (ABS(ptrTAxisZ^.T_LiveValue.lrActualPosition - T_Station_Parameter.T_StProcess.rPositionLoad) <= 10.0)) THEN
			QxFastStrokeOn_St1:=FALSE;
		END_IF;
		IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut Bewegung *)
			ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_LoadPos;	(* AxisSlide auf BearbStartPosition setzen *)
			ptrTAxisZ^.T_CtrleSingle.lrVelocity:=rOutfeedStrokeAxisSpeed;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			(* Spindel mit Ausfahrgeschwindigkeit *)
			IF ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=6;	(* Move Velocity *)
			ELSE
				ptrTAxisS^.T_CtrleSingle.iFunction:=12;	(* Move Velocity *)
			END_IF;
			ptrTAxisS^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rOutfeedSpindleSpeed;
			ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			IF NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xNotMoving) THEN
				(* Abstreifer ZU *)
				QxCylStripperClose_St1:=TRUE;
				QxCylStripperOpen_St1:=FALSE;
			END_IF
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone AND
		     NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	13:	(* Bei max. erreicht Startposition-->HubAchse wieder auf LadePosition gesetzt *)
		IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut Bewegung *)
			ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_LoadPos;	(* AxisSlide auf LadePosition setzen *)
			ptrTAxisZ^.T_CtrleSingle.lrVelocity:=rOutfeedStrokeAxisSpeed;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			IF NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xNotMoving) THEN
				(* Abstreifer ZU *)
				QxCylStripperClose_St1:=TRUE;
				QxCylStripperOpen_St1:=FALSE;
			END_IF
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=0;
			xStFct_SetEnd:=TRUE;
			IF xProcessDone THEN
				IF (NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) OR NOT(ptrTAxisS^.T_CtrleSingle.xDone)) AND
				     NOT((ptrTAxisS^.T_CtrleSingle.iFunction = 5) AND NOT(ptrTAxisS^.T_CtrleSingle.xDone)) AND NOT(ptrTAxisS^.T_CtrleSingle.xErr) THEN
					ptrTAxisS^.T_CtrleSingle.iFunction:=5;
					ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
			(* Abstreifer AUF *)
			QxCylStripperClose_St1:=FALSE;
			QxCylStripperOpen_St1:=TRUE;
		END_IF;
	(* Gilt nur für falls HW ausgeschaltet ist *)
	14:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			TONWorkTime(IN:=FALSE);
		END_IF;
		TONWorkTime(IN:=TRUE,PT:=T#3s);
		IF TONWorkTime.Q THEN
			TONWorkTime(IN:=FALSE);
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
			T_Station_Work.THWWorkStation.TCtrlWork.xWorkingFinished:=TRUE;
			(* Bearbeitungsprozess hatte keinen Ausschlag, MindestZeit wurde aber überschritten *)
			T_Station_Work.THWWorkStation.TCtrlWork.bPartQuality:=2;	(* < iO kein HC > *)
			IF T_Station_Parameter.T_StProcess.xPositionEndProcIncOnOff THEN
				garPositionEndProcCalc[1]:=garPositionEndProcCalc[1] + T_Station_Parameter.T_StProcess.rPositionEndProInc;
			END_IF;
		END_IF;
	(* Gilt nur für falls HW ausgeschaltet ist *)
	15:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			TONWorkTime(IN:=FALSE);
		END_IF;
		TONWorkTime(IN:=TRUE,PT:=T#2s);
		IF TONWorkTime.Q THEN
			TONWorkTime(IN:=FALSE);
			wStFct_Status:=0;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=0;
			xStFct_SetEnd:=TRUE;
		END_IF;


	20:	(* Spindel stoppen *)	(* IGS1 neu mit umgekehrter Geschwindigkeit ausfahren, mit YGD besprochen *)
		IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisS^.T_CtrleSingle.iFunction:=5;
			ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=10;
		END_IF;

	30:	(* Bei Drehzahlregler passt der Sollwert der Position nicht mehr mit dem Ist Wert und deshalb muss ein Reset durchgeführt werden *)
		IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=1;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	31:	(* Bei Drehzahlregler ohne verweilzeit und man dann direkt eine Positionsfahrt auslösen will, dann führt es zum Fehler 18000 der Achse *)
		IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			TONWaitMovement(IN:=FALSE);
		END_IF;
		TONWaitMovement(IN:=TRUE,PT:=T#0.3s);
		IF TONWaitMovement.Q THEN
			TONWaitMovement(IN:=FALSE);
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			IF NOT(gxProcessCylindricalAreaActive) THEN
				iStFct_StepPrc:=9;
			ELSE
				IF NOT(xEndPosReachZylindricalProcess) THEN
					(* Beim neuen Ablauf darf die Max Endposition nicht erreicht werden *)
					iStFct_StepPrc:=50;
				ELSE
					iStFct_StepPrc:=9;
				END_IF;
			END_IF;
		END_IF;

	(* Beim Drehzahlregler wenn ein HC eintrifft für den Offset zurück wird auch mit dem Drehzahlregler bewegt, anderenfalls müsste man die Achse resetten *)
	40:	IF (T_Station_Parameter.T_StProcess.iWorkControlType = 2) THEN
			rStFct_CalcZSpeed:=(ABS(T_Station_Parameter.T_StProcess.rZ_PID_MinSpeed)/100.0) * BYTE_TO_REAL(T_ExchgParam.byOverride);
		ELSE
			rStFct_CalcZSpeed:=(T_Station_Parameter.T_OnlineChange.rWorkingSpeedBackward/100.0) * BYTE_TO_REAL(T_ExchgParam.byOverride);
		END_IF;
		T_Z_St1_Ctrle.diVelocityCommandValue:=LREAL_TO_DINT(rStFct_CalcZSpeed * 558349.25) ; (* 11166985 --> 20mm/s --> 1mm/s = 558349.25 *)
		T_Station_Work.TCtrlOnlineChange.xLockChange_Z_WorkSpeedBackward:=ptrTAxisZ^.T_CtrleSingle.xNotMoving;
		IF ptrTAxisZ^.T_LiveValue.lrActualPosition < (rStFct_StopPosition + T_Station_Parameter.T_OnlineChange.rWorkingOffsetBackward) THEN
			IF NOT(xStFct_ToolDeflectionActiv) AND NOT(ptrTSensorTorque^.T_CtrleCyl.xStatePosOn) THEN
				T_Z_St1_Ctrle.diVelocityCommandValue:=0;
				xStFct_StartMainPrc:=FALSE;
				xStFct_InitStep:=FALSE;
				iStFct_StepPrc:=3;
			END_IF
		END_IF;

	(* Dies gilt für den neuen Ablauf und setzt die Z Achse zurück auf die LadePos und gibt einen Fehler aus *)
	50:	IF (T_Station_Parameter.T_StProcess.rZ1AxisPosSwitchOAxisOff >= garPositionEndProcCalc[1])
		OR ((ptrTAxisZ^.T_LiveValue.lrActualPosition <= T_Station_Parameter.T_StProcess.rZ1AxisPosSwitchOAxisOff)
		OR (ABS(ptrTAxisZ^.T_LiveValue.lrActualPosition - T_Station_Parameter.T_StProcess.rPositionLoad) <= 10.0)) THEN
			QxFastStrokeOn_St1:=FALSE;
		END_IF;
		IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut Bewegung *)
			ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_LoadPos;	(* AxisSlide auf BearbStartPosition setzen *)
			ptrTAxisZ^.T_CtrleSingle.lrVelocity:=rOutfeedStrokeAxisSpeed;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			(* Spindel mit Ausfahrgeschwindigkeit *)
			IF ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=6;	(* Move Velocity *)
			ELSE
				ptrTAxisS^.T_CtrleSingle.iFunction:=12;	(* Move Velocity *)
			END_IF;
			ptrTAxisS^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rOutfeedSpindleSpeed;
			ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			IF NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xNotMoving) THEN
				(* Abstreifer ZU *)
				QxCylStripperClose_St1:=TRUE;
				QxCylStripperOpen_St1:=FALSE;
			END_IF
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone AND
		     NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;

	51:	(* Abstreifer AUF *)
		QxCylStripperClose_St1:=FALSE;
		QxCylStripperOpen_St1:=TRUE;
		QxFastStrokeOn_St1:=FALSE;
		xStFct_HardwareError:=TRUE;
		diStFct_TmpErrorNr:=44;		(* Beim zylindrischer Teil wurde die Max EndPos erreicht *)
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Parallelablauf                                       *****************************)
(******************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				     Stationsfunktion Endprozedur                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_End;
END_ACTION

ACTION	StationFunction_Fct_06_ToolRotationOFF:
(******************************************************************************************************************************************)
(****************************				           Reset Stationsfunktion                                            *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Reset;
(******************************************************************************************************************************************)
(****************************			        Stationsfunktion Fehler Controller                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Error;
(******************************************************************************************************************************************)
(****************************				    Stationsfunktion Haupt Controller                               *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Main;
(******************************************************************************************************************************************)
(****************************			         Stationsfunktion sofort Unterbrechung                           *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Stop;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Hauptablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartMainPrc AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) AND NOT(xStFct_TmpStop) THEN
	CASE iStFct_StepPrc OF
	1:	IF NOT(xStFct_InitStep) THEN
			IF NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) AND ptrTAxisS^.T_CtrleSingle.xPower THEN
				(* Die Spindel dreht, daher muss sie gestoppt werden und dann der Strom noch ausschalten *)
				iStFct_StepPrc:=iStFct_StepPrc + 1;
			ELSIF ptrTAxisS^.T_CtrleSingle.xNotMoving AND ptrTAxisS^.T_CtrleSingle.xPower THEN
				(* Die Spindel ist schon gestoppt, der Strom muss aber noch ausgeschaltet werden *)
				iStFct_StepPrc:=3;
			ELSE
				(* Die Spindel ist schon im entsprechenden Zustand, daher kann die Funktion beendet werden *)
				iStFct_StepPrc:=4;
			END_IF;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
		END_IF;
	2:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisS^.T_CtrleSingle.iFunction:=5;
			ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	3:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisS^.T_CtrleSingle.iFunction:=4;	(* Strom ausschalten *)
			ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND NOT(ptrTAxisS^.T_CtrleSingle.xPower) THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	4:	xStFct_StartMainPrc:=FALSE;
		xStFct_InitStep:=FALSE;
		iStFct_StepPrc:=0;
		xStFct_SetEnd:=TRUE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Parallelablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartPrc_Parallel AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) THEN
	CASE iStFct_StepPrc_Parallel OF
	1:	iStFct_StepPrc_Parallel:=1;
		xStFct_InitStep_Parallel:=FALSE;
		xStFct_StartPrc_Parallel:=FALSE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				     Stationsfunktion Endprozedur                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_End;
END_ACTION

ACTION	StationFunction_Fct_07_Calibration:
(******************************************************************************************************************************************)
(****************************				           Reset Stationsfunktion                                            *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Reset;
(******************************************************************************************************************************************)
(****************************			        Stationsfunktion Fehler Controller                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Error;
(******************************************************************************************************************************************)
(****************************				    Stationsfunktion Haupt Controller                               *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Main;
(******************************************************************************************************************************************)
(****************************			         Stationsfunktion sofort Unterbrechung                           *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Stop;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Hauptablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_TmpStop AND NOT(xStFct_HardwareError) THEN
	T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=rStFct_TmpOffsetDeflection;
	T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]:=rStFct_TmpOffsetTorque;
END_IF;
IF xStFct_StartMainPrc AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) AND NOT(xStFct_TmpStop) THEN
	IF ((iStFct_StepPrc >= 4) AND (iStFct_StepPrc <= 6)) OR xStFct_StartPrc_Parallel THEN
		IF ((iStFct_StepPrc >= 4) AND (iStFct_StepPrc <= 6)) THEN
			T_Station_Work.THWWorkStation.TCtrlWork.rOffsetToolDeflection:=rStFct_ForceDeflection;
		END_IF;
		IF xStFct_StartPrc_Parallel THEN
			T_Station_Work.THWWorkStation.TCtrlWork.rOffsetToolTorque:=rStFct_ForceTorque;
		END_IF;
		CASE T_ExchgParam.bToolSpindleActive OF
		1:	(* Maxon Spindel *)
			IF NOT(xStFct_DeflCalibError) AND ((rStFct_ForceDeflection < 0) OR (rStFct_ForceDeflection > (T_Station_Parameter.T_SpindleSystem.rMaxDeflectionForce + rStFct_TmpOffsetDeflection))) THEN
				xStFct_DeflCalibError:=TRUE;
				xStFct_StartMainPrc:=FALSE;
				xStFct_InitStep:=FALSE;
				iStFct_StepPrc:=7;
				T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=rStFct_TmpOffsetDeflection;
			END_IF;
			IF NOT(xStFct_TorqueCalibError) AND ((rStFct_ForceTorque < 0) OR (rStFct_ForceTorque > (T_Station_Parameter.T_TorqueSystem.rMaxTorque_HC + rStFct_TmpOffsetTorque))) THEN
				xStFct_TorqueCalibError:=TRUE;
				xStFct_StartMainPrc:=FALSE;
				xStFct_InitStep:=FALSE;
				iStFct_StepPrc:=7;
				T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]:=rStFct_TmpOffsetTorque;
				xStFct_StartPrc_Parallel:=FALSE;
			END_IF;
		2:	(* Beckhoff Spindel L *)
			IF NOT(xStFct_DeflCalibError) AND ((rStFct_ForceDeflection < 0) OR (rStFct_ForceDeflection > (T_Station_Parameter.T_SpindleSystem_L.rMaxDeflectionForce + rStFct_TmpOffsetDeflection))) THEN
				xStFct_DeflCalibError:=TRUE;
				xStFct_StartMainPrc:=FALSE;
				xStFct_InitStep:=FALSE;
				iStFct_StepPrc:=7;
				T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=rStFct_TmpOffsetDeflection;
			END_IF;
		3:	(* Beckhoff Spindel M *)
			IF NOT(xStFct_DeflCalibError) AND ((rStFct_ForceDeflection < 0) OR (rStFct_ForceDeflection > (T_Station_Parameter.T_SpindleSystem_M.rMaxDeflectionForce + rStFct_TmpOffsetDeflection))) THEN
				xStFct_DeflCalibError:=TRUE;
				xStFct_StartMainPrc:=FALSE;
				xStFct_InitStep:=FALSE;
				iStFct_StepPrc:=7;
				T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=rStFct_TmpOffsetDeflection;
			END_IF;
		END_CASE;
	END_IF;
	IF T_Station_Work.THWWorkStation.TCtrlWork.xWorkStopToolRotation THEN
		xStFct_TmpSaveOffset:=FALSE;
		xStFct_StartMainPrc:=FALSE;
		xStFct_InitStep:=FALSE;
		iStFct_StepPrc:=0;
		xStFct_SetEnd:=TRUE;
	END_IF;
	(* Deflection Sensor ON/OFF-->Muss für 0.1s gesetzt bleiben, damit Sensor ON/OFF ist, damit Prellungen ausgeschaltet werden können *)
	IF ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn THEN
		TONStFct_DeflectionSensorOFF(IN:=FALSE);
		TONStFct_DeflectionSensorON(IN:=TRUE,PT:=T#0.05s);
		IF TONStFct_DeflectionSensorON.Q THEN
			xStFct_DeflectionSensorON:=TRUE;
		END_IF;
	ELSE
		TONStFct_DeflectionSensorON(IN:=FALSE);
		TONStFct_DeflectionSensorOFF(IN:=TRUE,PT:=T#0.05s);
		IF TONStFct_DeflectionSensorOFF.Q THEN
			xStFct_DeflectionSensorON:=FALSE;
		END_IF;
	END_IF;
	(* Toruque Sensor ON/OFF-->Muss für 0.1s gesetzt bleiben, damit Sensor ON/OFF ist, damit Prellungen ausgeschaltet werden können *)
	IF ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn THEN
		TONStFct_TorqueSensorOFF(IN:=FALSE);
		TONStFct_TorqueSensorON(IN:=TRUE,PT:=T#0.04s);
		IF TONStFct_TorqueSensorON.Q THEN
			xStFct_TorqueSensorON:=TRUE;
		END_IF;
	ELSE
		TONStFct_TorqueSensorON(IN:=FALSE);
		TONStFct_TorqueSensorOFF(IN:=TRUE,PT:=T#0.04s);
		IF TONStFct_TorqueSensorOFF.Q THEN
			xStFct_TorqueSensorON:=FALSE;
		END_IF;
	END_IF;
	CASE iStFct_StepPrc OF
	1:	(* Offsets während Kalibrierung auf 0 setzen, aktuelle Werte für den Fehlerfall temporär ziwschen speichern*)
		xStFct_TmpSaveOffset:=TRUE;
		TONStFct_DeflectionSensorON(IN:=FALSE);
		TONStFct_DeflectionSensorOFF(IN:=FALSE);
		TONStFct_TorqueSensorON(IN:=FALSE);
		TONStFct_TorqueSensorOFF(IN:=FALSE);
		xStFct_DeflectionSensorON:=FALSE;
		xStFct_TorqueSensorON:=FALSE;
		IF  (T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1] < 0) THEN
			T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=2.0;
			rStFct_TmpOffsetDeflection:= 2.0;
		ELSE
			rStFct_TmpOffsetDeflection:= T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1];
		END_IF;
		IF (T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1] < 0) THEN
			T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]:=2.0;
			rStFct_TmpOffsetTorque:= 2.0;
		ELSE
			rStFct_TmpOffsetTorque:= T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1];
		END_IF;
		xStFct_DeflCalibError:=FALSE;
		xStFct_TorqueCalibError:=FALSE;
		IF NOT(xStFct_InitStep) THEN
			(* Falls die Spindel nicht bestromt ist, dann wird der Motorstrom eingeschaltet *)
			IF NOT(ptrTAxisS^.T_CtrleSingle.xPower) THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=3;	(* Strom einschalten *)
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			(* Zylinder für Überlast Drehmoment *)
			ptrTCylToolTorqueOverload^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolTorqueOverload^.T_Config.tDelayOn:=T#0.2s;
			CASE T_ExchgParam.bToolSpindleActive OF
			1:	(* Maxon Spindel *)
				ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_TorqueSystem.rMaxTorque_HCOver;	(* Dieser Zylinder muss aktiviert sein, anderenfalls führt es zu Probleme mit der Kalibrierung wegem auskoppeln der Spindel *)
			END_CASE;
			ptrTCylToolTorqueOverload^.T_CtrleCyl.xExecute:=(T_ExchgParam.bToolSpindleActive = 1);		(* nur ausführen wenn Maxon Spindel aktiv ist *)
			xStFct_InitStep:=TRUE;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND ptrTAxisS^.T_CtrleSingle.xPower AND
		     NOT(ptrTCylToolTorqueOverload^.T_CtrleCyl.xExecute) AND ptrTCylToolTorqueOverload^.T_CtrleCyl.xDone THEN
			IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolDeflection THEN
				FOR iStFct_ii:=5 TO 2 BY -1 DO
					T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[iStFct_ii]:=T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[iStFct_ii-1];
				END_FOR;
			END_IF;
			IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolTorque THEN
				FOR iStFct_ii:=5 TO 2 BY -1 DO
					T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[iStFct_ii]:=T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[iStFct_ii-1];
				END_FOR;
			END_IF;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	2:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			IF ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=6;	(* Move Velocity *)
			ELSE
				ptrTAxisS^.T_CtrleSingle.iFunction:=12;	(* Move Velocity with new velocity *)
			END_IF;
			ptrTAxisS^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_OnlineChange.rWorkingSpindleSpeed;
			ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) THEN
			rStFct_ForceDeflection:=rStFct_TmpOffsetDeflection;
			rStFct_ForceTorque:=rStFct_TmpOffsetTorque;
			IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolDeflection THEN
				T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=0.0;
			END_IF;
			IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolTorque THEN
				T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]:=0.0;
			END_IF;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	(* Überprüfe zuerst ob die Sensorik in Ordnung ist *)
	3:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolDeflection THEN
				(* Zylinder für Auslenkung-->ausschalten *)
				ptrTCylToolDeflection^.T_CtrleCyl.iFunction:=1;
				ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.tDelayActiv:=T#0s;
				ptrTCylToolDeflection^.T_Config.tDelayOff:=T#0.3s;
				ptrTCylToolDeflection^.T_Config.xCtrlePosOff:=FALSE;
				ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceIn:=0.0;
				ptrTCylToolDeflection^.T_CtrleCyl.xExecute:=TRUE;
			END_IF;
			IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolTorque THEN
				(* Zylinder für Drehmoment-->ausschalten *)
				ptrTCylToolTorqueHC^.T_CtrleCyl.iFunction:=1;
				ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.tDelayActiv:=T#0s;
				ptrTCylToolTorqueHC^.T_Config.tDelayOff:=T#1.0s;
				ptrTCylToolTorqueHC^.T_Config.xCtrlePosOff:=FALSE;
				ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.rForceIn:=0.0;
				ptrTCylToolTorqueHC^.T_CtrleCyl.xExecute:=TRUE;
			END_IF;
			xStFct_ToolTorqueCheckedOK:=FALSE;
		END_IF;
		IF ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn THEN
			xStFct_ToolTorqueCheckedOK:=TRUE;
			ptrTCylToolTorqueHC^.T_CtrleCyl.xReset:=TRUE;
		END_IF;
		IF NOT(ptrTCylToolDeflection^.T_CtrleCyl.xExecute) AND ptrTCylToolDeflection^.T_CtrleCyl.xDone AND
		     NOT(ptrTCylToolTorqueHC^.T_CtrleCyl.xExecute) AND ptrTCylToolTorqueHC^.T_CtrleCyl.xDone THEN
			xStFct_CheckState1:=ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn;
			xStFct_CheckState2:=ptrTCylToolTorqueHC^.T_CtrleCyl.xStatePosOn OR xStFct_ToolTorqueCheckedOK;
			xStFct_CheckActive1:=T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolDeflection;
			xStFct_CheckActive2:=T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolTorque;
			IF (xStFct_CheckState1 AND xStFct_CheckState2) OR
			     (NOT(xStFct_CheckState1) AND NOT(xStFct_CheckActive1) AND xStFct_CheckState2 AND xStFct_CheckActive2) OR
			     (xStFct_CheckState1 AND xStFct_CheckActive1 AND NOT(xStFct_CheckState2) AND NOT(xStFct_CheckActive2)) THEN
				IF xStFct_CheckActive1 THEN
					iStFct_StepPrc:=iStFct_StepPrc + 1;
					xStFct_FirstTime:=TRUE;
				ELSE
					iStFct_StepPrc:=7;
				END_IF;
				IF xStFct_CheckActive2 THEN
					xStFct_StartPrc_Parallel:=TRUE;		(* Start Parallel Prozedur *)
					xStFct_FirstTimeTorque:=TRUE;
				END_IF;
				xStFct_StartMainPrc:=FALSE;
				xStFct_InitStep:=FALSE;
			ELSE
				IF xStFct_CheckActive1 AND xStFct_CheckActive2 THEN
					IF NOT(xStFct_CheckState1) AND xStFct_CheckState2 AND xStFct_CheckActive1 THEN
						diStFct_TmpErrorNr:=38;		(* Kalibrierung-->ZylWzAuslenkung Zylinder blockiert *)
					ELSIF xStFct_CheckState1 AND NOT(xStFct_CheckState2) AND xStFct_CheckActive2 THEN
						diStFct_TmpErrorNr:=39;		(* Kalibrierung-->ZylWzDrehmHC Zylinder blockiert *)
					ELSE
						diStFct_TmpErrorNr:=40;		(* Kalibrierung-->ZylWzAuslenkung+ZylWzDrehmHC Zylinder blockiert *)
					END_IF;
					T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=rStFct_TmpOffsetDeflection;
					T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]:=rStFct_TmpOffsetTorque;
					xStFct_HardwareError:=TRUE;
					RETURN;
				ELSE
					IF NOT(xStFct_CheckState1) AND xStFct_CheckActive1 THEN
						diStFct_TmpErrorNr:=38;		(* Kalibrierung-->ZylWzAuslenkung Zylinder blockiert *)
					ELSIF NOT(xStFct_CheckState2) AND xStFct_CheckActive2 THEN
						diStFct_TmpErrorNr:=39;		(* Kalibrierung-->ZylWzDrehmHC Zylinder blockiert *)
					END_IF;
					T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=rStFct_TmpOffsetDeflection;
					T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]:=rStFct_TmpOffsetTorque;
					xStFct_HardwareError:=TRUE;
				END_IF;
			END_IF;
		END_IF;
	4:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			xStFct_SetForceToolDeflection:=TRUE;
		END_IF;
		IF NOT(xStFct_SetForceToolDeflection) THEN
			IF NOT(xStFct_DeflectionSensorON) THEN
				IF NOT(xStFct_FirstTime) THEN
					xStFct_StartMainPrc:=FALSE;
					xStFct_InitStep:=FALSE;
					iStFct_StepPrc:=iStFct_StepPrc + 1;
					xStFct_FirstTime:=TRUE;
				ELSE
					xStFct_FirstTime:=FALSE;
					rStFct_ForceDeflection:=rStFct_ForceDeflection + 0.05;
					xStFct_InitStep:=FALSE;
				END_IF;
			ELSE
				rStFct_ForceDeflection:=rStFct_ForceDeflection + 0.1;
				xStFct_InitStep:=FALSE;
			END_IF;
		END_IF;
	5:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			xStFct_SetForceToolDeflection:=TRUE;
		END_IF;
		IF NOT(xStFct_SetForceToolDeflection) THEN
			IF NOT(xStFct_DeflectionSensorON) THEN
				rStFct_ForceDeflection:=rStFct_ForceDeflection - 0.05;
				xStFct_InitStep:=FALSE;
			ELSE
				IF NOT(xStFct_FirstTime) THEN
					xStFct_StartMainPrc:=FALSE;
					xStFct_InitStep:=FALSE;
					iStFct_StepPrc:=iStFct_StepPrc + 1;
					xStFct_FirstTime:=TRUE;
				ELSE
					xStFct_FirstTime:=FALSE;
					rStFct_ForceDeflection:=rStFct_ForceDeflection - 0.03;
					xStFct_InitStep:=FALSE;
				END_IF;
			END_IF;
		END_IF;
	6:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			xStFct_SetForceToolDeflection:=TRUE;
		END_IF;
		IF NOT(xStFct_SetForceToolDeflection) THEN
			IF NOT(xStFct_DeflectionSensorON) THEN
				IF NOT(xStFct_FirstTime) THEN
					T_Station_Work.THWWorkStation.TCtrlWork.rOffsetToolDeflection:=rStFct_ForceDeflection;
					T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=rStFct_ForceDeflection;
					xStFct_SetForceToolDeflection:=TRUE;
					rStFct_ForceDeflection:=T_Station_Parameter.T_OnlineChange.rForceDeflection;
					xStFct_StartMainPrc:=FALSE;
					xStFct_InitStep:=FALSE;
					iStFct_StepPrc:=iStFct_StepPrc + 1;
				ELSE
					xStFct_FirstTime:=FALSE;
					rStFct_ForceDeflection:=rStFct_ForceDeflection + 0.01;
					xStFct_InitStep:=FALSE;
				END_IF;
			ELSE
				rStFct_ForceDeflection:=rStFct_ForceDeflection + 0.01;
				xStFct_InitStep:=FALSE;
			END_IF;
		END_IF;
	7:	IF NOT(xStFct_InitStep) THEN
			IF NOT(xStFct_StartPrc_Parallel) THEN
				xStFct_InitStep:=TRUE;
				IF T_Station_Work.THWWorkStation.TCtrlWork.xStopToolRotation THEN
					T_Station_Work.THWWorkStation.TCtrlWork.xStopToolRotation:=FALSE;
					ptrTAxisS^.T_CtrleSingle.iFunction:=5;
					ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
				ELSE
					iStFct_StepPrc:=iStFct_StepPrc + 2;
					xStFct_StartMainPrc:=FALSE;
					xStFct_InitStep:=FALSE;
					RETURN;
				END_IF;
			END_IF;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND ptrTAxisS^.T_CtrleSingle.xNotMoving AND NOT(xStFct_StartPrc_Parallel) THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	8:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisS^.T_CtrleSingle.iFunction:=4;	(* Strom ausschalten *)
			ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND NOT(ptrTAxisS^.T_CtrleSingle.xPower) THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	9:	IF NOT(xStFct_StartPrc_Parallel) AND NOT(xStFct_SetForceToolDeflection) THEN
			IF xStFct_DeflCalibError OR xStFct_TorqueCalibError THEN
				IF xStFct_DeflCalibError AND NOT(xStFct_TorqueCalibError) THEN
					diStFct_TmpErrorNr:=6;		(* Kalibrierung-->ZylWzAuslenkung Sensor fehlerhaft *)
				ELSIF NOT(xStFct_DeflCalibError) AND xStFct_TorqueCalibError THEN
					diStFct_TmpErrorNr:=7;		(* Kalibrierung-->ZylWzDrehmHC Sensor fehlerhaft *)
				ELSE
					diStFct_TmpErrorNr:=8;		(* Kalibrierung-->ZylWzAuslenkung+ZylWzDrehmHC Sensor fehlerhaft *)
				END_IF;
				T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=rStFct_TmpOffsetDeflection;
				T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]:=rStFct_TmpOffsetTorque;
				xStFct_HardwareError:=TRUE;
				RETURN;
			END_IF;
			xStFct_TmpSaveOffset:=FALSE;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=0;
			xStFct_SetEnd:=TRUE;
		END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Parallelablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartPrc_Parallel AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) THEN
	CASE iStFct_StepPrc_Parallel OF
	1:	IF NOT(xStFct_InitStep_Parallel) THEN
			xStFct_InitStep_Parallel:=TRUE;
			xStFct_SetForceToolTorque:=TRUE;
		END_IF;
		IF NOT(xStFct_SetForceToolTorque) THEN
			IF NOT(xStFct_TorqueSensorON) THEN
				IF NOT(xStFct_FirstTimeTorque) THEN
					xStFct_FirstTimeTorque:=TRUE;
					xStFct_InitStep_Parallel:=FALSE;
					iStFct_StepPrc_Parallel:=iStFct_StepPrc_Parallel + 1;
				ELSE
					xStFct_FirstTimeTorque:=FALSE;
					rStFct_ForceTorque:=rStFct_ForceTorque + 0.05;
					xStFct_InitStep_Parallel:=FALSE;
				END_IF;
			ELSE
				rStFct_ForceTorque:=rStFct_ForceTorque + 0.1;
				xStFct_InitStep_Parallel:=FALSE;
			END_IF;
		END_IF;
	2:	IF NOT(xStFct_InitStep_Parallel) THEN
			xStFct_InitStep_Parallel:=TRUE;
			xStFct_SetForceToolTorque:=TRUE;
		END_IF;
		IF NOT(xStFct_SetForceToolTorque) THEN
			IF NOT(xStFct_TorqueSensorON) THEN
				rStFct_ForceTorque:=rStFct_ForceTorque - 0.05;
				xStFct_InitStep_Parallel:=FALSE;
			ELSE
				IF NOT(xStFct_FirstTimeTorque) THEN
					xStFct_FirstTimeTorque:=TRUE;
					xStFct_InitStep_Parallel:=FALSE;
					iStFct_StepPrc_Parallel:=iStFct_StepPrc_Parallel + 1;
				ELSE
					xStFct_FirstTimeTorque:=FALSE;
					rStFct_ForceTorque:=rStFct_ForceTorque - 0.03;
					xStFct_InitStep_Parallel:=FALSE;
				END_IF;
			END_IF;
		END_IF;
	3:	IF NOT(xStFct_InitStep_Parallel) THEN
			xStFct_InitStep_Parallel:=TRUE;
			xStFct_SetForceToolTorque:=TRUE;
		END_IF;
		IF NOT(xStFct_SetForceToolTorque) THEN
			IF NOT(xStFct_TorqueSensorON) THEN
				IF NOT(xStFct_FirstTimeTorque) THEN
					T_Station_Work.THWWorkStation.TCtrlWork.rOffsetToolTorque:=rStFct_ForceTorque;
					T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]:=rStFct_ForceTorque;
					xStFct_SetForceToolTorque:=TRUE;
					rStFct_ForceTorque:=T_Station_Parameter.T_OnlineChange.rTorqueLevelHC;
					iStFct_StepPrc_Parallel:=1;
					xStFct_InitStep_Parallel:=FALSE;
					xStFct_StartPrc_Parallel:=FALSE;
				ELSE
					xStFct_FirstTimeTorque:=FALSE;
					rStFct_ForceTorque:=rStFct_ForceTorque + 0.01;
					xStFct_InitStep_Parallel:=FALSE;
				END_IF;
			ELSE
				rStFct_ForceTorque:=rStFct_ForceTorque + 0.01;
				xStFct_InitStep_Parallel:=FALSE;
			END_IF;
		END_IF;
	END_CASE;
END_IF;
IF xStFct_SetForceToolDeflection THEN
	CASE iStFct_StepSetForceToolDeflection OF
		1:	ptrTCylToolDeflection^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.tDelayActiv:=T#0s;
			ptrTCylToolDeflection^.T_Config.tDelayOn:=T#0.15s;
			ptrTCylToolDeflection^.T_Config.xCtrlePosOn:=FALSE;
			ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceIn:=rStFct_ForceDeflection;
			ptrTCylToolDeflection^.T_CtrleCyl.xExecute:=TRUE;
			iStFct_StepSetForceToolDeflection:=iStFct_StepSetForceToolDeflection + 1;
		2:	IF NOT(ptrTCylToolDeflection^.T_CtrleCyl.xExecute) AND ptrTCylToolDeflection^.T_CtrleCyl.xDone THEN
				xStFct_SetForceToolDeflection:=FALSE;
				iStFct_StepSetForceToolDeflection:=1;
			END_IF;
	END_CASE;
ELSE
	iStFct_StepSetForceToolDeflection:=1;
END_IF;
IF xStFct_SetForceToolTorque THEN
	CASE iStFct_StepSetForceToolTorque OF
		1:	ptrTCylToolTorqueHC^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.tDelayActiv:=T#0s;
			ptrTCylToolTorqueHC^.T_Config.tDelayOn:=T#0.15s;
			ptrTCylToolTorqueHC^.T_Config.xCtrlePosOn:=FALSE;
			ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.rForceIn:=rStFct_ForceTorque;
			ptrTCylToolTorqueHC^.T_CtrleCyl.xExecute:=TRUE;
			iStFct_StepSetForceToolTorque:=iStFct_StepSetForceToolTorque + 1;
		2:	IF NOT(ptrTCylToolTorqueHC^.T_CtrleCyl.xExecute) AND ptrTCylToolTorqueHC^.T_CtrleCyl.xDone THEN
				xStFct_SetForceToolTorque:=FALSE;
				iStFct_StepSetForceToolTorque:=1;
			END_IF;
	END_CASE;
ELSE
	iStFct_StepSetForceToolTorque:=1;
END_IF;
(******************************************************************************************************************************************)
(****************************				     Stationsfunktion Endprozedur                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_End;
END_ACTION

ACTION	StationFunction_Fct_07_Calibration2:
(******************************************************************************************************************************************)
(****************************				           Reset Stationsfunktion                                            *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Reset;
(******************************************************************************************************************************************)
(****************************			        Stationsfunktion Fehler Controller                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Error;
(******************************************************************************************************************************************)
(****************************				    Stationsfunktion Haupt Controller                               *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Main;
(******************************************************************************************************************************************)
(****************************			         Stationsfunktion sofort Unterbrechung                           *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Stop;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Hauptablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_TmpStop AND NOT(xStFct_HardwareError) THEN
	T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=rStFct_TmpOffsetDeflection;
	T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]:=rStFct_TmpOffsetTorque;
END_IF;
IF xStFct_StartMainPrc AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) AND NOT(xStFct_TmpStop) THEN
	IF ((iStFct_StepPrc >= 4) AND (iStFct_StepPrc <= 6)) OR xStFct_StartPrc_Parallel THEN
		IF ((iStFct_StepPrc >= 4) AND (iStFct_StepPrc <= 6)) THEN
			T_Station_Work.THWWorkStation.TCtrlWork.rOffsetToolDeflection:=rStFct_ForceDeflection;
		END_IF;
		IF xStFct_StartPrc_Parallel THEN
			T_Station_Work.THWWorkStation.TCtrlWork.rOffsetToolTorque:=rStFct_ForceTorque;
		END_IF;
		IF NOT(xStFct_DeflCalibError) AND ((rStFct_ForceDeflection < 0) OR (rStFct_ForceDeflection > (T_Station_Parameter.T_SpindleSystem.rMaxDeflectionForce + rStFct_TmpOffsetDeflection))) THEN
			xStFct_DeflCalibError:=TRUE;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=7;
			T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=rStFct_TmpOffsetDeflection;
		END_IF;
	END_IF;
	IF T_Station_Work.THWWorkStation.TCtrlWork.xWorkStopToolRotation THEN
		T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=rStFct_TmpOffsetDeflection;
		T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]:=rStFct_TmpOffsetTorque;
		xStFct_TmpSaveOffset:=FALSE;
		xStFct_StartMainPrc:=FALSE;
		xStFct_InitStep:=FALSE;
		iStFct_StepPrc:=0;
		xStFct_SetEnd:=TRUE;
	END_IF;
	(* Deflection Sensor ON/OFF-->Muss für 0.1s gesetzt bleiben, damit Sensor ON/OFF ist, damit Prellungen ausgeschaltet werden können *)
	IF ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn THEN
		TONStFct_DeflectionSensorOFF(IN:=FALSE);
		TONStFct_DeflectionSensorON(IN:=TRUE,PT:=T#0.1s);
		IF TONStFct_DeflectionSensorON.Q THEN
			xStFct_DeflectionSensorON:=TRUE;
		END_IF;
	ELSE
		TONStFct_DeflectionSensorON(IN:=FALSE);
		TONStFct_DeflectionSensorOFF(IN:=TRUE,PT:=T#0.1s);
		IF TONStFct_DeflectionSensorOFF.Q THEN
			xStFct_DeflectionSensorON:=FALSE;
		END_IF;
	END_IF;
	CASE iStFct_StepPrc OF
	1:	IF gxHardwareOFF OR gxAxisOFF THEN
			iStFct_StepPrc:=9;
			RETURN;
		END_IF;
		(* Offsets während Kalibrierung auf 0 setzen, aktuelle Werte für den Fehlerfall temporär ziwschen speichern*)
		xStFct_TmpSaveOffset:=TRUE;
		TONStFct_DeflectionSensorON(IN:=FALSE);
		TONStFct_DeflectionSensorOFF(IN:=FALSE);
		xStFct_DeflectionSensorON:=FALSE;
		IF  (T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1] < 0) THEN
			T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=6.0;
			rStFct_TmpOffsetDeflection:= 6.0;
		ELSE
			rStFct_TmpOffsetDeflection:= T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1];
		END_IF;
		IF (T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1] < 0) THEN
			T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]:=3.0;
			rStFct_TmpOffsetTorque:= 3.0;
		ELSE
			rStFct_TmpOffsetTorque:= T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1];
		END_IF;
		xStFct_DeflCalibError:=FALSE;
		IF NOT(xStFct_InitStep) THEN
			(* Falls die Spindel nicht bestromt ist, dann wird der Motorstrom eingeschaltet *)
			IF NOT(ptrTAxisS^.T_CtrleSingle.xPower) THEN
				xStFct_InitStep:=TRUE;
				IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolTorque THEN
					ptrTAxisS^.T_CtrleSingle.iFunction:=3;	(* Strom einschalten *)
					ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
		END_IF;
		IF (NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND ptrTAxisS^.T_CtrleSingle.xPower) OR NOT(T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolTorque) THEN
			IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolDeflection THEN
				FOR iStFct_ii:=5 TO 2 BY -1 DO
					T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[iStFct_ii]:=T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[iStFct_ii-1];
				END_FOR;
			END_IF;
			IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolTorque THEN
				FOR iStFct_ii:=5 TO 2 BY -1 DO
					T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[iStFct_ii]:=T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[iStFct_ii-1];
				END_FOR;
			END_IF;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	2:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolTorque THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=6;	(* Move Velocity *)
				ptrTAxisS^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_OnlineChange.rWorkingSpindleSpeed;
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF (NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving)) OR NOT(T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolTorque) THEN
			rStFct_ForceDeflection:=rStFct_TmpOffsetDeflection;
			rStFct_ForceTorque:=rStFct_TmpOffsetTorque;
			IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolDeflection THEN
				T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=0.0;
			END_IF;
			IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolTorque THEN
				T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]:=0.0;
			END_IF;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	(* Überprüfe zuerst ob die Sensorik in Ordnung ist *)
	3:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolDeflection THEN
				(* Zylinder für Auslenkung-->ausschalten *)
				ptrTCylToolDeflection^.T_CtrleCyl.iFunction:=1;
				ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.tDelayActiv:=T#0s;
				ptrTCylToolDeflection^.T_Config.tDelayOff:=T#0.3s;
				ptrTCylToolDeflection^.T_Config.xCtrlePosOff:=FALSE;
				ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceIn:=0.0;
				ptrTCylToolDeflection^.T_CtrleCyl.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF NOT(ptrTCylToolDeflection^.T_CtrleCyl.xExecute) AND ptrTCylToolDeflection^.T_CtrleCyl.xDone THEN
			IF NOT(T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolDeflection AND NOT(ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn)) THEN
				IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolDeflection THEN
					iStFct_StepPrc:=iStFct_StepPrc + 1;
					xStFct_FirstTime:=TRUE;
				ELSE
					iStFct_StepPrc:=7;
				END_IF;
				IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolTorque THEN
					xStFct_StartPrc_Parallel:=TRUE;		(* Start Parallel Prozedur *)
				END_IF;
				xStFct_StartMainPrc:=FALSE;
				xStFct_InitStep:=FALSE;
			ELSE
				diStFct_TmpErrorNr:=35;		(* Kalibrierung-->ZylWzAuslenkung Zylinder blockiert *)
				xStFct_HardwareError:=TRUE;
				RETURN;
			END_IF;
		END_IF;
	4:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			xStFct_SetForceToolDeflection:=TRUE;
		END_IF;
		IF NOT(xStFct_SetForceToolDeflection) THEN
			IF NOT(xStFct_DeflectionSensorON) THEN
				IF NOT(xStFct_FirstTime) THEN
					xStFct_StartMainPrc:=FALSE;
					xStFct_InitStep:=FALSE;
					iStFct_StepPrc:=iStFct_StepPrc + 1;
					xStFct_FirstTime:=TRUE;
				ELSE
					xStFct_FirstTime:=FALSE;
					rStFct_ForceDeflection:=rStFct_ForceDeflection + 0.05;
					xStFct_InitStep:=FALSE;
				END_IF;
			ELSE
				rStFct_ForceDeflection:=rStFct_ForceDeflection + 0.1;
				xStFct_InitStep:=FALSE;
			END_IF;
		END_IF;
	5:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			xStFct_SetForceToolDeflection:=TRUE;
		END_IF;
		IF NOT(xStFct_SetForceToolDeflection) THEN
			IF NOT(xStFct_DeflectionSensorON) THEN
				rStFct_ForceDeflection:=rStFct_ForceDeflection - 0.05;
				xStFct_InitStep:=FALSE;
			ELSE
				IF NOT(xStFct_FirstTime) THEN
					xStFct_StartMainPrc:=FALSE;
					xStFct_InitStep:=FALSE;
					iStFct_StepPrc:=iStFct_StepPrc + 1;
					xStFct_FirstTime:=TRUE;
				ELSE
					xStFct_FirstTime:=FALSE;
					rStFct_ForceDeflection:=rStFct_ForceDeflection - 0.03;
					xStFct_InitStep:=FALSE;
				END_IF;
			END_IF;
		END_IF;
	6:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			xStFct_SetForceToolDeflection:=TRUE;
		END_IF;
		IF NOT(xStFct_SetForceToolDeflection) THEN
			IF NOT(xStFct_DeflectionSensorON) THEN
				IF NOT(xStFct_FirstTime) THEN
					T_Station_Work.THWWorkStation.TCtrlWork.rOffsetToolDeflection:=rStFct_ForceDeflection;
					T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=rStFct_ForceDeflection;
					xStFct_SetForceToolDeflection:=TRUE;
					rStFct_ForceDeflection:=T_Station_Parameter.T_OnlineChange.rForceDeflection;
					xStFct_StartMainPrc:=FALSE;
					xStFct_InitStep:=FALSE;
					iStFct_StepPrc:=iStFct_StepPrc + 1;
				ELSE
					xStFct_FirstTime:=FALSE;
					rStFct_ForceDeflection:=rStFct_ForceDeflection + 0.01;
					xStFct_InitStep:=FALSE;
				END_IF;
			ELSE
				rStFct_ForceDeflection:=rStFct_ForceDeflection + 0.01;
				xStFct_InitStep:=FALSE;
			END_IF;
		END_IF;
	7:	IF NOT(xStFct_InitStep) THEN
			IF NOT(xStFct_StartPrc_Parallel) THEN
				xStFct_InitStep:=TRUE;
				IF T_Station_Work.THWWorkStation.TCtrlWork.xStopToolRotation THEN
					T_Station_Work.THWWorkStation.TCtrlWork.xStopToolRotation:=FALSE;
					IF T_Station_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolTorque THEN
						ptrTAxisS^.T_CtrleSingle.iFunction:=5;
						ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
					END_IF;
				ELSE
					iStFct_StepPrc:=iStFct_StepPrc + 2;
					xStFct_StartMainPrc:=FALSE;
					xStFct_InitStep:=FALSE;
					RETURN;
				END_IF;
			END_IF;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND ptrTAxisS^.T_CtrleSingle.xNotMoving AND NOT(xStFct_StartPrc_Parallel) THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	8:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisS^.T_CtrleSingle.iFunction:=4;	(* Strom ausschalten *)
			ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND NOT(ptrTAxisS^.T_CtrleSingle.xPower) THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	9:	IF NOT(xStFct_StartPrc_Parallel) AND NOT(xStFct_SetForceToolDeflection) THEN
			IF xStFct_DeflCalibError THEN
				IF xStFct_DeflCalibError THEN
					diStFct_TmpErrorNr:=36;		(* Kalibrierung-->ZylWzAuslenkung Sensor fehlerhaft *)
				END_IF;
				xStFct_HardwareError:=TRUE;
				RETURN;
			END_IF;
			xStFct_TmpSaveOffset:=FALSE;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=0;
			xStFct_SetEnd:=TRUE;
		END_IF;
	END_CASE;
END_IF;
IF xStFct_TmpSaveOffset AND xStFct_SetEnd THEN
	(* Im Fehlerfall oder die Funktion gestoppt wird muss der alte Wert wieder übergeben werden *)
	xStFct_TmpSaveOffset:=FALSE;
	T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=rStFct_TmpOffsetDeflection;
	T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]:=rStFct_TmpOffsetTorque;
END_IF;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Parallelablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartPrc_Parallel AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) THEN
	CASE iStFct_StepPrc_Parallel OF
	1:	IF NOT(xStFct_InitStep_Parallel) THEN
			xStFct_InitStep_Parallel:=TRUE;
			TONStFct_WaitMeasure(IN:=FALSE);
		END_IF;
		TONStFct_WaitMeasure(IN:=TRUE,PT:=T#0.2s);
		IF TONStFct_WaitMeasure.Q THEN
			TONStFct_WaitMeasure(IN:=FALSE);
			xStFct_InitStep_Parallel:=FALSE;
			iStFct_MeasuringStep:=iStFct_MeasuringStep + 1;
			IF (iStFct_MeasuringStep <= 20) THEN
				arStFct_NullPointToolTorque[iStFct_MeasuringStep]:=ptrTSensorTorque^.T_CtrleCyl.T_Analog.rPosIn;
				rStFct_ForceTorque:=ptrTSensorTorque^.T_CtrleCyl.T_Analog.rPosIn;
			ELSE
				iStFct_StepPrc_Parallel:=iStFct_StepPrc_Parallel + 1;
			END_IF;
		END_IF;
	2:	rStFct_NullPointToolTorque:=0.0;
		FOR iStFct_ii:=1 TO 20 DO
			rStFct_NullPointToolTorque:=rStFct_NullPointToolTorque + arStFct_NullPointToolTorque[iStFct_ii];
		END_FOR;
		rStFct_ForceTorque:=rStFct_NullPointToolTorque / 20.0;
		T_Station_Work.THWWorkStation.TCtrlWork.rOffsetToolTorque:=rStFct_ForceTorque;
		T_Station_Parameter.T_Fct_SpindleCalibration.arOffsetToolTorque[1]:=rStFct_ForceTorque;
		iStFct_StepPrc_Parallel:=1;
		xStFct_InitStep_Parallel:=FALSE;
		xStFct_StartPrc_Parallel:=FALSE;
	END_CASE;
ELSE
	iStFct_MeasuringStep:=0;
END_IF;
IF xStFct_SetForceToolDeflection THEN
	CASE iStFct_StepSetForceToolDeflection OF
		1:	ptrTCylToolDeflection^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.tDelayActiv:=T#0s;
			ptrTCylToolDeflection^.T_Config.tDelayOn:=T#0.15s;
			ptrTCylToolDeflection^.T_Config.xCtrlePosOn:=FALSE;
			ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceIn:=rStFct_ForceDeflection;
			ptrTCylToolDeflection^.T_CtrleCyl.xExecute:=TRUE;
			iStFct_StepSetForceToolDeflection:=iStFct_StepSetForceToolDeflection + 1;
		2:	IF NOT(ptrTCylToolDeflection^.T_CtrleCyl.xExecute) AND ptrTCylToolDeflection^.T_CtrleCyl.xDone THEN
				xStFct_SetForceToolDeflection:=FALSE;
				iStFct_StepSetForceToolDeflection:=1;
			END_IF;
	END_CASE;
ELSE
	iStFct_StepSetForceToolDeflection:=1;
END_IF;
(******************************************************************************************************************************************)
(****************************				     Stationsfunktion Endprozedur                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_End;
END_ACTION

ACTION	StationFunction_Fct_08_SpindleBurnIn:
(******************************************************************************************************************************************)
(****************************				           Reset Stationsfunktion                                            *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Reset;
(******************************************************************************************************************************************)
(****************************			        Stationsfunktion Fehler Controller                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Error;
(******************************************************************************************************************************************)
(****************************				    Stationsfunktion Haupt Controller                               *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Main;
(******************************************************************************************************************************************)
(****************************			         Stationsfunktion sofort Unterbrechung                           *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Stop;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Hauptablauf                                       *****************************)
(******************************************************************************************************************************************)
IF (T_Station_Parameter.T_Fct_SpindleBurnIn.rTimeMaxActiveFunction <> 0) THEN	(* If the Time is 0, than the function is active as long as the operator does stop *)
	tStFct_MaxTimeActiveFunction:=REAL_TO_TIME(T_Station_Parameter.T_Fct_SpindleBurnIn.rTimeMaxActiveFunction * 1000);
	IF (iStFct_StepPrc > 1) AND (iStFct_StepPrc < 10) THEN
		fbStFct_TONChkMaxTimeActive(IN:=TRUE,PT:=tStFct_MaxTimeActiveFunction);
		IF fbStFct_TONChkMaxTimeActive.Q THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=10;
		END_IF;
	END_IF;
END_IF;
tStFct_TimeSpindleActive:=REAL_TO_TIME(T_Station_Parameter.T_Fct_SpindleBurnIn.rTimeSpindleActive * 1000.0);
IF (tStFct_TimeSpindleActive = T#0s) THEN tStFct_TimeSpindleActive:=T#5s; END_IF;
tStFct_TimeSpindleInactive:=REAL_TO_TIME(T_Station_Parameter.T_Fct_SpindleBurnIn.rTimeSpindleInactive * 1000.0);
IF (tStFct_TimeSpindleInactive = T#0s) THEN tStFct_TimeSpindleInactive:=T#5s; END_IF;
IF xStFct_StartMainPrc AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) AND NOT(xStFct_TmpStop) THEN
	CASE iStFct_StepPrc OF
	1:	fbStFct_TONChkMaxTimeActive(IN:=FALSE);
		IF NOT(xStFct_InitStep) THEN
			(* Falls die Spindel nicht bestromt ist, dann wird der Motorstrom eingeschaltet *)
			IF NOT(ptrTAxisS^.T_CtrleSingle.xPower) THEN
				xStFct_InitStep:=TRUE;
				ptrTAxisS^.T_CtrleSingle.iFunction:=3;	(* Strom einschalten *)
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND ptrTAxisS^.T_CtrleSingle.xPower THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	2:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			(* Zylinder für Auslenkung-->mit Workauslenkkraft *)
			ptrTCylToolDeflection^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolDeflection^.T_Config.tDelayOn:=T#0.3s;
			ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_OnlineChange.rForceDeflection;
			ptrTCylToolDeflection^.T_CtrleCyl.xExecute:=TRUE;
			(* Zylinder für Drehmoment HC-->mit Schwellwert Startposition *)
			ptrTCylToolTorqueHC^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolTorqueHC^.T_Config.tDelayOn:=T#0.2s;
			ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_OnlineChange.rTorqueLevelHC;
			ptrTCylToolTorqueHC^.T_CtrleCyl.xExecute:=TRUE;
			(* Zylinder für Überlast Drehmoment *)
			ptrTCylToolTorqueOverload^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolTorqueOverload^.T_Config.tDelayOn:=T#0.2s;
			ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_StProcess.rTorqueLevel_Overload;
			ptrTCylToolTorqueOverload^.T_CtrleCyl.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTCylToolDeflection^.T_CtrleCyl.xExecute) AND ptrTCylToolDeflection^.T_CtrleCyl.xDone AND
		     NOT(ptrTCylToolTorqueHC^.T_CtrleCyl.xExecute) AND ptrTCylToolTorqueHC^.T_CtrleCyl.xDone AND
		     NOT(ptrTCylToolTorqueOverload^.T_CtrleCyl.xExecute) AND ptrTCylToolTorqueOverload^.T_CtrleCyl.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	3:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			IF ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=6;	(* Move Velocity *)
			ELSE
				ptrTAxisS^.T_CtrleSingle.iFunction:=12;	(* Move Velocity *)
			END_IF;
			ptrTAxisS^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_Fct_SpindleBurnIn.rSpindleSpeed;
			ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	4:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			fbStFct_TONWaitCycle(IN:=FALSE);
		END_IF;
		fbStFct_TONWaitCycle(IN:=TRUE,PT:=tStFct_TimeSpindleActive);
		IF fbStFct_TONWaitCycle.Q THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	5:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisS^.T_CtrleSingle.iFunction:=5;
			ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	6:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			fbStFct_TONWaitCycle(IN:=FALSE);
		END_IF;
		fbStFct_TONWaitCycle(IN:=TRUE,PT:=tStFct_TimeSpindleInactive);
		IF fbStFct_TONWaitCycle.Q THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=3;
		END_IF;
	10:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisS^.T_CtrleSingle.iFunction:=5;
			ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	11:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			IF ptrTAxisS^.T_CtrleSingle.xPower THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=4;	(* Strom ausschalten *)
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone AND NOT(ptrTAxisS^.T_CtrleSingle.xPower) THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=0;
			xStFct_SetEnd:=TRUE;
		END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Parallelablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartPrc_Parallel AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) THEN
	CASE iStFct_StepPrc_Parallel OF
	1:	iStFct_StepPrc_Parallel:=1;
		xStFct_InitStep_Parallel:=FALSE;
		xStFct_StartPrc_Parallel:=FALSE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				     Stationsfunktion Endprozedur                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_End;
END_ACTION

ACTION	StationFunction_Fct_09_Initial_Z_Axis:
(******************************************************************************************************************************************)
(****************************				           Reset Stationsfunktion                                            *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Reset;
(******************************************************************************************************************************************)
(****************************			        Stationsfunktion Fehler Controller                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Error;
(******************************************************************************************************************************************)
(****************************				    Stationsfunktion Haupt Controller                               *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Main;
(******************************************************************************************************************************************)
(****************************			         Stationsfunktion sofort Unterbrechung                           *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Stop;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Hauptablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartMainPrc AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) AND NOT(xStFct_TmpStop) THEN
	CASE iStFct_StepPrc OF
	1:	wStFct_Status:=0;
		IF NOT(xStFct_InitStep) THEN
			(* Falls Z Achse sich bewegt, dann wird der Motor gestoppt *)
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) THEN
				xStFct_InitStep:=TRUE;
				ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone AND ptrTAxisZ^.T_CtrleSingle.xNotMoving THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	2:	IF NOT(xStFct_InitStep) THEN
			(* Falls Z Achse nicht bestromt ist, dann wird der Motorstrom eingeschaltet *)
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xPower) THEN
				xStFct_InitStep:=TRUE;
				ptrTAxisZ^.T_CtrleSingle.iFunction:=3;	(* Strom einschalten *)
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone AND ptrTAxisZ^.T_CtrleSingle.xPower THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	3:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			(* Zylinder für Auslenkung-->mit Workauslenkkraft *)
			ptrTCylToolDeflection^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolDeflection^.T_Config.tDelayOn:=T#0.3s;
			ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_OnlineChange.rForceDeflection;
			ptrTCylToolDeflection^.T_CtrleCyl.xExecute:=TRUE;
			(* Zylinder für Drehmoment HC-->mit Schwellwert Startposition *)
			ptrTCylToolTorqueHC^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolTorqueHC^.T_Config.tDelayOn:=T#0.2s;
			ptrTCylToolTorqueHC^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_OnlineChange.rTorqueLevelHC;
			ptrTCylToolTorqueHC^.T_CtrleCyl.xExecute:=TRUE;
			(* Zylinder für Überlast Drehmoment *)
			ptrTCylToolTorqueOverload^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolTorqueOverload^.T_Config.tDelayOn:=T#0.2s;
			ptrTCylToolTorqueOverload^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_StProcess.rTorqueLevel_Overload;
			ptrTCylToolTorqueOverload^.T_CtrleCyl.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTCylToolDeflection^.T_CtrleCyl.xExecute) AND ptrTCylToolDeflection^.T_CtrleCyl.xDone AND
		     NOT(ptrTCylToolTorqueHC^.T_CtrleCyl.xExecute) AND ptrTCylToolTorqueHC^.T_CtrleCyl.xDone AND
		     NOT(ptrTCylToolTorqueOverload^.T_CtrleCyl.xExecute) AND ptrTCylToolTorqueOverload^.T_CtrleCyl.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	(* Aufsuchen des negativen Endschalter der Z Achse *)
	4:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=6;	(* Geschwindigkeits Bewegung *)
			ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_AxisState.rZDetectEndSwitchSpeed * -1.0;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	(* Sobald der Endschalter eintrifft muss der Treiber gestoppt werden-->Achse stoppt von selbst *)
	5:	IF ptrTAxisZ^.T_CtrleSingle.xStateHWLimitNeg THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	(* Achsen Treiber wird gestoppt *)
	6:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) AND ptrTAxisZ^.T_CtrleSingle.xDone AND NOT(ptrTAxisZ^.T_CtrleSingle.xStateHWLimitNeg) THEN
				ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone AND ptrTAxisZ^.T_CtrleSingle.xReady AND ptrTAxisZ^.T_CtrleSingle.xPower THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			IF ptrTAxisZ^.T_CtrleSingle.xNotMoving THEN
				iStFct_StepPrc:=iStFct_StepPrc + 1;
			END_IF;
		END_IF;
	(* Warten bis die Achse wieder bereit steht *)
	7:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			TONStFct_WaitAxisReady(IN:=FALSE);
		END_IF;
		TONStFct_WaitAxisReady(IN:=TRUE,PT:=T#0.5s);
		IF TONStFct_WaitAxisReady.Q THEN
			TONStFct_WaitAxisReady(IN:=FALSE);
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	(* Bewege die Achse weg vom Endschalter bis der Endschalter nicht mehr angibt + 1mm reserve *)
	8:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=6;	(* Geschwindigkeits Bewegung *)
			ptrTAxisZ^.T_CtrleSingle.lrVelocity:=1.0;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	(* Sobald der Endschalter nicht mehr bedämpft ist und 1mm gefahren wurde dann muss die Achse gestoppt werden *)
	9:	IF NOT(ptrTAxisZ^.T_CtrleSingle.xStateHWLimitNeg) THEN
			lrStFct_SaveAxisPosition:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	(* Abwarten bis 0.5mm nach dem Endschalter abgefahren ist und dann die Achse stoppen *)
	10:	IF (ptrTAxisZ^.T_LiveValue.lrActualPosition >= (lrStFct_SaveAxisPosition + 0.5)) THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	(* Achse muss gestoppt werden *)
	11:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			IF NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
				ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			IF ptrTAxisZ^.T_CtrleSingle.xNotMoving THEN
				iStFct_StepPrc:=iStFct_StepPrc + 1;
			END_IF;
		END_IF;
	(* Übernehmen der Position *)
	12:	T_Station_Parameter.T_AxisState.rPositionNegLimitSwitchZAxis_Old:=	T_Station_Parameter.T_AxisState.rPositionNegLimitSwitchZAxis;
		T_Station_Parameter.T_AxisState.rPositionNegLimitSwitchZAxis:=		ptrTAxisZ^.T_LiveValue.lrActualPosition;
		xStFct_StartMainPrc:=FALSE;
		xStFct_InitStep:=FALSE;
		iStFct_StepPrc:=iStFct_StepPrc + 1;
	13:	xStFct_StartMainPrc:=FALSE;
		xStFct_InitStep:=FALSE;
		iStFct_StepPrc:=0;
		xStFct_SetEnd:=TRUE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Parallelablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartPrc_Parallel AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) THEN
	CASE iStFct_StepPrc_Parallel OF
	1:	iStFct_StepPrc_Parallel:=1;
		xStFct_InitStep_Parallel:=FALSE;
		xStFct_StartPrc_Parallel:=FALSE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				     Stationsfunktion Endprozedur                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_End;
END_ACTION

ACTION	StationFunction_Fct_10_CheckAxisBreak:
(******************************************************************************************************************************************)
(****************************				           Reset Stationsfunktion                                            *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Reset;
(******************************************************************************************************************************************)
(****************************			        Stationsfunktion Fehler Controller                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Error;
(******************************************************************************************************************************************)
(****************************				    Stationsfunktion Haupt Controller                               *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Main;
(******************************************************************************************************************************************)
(****************************			         Stationsfunktion sofort Unterbrechung                           *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Stop;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Hauptablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartMainPrc AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) AND NOT(xStFct_TmpStop) THEN
	CASE iStFct_StepPrc OF
	1:	IF NOT(xStFct_InitStep) THEN
			T_Station_Work.THWWorkStation.TCtrlWork.xBlockCheckAxisBrake:=TRUE;	(* Überwachung muss für diese Funktion ausgeschaltet werden *)
			xStFct_ZAxisBrakeBlocked:=FALSE;
			xStFct_InitStep:=TRUE;
			(* Bremszylinder für Achse Z *)
			ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.iFunction:=1;
			ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xExecute) AND ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xDone THEN
			IF ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xStatePosOn THEN
				xStFct_ZAxisBrakeBlocked:=TRUE;	(* Achsenbremse ist blockiert *)
			END_IF;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	2:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			(* Bremszylinder für Achse Z *)
			ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.iFunction:=2;
			ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xExecute) AND ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xDone THEN
			IF NOT(ptrTCylBrakeReleaseZAxis^.T_CtrleCyl.xStatePosOn) THEN
				xStFct_ZAxisBrakeBlocked:=TRUE;	(* Sensor evtl nicht richtig eingestellt *)
			END_IF;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	3:	IF NOT(xStFct_StartPrc_Parallel) THEN
			T_Station_Work.THWWorkStation.TCtrlWork.xZAxisBrakeBlocked:=xStFct_ZAxisBrakeBlocked;
			T_Station_Work.THWWorkStation.TCtrlWork.xBlockCheckAxisBrake:=FALSE;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=0;
			xStFct_SetEnd:=TRUE;
		END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Parallelablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartPrc_Parallel AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) THEN
	CASE iStFct_StepPrc_Parallel OF
	1:	iStFct_StepPrc_Parallel:=1;
		xStFct_InitStep_Parallel:=FALSE;
		xStFct_StartPrc_Parallel:=FALSE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				     Stationsfunktion Endprozedur                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_End;
END_ACTION

ACTION	StationFunction_Fct_11_Centring:
(******************************************************************************************************************************************)
(****************************				           Reset Stationsfunktion                                            *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Reset;
(******************************************************************************************************************************************)
(****************************			        Stationsfunktion Fehler Controller                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Error;
(******************************************************************************************************************************************)
(****************************				    Stationsfunktion Haupt Controller                               *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Main;
(******************************************************************************************************************************************)
(****************************			         Stationsfunktion sofort Unterbrechung                           *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_Stop;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Hauptablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartMainPrc AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) AND NOT(xStFct_TmpStop) THEN
(***************************************************************************************************************************************************)
(* Überwachung auf die Axiale Auslenkung *)
	IF xStFct_ToolDeflectionActiv THEN
		IF NOT(IxToolDeflection2_St1) THEN
			xStFct_ToolDeflectionActiv:=FALSE;
			xStFct_InitAxialSensor:=FALSE;
			xStFct_CheckAxialSensor:=FALSE;
		END_IF;
	END_IF;
	IF (IxToolDeflection2_St1 OR xStFct_CheckAxialSensor) AND NOT(xStFct_ToolDeflectionActiv) THEN
		IF NOT(xStFct_InitAxialSensor) THEN
			xStFct_InitAxialSensor:=TRUE;
			xStFct_CheckAxialSensor:=TRUE;
			lrStFct_ActualPosition:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
		END_IF;
		IF NOT(IxToolDeflection2_St1) THEN
			xStFct_InitAxialSensor:=FALSE;
			xStFct_CheckAxialSensor:=FALSE;
			xStFct_ToolDeflectionActiv:=FALSE;
		END_IF;
		IF (ABS(ptrTAxisZ^.T_LiveValue.lrActualPosition - lrStFct_ActualPosition) >= T_Station_Parameter.T_StProcess.rCenteringDeflectionSensorOffset) AND IxToolDeflection2_St1 THEN
			xStFct_ToolDeflectionActiv:=TRUE;
		END_IF;
	END_IF;
(***************************************************************************************************************************************************)
(* Hauptablauf für das Zentrieren *)
	CASE iStFct_StepPrc OF
	(* ZylAuslenkung mit ZentrierKraft setzen *)
	(* ZylWPUnfix setzen *)
	1:	gxWP_Analyse_ActiveCentering:=TRUE;
		lrZ1HCMinPosition:=0.0;
		lrZ1HCMaxPosition:=0.0;
		diHCCheckCounter:=0;
		T_ExchgParam.T_StationCommon.diCentringNumberHCinWindow:=0;
		wStFct_Status:=0;
		xZFastSpeedSettled:=FALSE;
		IF gxHardwareOFF OR gxAxisOFF THEN
			gxWP_Analyse_ActiveWork:=TRUE;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=90;
			IF NOT(IxCylWPUnfixAtWorkPos_St1) THEN
				xStFct_HardwareError:=TRUE;
				diStFct_TmpErrorNr:=30;	(* Beim Zentrieren muss der ZylWstkEntspannen auf BearbeitPos sein *)
				RETURN;
			END_IF;
			RETURN;
		END_IF;
		(* Überprüfmechanismen die bestehen müssen, damit diese Funktion gestartet werden kann *)
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xRef) THEN	(* Z Achse muss referenziert sein *)
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=9;	(* Z Achse muss referenziert sein *)
			RETURN;
		END_IF;
		(* Überprüfe alle Positionen der Z Achse *)
		StationFunction_Ctrl_CheckPos_Z;
		IF xStFct_PositionOutRange_Z THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=iStFct_PosErrorNr;
			RETURN;
		END_IF;
		IF (garPositionEndProcCalc[1] > T_Station_Parameter.T_StProcess.rPositionEndMech) THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=12;		(* Hubprozesslänge > Z Mech EndPos *)
			RETURN;
		END_IF;
		IF (garCentringEndProcCalc[1] > T_Station_Parameter.T_StProcess.rPositionEndMech) THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=18;		(* Zentrier EndPos > Z Mech EndPos *)
			RETURN;
		END_IF;
		IF (garCentringEndProcCalc[1] > T_Station_Parameter.T_StProcess.rPositionEndProcMaxInc) AND T_Station_Parameter.T_StProcess.xCentringEndProcIncOnOff THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=19;			(* Z ZentrierPos berechn. > Z Bearb EndPos Max *)
			RETURN;
		END_IF;
		(* Überprüfe ob Wz im Wstk eingefädelt ist *)
		IF NOT(ptrTAxisZ^.T_LiveValue.lrActualPosition >= (grZ_WorkStartPos - 0.1)) THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=14;		(* Werkzeug ist nicht im Werkstück eingefädelt *)
			RETURN;
		END_IF;
		(* Überprüfmechanismen die bestehen müssen, damit diese Funktion gestartet werden kann *)
		IF NOT(IxCylWPUnfixAtWorkPos_St1) THEN
			xStFct_HardwareError:=TRUE;
			diStFct_TmpErrorNr:=30;	(* Beim Zentrieren muss der ZylWstkEntspannen auf BearbeitPos sein *)
			RETURN;
		END_IF;
		IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			IF NOT(ptrTAxisS^.T_CtrleSingle.xPower) THEN
				ptrTAxisS^.T_CtrleSingle.iFunction:=3;	(* Strom einschalten *)
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			(* Zylinder für Auslenkung-->mit Zentrierkraft *)
			ptrTCylToolDeflection^.T_CtrleCyl.iFunction:=2;
			ptrTCylToolDeflection^.T_Config.tDelayOn:=T#0.3s;
			ptrTCylToolDeflection^.T_CtrleCyl.T_Analog.rForceIn:=T_Station_Parameter.T_StProcess.rCentringForceDeflection;
			ptrTCylToolDeflection^.T_CtrleCyl.xExecute:=TRUE;
			QxCylWPUnfix_St1:=TRUE;		(* Wstk Spannung lösen *)
		END_IF;
		IF NOT(ptrTCylToolDeflection^.T_CtrleCyl.xExecute) AND ptrTCylToolDeflection^.T_CtrleCyl.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF
	(* Z1 Achse auf ZentrierPos fahren -->Zentriergeschwindigkeit setzen *)
	(* S Achse mit ZentrierGeschwindigkeit *)
	(* O Achse mit ZentrierGeschwindigkeit *)
	2:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut Bewegung *)
			ptrTAxisZ^.T_CtrleSingle.lrPosition:=garCentringEndProcCalc[1];				(* Z1 Achse auf ZentrierPos fahren *)
			ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rCentringPosSpeedFastZ1Axis;	(* Mit schneller Zentriergeschwindigkeit fahren *)
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			IF (T_Station_Parameter.T_StProcess.rCentringSpeedSAxis <> 0.0) THEN
				(* Spindel mit Einfädelgeschwindigkeit *)
				IF ptrTAxisS^.T_CtrleSingle.xNotMoving THEN
					ptrTAxisS^.T_CtrleSingle.iFunction:=6;	(* Move Velocity *)
				ELSE
					ptrTAxisS^.T_CtrleSingle.iFunction:=12;	(* Move Velocity *)
				END_IF;
				ptrTAxisS^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rCentringSpeedSAxis;
				ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
			ELSE
				IF (NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) OR NOT(ptrTAxisS^.T_CtrleSingle.xDone))
				AND NOT((ptrTAxisS^.T_CtrleSingle.iFunction = 5) AND NOT(ptrTAxisS^.T_CtrleSingle.xDone)) AND NOT(ptrTAxisS^.T_CtrleSingle.xErr) THEN
					ptrTAxisS^.T_CtrleSingle.iFunction:=5;
					ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF
			IF (T_Station_Parameter.T_StProcess.rCentringSpeedOAxis > 0.0) THEN
				QxFastStrokeOn_St1:=TRUE;
				QiAFastStroke:=REAL_TO_INT(32757 / 50.0 * T_Station_Parameter.T_StProcess.rCentringSpeedOAxis);		(* 32767digits / 50Hz * Param Hz *)
			END_IF;
		END_IF;
		IF TRUE THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	(* Der erste HC im Schnellgang wird gesucht *)
	3:	IF ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn AND NOT(xStFct_StopSlide) THEN	(* Neu wird der HC1 auch überwacht und falls eintrifft dann stoppen und z auf LadePos setzen und Fehler ausgeben *)
			xStFct_StopSlide:=TRUE;
			wStFct_Status:=1;	(* 1 = < Wz Auslenk. Sensor > *)
			lrActualPositionSaveSwitchZSpeed:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
		END_IF;
		IF xStFct_ToolDeflectionActiv AND NOT(xStFct_StopSlide) THEN
			xStFct_StopSlide:=TRUE;
			wStFct_Status:=5;	(* 1 = < Wz Auslenk 2. Sensor > *)
			lrActualPositionSaveSwitchZSpeed:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			(* Wz konnte erfolgreich Zentriert werden aber es hatte keinen HC *)
			iStFct_StepPrc:=50;		(* Z Achse um einen Offset zurückfahren oder auf LadePosition zurücksetzen *)
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			IF T_Station_Parameter.T_StProcess.xCentringEndProcIncOnOff THEN
				garCentringEndProcCalc[1]:=garCentringEndProcCalc[1] + T_Station_Parameter.T_StProcess.rCentringEndProInc;	(* Zentrier EndPos Inkrementieren *)
			END_IF;
			RETURN;
		END_IF;
		IF xStFct_StopSlide AND NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone) AND
		    NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) AND (ptrTAxisZ^.T_CtrleSingle.iFunction <> 12) THEN
			ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			(* init. variable *)
			xStFct_StopSlide:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
			xStFct_InitStep:=FALSE;
		END_IF;
	4:	(* Abwarten bis die HubAchse stillsteht *)
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			IF (wStFct_Status <> 1) THEN
				iStFct_StepPrc:=iStFct_StepPrc + 1;
			ELSE
				iStFct_StepPrc:=50;	(* Wenn HC1 eintrifft dann auf LadePos zurück und Fehler ausgeben *)
			END_IF;
		END_IF;
	5:	(* Z Achse um einen Offset beim ersten HC zurücksetzen *)
		IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			IF ((ptrTAxisZ^.T_LiveValue.lrActualPosition - ABS(T_Station_Parameter.T_StProcess.rCentringBackStrokeOffsetFirstHC)) >= grZ_WorkStartPos) THEN
				ptrTAxisZ^.T_CtrleSingle.iFunction:=8;
				ptrTAxisZ^.T_CtrleSingle.lrDistance:=T_Station_Parameter.T_StProcess.rCentringBackStrokeOffsetFirstHC;
				ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rCentringBackStrokeSpeed;
			ELSE
				ptrTAxisZ^.T_CtrleSingle.iFunction:=7;
				ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_WorkStartPos;
				ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rCentringBackStrokeSpeed;
			END_IF;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 5;
		END_IF;

	10:	(* Z Achse auf Zentrierposition mit langsamer Geschwindigkeit setzen *)
		IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut Bewegung *)
			ptrTAxisZ^.T_CtrleSingle.lrPosition:=garCentringEndProcCalc[1];				(* Z1 Achse auf ZentrierPos fahren *)
			ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rCentringPosSpeedSlowZ1Axis;	(* Mit langsamer Zentriergeschwindigkeit fahren *)
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF TRUE THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	(* Die weiteren HC im Langsamgang wird gesucht *)
	11:	IF ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn AND NOT(xStFct_StopSlide) THEN	(* Neu wird der HC1 auch überwacht und falls eintrifft dann stoppen und z auf LadePos setzen und Fehler ausgeben *)
			xStFct_StopSlide:=TRUE;
			wStFct_Status:=1;	(* 1 = < Wz Auslenk. Sensor > *)
			T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterCentering:=T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterCentering + 1;	(* Erst hier werden die HC gezählt, d.h. der erste wird nicht gezählt *)
			lrActualPositionSave:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
			lrActualPositionSaveSwitchZSpeed:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
			xZFastSpeedSettled:=FALSE;
		END_IF;
		IF xStFct_ToolDeflectionActiv AND NOT(xStFct_StopSlide) THEN
			xStFct_StopSlide:=TRUE;
			wStFct_Status:=5;	(* 1 = < Wz Auslenk 2. Sensor > *)
			T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterCentering:=T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterCentering + 1;	(* Erst hier werden die HC gezählt, d.h. der erste wird nicht gezählt *)
			lrActualPositionSave:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
			lrActualPositionSaveSwitchZSpeed:=ptrTAxisZ^.T_LiveValue.lrActualPosition;
			xZFastSpeedSettled:=FALSE;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			(* Wz konnte erfolgreich Zentriert werden und es hatte mindesten einen HC *)
			xZFastSpeedSettled:=FALSE;
			wStFct_Status:=0;
			iStFct_StepPrc:=50;		(* Z Achse um einen Offset zurückfahren oder auf LadePosition zurücksetzen *)
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			IF T_Station_Parameter.T_StProcess.xCentringEndProcIncOnOff THEN
				garCentringEndProcCalc[1]:=garCentringEndProcCalc[1] + T_Station_Parameter.T_StProcess.rCentringEndProInc;	(* Zentrier EndPos Inkrementieren *)
			END_IF;
			RETURN;
		END_IF;
		IF xStFct_StopSlide AND NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone) AND
		    NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) AND (ptrTAxisZ^.T_CtrleSingle.iFunction <> 12) THEN
			ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			(* init. variable *)
			xStFct_StopSlide:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
			xStFct_InitStep:=FALSE;
			xZFastSpeedSettled:=FALSE;
			RETURN;
		END_IF;
		IF NOT(xStFct_StopSlide) AND NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone) AND
		    NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) AND (ptrTAxisZ^.T_CtrleSingle.iFunction <> 12) AND NOT(xZFastSpeedSettled) THEN
			IF (ptrTAxisZ^.T_LiveValue.lrActualPosition >= (lrActualPositionSaveSwitchZSpeed + T_Station_Parameter.T_StProcess.rCentringOffsetSlowToFastZSpeed)) AND (T_Station_Parameter.T_StProcess.rCentringOffsetSlowToFastZSpeed <> 0.0) THEN
				(* Wenn die Z Achse um einen definierten Offset kein HC eingetroffen ist, dann soll es auf die schnelle Geschwindigkeit umschalten *)
				xZFastSpeedSettled:=TRUE;
				ptrTAxisZ^.T_CtrleSingle.iFunction:=12;	(* Move Velocity *)
				ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rCentringPosSpeedFastZ1Axis;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
	12:	(* Abwarten bis die HubAchse stillsteht *)
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			TONWaitHCActive(IN:=FALSE);
			TONWaitHCInactive(IN:=FALSE);
			IF (wStFct_Status <> 1) THEN
				IF (lrZ1HCMinPosition = 0) THEN
					lrZ1HCMinPosition:=lrActualPositionSave;
					lrZ1HCMaxPosition:=lrActualPositionSave;
					IF (T_Station_Parameter.T_StProcess.iCentringSelectProcess <= 1) THEN
						iStFct_StepPrc:=iStFct_StepPrc + 1;	(* Konventioneller Ablauf *)
					ELSE
						iStFct_StepPrc:=iStFct_StepPrc + 3;	(* Ablauf für Finde Grauzone, zurückfahren bis HC2 nicht mehr angibt *)
					END_IF;
				ELSE
					IF (lrActualPositionSave < lrZ1HCMinPosition) THEN
						lrZ1HCMinPosition:=lrActualPositionSave;
					END_IF;
					IF (lrActualPositionSave > lrZ1HCMaxPosition) THEN
						lrZ1HCMaxPosition:=lrActualPositionSave;
					END_IF;
					IF ((lrZ1HCMaxPosition - lrZ1HCMinPosition) <= T_Station_Parameter.T_StProcess.rCentringHCWindow) THEN
						diHCCheckCounter:=diHCCheckCounter + 1;
						IF (diHCCheckCounter >= T_Station_Parameter.T_StProcess.iCentringNumberMaxHCinWindow) THEN
							IF (T_Station_Parameter.T_StProcess.iCentringSelectProcess <= 1) THEN
								(* Maximale Anzahl HC im definierten Fenster erreicht und der Prozess wird abegbrochen *)
								wStFct_Status:=99;
								iStFct_StepPrc:=50;
							ELSE
								(* Neu definiert Prozessablauf für Finde Grauzone. hier wird nicht abgebrochen sondern Rückhub wie bei normalen Ablauf *)
								iStFct_StepPrc:=20;
							END_IF;
						ELSE
							IF (T_Station_Parameter.T_StProcess.iCentringSelectProcess <= 1) THEN
								iStFct_StepPrc:=iStFct_StepPrc + 1;	(* Konventioneller Ablauf *)
							ELSE
								iStFct_StepPrc:=iStFct_StepPrc + 3;	(* Ablauf für Finde Grauzone, zurückfahren bis HC2 nicht mehr angibt *)
							END_IF;
						END_IF;
					ELSE
						diHCCheckCounter:=0;
						lrZ1HCMinPosition:=lrActualPositionSave;
						lrZ1HCMaxPosition:=lrActualPositionSave;
						IF (T_Station_Parameter.T_StProcess.iCentringSelectProcess <= 1) THEN
							iStFct_StepPrc:=iStFct_StepPrc + 1;
						ELSE
							iStFct_StepPrc:=iStFct_StepPrc + 3;	(* Ablauf für Finde Grauzone, zurückfahren bis HC2 nicht mehr angibt *)
						END_IF;
					END_IF;
				END_IF;
			ELSE
				iStFct_StepPrc:=50;	(* Wenn HC1 eintrifft dann auf LadePos zurück und Fehler ausgeben *)
			END_IF;
		END_IF;
		T_ExchgParam.T_StationCommon.diCentringNumberHCinWindow:=diHCCheckCounter;
	13:	(* Wartezeiten laufen lassen *)
		TONWaitHCActive(IN:=TRUE,PT:=REAL_TO_TIME(T_Station_Parameter.T_StProcess.rCentringTimeHCActive * 1000.0));
		TONWaitHCInactive(IN:=NOT(IxToolDeflection2_St1),PT:=REAL_TO_TIME(T_Station_Parameter.T_StProcess.rCentringTimeHCInactive * 1000.0));
		IF TONWaitHCInactive.Q THEN
			(* HC ist für eine bestimmte Zeit nicht mehr Aktiv und deshalb kann die Z Achse wieder weiterfahren im Langsamgang *)
			xStFct_ToolDeflectionActiv:=FALSE;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc - 3 ;
			RETURN;
		END_IF;
		IF TONWaitHCActive.Q THEN
			(* HC ist immer noch Aktiv, dann muss die Z Achse um einen Offset zurückgesetzt werden *)
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 7;
		END_IF;

	(* Gilt nur für den Zentrierablauf mit Finde Grauzone, nach dem ersten HC zurückfahren bis HC nicht mehr eintrifft und dann Normal wieder langsam nach vorne fahren *)
	15:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut Bewegung *)
			ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_WorkStartPos;	(* Zurück bis Startpos fahren und soabld HC2 nicht mehr aktiv ist kann gestoppt werden *)
			ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rCentringPosSpeedSlowZ1Axis;	(* Mit langsamer Zentriergeschwindigkeit fahren *)
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			TONWaitHCInactive(IN:=FALSE);
		END_IF;
		IF TRUE THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	16:	TONWaitHCInactive(IN:=NOT(IxToolDeflection2_St1),PT:=REAL_TO_TIME(T_Station_Parameter.T_StProcess.rCentringTimeHCInactive * 1000.0));
		IF TONWaitHCInactive.Q THEN
			(* HC ist für eine bestimmte Zeit nicht mehr Aktiv und deshalb kann die Z Achse wieder weiterfahren im Langsamgang *)
			xStFct_ToolDeflectionActiv:=FALSE;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			xStFct_StopSlide:=TRUE;
		END_IF;
		IF xStFct_StopSlide AND NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone) AND
		    NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) AND (ptrTAxisZ^.T_CtrleSingle.iFunction <> 12) THEN
			ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			(* init. variable *)
			xStFct_StopSlide:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
			xStFct_InitStep:=FALSE;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			(* Der HC2 ist immer noch aktiv und die Startposition wurde erreicht und es muss einen Fehler ausgegeben werden *)
			iStFct_StepPrc:=50;		(* Z Achse um einen Offset zurückfahren oder auf LadePosition zurücksetzen *)
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			wStFct_Status:=98;	(* Dummy Zahl setzen um es auffangen zu können *)
			RETURN;
		END_IF;
	17:	(* Abwarten bis die HubAchse stillsteht *)
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_ToolDeflectionActiv:=FALSE;
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc - 7 ;
			RETURN;
		END_IF;

	20:	(* Z Achse um einen Offset nach dem ersten HC zurücksetzen *)
		IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			IF ((ptrTAxisZ^.T_LiveValue.lrActualPosition - ABS(T_Station_Parameter.T_StProcess.rCentringBackStrokeOffsetAfterFirstHC)) >= grZ_WorkStartPos) THEN
				ptrTAxisZ^.T_CtrleSingle.iFunction:=8;
				ptrTAxisZ^.T_CtrleSingle.lrDistance:=T_Station_Parameter.T_StProcess.rCentringBackStrokeOffsetAfterFirstHC;
				ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rCentringBackStrokeSpeed;
			ELSE
				ptrTAxisZ^.T_CtrleSingle.iFunction:=7;
				ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_WorkStartPos;
				ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rCentringBackStrokeSpeed;
			END_IF;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	21:	(* Z Achse im Schnellgang zum letzte HC minus den Offset setzen *)
		IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolut Bewegung *)
			ptrTAxisZ^.T_CtrleSingle.lrPosition:=lrActualPositionSave - ABS(T_Station_Parameter.T_StProcess.rCentringOffsetBeforeLastHC);	(* Z1 Achse auf die letzte HC Position minus den Offset setzen *)
			ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rCentringPosSpeedFastZ1Axis;							(* Mit schneller Zentriergeschwindigkeit fahren *)
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
		END_IF;
		IF ptrTCylToolDeflection^.T_CtrleCyl.xStatePosOn AND NOT(xStFct_StopSlide) THEN	(* Neu wird der HC1 auch überwacht und falls eintrifft dann stoppen und z auf LadePos setzen und Fehler ausgeben *)
			xStFct_StopSlide:=TRUE;
			wStFct_Status:=1;	(* 1 = < Wz Auslenk. Sensor > *)
		END_IF;
		IF xStFct_ToolDeflectionActiv AND NOT(xStFct_StopSlide) THEN	(* Trotzdem überwachen ob die Auslenkung angeben sollte *)
			xStFct_StopSlide:=TRUE;
		END_IF;
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			(* Die Z Achse kann wieder weiterfahren im Langsamgang *)
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc - 11 ;
		END_IF;
		IF xStFct_StopSlide AND NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND NOT(ptrTAxisZ^.T_CtrleSingle.xDone) AND
		    NOT(ptrTAxisZ^.T_CtrleSingle.xNotMoving) AND (ptrTAxisZ^.T_CtrleSingle.iFunction <> 12) THEN
			ptrTAxisZ^.T_CtrleSingle.iFunction:=5;
			ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			(* init. variable *)
			xStFct_StopSlide:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
			xStFct_InitStep:=FALSE;
		END_IF;
	22:	(* Abwarten bis die HubAchse stillsteht *)
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			IF (wStFct_Status <> 1) THEN
				iStFct_StepPrc:=iStFct_StepPrc - 17;
			ELSE
				iStFct_StepPrc:=50;	(* Wenn HC1 eintrifft dann auf LadePos zurück und Fehler ausgeben *)
			END_IF;
		END_IF;

	(* Falls nur Zentrierung aktiviert ist, dann zuerst den Schnellhub stoppen *)
	50:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			IF gxOnlyCentringActive OR (wStFct_Status = 99) OR (wStFct_Status = 1) OR (wStFct_Status = 98) THEN
				IF (T_Station_Parameter.T_StProcess.rCentringSpeedOAxis > 0.0) THEN
					QxFastStrokeOn_St1:=FALSE;
					QiAFastStroke:=0;
					TONWaitStopOAxis(IN:=FALSE,PT:=T#0.5s);
				ELSE
					TONWaitStopOAxis(IN:=FALSE,PT:=T#0.01s);
				END_IF;
			ELSE
				TONWaitStopOAxis(IN:=FALSE,PT:=T#0.01s);
			END_IF;
		END_IF;
		TONWaitStopOAxis(IN:=TRUE);
		IF TONWaitStopOAxis.Q THEN
			TONWaitStopOAxis(IN:=FALSE);
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
		END_IF;
	(* Z1 Achse auf LadePosition zurückfahren ODER einen Offset zurückfahren *)
	51:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			IF gxOnlyCentringActive OR (wStFct_Status = 99) OR (wStFct_Status = 1) OR (wStFct_Status = 98) THEN
				ptrTAxisZ^.T_CtrleSingle.iFunction:=7;
				ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_LoadPos;
				ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rOutfeedStrokeAxisSpeed;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
				IF NOT(ptrTAxisBubbler^.T_CtrleDCAxis.xNotMoving) THEN
					(* Abstreifer ZU *)
					QxCylStripperClose_St1:=TRUE;
					QxCylStripperOpen_St1:=FALSE;
				END_IF
				IF (T_Station_Parameter.T_StProcess.rCentringSpeedOAxis > 0.0) THEN
					QxFastStrokeOn_St1:=FALSE;
					QiAFastStroke:=0;
				END_IF;
			ELSE
				lrZCheckPosition:=ptrTAxisZ^.T_LiveValue.lrActualPosition + T_Station_Parameter.T_StProcess.rCentringOffsetBackward;
				IF (lrZCheckPosition <= grZ_WorkStartPos) THEN
					ptrTAxisZ^.T_CtrleSingle.iFunction:=7;	(* Absolute Bewegung *)
					ptrTAxisZ^.T_CtrleSingle.lrPosition:=grZ_WorkStartPos;
				ELSE
					ptrTAxisZ^.T_CtrleSingle.iFunction:=8;	(* Relative Bewegung *)
					ptrTAxisZ^.T_CtrleSingle.lrDistance:=T_Station_Parameter.T_StProcess.rCentringOffsetBackward;
				END_IF;
				ptrTAxisZ^.T_CtrleSingle.lrVelocity:=T_Station_Parameter.T_StProcess.rCentringBackStrokeSpeed;
				ptrTAxisZ^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF (gxOnlyCentringActive OR (wStFct_Status = 99) OR (wStFct_Status = 1) OR (wStFct_Status = 98)) AND (ptrTAxisZ^.T_LiveValue.lrActualPosition <= (garCentringEndProcCalc[1] + T_Station_Parameter.T_StProcess.rCentringOffsetBackward)) THEN
			QxCylWPUnfix_St1:=FALSE;
		END_IF
		IF NOT(ptrTAxisZ^.T_CtrleSingle.xExecute) AND ptrTAxisZ^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=iStFct_StepPrc + 1;
			QxCylWPUnfix_St1:=FALSE;
		END_IF;
	(* S Achse stoppen *)
	(* O Achse stoppen *)
	(* ZylWPUnfix zurücksetzen *)
	52:	IF NOT(xStFct_InitStep) THEN
			xStFct_InitStep:=TRUE;
			IF gxOnlyCentringActive OR (wStFct_Status = 99) OR (wStFct_Status = 1) OR (wStFct_Status = 98) THEN
				IF (NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) OR NOT(ptrTAxisS^.T_CtrleSingle.xDone))
				AND NOT((ptrTAxisS^.T_CtrleSingle.iFunction = 5) AND NOT(ptrTAxisS^.T_CtrleSingle.xDone)) AND NOT(ptrTAxisS^.T_CtrleSingle.xErr) THEN
					ptrTAxisS^.T_CtrleSingle.iFunction:=5;
					ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				IF (T_Station_Parameter.T_StProcess.rCentringSpeedOAxis > 0.0) THEN
					QxFastStrokeOn_St1:=FALSE;
					QiAFastStroke:=0;
				END_IF;
				QxCylWPUnfix_St1:=FALSE;
			END_IF
			IF xProcessDone THEN
				IF (NOT(ptrTAxisS^.T_CtrleSingle.xNotMoving) OR NOT(ptrTAxisS^.T_CtrleSingle.xDone))
				AND NOT((ptrTAxisS^.T_CtrleSingle.iFunction = 5) AND NOT(ptrTAxisS^.T_CtrleSingle.xDone)) AND NOT(ptrTAxisS^.T_CtrleSingle.xErr) THEN
					ptrTAxisS^.T_CtrleSingle.iFunction:=5;
					ptrTAxisS^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
				QxFastStrokeOn_St1:=FALSE;
				QiAFastStroke:=0;
			END_IF
			(* Abstreifer AUF *)
			QxCylStripperClose_St1:=FALSE;
			QxCylStripperOpen_St1:=TRUE;
		END_IF;
		IF NOT(ptrTAxisS^.T_CtrleSingle.xExecute) AND ptrTAxisS^.T_CtrleSingle.xDone THEN
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			IF (wStFct_Status <> 1) THEN
				iStFct_StepPrc:=90;
			ELSIF (wStFct_Status = 1) THEN
				xStFct_HardwareError:=TRUE;
				diStFct_TmpErrorNr:=41;		(* Zentrierproz. HC1 eingetroffen *)
				RETURN;
			ELSE
				xStFct_HardwareError:=TRUE;
				diStFct_TmpErrorNr:=42;		(* Zentrierproz. StartPos erreicht und HC2 immer noch ON *)
			END_IF;
		END_IF;

	90:	IF gxHardwareOFF OR gxAxisOFF THEN
		(* Gilt nur falls HW ausgeschaltet ist *)
			IF NOT(xStFct_InitStep) THEN
				xStFct_InitStep:=TRUE;
				TONWorkTime(IN:=FALSE);
			END_IF;
			TONWorkTime(IN:=TRUE,PT:=T#5s);
			T_Station_Work.THWWorkStation.TCtrlWork.iOverLimitCounterCentering:=5;
			IF TONWorkTime.Q THEN
				TONWorkTime(IN:=FALSE);
				xStFct_StartMainPrc:=FALSE;
				xStFct_InitStep:=FALSE;
				iStFct_StepPrc:=0;
				xStFct_SetEnd:=TRUE;
				wStFct_Status:=0;
				IF T_Station_Parameter.T_StProcess.xCentringEndProcIncOnOff THEN
					garCentringEndProcCalc[1]:=garCentringEndProcCalc[1] + T_Station_Parameter.T_StProcess.rCentringEndProInc;	(* Zentrier EndPos Inkrementieren *)
				END_IF;
			END_IF;
		ELSE
			xStFct_StartMainPrc:=FALSE;
			xStFct_InitStep:=FALSE;
			iStFct_StepPrc:=0;
			xStFct_SetEnd:=TRUE;
		END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************			             Stationsfunktion Parallelablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xStFct_StartPrc_Parallel AND NOT(xStFct_SetEnd) AND NOT(xStFct_HardwareError) THEN
	CASE iStFct_StepPrc_Parallel OF
	1:	iStFct_StepPrc_Parallel:=1;
		xStFct_InitStep_Parallel:=FALSE;
		xStFct_StartPrc_Parallel:=FALSE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************				     Stationsfunktion Endprozedur                                    *****************************)
(******************************************************************************************************************************************)
StationFunction_Ctrl_End;
END_ACTION






































(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER3_STATION' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_STATION_WORK_ST1
VAR
	FBStationWork_St1: FB_STATION_WORK;
	xActive_Work_St1: BOOL;
	xRdy_Work_St1: BOOL;
	xEnd_Work_St1: BOOL;
	xStop_Work_St1: BOOL;
	xReferenced_Work_St1: BOOL;
	xError_Work_St1: BOOL;
	iErrorNr_Work_St1: DINT;
	iStatusFctNr_Work_St1 : INT;
	xStationPowerON_St1: BOOL;
	xAxisBrakeBlock_St1:BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
_FBD_BODY
_NETWORKS : 3
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERATOR
_BOX_EXPR : 3
_OPERAND
_EXPRESSION
_POSITIV
gT_SafetyStatus.xEnergyONNormalMode
_OPERAND
_EXPRESSION
_POSITIV
gT_SafetyStatus.xEnergyONSetupModeASt1
_OPERAND
_EXPRESSION
_POSITIV
gT_SafetyStatus.xEnergyONSetupModeBSt1
_EXPRESSION
_POSITIV
OR
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
xStationPowerON_St1
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERATOR
_BOX_EXPR : 2
_OPERATOR
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
T_VisuQVis.T_PlcParam.dwActualPage
_OPERAND
_EXPRESSION
_POSITIV
gT_PageNumber.iWorkStation_Cylinder1
_EXPRESSION
_POSITIV
EQ
_OPERAND
_EXPRESSION
_POSITIV
TStation_Work_St1.THWWorkStation.TCtrlWork.xBlockCheckAxisBrake
_EXPRESSION
_POSITIV
OR
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
xAxisBrakeBlock_St1
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_FUNCTIONBLOCK
FBStationWork_St1
_BOX_EXPR : 5
_OPERAND
_EXPRESSION
_POSITIV
xStationPowerON_St1
_OPERAND
_EXPRESSION
_POSITIV
xAxisBrakeBlock_St1
_OPERAND
_EXPRESSION
_POSITIV
TProcess.T_Ctrle.xDone
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam.T_Parameter.T_StationWork[gciStationSt1]
_OPERAND
_EXPRESSION
_POSITIV
TStation_Work_St1
_EXPRESSION
_POSITIV
FB_STATION_WORK
_OUTPUTS : 7
_OUTPUT
_POSITIV
_NO_SET
xRdy_Work_St1
_OUTPUT
_POSITIV
_NO_SET
xEnd_Work_St1
_OUTPUT
_POSITIV
_NO_SET
xStop_Work_St1
_OUTPUT
_POSITIV
_NO_SET
xReferenced_Work_St1
_OUTPUT
_POSITIV
_NO_SET
xError_Work_St1
_OUTPUT
_POSITIV
_NO_SET
iErrorNr_Work_St1
_OUTPUT
_POSITIV
_NO_SET
iStatusFctNr_Work_St1
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
xActive_Work_St1

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER4_PROCESS\/FBPROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_PreWarning_Ctrl_Message
VAR_INPUT
	xPreWarninMessageBoxActive:BOOL;
END_VAR
VAR_IN_OUT
	T_PreWarning:ST_PREWARNING;
END_VAR
VAR_OUTPUT
END_VAR
VAR
	asMessageStringEngl:ARRAY [1..10,1..5] OF STRING(55);
	asMessageStringGer:ARRAY [1..10,1..5] OF STRING(55);
	FBPreWarningMessage: FB_PreWarning_Message;
	xInitMessageText: BOOL;
	RisingEdge_Message1: R_TRIG;
	RisingEdge_Message2: R_TRIG;
	FaillingEdge_Message1: F_TRIG;
	FaillingEdge_Message2: F_TRIG;
	ii: INT;
	iMessagePointer: INT;
	iNumberMessage: INT;
	aiSetMessageNumber:ARRAY [1..10] OF INT;
	asCopyMessageStringEngl:ARRAY [1..10,1..5] OF STRING(55);
	asCopyMessageStringGer:ARRAY [1..10,1..5] OF STRING(55);
	asDeleteMessageString:ARRAY [1..10,1..5] OF STRING(55);
	aiCopyMessageNrBuffer:ARRAY [1..10] OF INT;
	aiDeleteMessageNrBuffer:ARRAY [1..10] OF INT;
	jj: INT;
	xMessageExist: BOOL;
	iDeleteMessage: INT;
	iSaveDeleteMessage:ARRAY [1..12] OF INT;
	iSaveArrayNrMessage:INT:=0;
	FaillingEdgeDeleteWarningByMessageBox: F_TRIG;
	iSetMessageNumber: INT:=0;
	xForceDeleteMessage: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
IF NOT(xInitMessageText) THEN
	(* Initialisierung der Texte für die Vorwarnungen *)
	xInitMessageText:=TRUE;
	FBPreWarningMessage(	asMessageStringEngl:=asMessageStringEngl,
							asEmptyMessageEngl:=T_PreWarning.asEmptyMessageEngl,
							asMessageStringGer:=asMessageStringGer,
							asEmptyMessageGer:=T_PreWarning.asEmptyMessageGer);
END_IF;

IF (giDeleteMessageNumber <> 0) THEN
	iDeleteMessage:=0;
	FOR ii:=1 TO 10 DO
		IF (T_PreWarning.aiMessageNrBuffer[ii] = T_PreWarning.aiDeleteMessage[giDeleteMessageNumber]) THEN
			iSaveArrayNrMessage:=iSaveArrayNrMessage + 1;
			iSaveDeleteMessage[iSaveArrayNrMessage]:=T_PreWarning.aiDeleteMessage[giDeleteMessageNumber];
			iDeleteMessage:=ii;
			EXIT;
		END_IF;
	END_FOR;
	IF (iDeleteMessage <> 0) THEN
		T_PreWarning.asMessageBufferEngl[iDeleteMessage,1]:='';
		T_PreWarning.asMessageBufferEngl[iDeleteMessage,2]:='';
		T_PreWarning.asMessageBufferEngl[iDeleteMessage,3]:='';
		T_PreWarning.asMessageBufferEngl[iDeleteMessage,4]:='';
		T_PreWarning.asMessageBufferEngl[iDeleteMessage,5]:='';
		T_PreWarning.asMessageBufferGer[iDeleteMessage,1]:='';
		T_PreWarning.asMessageBufferGer[iDeleteMessage,2]:='';
		T_PreWarning.asMessageBufferGer[iDeleteMessage,3]:='';
		T_PreWarning.asMessageBufferGer[iDeleteMessage,4]:='';
		T_PreWarning.asMessageBufferGer[iDeleteMessage,5]:='';
		T_PreWarning.aiMessageNrBuffer[iDeleteMessage]:=0;
		asCopyMessageStringEngl:=asDeleteMessageString;
		asCopyMessageStringGer:=asDeleteMessageString;
		aiCopyMessageNrBuffer:=aiDeleteMessageNrBuffer;
		jj:=1;
		FOR ii:=1 TO 10 DO
			IF (T_PreWarning.asMessageBufferEngl[ii,1] <> '') THEN
				asCopyMessageStringEngl[jj,1]:=T_PreWarning.asMessageBufferEngl[ii,1];
				asCopyMessageStringEngl[jj,2]:=T_PreWarning.asMessageBufferEngl[ii,2];
				asCopyMessageStringEngl[jj,3]:=T_PreWarning.asMessageBufferEngl[ii,3];
				asCopyMessageStringEngl[jj,4]:=T_PreWarning.asMessageBufferEngl[ii,4];
				asCopyMessageStringEngl[jj,5]:=T_PreWarning.asMessageBufferEngl[ii,5];
				asCopyMessageStringGer[jj,1]:=T_PreWarning.asMessageBufferGer[ii,1];
				asCopyMessageStringGer[jj,2]:=T_PreWarning.asMessageBufferGer[ii,2];
				asCopyMessageStringGer[jj,3]:=T_PreWarning.asMessageBufferGer[ii,3];
				asCopyMessageStringGer[jj,4]:=T_PreWarning.asMessageBufferGer[ii,4];
				asCopyMessageStringGer[jj,5]:=T_PreWarning.asMessageBufferGer[ii,5];
				aiCopyMessageNrBuffer[jj]:=T_PreWarning.aiMessageNrBuffer[ii];
				jj:=jj + 1;
			END_IF;
		END_FOR;
		T_PreWarning.asMessageBufferEngl:=asCopyMessageStringEngl;
		T_PreWarning.asMessageBufferGer:=asCopyMessageStringGer;
		T_PreWarning.aiMessageNrBuffer:=aiCopyMessageNrBuffer;
	END_IF;
	 T_PreWarning.aiDeleteMessage[giDeleteMessageNumber]:=0;
	giDeleteMessageNumber:=giDeleteMessageNumber - 1;
	IF (giDeleteMessageNumber > 10) THEN
		giDeleteMessageNumber:=0;
	END_IF;
	IF NOT(xPreWarninMessageBoxActive) THEN
		xForceDeleteMessage:=TRUE;
	END_IF;
END_IF;

FaillingEdgeDeleteWarningByMessageBox(CLK:=xPreWarninMessageBoxActive);
IF FaillingEdgeDeleteWarningByMessageBox.Q OR xForceDeleteMessage THEN
	xForceDeleteMessage:=FALSE;
	FOR ii:=1 TO 10 DO
		IF (iSaveDeleteMessage[ii] =1) THEN
			T_PreWarning.xToolNearChangeSt1:=FALSE;
		ELSIF (iSaveDeleteMessage[ii] =2) THEN
			T_PreWarning.xZAxisBrakeBlockedSt1:=FALSE;
		END_IF;
		iSaveDeleteMessage[ii]:=0;
	END_FOR;;
	iSaveArrayNrMessage:=0;
END_IF;

(* aiSetMessageNumber:=0; *)
RisingEdge_Message1(CLK:=T_PreWarning.xToolNearChangeSt1);
IF RisingEdge_Message1.Q THEN
	iSetMessageNumber:=iSetMessageNumber + 1;
	aiSetMessageNumber[iSetMessageNumber]:=1;	(* Wz Wechsel für Station 1 muss bald vorgenommen werden! Beim erreichen max Anz. WzZyklen->Maschinen Stillstand! OK für Meldung Quittieren! RESET für ausgewählte Meldung Löschen! *)
END_IF;
RisingEdge_Message2(CLK:=T_PreWarning.xZAxisBrakeBlockedSt1);
IF RisingEdge_Message2.Q THEN
	iSetMessageNumber:=iSetMessageNumber + 1;
	aiSetMessageNumber[iSetMessageNumber]:=2;	(* Z Achsenbremse von Station 1 ist blockiert!' Lösen Sie Bitte die Handblockierung der Z Achse. OK für Meldung Quittieren! RESET für ausgewählte Meldung Löschen! *)
END_IF;

FaillingEdge_Message1(CLK:=T_PreWarning.xToolNearChangeSt1);
IF FaillingEdge_Message1.Q THEN
	giDeleteMessageNumber:=giDeleteMessageNumber + 1;
	T_PreWarning.aiDeleteMessage[giDeleteMessageNumber]:=2;	(* Löschen: Wz Wechsel für Station 1 muss bald vorgenommen werden! Beim erreichen max Anz. WzZyklen->Maschinen Stillstand! OK für Meldung Quittieren! RESET für ausgewählte Meldung Löschen! *)
END_IF;
FaillingEdge_Message2(CLK:=T_PreWarning.xZAxisBrakeBlockedSt1);
IF FaillingEdge_Message2.Q THEN
	TStation_Work_St1.THWWorkStation.TCtrlWork.xZAxisBrakeBlocked:=FALSE;
	giDeleteMessageNumber:=giDeleteMessageNumber + 1;
	T_PreWarning.aiDeleteMessage[giDeleteMessageNumber]:=6;	(* Löschen: Z Achsenbremse von Station 1 ist blockiert!' Lösen Sie Bitte die Handblockierung der Z Achse. OK für Meldung Quittieren! RESET für ausgewählte Meldung Löschen! *)
END_IF;

IF (T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter.diMaxNumberToolCycle <> 0) AND
	(T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter.diWarningAtToolCycleCounter <> 0) THEN
	IF (T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter.diToolCycleCounter >= T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter.diWarningAtToolCycleCounter) AND
	     (T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter.diToolCycleCounter < T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter.diMaxNumberToolCycle) THEN
		T_PreWarning.xToolNearChangeSt1:=TRUE;
	ELSE
		T_PreWarning.xToolNearChangeSt1:=FALSE;
	END_IF;
ELSE
	T_PreWarning.xToolNearChangeSt1:=FALSE;		(* WzZähler ist ausgeschaltet und darf daher auch keine Meldung ausgeben *)
END_IF;
IF TStation_Work_St1.THWWorkStation.TCtrlWork.xZAxisBrakeBlocked THEN
	T_PreWarning.xZAxisBrakeBlockedSt1:=TRUE;
ELSE
	T_PreWarning.xZAxisBrakeBlockedSt1:=FALSE;
END_IF;

iMessagePointer:=1;	(* Dies besagt die Stelle wo eine Meldung eingetragen werden *)
iNumberMessage:=0;	(* Dies besagt wieviele Meldungen im Buffer vorhanden sind *)
(* Überprüfe wieviele Meldungen im Buffer abgelegt sind *)
FOR ii:=1 TO 10 DO
	IF T_PreWarning.asMessageBufferEngl[ii,1] <> '' THEN
		iNumberMessage:=iNumberMessage + 1;
		IF (iMessagePointer < 10) THEN
			iMessagePointer:=iMessagePointer + 1;
		END_IF;
	END_IF;
END_FOR;
IF (iNumberMessage <> 0) THEN T_PreWarning.xPreWarningActive:=TRUE; ELSE T_PreWarning.xPreWarningActive:=FALSE; END_IF;
T_PreWarning.iNumberOfMessage:=iNumberMessage;
IF (iSetMessageNumber <> 0) THEN
	xMessageExist:=FALSE;
	(* Überprüfe zuerst ob es nicht schon die gleiche Meldung gibt *)
	FOR ii:=1 TO 10 DO
		IF (T_PreWarning.aiMessageNrBuffer[ii] = aiSetMessageNumber[iSetMessageNumber]) THEN
			xMessageExist:=TRUE;
			EXIT;
		END_IF;
	END_FOR;
	IF NOT(xMessageExist) THEN
		T_PreWarning.asMessageBufferEngl[iMessagePointer,1]:=asMessageStringEngl[aiSetMessageNumber[iSetMessageNumber],1];
		T_PreWarning.asMessageBufferEngl[iMessagePointer,2]:=asMessageStringEngl[aiSetMessageNumber[iSetMessageNumber],2];
		T_PreWarning.asMessageBufferEngl[iMessagePointer,3]:=asMessageStringEngl[aiSetMessageNumber[iSetMessageNumber],3];
		T_PreWarning.asMessageBufferEngl[iMessagePointer,4]:=asMessageStringEngl[aiSetMessageNumber[iSetMessageNumber],4];
		T_PreWarning.asMessageBufferEngl[iMessagePointer,5]:=asMessageStringEngl[aiSetMessageNumber[iSetMessageNumber],5];
		T_PreWarning.asMessageBufferGer[iMessagePointer,1]:=asMessageStringGer[aiSetMessageNumber[iSetMessageNumber],1];
		T_PreWarning.asMessageBufferGer[iMessagePointer,2]:=asMessageStringGer[aiSetMessageNumber[iSetMessageNumber],2];
		T_PreWarning.asMessageBufferGer[iMessagePointer,3]:=asMessageStringGer[aiSetMessageNumber[iSetMessageNumber],3];
		T_PreWarning.asMessageBufferGer[iMessagePointer,4]:=asMessageStringGer[aiSetMessageNumber[iSetMessageNumber],4];
		T_PreWarning.asMessageBufferGer[iMessagePointer,5]:=asMessageStringGer[aiSetMessageNumber[iSetMessageNumber],5];
		T_PreWarning.aiMessageNrBuffer[iMessagePointer]:=aiSetMessageNumber[iSetMessageNumber];
	END_IF;
	aiSetMessageNumber[iSetMessageNumber]:=0;
	iSetMessageNumber:=iSetMessageNumber - 1;
	IF (iSetMessageNumber > 10) THEN
		iSetMessageNumber:=0;
	END_IF;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER4_PROCESS\/FBPROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_PreWarning_Message
VAR_INPUT
END_VAR
VAR_IN_OUT
	asMessageStringEngl:ARRAY [1..10,1..5] OF STRING(55);
	asEmptyMessageEngl:ARRAY [1..5] OF STRING(55);
	asMessageStringGer:ARRAY [1..10,1..5] OF STRING(55);
	asEmptyMessageGer:ARRAY [1..5] OF STRING(55);
END_VAR
VAR_OUTPUT
END_VAR
VAR
	iMessageNr: INT;
END_VAR
(* @END_DECLARATION := '0' *)
(* ENGLISCH *)
asEmptyMessageEngl[1]:='Message 0 of 0';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asEmptyMessageEngl[2]:='No Pre Warning Message';
asEmptyMessageEngl[3]:='';
asEmptyMessageEngl[4]:='OK for acknowledge Message!';
asEmptyMessageEngl[5]:='RESET no effect!';
iMessageNr:=1;
asMessageStringEngl[iMessageNr,1]:='Message 1 of 1';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringEngl[iMessageNr,2]:='Tool Change for Station 1 must be nearly occur!';
asMessageStringEngl[iMessageNr,3]:='On reach of max. Number ToolCycle->Automat stop!';
asMessageStringEngl[iMessageNr,4]:='OK for acknowledge Message!';
asMessageStringEngl[iMessageNr,5]:='RESET for delete selected Message!';
iMessageNr:=iMessageNr + 1;
asMessageStringEngl[iMessageNr,1]:='Message 2 of 2';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringEngl[iMessageNr,2]:='Z Axis brake of Station 1 is blocked!';
asMessageStringEngl[iMessageNr,3]:='Please release the Manual block of the Z Axis.';
asMessageStringEngl[iMessageNr,4]:='OK for acknowledge Message!';
asMessageStringEngl[iMessageNr,5]:='RESET for delete selected Message!';
iMessageNr:=iMessageNr + 1;
asMessageStringEngl[iMessageNr,1]:='Message 3 of 3';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringEngl[iMessageNr,2]:='';
asMessageStringEngl[iMessageNr,3]:='';
asMessageStringEngl[iMessageNr,4]:='OK for acknowledge Message!';
asMessageStringEngl[iMessageNr,5]:='RESET for delete selected Message!';
iMessageNr:=iMessageNr + 1;
asMessageStringEngl[iMessageNr,1]:='Message 4 of 4';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringEngl[iMessageNr,2]:='';
asMessageStringEngl[iMessageNr,3]:='';
asMessageStringEngl[iMessageNr,4]:='OK for acknowledge Message!';
asMessageStringEngl[iMessageNr,5]:='RESET for delete selected Message!';
iMessageNr:=iMessageNr + 1;
asMessageStringEngl[iMessageNr,1]:='Message 5 of 5';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringEngl[iMessageNr,2]:='';
asMessageStringEngl[iMessageNr,3]:='';
asMessageStringEngl[iMessageNr,4]:='OK for acknowledge Message!';
asMessageStringEngl[iMessageNr,5]:='RESET for delete selected Message!';
iMessageNr:=iMessageNr + 1;
asMessageStringEngl[iMessageNr,1]:='Message 6 of 6';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringEngl[iMessageNr,2]:='';
asMessageStringEngl[iMessageNr,3]:='';
asMessageStringEngl[iMessageNr,4]:='OK for acknowledge Message!';
asMessageStringEngl[iMessageNr,5]:='RESET for delete selected Message!';
iMessageNr:=iMessageNr + 1;
asMessageStringEngl[iMessageNr,1]:='Message 7 of 7';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringEngl[iMessageNr,2]:='';
asMessageStringEngl[iMessageNr,3]:='';
asMessageStringEngl[iMessageNr,4]:='OK for acknowledge Message!';
asMessageStringEngl[iMessageNr,5]:='RESET for delete selected Message!';
iMessageNr:=iMessageNr + 1;
asMessageStringEngl[iMessageNr,1]:='Message 8 of 8';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringEngl[iMessageNr,2]:='';
asMessageStringEngl[iMessageNr,3]:='';
asMessageStringEngl[iMessageNr,4]:='OK for acknowledge Message!';
asMessageStringEngl[iMessageNr,5]:='RESET for delete selected Message!';
iMessageNr:=iMessageNr + 1;
asMessageStringEngl[iMessageNr,1]:='Message 9 of 9';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringEngl[iMessageNr,2]:='';
asMessageStringEngl[iMessageNr,3]:='';
asMessageStringEngl[iMessageNr,4]:='OK for acknowledge Message!';
asMessageStringEngl[iMessageNr,5]:='RESET for delete selected Message!';
iMessageNr:=iMessageNr + 1;
asMessageStringEngl[iMessageNr,1]:='Message 10 of 10';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringEngl[iMessageNr,2]:='';
asMessageStringEngl[iMessageNr,3]:='';
asMessageStringEngl[iMessageNr,4]:='OK for acknowledge Message!';
asMessageStringEngl[iMessageNr,5]:='RESET for delete selected Message!';

(* DEUTSCH *)
asEmptyMessageGer[1]:='Meldung 0 von 0';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asEmptyMessageGer[2]:='Es bestehen keine Warnungen';
asEmptyMessageGer[3]:='';
asEmptyMessageGer[4]:='OK für Meldung Quittieren!';
asEmptyMessageGer[5]:='RESET hat keine Auswirkung!';
iMessageNr:=1;
asMessageStringGer[iMessageNr,1]:='Meldung 1 von 1';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringGer[iMessageNr,2]:='Wz Wechsel für Station 1 muss bald vorgenommen werden!';
asMessageStringGer[iMessageNr,3]:='Beim erreichen max Anz. WzZyklen->Maschinen Stillstand!';
asMessageStringGer[iMessageNr,4]:='OK für Meldung Quittieren!';
asMessageStringGer[iMessageNr,5]:='RESET für ausgewählte Meldung Löschen!';
iMessageNr:=iMessageNr + 1;
asMessageStringGer[iMessageNr,1]:='Meldung 2 von 2';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringGer[iMessageNr,2]:='Z Achsenbremse von Station 1 ist blockiert!';
asMessageStringGer[iMessageNr,3]:='Lösen Sie Bitte die Handblockierung der Z Achse.';
asMessageStringGer[iMessageNr,4]:='OK für Meldung Quittieren!';
asMessageStringGer[iMessageNr,5]:='RESET für ausgewählte Meldung Löschen!';
iMessageNr:=iMessageNr + 1;
asMessageStringGer[iMessageNr,1]:='Meldung 3 von 3';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringGer[iMessageNr,2]:='';
asMessageStringGer[iMessageNr,3]:='';
asMessageStringGer[iMessageNr,4]:='OK für Meldung Quittieren!';
asMessageStringGer[iMessageNr,5]:='RESET für ausgewählte Meldung Löschen!';
iMessageNr:=iMessageNr + 1;
asMessageStringGer[iMessageNr,1]:='Meldung 4 von 4';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringGer[iMessageNr,2]:='';
asMessageStringGer[iMessageNr,3]:='';
asMessageStringGer[iMessageNr,4]:='OK für Meldung Quittieren!';
asMessageStringGer[iMessageNr,5]:='RESET für ausgewählte Meldung Löschen!';
iMessageNr:=iMessageNr + 1;
asMessageStringGer[iMessageNr,1]:='Meldung 5 von 5';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringGer[iMessageNr,2]:='';
asMessageStringGer[iMessageNr,3]:='';
asMessageStringGer[iMessageNr,4]:='OK für Meldung Quittieren!';
asMessageStringGer[iMessageNr,5]:='RESET für ausgewählte Meldung Löschen!';
iMessageNr:=iMessageNr + 1;
asMessageStringGer[iMessageNr,1]:='Meldung 6 von 6';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringGer[iMessageNr,2]:='';
asMessageStringGer[iMessageNr,3]:='';
asMessageStringGer[iMessageNr,4]:='OK für Meldung Quittieren!';
asMessageStringGer[iMessageNr,5]:='RESET für ausgewählte Meldung Löschen!';
iMessageNr:=iMessageNr + 1;
asMessageStringGer[iMessageNr,1]:='Meldung 7 von 7';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringGer[iMessageNr,2]:='';
asMessageStringGer[iMessageNr,3]:='';
asMessageStringGer[iMessageNr,4]:='OK für Meldung Quittieren!';
asMessageStringGer[iMessageNr,5]:='RESET für ausgewählte Meldung Löschen!';
iMessageNr:=iMessageNr + 1;
asMessageStringGer[iMessageNr,1]:='Meldung 8 von 8';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringGer[iMessageNr,2]:='';
asMessageStringGer[iMessageNr,3]:='';
asMessageStringGer[iMessageNr,4]:='OK für Meldung Quittieren!';
asMessageStringGer[iMessageNr,5]:='RESET für ausgewählte Meldung Löschen!';
iMessageNr:=iMessageNr + 1;
asMessageStringGer[iMessageNr,1]:='Meldung 9 von 9';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringGer[iMessageNr,2]:='';
asMessageStringGer[iMessageNr,3]:='';
asMessageStringGer[iMessageNr,4]:='OK für Meldung Quittieren!';
asMessageStringGer[iMessageNr,5]:='RESET für ausgewählte Meldung Löschen!';
iMessageNr:=iMessageNr + 1;
asMessageStringGer[iMessageNr,1]:='Meldung 10 von 10';	(* Dieser Text wird Dynamisch erstellt und besagt welche Message von wievielen Messages ausgewählt wurde *)
asMessageStringGer[iMessageNr,2]:='';
asMessageStringGer[iMessageNr,3]:='';
asMessageStringGer[iMessageNr,4]:='OK für Meldung Quittieren!';
asMessageStringGer[iMessageNr,5]:='RESET für ausgewählte Meldung Löschen!';
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER4_PROCESS\/FBPROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_PROCESS
VAR_INPUT
	xActiveProcessState:BOOL;
	xEnergyON:BOOL;
END_VAR
VAR_IN_OUT
	T_Process : ST_PROCESS;
	T_NovRam : ST_NOVRAM;
	TStation_Work : ST_STATION;
	T_ProcessData:ST_PROCESSDATA;
END_VAR
VAR_OUTPUT
	xStatusRdy : BOOL := FALSE;
	xStatusDone : BOOL := FALSE;
	xStatusStop : BOOL := FALSE;
	xStatusRef : BOOL := FALSE;
	xStatusError : BOOL := FALSE;
	diStatusErrorNr : DINT :=0;
	iStatusFctNr : INT := 0;
END_VAR
VAR
	xDisable: BOOL;
	xSetEnd: BOOL;
	RisingEdgeProcessExecute: R_TRIG;
	RisingEdgeProcessStop: R_TRIG;
	RisingEdgeProcessAbord: R_TRIG;
	FBErrorMessage : FB_ErrorMessage;
	xPrcFct_StationError: BOOL;
	xPrcFct_SaveStationError: BOOL;
	iPrcFct_StepStationError: INT;
	xPrcFct_StationReady: BOOL;
	xPrcFct_StationBlock: BOOL;
	xPrcFct_StartMainPrc: BOOL;
	iPrcFct_StepPrc: INT;
	xPrcFct_InitStep: BOOL;
	diPrcFct_SaveErrorNr: DINT;
	xPrcFct_StopProcess: BOOL;
	iPrcFct_StepStopProcess: INT;
	xStartMainPrc: BOOL;
	xPrcFct_StartPrc_Parallel1: BOOL;
	iPrcFct_StepPrc_Parallel1: INT;
	xPrcFct_InitStep_Parallel1: BOOL;
	iPrcFct_StepPrc_Parallel2: INT;
	xPrcFct_InitStep_Parallel2: BOOL;
	xPrcFct_StartPrc_Parallel2: BOOL;
	xPrcFct_SetNextStationActive_St1: BOOL;
	iPrcFct_PickPlaceProcedure: INT;
	TONTickTime: TON;
	FBProcessInformation_StR: FB_ProcessInformation;
	xAutoActiveProcess: BOOL;
	TONTickTime1: TON;
	FBWPCounter_StR: FB_WPCounter;
	xPrcFct_PartDiscReady: BOOL;
	xPrcFct_ReadyToWriteQuality_St1: BOOL;
	xPrcFct_WorkStationReady: BOOL;
	xPrcFct_XAxisGoToWaitPos: BOOL;
	xPrcFct_ForceResetFlag: BOOL;
	xPrcFct_SaveNoMoreParts: BOOL;
	xExecuteOneTime: BOOL;
	ii: INT;
	xHoleToWork: BOOL;
	RisingEdgeCheckWorkEnd: R_TRIG;
	xProcessActive: BOOL;
	xRdyCycleTime: BOOL;
	FBWPAnalysis_StR: FB_WPAnalysis;
	xPrcFct_ProcessContinueActive: BOOL;
	xPrcFct_StopCycleProcess: BOOL;
	xPrcFct_Ready_St1: BOOL;
	xSpindelCalibrationONOFF: BOOL;
	iStepPrc_1: INT;
	xInitPrc_1: BOOL;
	iNumberTryInfeed: INT;
	xActivate_StationRight: BOOL;
	xBlockQuality_StR: BOOL;
	xWriteData: BOOL;
	xStartWorkPart: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
CtrlInformation;
(******************************************************************************************************************************************)
(***********************************		           Enable/Disable Prozess                           ******************************************)
(******************************************************************************************************************************************)
IF NOT(T_Process.T_Ctrle.xEnable) THEN
	T_Process.T_Ctrle.xRdy:=FALSE;
	xDisable:=TRUE;
	RETURN;
ELSE
	IF xDisable THEN
		T_Process.T_Ctrle.xRdy:=TRUE;
		xDisable:=FALSE;
		xSetEnd:=TRUE;
	END_IF;
END_IF;
CtrlWorkpiece;
(******************************************************************************************************************************************)
(****************************				                  Status Part                                                            *****************************)
(******************************************************************************************************************************************)
xStatusRdy:=T_Process.T_Ctrle.xRdy;
xStatusDone:=T_Process.T_Ctrle.xDone;
xStatusStop:=T_Process.T_Ctrle.xStop;
xStatusRef:=	TStation_Work.TControl.xReferenced;
T_Process.T_Ctrle.xReferenced:=xStatusRef;
xStatusError:=T_Process.T_Ctrle.xError;
diStatusErrorNr:=T_Process.T_Ctrle.diErrorNr;
iStatusFctNr:=T_Process.T_Ctrle.iFunctNr;
(******************************************************************************************************************************************)
(****************************				         Error Controlling Part                                                  *****************************)
(******************************************************************************************************************************************)
CtrlErrorProcess;
(******************************************************************************************************************************************)
(****************************				         Main Controlling Part                                                  *****************************)
(******************************************************************************************************************************************)
CtrlMainProcess;
(******************************************************************************************************************************************)
(****************************				              Funktionen                                                               *****************************)
(******************************************************************************************************************************************)
IF xStartMainPrc AND NOT(xSetEnd) THEN
	IF (T_Process.T_Fct.iFunctNr = 1) THEN
		ProcessFunction_Fct_Referencing;
	END_IF;
	IF (T_Process.T_Fct.iFunctNr = 2) THEN
		ProcessFunction_Fct_Automat;
	END_IF;
	IF (T_Process.T_Fct.iFunctNr = 3) THEN
		ProcessFunction_Fct_HandMode;
		gxHandModeActive:=TRUE;
	ELSE
		gxHandModeActive:=FALSE;
		gxBlockSetQuality:=FALSE;
	END_IF;
ELSE
	gxHandModeActive:=FALSE;
	gxBlockSetQuality:=FALSE;
END_IF;
(******************************************************************************************************************************************)
(****************************				               Init / Reset Flag                                                      *****************************)
(******************************************************************************************************************************************)
IF xSetEnd THEN
	xSetEnd:=FALSE;
	T_Process.T_Ctrle.xStop:=FALSE;
	T_Process.T_Ctrle.xExecute:=FALSE;
	T_Process.T_Ctrle.xDone:=TRUE;
	T_Process.T_Ctrle.xAbordProcess:=FALSE;
	T_Process.T_Ctrle.xError:=FALSE;
	T_Process.T_Ctrle.diErrorNr:=0;
	T_Process.T_Ctrle.xErrorReady:=FALSE;
	T_Process.T_Ctrle.xQuitError:=FALSE;
	T_Process.T_Fct.xSetEndFunction:=TRUE;
	ProcessFunction_Ctrl_End;
	xStartMainPrc:=FALSE;
	xPrcFct_StationBlock:=FALSE;
	iPrcFct_StepStationError:=1;
	xPrcFct_SaveStationError:=FALSE;
	T_Process.T_Fct.xErrorReady:=FALSE;
	TStation_Work.THWWorkStation.TCtrlWork.xActiveProcess:=FALSE;
	TStation_Work.THWWorkStation.TCtrlWork.xWorkingFinished:=FALSE;
	TStation_Work.THWWorkStation.TCtrlWork.xWorkingStarted:=FALSE;
END_IF;
END_FUNCTION_BLOCK
ACTION	CtrlErrorProcess:
IF T_Process.T_Fct.xError AND NOT(T_Process.T_Fct.xQuitError) THEN
	(* Bei Fehler wird der Prozess abgebrochen, Bei Warnung kann weitergefahren oder abgebrochen werden *)
	T_Process.T_Ctrle.diErrorNr:=T_Process.T_Fct.diErrorNr;
	T_Process.T_Fct.xQuitError:=TRUE;
END_IF;
IF T_Process.T_Fct.xErrorReady THEN
	IF NOT(T_Process.T_Fct.xQuitError) AND T_Process.T_Fct.xDone AND NOT(T_Process.T_Ctrle.xErrorReady) THEN
		(* Fehler kann nun gesetzt werden *)
		T_Process.T_Ctrle.xError:=TRUE;
		T_Process.T_Ctrle.xErrorReady:=TRUE;
		T_Process.T_Fct.xErrorReady:=FALSE;
	END_IF;
END_IF;
IF T_Process.T_Ctrle.xError THEN
	IF T_Process.T_Ctrle.xQuitError THEN
		T_Process.T_Ctrle.xQuitError:=FALSE;
		IF T_Process.T_Ctrle.xError THEN
			T_Process.T_Ctrle.xError:=FALSE;
			T_Process.T_Ctrle.xErrorReady:=FALSE;
			xSetEnd:=TRUE;
		END_IF;
	END_IF;
END_IF;
END_ACTION

ACTION	CtrlInformation:
(* Logik für Wstk Daten Analyse *)
FBWPAnalysis_StR(	diActual_NumberHoleToWork:=  T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].diActual_NumberHoleToWork,
					T_PartAnalysis:= T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1],
					TStation_Work:= TStation_Work,
					xAddInfeedZ:=gxAddInfeedZ,
					xSetPartQuality:=gxSetPartQuality);

(* Prozessinformationen zu den einzelnen Bearbeitungs Stationen *)
FBProcessInformation_StR(	T_Parameter:= T_NovRam.T_Parameter,
							TStation_Work:= TStation_Work);

(* Logik für Automatik Prozesszeit *)
xAutoActiveProcess:=	T_Process.T_Ctrle.xEnable AND
						NOT(T_Process.T_Ctrle.xDone) AND
						NOT(T_Process.T_Ctrle.xError) AND
						(T_Process.T_Ctrle.iFunctNr = 2);

IF xAutoActiveProcess THEN
	TONTickTime(IN:=TRUE,PT:=T#1s);
	IF TONTickTime.Q THEN
		TONTickTime(IN:=FALSE);
		T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.tAutoProcessTime_St1St2:=T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.tAutoProcessTime_St1St2 + T#1s;
		IF T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.tAutoProcessTime_St1St2 >= T#86400s THEN
			IF (T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.iAutoProcessDay_St1St2 < 32767) THEN
				T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.iAutoProcessDay_St1St2:=T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.iAutoProcessDay_St1St2 + 1;
			END_IF;
			T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.tAutoProcessTime_St1St2:=T#0s;
		END_IF;
	END_IF;
ELSE
	TONTickTime(IN:=FALSE);
END_IF;

(* AutoBetrieb Aktiv Zeit-->zeigt die Absolute Zeit von jeder Station wie lange es schon Aktiv ist *)
IF xAutoActiveProcess THEN
	TONTickTime1(IN:=TRUE,PT:=T#0.1s);
	IF TONTickTime1.Q THEN
		TONTickTime1(IN:=FALSE);
		IF TStation_Work.TControl.xEnable AND NOT(TStation_Work.TControl.xDone) AND NOT(TStation_Work.TControl.xError) THEN
			T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.tActualActiveTime_St1:=T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.tActualActiveTime_St1 + T#0.1s;
			IF T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.tActualActiveTime_St1 >= T#86400s THEN
				IF (T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.iActualActiveTime_St1 < 32767) THEN
					T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.iActualActiveTime_St1:=T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.iActualActiveTime_St1 + 1;
				END_IF;
				T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.tActualActiveTime_St1:=T#0s;
			END_IF;
		END_IF;
	END_IF;
ELSE
	TONTickTime1(IN:=FALSE);
END_IF;

(* Wstk Zähler *)
FBWPCounter_StR(	iStationNr:=gciStationSt1,
					T_Parameter:= T_NovRam.T_Parameter,
					T_CtrlWork:= TStation_Work.THWWorkStation.TCtrlWork);
END_ACTION

ACTION	CtrlMainProcess:
RisingEdgeProcessExecute(CLK:=T_Process.T_Ctrle.xExecute);
RisingEdgeProcessStop(CLK:=T_Process.T_Ctrle.xStop);
RisingEdgeProcessAbord(CLK:=T_Process.T_Ctrle.xAbordProcess);
(* Prozess Start *)
IF RisingEdgeProcessExecute.Q THEN
	IF T_Process.T_Ctrle.xDone AND NOT(T_Process.T_Ctrle.xError) THEN
		T_Process.T_Ctrle.xStop:=FALSE;
		T_Process.T_Ctrle.xExecute:=FALSE;
		T_Process.T_Ctrle.xDone:=FALSE;
		T_Process.T_Ctrle.xAbordProcess:=FALSE;
		T_Process.T_Ctrle.xError:=FALSE;
		T_Process.T_Ctrle.diErrorNr:=0;
		T_Process.T_Fct.xExecute:=TRUE;
		xStartMainPrc:=TRUE;
		T_Process.T_Fct.iFunctNr:=T_Process.T_Ctrle.iFunctNr;
		xRdyCycleTime:=FALSE;
		xStartWorkPart:=FALSE;
	END_IF;
END_IF;

(* Prozess Stop *)
IF RisingEdgeProcessStop.Q THEN
	IF NOT(T_Process.T_Ctrle.xDone) AND NOT(T_Process.T_Fct.xExecute) THEN
		(* Prozess muss Aktiv sein und dürfte auch im ZyklusStop Zustand sein, welches dann unterbrochen werden würde *)
		T_Process.T_Fct.xStop:=T_Process.T_Ctrle.xStop;
	ELSE
		T_Process.T_Ctrle.xStop:=FALSE;
	END_IF;
END_IF;
(* Abbrechen des Prozesses *)
IF RisingEdgeProcessAbord.Q THEN
	T_Process.T_Fct.xAbordProcess:=TRUE;
END_IF;
(* Auffangen des Prozess Endes *)
IF NOT(T_Process.T_Ctrle.xDone) AND NOT(T_Process.T_Ctrle.xErrorReady) THEN
	IF NOT(T_Process.T_Fct.xExecute) AND T_Process.T_Fct.xDone THEN
		xSetEnd:=TRUE;
	END_IF;
END_IF;

END_ACTION

ACTION	CtrlWorkpiece:
RisingEdgeCheckWorkEnd(CLK:=TStation_Work_St1.THWWorkStation.TCtrlWork.xWorkingFinished);
IF RisingEdgeCheckWorkEnd.Q AND xAutoActiveProcess AND (TStation_Work_St1.THWWorkStation.TCtrlWork.bPartQuality <> 0) AND
     (TStation_Work_St1.THWWorkStation.TCtrlWork.bPartQuality <> 7) AND (TStation_Work_St1.THWWorkStation.TCtrlWork.bPartQuality <> 8) THEN
	(* Nach jeder bearbeitenden Bohrung muss "xAddToolCounter_Machine" gesetzt werden-->Ist für den WzWechsel *)
	TStation_Work_St1.THWWorkStation.TCtrlWork.xAddToolCounter_Machine:=TRUE;
END_IF;
IF xHoleToWork THEN
	IF NOT(xWriteData) THEN
		IF (T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].diActual_NumberHoleToWork <= 0) THEN
			T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].diActual_NumberHoleToWork:=1;
		END_IF;
		FOR ii:= 1 TO ciMaxWP DO
			IF (T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiNumberHole[ii] = T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].diActual_NumberHoleToWork) THEN
				IF ((T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].abWorkPartQuality[ii] >= 1) AND (T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].abWorkPartQuality[ii] <= 6)) OR (T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].abWorkPartQuality[ii] = 10) THEN
					T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].diActual_NumberHoleToWork:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].diActual_NumberHoleToWork + 1;
				END_IF;
			END_IF;
		END_FOR;
		(* Überprüfe ob Arrayelement erreicht wurde *)
		IF (T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].diActual_NumberHoleToWork > T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiNumberHole[ciMaxWP]) THEN
			FOR ii:=1 TO (ciMaxWP-1) DO
				T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].abWorkPartQuality[ii]:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].abWorkPartQuality[ii+1];
				T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].arFirstHC[ii]:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].arFirstHC[ii+1];
				T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].aiHCCounter[ii]:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].aiHCCounter[ii+1];
				T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].aiHCCounterCentering[ii]:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].aiHCCounterCentering[ii+1];
				T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].aiHCCounterTorque[ii]:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].aiHCCounterTorque[ii+1];
				T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].aiHCCounterSpeed[ii]:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].aiHCCounterSpeed[ii+1];
				T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiCycleTime[ii]:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiCycleTime[ii+1];
				T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiWorkTime[ii]:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiWorkTime[ii+1];
				T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].abInfeedCounterZ[ii]:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].abInfeedCounterZ[ii+1];
				T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiNumberHole[ii]:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiNumberHole[ii+1];
			END_FOR;
			T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].abWorkPartQuality[ciMaxWP]:=0;
			T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].arFirstHC[ciMaxWP]:=0.0;
			T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].aiHCCounter[ciMaxWP]:=0;
			T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].aiHCCounterCentering[ciMaxWP]:=0;
			T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].aiHCCounterTorque[ciMaxWP]:=0;
			T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].aiHCCounterSpeed[ciMaxWP]:=0;
			T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiCycleTime[ciMaxWP]:=0;
			T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiWorkTime[ciMaxWP]:=0;
			T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].abInfeedCounterZ[ciMaxWP]:=0;
			T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiNumberHole[ciMaxWP]:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiNumberHole[ciMaxWP] + 1;
		END_IF;
		xHoleToWork:=FALSE;
	END_IF;
END_IF;
END_ACTION

ACTION	ProcessFunction_Ctrl_End:
IF T_Process.T_Fct.xSetEndFunction OR xPrcFct_ForceResetFlag THEN
	IF NOT(xPrcFct_ForceResetFlag) THEN
		T_Process.T_Fct.xDone:=TRUE;
	END_IF;
	xPrcFct_ForceResetFlag:=FALSE;
	T_Process.T_Fct.xStop:=FALSE;
	T_Process.T_Fct.xExecute:=FALSE;
	T_Process.T_Fct.xAbordProcess:=FALSE;
	T_Process.T_Fct.xError:=FALSE;
	T_Process.T_Fct.diErrorNr:=0;
	T_Process.T_Fct.xQuitError:=FALSE;
	T_Process.T_Fct.xSetEndFunction:=FALSE;
	T_Process.T_Fct.xReset:=FALSE;
	xPrcFct_SaveStationError:=FALSE;
	xPrcFct_StartPrc_Parallel1:=FALSE;
	xPrcFct_StartPrc_Parallel2:=FALSE;
	iPrcFct_StepPrc_Parallel1:=1;
	iPrcFct_StepPrc_Parallel2:=1;
	xPrcFct_InitStep_Parallel1:=FALSE;
	xPrcFct_InitStep_Parallel2:=FALSE;
	xPrcFct_SetNextStationActive_St1:=FALSE;
	iPrcFct_PickPlaceProcedure:=0;
	xPrcFct_PartDiscReady:=FALSE;
	xPrcFct_ReadyToWriteQuality_St1:=FALSE;
	xPrcFct_XAxisGoToWaitPos:=FALSE;
	xPrcFct_ProcessContinueActive:=FALSE;
	iPrcFct_StepPrc:=1;
	xPrcFct_InitStep:=FALSE;
	xPrcFct_SaveNoMoreParts:=FALSE;
	xPrcFct_StopProcess:=FALSE;
	xPrcFct_StopCycleProcess:=FALSE;
	diPrcFct_SaveErrorNr:=0;
	TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveCycle:=FALSE;			(* Zykluszeit für zu bearbeitende Bohrung ist gestartet *)
	TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveWork:=FALSE;			(* Bearbeitungszeit für zu bearbeitende Bohrung ist gestartet *)
	xStartWorkPart:=FALSE;
	QxCoolant_St1:=FALSE;
	QxFastStrokeOn_St1:=FALSE;
END_IF;
END_ACTION

ACTION	ProcessFunction_Ctrl_Error:
xPrcFct_StationError:=	TStation_Work.TControl.xError OR T_ProcessData.T_Ctrle.xErr;
IF (xPrcFct_StationError OR xPrcFct_SaveStationError) AND NOT(T_Process.T_Fct.xErrorReady) THEN
	xPrcFct_SaveStationError:=TRUE;
	IF (T_Process.T_Fct.iFunctNr = 2) THEN
		(* Automat *)
		xPrcFct_WorkStationReady:=	TStation_Work.TControl.xError OR NOT(xStartWorkPart);
	ELSE
		(* Restliche Prozesse *)
		xPrcFct_WorkStationReady:=	(TStation_Work.TControl.xError OR TStation_Work.TControl.xDone);
	END_IF;
	xPrcFct_StationReady:=	(xPrcFct_WorkStationReady OR xPrcFct_StationBlock);
	CASE iPrcFct_StepStationError OF
	(* Abwarten bis alle Station Zyklus beendet haben *)
	1: 	IF xPrcFct_StationReady THEN
			xPrcFct_StationBlock:=TRUE;
			iPrcFct_StepStationError:=iPrcFct_StepStationError + 1;
			IF TStation_Work.THWWorkStation.TCtrlWork.xWorkStartToolRotation THEN
				TStation_Work.THWWorkStation.TCtrlWork.xWorkStopToolRotation:=TRUE;
			END_IF;
		END_IF;
	2:	iPrcFct_StepStationError:=iPrcFct_StepStationError + 1;
		TStation_Work.THWWorkStation.TCtrlWork.xActiveProcess:=FALSE;
		TStation_Work.THWWorkStation.TCtrlWork.xWorkingFinished:=FALSE;
	(* Überprüfen ob es einen Fehler oder eine Warnung ist *)
	3:	IF (diPrcFct_SaveErrorNr <> 0)THEN
			T_Process.T_Fct.diErrorNr:=diPrcFct_SaveErrorNr;
		ELSIF TStation_Work.TControl.xError THEN
			T_Process.T_Fct.diErrorNr:=TStation_Work.TControl.diErrorNr;
		ELSIF T_ProcessData.T_Ctrle.xErr THEN
			T_Process.T_Fct.diErrorNr:=82000000 + T_ProcessData.T_Ctrle.udiErrorID;
		END_IF;
		FBErrorMessage(	diErrorNr:=T_Process.T_Fct.diErrorNr,
							T_ErrorList:=T_ErrorList);
		T_Process.T_Fct.xError:=TRUE;
		diPrcFct_SaveErrorNr:=0;
		iPrcFct_StepStationError:=iPrcFct_StepStationError + 1;
	(* Warten bis Quittiert wird *)
	4:	IF T_Process.T_Fct.xQuitError THEN
			T_Process.T_Fct.xQuitError:=FALSE;
			T_Process.T_Fct.xErrorReady:=TRUE;
			T_Process.T_Fct.xError:=FALSE;
			T_Process.T_Fct.xSetEndFunction:=TRUE;
		END_IF;
	END_CASE;
ELSE
	xExecuteOneTime:=FALSE;
	iPrcFct_StepStationError:=1;
END_IF;
END_ACTION

ACTION	ProcessFunction_Ctrl_Main:
(* Prozess Start *)
IF T_Process.T_Fct.xExecute THEN
	T_Process.T_Fct.xStop:=FALSE;
	T_Process.T_Fct.xExecute:=FALSE;
	T_Process.T_Fct.xDone:=FALSE;
	T_Process.T_Fct.xAbordProcess:=FALSE;
	T_Process.T_Fct.xError:=FALSE;
	T_Process.T_Fct.diErrorNr:=0;
	iPrcFct_StepPrc:=1;
	xPrcFct_InitStep:=FALSE;
	xPrcFct_StartMainPrc:=TRUE;
	diPrcFct_SaveErrorNr:=0;
	TStation_Work.THWWorkStation.TCtrlWork.xWorkStartToolRotation:=FALSE;
	TStation_Work.THWWorkStation.TCtrlWork.xWorkStopToolRotation:=FALSE;
	TStation_Work.THWWorkStation.TCtrlWork.xWorkingFinished:=FALSE;
	xPrcFct_SaveNoMoreParts:=FALSE;
	xProcessActive:=FALSE;
END_IF;
(* Abbrechen des Prozesses *)
IF T_Process.T_Fct.xAbordProcess THEN
	T_Process.T_Fct.xAbordProcess:=FALSE;
	T_Process.T_Fct.xSetEndFunction:=TRUE;
END_IF;
IF NOT(xPrcFct_ForceResetFlag) AND xPrcFct_ProcessContinueActive THEN
	xPrcFct_StationBlock:=FALSE;
END_IF;
END_ACTION

ACTION	ProcessFunction_Ctrl_Reset:
IF T_Process.T_Fct.xReset THEN
	T_Process.T_Fct.xSetEndFunction:=TRUE;
END_IF;
END_ACTION

ACTION	ProcessFunction_Ctrl_Stop:
IF T_Process.T_Fct.xStop OR xPrcFct_StopProcess THEN
	xPrcFct_StationReady:=	NOT(TStation_Work.TControl.xExecute) AND (TStation_Work.TControl.xDone OR TStation_Work.TControl.xError);
	CASE iPrcFct_StepStopProcess OF
	(* Stoppen der Aktiven Stationen *)
	1:	xPrcFct_StationBlock:=TRUE;
		xPrcFct_StopProcess:=TRUE;
		xPrcFct_ProcessContinueActive:=FALSE;
		TStation_Work.TControl.xStop:=NOT(TStation_Work.TControl.xError) AND NOT(TStation_Work.TControl.xDone) AND xEnergyON;
		(* Flag für die WstkAnalyse zurücksetzen *)
		iPrcFct_StepStopProcess:=iPrcFct_StepStopProcess + 1;
	(* Zurücksetzen der Steuerflag für Bearbstationen *)
	2:	IF xPrcFct_StationReady OR xPrcFct_SaveStationError THEN
			iPrcFct_StepStopProcess:=iPrcFct_StepStopProcess + 1;
			TStation_Work.THWWorkStation.TCtrlWork.xActiveProcess:=FALSE;
			TStation_Work.THWWorkStation.TCtrlWork.xWorkingFinished:=FALSE;
			TStation_Work.THWWorkStation.TCtrlWork.xWorkStopToolRotation:=xEnergyON;
			(* Flag für die WstkAnalyse zurücksetzen *)
		END_IF;
	3:	IF (T_Process.T_Ctrle.iFunctNr <> 1) THEN
			TStation_Work.TControl.iFunctNr:=2;			(* Bearbeitungsstation Grundstellung *)
			TStation_Work.TControl.xExecute:=NOT(TStation_Work.TControl.xError) AND xEnergyON;
			IF (TStation_Work.THWWorkStation.TCtrlWork.bPartQuality >= 1) AND (TStation_Work.THWWorkStation.TCtrlWork.bPartQuality <= 6) THEN
				IF T_NovRam.T_Parameter.T_Machine.T_ParamSystem.xDataFileActive AND NOT(T_NovRam.T_Parameter.T_Machine.xEndlessProcessActive) THEN
					(* Prozessdatei wird geschrieben *)
					T_ProcessData.T_Ctrle.iFunction:=1;
					T_ProcessData.T_Ctrle.xExecute:=TRUE;
				END_IF;
			END_IF;
		END_IF;
		iPrcFct_StepStopProcess:=iPrcFct_StepStopProcess + 1;
	4:	IF NOT(TStation_Work.TControl.xExecute) AND (TStation_Work.TControl.xDone OR TStation_Work.TControl.xError) THEN
			iPrcFct_StepStopProcess:=iPrcFct_StepStopProcess + 1;
		END_IF;
	(* Abwarten bis alle Stationen bereit stehen *)
	5:	IF xPrcFct_StationReady OR xPrcFct_SaveStationError THEN
			iPrcFct_StepStopProcess:=iPrcFct_StepStopProcess + 1;
		END_IF;
	6:	xPrcFct_StopProcess:=FALSE;
		T_Process.T_Fct.xStop:=FALSE;
		IF NOT(xPrcFct_SaveStationError) THEN
			T_Process.T_Fct.xAbordProcess:=TRUE;
		END_IF;
	END_CASE;
ELSE
	iPrcFct_StepStopProcess:=1;
END_IF;
END_ACTION

ACTION	ProcessFunction_Fct_Automat:
(******************************************************************************************************************************************)
(****************************				           Reset Processfunktion                                            *****************************)
(******************************************************************************************************************************************)
ProcessFunction_Ctrl_Reset;
(******************************************************************************************************************************************)
(****************************			        Processfunktion Fehler Controller                                    *****************************)
(******************************************************************************************************************************************)
ProcessFunction_Ctrl_Error;
(******************************************************************************************************************************************)
(****************************				    Processfunktion Haupt Controller                               *****************************)
(******************************************************************************************************************************************)
ProcessFunction_Ctrl_Main;
(******************************************************************************************************************************************)
(****************************			         Processfunktion sofort Unterbrechung                           *****************************)
(******************************************************************************************************************************************)
ProcessFunction_Ctrl_Stop;
(******************************************************************************************************************************************)
(****************************			             Processfunktion Hauptablauf                                       *****************************)
(******************************************************************************************************************************************)
ProcessFunction_Fct_Automat_Station;
IF xPrcFct_StartMainPrc AND NOT(xPrcFct_StationBlock) AND NOT(T_Process.T_Fct.xSetEndFunction) AND NOT(xPrcFct_SaveStationError) THEN
	CASE iPrcFct_StepPrc OF
	1:	T_ExchgParam.T_Visu.T_Message.iState:=0;
		IF (T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter.diMaxNumberToolCycle <> 0) AND
		    (T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter.diToolCycleCounter >= T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter.diMaxNumberToolCycle) THEN
			TStation_Work.TControl.xError:=TRUE;
			TStation_Work.TControl.xDone:=FALSE;
			TStation_Work.TControl.diErrorNr:=(gciStationSt1 * 1000000) + 16#F101;		(* WzWechsel muss vorgenommen werden *)
			RETURN;
		END_IF;
		IF (garPositionEndProcCalc[1] > T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rPositionEndProcMaxInc) AND (T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.xPositionEndProcIncOnOff OR gxProcessCylindricalAreaActive) THEN
			TStation_Work.TControl.xError:=TRUE;
			TStation_Work.TControl.xDone:=FALSE;
			TStation_Work.TControl.diErrorNr:=(gciStationSt1 * 1000000) + 17;		(* Z Bearb EndPos Berechn. > Z Bearb EndPos Max *)
			RETURN;
		END_IF;
		IF (garCentringEndProcCalc[1] > T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rPositionEndProcMaxInc) AND T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.xCentringEndProcIncOnOff THEN
			TStation_Work.TControl.xError:=TRUE;
			TStation_Work.TControl.xDone:=FALSE;
			TStation_Work.TControl.diErrorNr:=(gciStationSt1 * 1000000) + 19;		(* Z ZentrierPos berechn. > Z Bearb EndPos Max *)
			RETURN;
		END_IF;
		IF NOT(xPrcFct_InitStep) THEN
			xPrcFct_InitStep:=TRUE;
			gdiSavePartQuality:=0;
			xHoleToWork:=TRUE;
		END_IF;
		IF NOT(xHoleToWork) THEN
			xPrcFct_InitStep:=FALSE;
			iPrcFct_StepPrc:=iPrcFct_StepPrc + 1;
		END_IF;
	2:	IF NOT(xPrcFct_InitStep) THEN
			xPrcFct_InitStep:=TRUE;
			TStation_Work.TControl.iFunctNr:=2;		(* Bearbeitungsstation Grundstellung *)
			TStation_Work.TControl.xExecute:=TRUE;
			TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveCycle:=TRUE;			(* Zykluszeit für zu bearbeitende Bohrung ist gestartet *)
		END_IF;
		IF NOT(TStation_Work.TControl.xExecute) AND TStation_Work.TControl.xDone THEN
			TStation_Work.THWWorkStation.TCtrlWork.xWorkStartToolRotation:=TRUE;
			xPrcFct_InitStep:=FALSE;
			iPrcFct_StepPrc:=iPrcFct_StepPrc + 1;
		END_IF;
	3:	IF NOT(xPrcFct_InitStep) THEN
			xPrcFct_InitStep:=TRUE;
			xStartWorkPart:=TRUE;
		END_IF;
		IF NOT(xStartWorkPart) THEN
			xPrcFct_InitStep:=FALSE;
			iPrcFct_StepPrc:=90;
		END_IF;
	90:	iPrcFct_StepPrc:=1;
		xPrcFct_InitStep:=FALSE;
		IF NOT(T_NovRam.T_Parameter.T_Machine.xEndlessProcessActive) THEN
			xPrcFct_StartMainPrc:=FALSE;
			T_Process.T_Fct.xSetEndFunction:=TRUE;	(* Prozess beendet *)
		END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************			             Processfunktion Parallelablauf                                       *****************************)
(******************************************************************************************************************************************)
IF NOT(xPrcFct_StationBlock) AND NOT(T_Process.T_Fct.xSetEndFunction) AND NOT(xPrcFct_SaveStationError) THEN
	IF xPrcFct_StartPrc_Parallel1 THEN
		CASE iPrcFct_StepPrc_Parallel1 OF
		1:	iPrcFct_StepPrc_Parallel1:=1;
			xPrcFct_InitStep_Parallel1:=FALSE;
			xPrcFct_StartPrc_Parallel1:=FALSE;
		END_CASE;
	END_IF;
	IF xPrcFct_StartPrc_Parallel2 THEN
		CASE iPrcFct_StepPrc_Parallel2 OF
		1:	iPrcFct_StepPrc_Parallel2:=1;
			xPrcFct_InitStep_Parallel2:=FALSE;
			xPrcFct_StartPrc_Parallel2:=FALSE;
		END_CASE;
	END_IF;
END_IF;
(******************************************************************************************************************************************)
(****************************				     Processfunktion Endprozedur                                    *****************************)
(******************************************************************************************************************************************)
ProcessFunction_Ctrl_End;
END_ACTION

ACTION	ProcessFunction_Fct_Automat_Station:
(*********************************************************************************************************************************)
(***********************************			BEARBSTATION RECHTS			***********************************)
(*********************************************************************************************************************************)
IF xStartWorkPart AND NOT(xPrcFct_StationBlock) THEN
	CASE iStepPrc_1 OF
	(* Zuerst überprüfen welche WstkNummer bearbeitet werden muss *)
	1:	iStepPrc_1:=iStepPrc_1 + 1;
		xInitPrc_1:=FALSE;
		xBlockQuality_StR:=FALSE;
		iNumberTryInfeed:=0;
		TStation_Work.THWWorkStation.TCtrlWork.xLastTryInfeed:=FALSE;
	(* .StationFunction_Fct_04_InfeedWorking*)
	2:	IF NOT(xInitPrc_1) THEN
			xInitPrc_1:=TRUE;
			TStation_Work.TControl.iFunctNr:=4;			(* Wz in das Wstk einfädeln *)
			TStation_Work.TControl.xExecute:=TRUE;
			gxSuspensionONOFF:=TRUE;
		END_IF;
		IF NOT(TStation_Work.TControl.xExecute) AND TStation_Work.TControl.xDone THEN
			gxAddInfeedZ:=TRUE;
			IF (TStation_Work.TControl.wStatus <> 99) THEN
				xInitPrc_1:=FALSE;
				iStepPrc_1:=iStepPrc_1 + 1;
				iNumberTryInfeed:=0;
			ELSE
				iNumberTryInfeed:=iNumberTryInfeed + 1;
				IF (iNumberTryInfeed <= T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.iNumberTryInfeed) THEN
					xInitPrc_1:=FALSE;
					iStepPrc_1:=iStepPrc_1;
					IF (iNumberTryInfeed = T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.iNumberTryInfeed) THEN
						TStation_Work.THWWorkStation.TCtrlWork.xLastTryInfeed:=TRUE;
					END_IF;
				ELSE
					(* Anzahl Einfädelversuche erreicht *)
					TStation_Work.THWWorkStation.TCtrlWork.xWorkingFinished:=TRUE;		(* dieses Loch muss als bearbeitet deklariert werden *)
					TStation_Work.THWWorkStation.TCtrlWork.bPartQuality:=5;	(* < NoGo insert fail > *)
					gxSetPartQuality:=TRUE;
					xInitPrc_1:=FALSE;
					iStepPrc_1:=iStepPrc_1 + 3;
					TStation_Work.THWWorkStation.TCtrlWork.xAddWPCounter_Machine_NIO:=TRUE;
					T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.diNumberPartWorked_St1St2:=T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.diNumberPartWorked_St1St2 + 1;
					TStation_Work.THWWorkStation.TCtrlWork.xWorkStopToolRotation:=TRUE;
				END_IF;
			END_IF;
		END_IF;
	(* .StationFunction_Fct_11_Centring *)
	3:	IF NOT(xInitPrc_1) THEN
			xInitPrc_1:=TRUE;
			TStation_Work.TControl.iFunctNr:=11;			(* Zentrieren *)
			TStation_Work.TControl.xExecute:=gxCentringActive OR gxOnlyCentringActive;
		END_IF;
		IF NOT(TStation_Work.TControl.xExecute) AND TStation_Work.TControl.xDone THEN
			IF (TStation_Work.TControl.wStatus <> 99) THEN
				xInitPrc_1:=FALSE;
				IF gxOnlyCentringActive THEN
					TStation_Work.THWWorkStation.TCtrlWork.bPartQuality:=11;	(* < WP Centered > *)
					iStepPrc_1:=iStepPrc_1 + 3;
				ELSE
					iStepPrc_1:=iStepPrc_1 + 1;
				END_IF;
			ELSE
				TStation_Work.THWWorkStation.TCtrlWork.xWorkingFinished:=TRUE;		(* dieses Loch muss als bearbeitet deklariert werden *)
				TStation_Work.THWWorkStation.TCtrlWork.bPartQuality:=10;	(* < NoGo HC Centr. > *)
				gxSetPartQuality:=TRUE;
				xInitPrc_1:=FALSE;
				iStepPrc_1:=iStepPrc_1 + 2;
				TStation_Work.THWWorkStation.TCtrlWork.xAddWPCounter_Machine_NIO:=TRUE;
				T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.diNumberPartWorked_St1St2:=T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.diNumberPartWorked_St1St2 + 1;
				TStation_Work.THWWorkStation.TCtrlWork.xWorkStopToolRotation:=TRUE;
			END_IF;
		END_IF;
	(* .StationFunction_Fct_05_Working *)
	4:	IF NOT(xInitPrc_1) THEN
			xInitPrc_1:=TRUE;
			TStation_Work.TControl.iFunctNr:=5;			(* Wstk bearbeiten *)
			TStation_Work.TControl.xExecute:=TRUE;
			TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveWork:=TRUE;			(* Bearbeitungszeit für zu bearbeitende Bohrung ist gestartet *)
			QxCoolant_St1:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.xActivateCoolantProcess;
		END_IF;
		IF TStation_Work.THWWorkStation.TCtrlWork.xWorkingFinished
		AND ((TStation_Work.THWWorkStation.TAxisZ.T_LiveValue.lrActualPosition <= T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rStrokeAxisPosSwitchCoolantOff)
		OR (TStation_Work.THWWorkStation.TAxisZ.T_LiveValue.lrActualPosition <= T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rPositionStartProc)) THEN
			QxCoolant_St1:=FALSE;
		END_IF;
		IF TStation_Work.THWWorkStation.TCtrlWork.xWorkingFinished AND NOT(xBlockQuality_StR) THEN
			xBlockQuality_StR:=TRUE;
			IF (TStation_Work.THWWorkStation.TCtrlWork.bPartQuality = 1) OR (TStation_Work.THWWorkStation.TCtrlWork.bPartQuality = 2) THEN
				TStation_Work.THWWorkStation.TCtrlWork.xAddWPCounter_Machine_IO:=TRUE;
				T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.diNumberPartWorked_St1St2:=T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.diNumberPartWorked_St1St2 + 1;
			ELSIF (TStation_Work.THWWorkStation.TCtrlWork.bPartQuality <> 7) AND (TStation_Work.THWWorkStation.TCtrlWork.bPartQuality <> 8) THEN
				TStation_Work.THWWorkStation.TCtrlWork.xAddWPCounter_Machine_NIO:=TRUE;
				T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.diNumberPartWorked_St1St2:=T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.diNumberPartWorked_St1St2 + 1;
			END_IF;
		END_IF;
		IF NOT(TStation_Work.TControl.xExecute) AND TStation_Work.TControl.xDone THEN
			xBlockQuality_StR:=FALSE;
			iStepPrc_1:=iStepPrc_1 + 1;
			xInitPrc_1:=FALSE;
		END_IF;
	5:	IF NOT(xInitPrc_1) THEN
			xInitPrc_1:=TRUE;
			IF T_NovRam.T_Parameter.T_Machine.T_ParamSystem.xDataFileActive AND NOT(T_NovRam.T_Parameter.T_Machine.xEndlessProcessActive) THEN
				(* Prozessdatei wird geschrieben *)
				T_ProcessData.T_Ctrle.iFunction:=1;
				T_ProcessData.T_Ctrle.xExecute:=TRUE;
			END_IF;
		END_IF;
		IF NOT(T_ProcessData.T_Ctrle.xExecute) AND T_ProcessData.T_Ctrle.xDone THEN
			iStepPrc_1:=iStepPrc_1 + 1;
			xInitPrc_1:=FALSE;
		END_IF;
		IF T_ProcessData.T_Ctrle.xErr THEN
			xStartWorkPart:=FALSE;
		END_IF;
	6:	IF NOT(xInitPrc_1) THEN
			xInitPrc_1:=TRUE;
			gxSuspensionONOFF:=FALSE;
		END_IF;
		IF TRUE THEN
			iStepPrc_1:=1;
			xInitPrc_1:=FALSE;
			TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveCycle:=FALSE;			(* Zykluszeit für zu bearbeitende Bohrung ist gestoppt *)
			xStartWorkPart:=FALSE;
		END_IF;
	END_CASE;
ELSE
	iStepPrc_1:=1;
	xInitPrc_1:=FALSE;
END_IF;
END_ACTION

ACTION	ProcessFunction_Fct_HandMode:
(******************************************************************************************************************************************)
(****************************				           Reset Processfunktion                                            *****************************)
(******************************************************************************************************************************************)
ProcessFunction_Ctrl_Reset;
(******************************************************************************************************************************************)
(****************************			        Processfunktion Fehler Controller                                    *****************************)
(******************************************************************************************************************************************)
ProcessFunction_Ctrl_Error;
(******************************************************************************************************************************************)
(****************************				    Processfunktion Haupt Controller                               *****************************)
(******************************************************************************************************************************************)
ProcessFunction_Ctrl_Main;
(******************************************************************************************************************************************)
(****************************			         Processfunktion sofort Unterbrechung                           *****************************)
(******************************************************************************************************************************************)
ProcessFunction_Ctrl_Stop;
(******************************************************************************************************************************************)
(****************************			             Processfunktion Hauptablauf                                       *****************************)
(******************************************************************************************************************************************)
ProcessFunction_Fct_Automat_Station;
IF xPrcFct_StartMainPrc AND NOT(xPrcFct_StationBlock) AND NOT(T_Process.T_Fct.xSetEndFunction) AND NOT(xPrcFct_SaveStationError) THEN
	CASE iPrcFct_StepPrc OF
	(* Grundstellung *)
	1:	IF (garPositionEndProcCalc[1] > T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rPositionEndProcMaxInc) AND (T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.xPositionEndProcIncOnOff OR gxProcessCylindricalAreaActive) THEN
			TStation_Work.TControl.xError:=TRUE;
			TStation_Work.TControl.xDone:=FALSE;
			TStation_Work.TControl.diErrorNr:=(gciStationSt1 * 1000000) + 17;		(* Z Bearb EndPos Berechn. > Z Bearb EndPos Max *)
			RETURN;
		END_IF;
		IF (garCentringEndProcCalc[1] > T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rPositionEndProcMaxInc) AND T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.xCentringEndProcIncOnOff THEN
			TStation_Work.TControl.xError:=TRUE;
			TStation_Work.TControl.xDone:=FALSE;
			TStation_Work.TControl.diErrorNr:=(gciStationSt1 * 1000000) + 19;		(* Z ZentrierPos berechn. > Z Bearb EndPos Max *)
			RETURN;
		END_IF;
		IF NOT(xPrcFct_InitStep) THEN
			xPrcFct_InitStep:=TRUE;
			TStation_Work.TControl.iFunctNr:=2;		(* Bearbeitungsstation Grundstellung *)
			TStation_Work.TControl.xExecute:=TRUE;
			iNumberTryInfeed:=0;
			TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveCycle:=TRUE;			(* Zykluszeit für zu bearbeitende Bohrung ist gestartet *)
			gxSuspensionONOFF:=TRUE;
		END_IF;
		IF NOT(TStation_Work.TControl.xExecute) AND TStation_Work.TControl.xDone THEN
			TStation_Work.THWWorkStation.TCtrlWork.xWorkStartToolRotation:=TRUE;
			xPrcFct_InitStep:=FALSE;
			iPrcFct_StepPrc:=iPrcFct_StepPrc + 1;
			TStation_Work.THWWorkStation.TCtrlWork.xLastTryInfeed:=FALSE;
		END_IF;
	(* Wz in das Wstk einfädeln *)
	2:	IF NOT(xPrcFct_InitStep) THEN
			xPrcFct_InitStep:=TRUE;
			TStation_Work.TControl.iFunctNr:=4;		(* Wz Einfädeln *)
			TStation_Work.TControl.xExecute:=TRUE;
		END_IF;
		IF NOT(TStation_Work.TControl.xExecute) AND TStation_Work.TControl.xDone THEN
			IF (TStation_Work.TControl.wStatus <> 99) THEN
				xPrcFct_InitStep:=FALSE;
				iPrcFct_StepPrc:=iPrcFct_StepPrc + 1;
			ELSE
				iNumberTryInfeed:=iNumberTryInfeed + 1;
				IF (iNumberTryInfeed <= T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.iNumberTryInfeed) THEN
					xPrcFct_InitStep:=FALSE;
					iPrcFct_StepPrc:=iPrcFct_StepPrc;
					IF (iNumberTryInfeed = T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.iNumberTryInfeed) THEN
						TStation_Work.THWWorkStation.TCtrlWork.xLastTryInfeed:=TRUE;
					END_IF;
				ELSE
					(* Anzahl Einfädelversuche erreicht *)
					TStation_Work.THWWorkStation.TCtrlWork.bPartQuality:=5;	(* < NoGo insert fail > *)
					TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveWork:=FALSE;
					TStation_Work.THWWorkStation.TCtrlWork.xWorkStopToolRotation:=TRUE;
					TStation_Work.THWWorkStation.TCtrlWork.xWorkingFinished:=TRUE;
					xPrcFct_InitStep:=FALSE;
					iPrcFct_StepPrc:=iPrcFct_StepPrc + 3;
				END_IF;
			END_IF;
		END_IF;



	(* .StationFunction_Fct_11_Centring *)
	3:	IF NOT(xPrcFct_InitStep) THEN
			xPrcFct_InitStep:=TRUE;
			TStation_Work.TControl.iFunctNr:=11;			(* Zentrieren *)
			TStation_Work.TControl.xExecute:=gxCentringActive OR gxOnlyCentringActive;
		END_IF;
		IF NOT(TStation_Work.TControl.xExecute) AND TStation_Work.TControl.xDone THEN
			IF (TStation_Work.TControl.wStatus <> 99) THEN
				xPrcFct_InitStep:=FALSE;
				IF gxOnlyCentringActive THEN
					TStation_Work.THWWorkStation.TCtrlWork.bPartQuality:=11;	(* < WP Centered > *)
					iPrcFct_StepPrc:=iPrcFct_StepPrc + 2;
				ELSE
					iPrcFct_StepPrc:=iPrcFct_StepPrc + 1;
				END_IF;
			ELSE
				TStation_Work.THWWorkStation.TCtrlWork.bPartQuality:=10;	(* < NoGo HC Centr. > *)
				xPrcFct_InitStep:=FALSE;
				iPrcFct_StepPrc:=iPrcFct_StepPrc + 2;
				TStation_Work.THWWorkStation.TCtrlWork.xAddWPCounter_Machine_NIO:=TRUE;
				T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.diNumberPartWorked_St1St2:=T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.diNumberPartWorked_St1St2 + 1;
				TStation_Work.THWWorkStation.TCtrlWork.xWorkStopToolRotation:=TRUE;
			END_IF;
		END_IF;



	(* Wstk bearbeiten *)
	4:	IF NOT(xPrcFct_InitStep) THEN
			xPrcFct_InitStep:=TRUE;
			TStation_Work.TControl.iFunctNr:=5;		(* Wstk bearbeiten *)
			TStation_Work.TControl.xExecute:=TRUE;
			TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveWork:=TRUE;			(* Bearbeitungszeit für zu bearbeitende Bohrung ist gestartet *)
			QxCoolant_St1:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.xActivateCoolantProcess;
		END_IF;
		IF TStation_Work.THWWorkStation.TCtrlWork.xWorkingFinished
		AND ((TStation_Work.THWWorkStation.TAxisZ.T_LiveValue.lrActualPosition <= T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rStrokeAxisPosSwitchCoolantOff)
		OR (TStation_Work.THWWorkStation.TAxisZ.T_LiveValue.lrActualPosition <= T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rPositionStartProc)) THEN
			QxCoolant_St1:=FALSE;
		END_IF;
		IF NOT(TStation_Work.TControl.xExecute) AND TStation_Work.TControl.xDone THEN
			xPrcFct_InitStep:=FALSE;
			iPrcFct_StepPrc:=iPrcFct_StepPrc + 1;
			xActivate_StationRight:=FALSE;
			TStation_Work.THWWorkStation.TCtrlWork.xWorkStopToolRotation:=TRUE;
		END_IF;
		IF TStation_Work.THWWorkStation.TCtrlWork.xWorkingFinished THEN
			IF (TStation_Work.THWWorkStation.TCtrlWork.bPartQuality <> 0) AND (TStation_Work.THWWorkStation.TCtrlWork.bPartQuality <> 7) AND
			     (TStation_Work.THWWorkStation.TCtrlWork.bPartQuality <> 8) THEN
				TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveWork:=FALSE;			(* Bearbeitungszeit für zu bearbeitende Bohrung ist gestoppt *)
			END_IF;
		END_IF;
	(* Grundstellung *)
	5:	IF NOT(xPrcFct_InitStep) THEN
			xPrcFct_InitStep:=TRUE;
			TStation_Work.TControl.iFunctNr:=2;		(* BearbeitStation Grundstellung *)
			TStation_Work.TControl.xExecute:=TRUE;
			gxBlockSetQuality:=TRUE;
		END_IF;
		IF NOT(TStation_Work.TControl.xExecute) AND TStation_Work.TControl.xDone THEN
			TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveCycle:=FALSE;			(* Zykluszeit für zu bearbeitende Bohrung ist gestoppt *)
			gxWP_Analyse_ActiveWork:=FALSE;
			gxWP_Analyse_ActiveWork:=FALSE;
			xPrcFct_InitStep:=FALSE;
			iPrcFct_StepPrc:=90;
		END_IF;



	(* Ende HandBetrieb Prozess *)
	90:	iPrcFct_StepPrc:=1;
		xPrcFct_InitStep:=FALSE;
		xPrcFct_StartMainPrc:=FALSE;
		T_Process.T_Fct.xSetEndFunction:=TRUE;	(* Prozess beendet *)
		gxSuspensionONOFF:=FALSE;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************			             Processfunktion Parallelablauf                                       *****************************)
(******************************************************************************************************************************************)

(******************************************************************************************************************************************)
(****************************				     Processfunktion Endprozedur                                    *****************************)
(******************************************************************************************************************************************)
ProcessFunction_Ctrl_End;
END_ACTION

ACTION	ProcessFunction_Fct_Referencing:
(******************************************************************************************************************************************)
(****************************				           Reset Processfunktion                                            *****************************)
(******************************************************************************************************************************************)
ProcessFunction_Ctrl_Reset;
(******************************************************************************************************************************************)
(****************************			        Processfunktion Fehler Controller                                    *****************************)
(******************************************************************************************************************************************)
ProcessFunction_Ctrl_Error;
(******************************************************************************************************************************************)
(****************************				    Processfunktion Haupt Controller                               *****************************)
(******************************************************************************************************************************************)
ProcessFunction_Ctrl_Main;
(******************************************************************************************************************************************)
(****************************			         Processfunktion sofort Unterbrechung                           *****************************)
(******************************************************************************************************************************************)
ProcessFunction_Ctrl_Stop;
(******************************************************************************************************************************************)
(****************************			             Processfunktion Hauptablauf                                       *****************************)
(******************************************************************************************************************************************)
IF xPrcFct_StartMainPrc AND NOT(xPrcFct_StationBlock) AND NOT(T_Process.T_Fct.xSetEndFunction) AND NOT(xPrcFct_SaveStationError) THEN
	CASE iPrcFct_StepPrc OF
	1:	gxInitialStateActivated:=FALSE;
		xSpindelCalibrationONOFF:=gxSpindelCalibrationONOFF_St1;
		xPrcFct_Ready_St1:=FALSE;
		xPrcFct_InitStep:=FALSE;
		iPrcFct_StepPrc:=iPrcFct_StepPrc + 1;
	2:	IF NOT(xPrcFct_InitStep) THEN
			xPrcFct_InitStep:=TRUE;
			xPrcFct_StartPrc_Parallel1:=TRUE;
		END_IF;
		IF xPrcFct_Ready_St1 THEN
			xPrcFct_InitStep:=FALSE;
			iPrcFct_StepPrc:=iPrcFct_StepPrc + 1;
		END_IF;
	3:	IF NOT(xPrcFct_StartPrc_Parallel1) THEN
			gxInitialStateActivated:=TRUE;
			iPrcFct_StepPrc:=1;
			xPrcFct_InitStep:=FALSE;
			xPrcFct_StartMainPrc:=FALSE;
			T_Process.T_Fct.xSetEndFunction:=TRUE;
		END_IF;
	END_CASE;
END_IF;
(******************************************************************************************************************************************)
(****************************			             Processfunktion Parallelablauf                                       *****************************)
(******************************************************************************************************************************************)
IF NOT(xPrcFct_StationBlock) AND NOT(T_Process.T_Fct.xSetEndFunction) AND NOT(xPrcFct_SaveStationError) THEN
	IF xPrcFct_StartPrc_Parallel1 THEN
		CASE iPrcFct_StepPrc_Parallel1 OF
		1:	IF NOT(xPrcFct_InitStep_Parallel1) THEN
				xPrcFct_InitStep_Parallel1:=TRUE;
				TStation_Work.TControl.iFunctNr:=2;	(* Bearbeitungsstation Grundstellung *)
				TStation_Work.TControl.xExecute:=TRUE;
			END_IF;
			IF NOT(TStation_Work.TControl.xExecute) AND TStation_Work.TControl.xDone THEN
				iPrcFct_StepPrc_Parallel1:=iPrcFct_StepPrc_Parallel1 + 1;
				xPrcFct_InitStep_Parallel1:=FALSE;
			END_IF;
		2:	IF NOT(xPrcFct_InitStep_Parallel1) THEN
				xPrcFct_InitStep_Parallel1:=TRUE;
				TStation_Work.TControl.iFunctNr:=10;	(* Überprüfen ob die Achsenbremse blockiert ist, damit im Fall dass sie blockiert ist eine Vorwarnung ausgegeben werden kann *)
				TStation_Work.TControl.xExecute:=TRUE;
				xPrcFct_Ready_St1:=TRUE;
			END_IF;
			IF NOT(TStation_Work.TControl.xExecute) AND TStation_Work.TControl.xDone THEN
				iPrcFct_StepPrc_Parallel1:=iPrcFct_StepPrc_Parallel1 + 1;
				xPrcFct_InitStep_Parallel1:=FALSE;
			END_IF;
		3:	IF NOT(xPrcFct_InitStep_Parallel1) THEN
				xPrcFct_InitStep_Parallel1:=TRUE;
				(* Existierende MicroHead Bearbstationen müssen noch kalibriert werden *)
				TStation_Work.TControl.iFunctNr:=7;		(* Kalibrierung starten *)
				TStation_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolDeflection:=xSpindelCalibrationONOFF;
				TStation_Work.THWWorkStation.TCtrlWork.xActiveCalibrateToolTorque:=xSpindelCalibrationONOFF;
				TStation_Work.THWWorkStation.TCtrlWork.xStopToolRotation:=xSpindelCalibrationONOFF;
				TStation_Work.TControl.xExecute:=xSpindelCalibrationONOFF;
			END_IF;
			IF ((NOT(TStation_Work.TControl.xExecute) AND TStation_Work.TControl.xDone AND xSpindelCalibrationONOFF) OR NOT(xSpindelCalibrationONOFF)) THEN
				iPrcFct_StepPrc_Parallel1:=1;
				xPrcFct_InitStep_Parallel1:=FALSE;
				xPrcFct_StartPrc_Parallel1:=FALSE;
			END_IF;
		END_CASE;
	END_IF;
ELSE
	iPrcFct_StepPrc_Parallel1:=1;
	xPrcFct_InitStep_Parallel1:=FALSE;
END_IF;
(******************************************************************************************************************************************)
(****************************				     Processfunktion Endprozedur                                    *****************************)
(******************************************************************************************************************************************)
ProcessFunction_Ctrl_End;
END_ACTION
















(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER4_PROCESS\/FBPROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_ProcessInformation
VAR_INPUT
END_VAR
VAR_IN_OUT
	T_Parameter:ST_RETAIN_DATA;
	TStation_Work : ST_STATION;
END_VAR
VAR_OUTPUT
END_VAR
VAR
	TONWorkTime: TON;
	TONCycleTime: TON;
	RisingEdgeStartWorkProcess: R_TRIG;
	RisingEdgeStartCycleProcess: R_TRIG;
	RisingEdgeStationFunction: R_TRIG;
END_VAR
(* @END_DECLARATION := '0' *)
RisingEdgeStartCycleProcess(CLK:=TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveCycle);
RisingEdgeStartWorkProcess(CLK:=TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveWork);
RisingEdgeStationFunction(CLK:=gxWP_Analyse_ActiveWork);

IF TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveCycle THEN
	IF RisingEdgeStartCycleProcess.Q THEN
		T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.tLastCycleTime:=T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.tActualCycleTime;
		T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.tActualCycleTime:=T#0s;
		T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.rActualCycleTime:=0.0;
		TONCycleTime(IN:=FALSE);
	END_IF;
	TONCycleTime(IN:=TRUE,PT:=T#999999s);
	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.tActualCycleTime:=TONCycleTime.ET;
	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.rActualCycleTime:=TIME_TO_REAL(TONCycleTime.ET)/1000.0;
END_IF;
IF TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveWork OR gxWP_Analyse_ActiveWork THEN
	IF RisingEdgeStartWorkProcess.Q OR RisingEdgeStationFunction.Q THEN
		T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.tLastEffProcTime:=T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.tActualEffProcTime;
		T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.tActualEffProcTime:=T#0s;
		T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.rActualEffProcTime:=0.0;
		TStation_Work.THWWorkStation.TCtrlWork.rDiffOverLimitPosition:=0.0;
		TONWorkTime(IN:=FALSE);
	END_IF;
	TONWorkTime(IN:=TRUE,PT:=T#999999s);
	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.tActualEffProcTime:=TONWorkTime.ET;
	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.rActualEffProcTime:=TIME_TO_REAL(TONWorkTime.ET)/1000.0;
END_IF;
IF TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveCycle OR TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveWork OR gxWP_Analyse_ActiveWork THEN
	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.rActualFirstContactPosition:=TStation_Work.THWWorkStation.TCtrlWork.rActualFirstContactPosition;
	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.rLastFirstContactPosition:=TStation_Work.THWWorkStation.TCtrlWork.rLastFirstContactPosition;
	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.rLastOverLimitPosition:=TStation_Work.THWWorkStation.TCtrlWork.rLastOverLimitPosition;
	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.rDiffOverLimitPosition:=TStation_Work.THWWorkStation.TCtrlWork.rDiffOverLimitPosition;
	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.rCuttingSpeed:=TStation_Work.THWWorkStation.TCtrlWork.rCuttingSpeed;
	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iOverLimitCounter:=TStation_Work.THWWorkStation.TCtrlWork.iOverLimitCounter;

	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iOverLimitCounterCentering:=TStation_Work.THWWorkStation.TCtrlWork.iOverLimitCounterCentering;

	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iOverLimitCounterTorque:=TStation_Work.THWWorkStation.TCtrlWork.iOverLimitCounterTorque;
	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iOverLimitCounterSpeed:=TStation_Work.THWWorkStation.TCtrlWork.iOverLimitCounterSpeed;
	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.bLastDetectionSignal:=WORD_TO_BYTE(TStation_Work.TControl.wStatus);
	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.bPartQuality:=TStation_Work.THWWorkStation.TCtrlWork.bPartQuality;
	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.rProcessWork:=TStation_Work.THWWorkStation.TCtrlWork.rProcessWork;

	T_Parameter.T_StationWork[TStation_Work.iStationNr].T_InfoProcess.rTorqueHC:=TStation_Work.THWWorkStation.TCtrlWork.rTorqueHC;
	T_Parameter.T_StationWork[TStation_Work.iStationNr].T_InfoProcess.rTorqueAfterHC_Min:=TStation_Work.THWWorkStation.TCtrlWork.rTorqueAfterHC_Min;
	T_Parameter.T_StationWork[TStation_Work.iStationNr].T_InfoProcess.rTorqueAfterHC_Max:=TStation_Work.THWWorkStation.TCtrlWork.rTorqueAfterHC_Max;
	T_Parameter.T_StationWork[TStation_Work.iStationNr].T_InfoProcess.xTorqueLastHC:=TStation_Work.THWWorkStation.TCtrlWork.xTorqueLastHC;
	T_Parameter.T_StationWork[TStation_Work.iStationNr].T_InfoProcess.xDeflectionLastHC:=TStation_Work.THWWorkStation.TCtrlWork.xDeflectionLastHC;
	T_Parameter.T_StationWork[TStation_Work.iStationNr].T_InfoProcess.iHCTorquePos:=TStation_Work.THWWorkStation.TCtrlWork.iHCTorquePos;
	T_Parameter.T_StationWork[TStation_Work.iStationNr].T_InfoProcess.iHCDeflectionPos:=TStation_Work.THWWorkStation.TCtrlWork.iHCDeflectionPos;
	T_Parameter.T_StationWork[TStation_Work.iStationNr].T_InfoProcess.xHCSparkOut:=TStation_Work.THWWorkStation.TCtrlWork.xHCSparkOut;
END_IF;
IF gxWP_Analyse_ActiveInfeed THEN
	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.bPartQuality:=TStation_Work.THWWorkStation.TCtrlWork.bPartQuality;
END_IF;
IF gxWP_Analyse_ResetCentCountValue THEN
	gxWP_Analyse_ResetCentCountValue:=FALSE;
	T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iOverLimitCounterCentering:=TStation_Work.THWWorkStation.TCtrlWork.iOverLimitCounterCentering;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER4_PROCESS\/FBPROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_WPAnalysis
VAR_INPUT
	diActual_NumberHoleToWork:DINT;		(* Aktuell zu bearbeitende Bohrungsnummer *)
END_VAR
VAR_IN_OUT
	T_PartAnalysis:ST_PARTANALYSIS;
	TStation_Work : ST_STATION;
	xAddInfeedZ:BOOL;
	xSetPartQuality:BOOL;
END_VAR
VAR_OUTPUT
END_VAR
VAR
	TONCycleTime: TON;
	TONWorkTime: TON;
	FBNT_GetTime:NT_GetTime;
	iSetTimeStamp_Start: INT;
	iSetTimeStamp_End: INT;
	diHoleNumber: DINT;
	xInitCycleTime: BOOL;
	tSaveCycleTime: TIME;
	xInitWorkTime: BOOL;
	tSaveWorkTime: TIME;
	ii: INT;
	iHCCounter_Save: INT;
	iHCCounterCentering_Save: INT;
	iHCCounterTorque_Save: INT;
	iHCCounterSpeed_Save:INT;	(* IGS *)
END_VAR
(* @END_DECLARATION := '0' *)
(* Aufzeichnung für wenn die Bearb Station aktiviert wurde *)
IF TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_StartAutomat THEN
	CASE iSetTimeStamp_Start OF
	1:	FBNT_GetTime(	NETID:= '',
						START:=FALSE );
		iSetTimeStamp_Start:=iSetTimeStamp_Start + 1;
	2:	FBNT_GetTime(	NETID:= '',
						START:= TRUE,
						TMOUT:= T#2s);
		IF NOT(FBNT_GetTime.BUSY) OR FBNT_GetTime.ERR THEN
			IF NOT(FBNT_GetTime.ERR) THEN
				T_PartAnalysis.sStartOfProcess:=Fct_ConvertDateToString(3,FBNT_GetTime.TIMESTR);
			END_IF;
			iSetTimeStamp_Start:=1;
			TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_StartAutomat:=FALSE;
		END_IF;
	END_CASE;
ELSE
	iSetTimeStamp_Start:=1;
END_IF;
IF TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_StopAutomat THEN
	CASE iSetTimeStamp_End OF
	1:	FBNT_GetTime(	NETID:= '',
						START:=FALSE );
		iSetTimeStamp_End:=iSetTimeStamp_End + 1;
	2:	FBNT_GetTime(	NETID:= '',
						START:= TRUE,
						TMOUT:= T#2s);
		IF NOT(FBNT_GetTime.BUSY) OR FBNT_GetTime.ERR THEN
			IF NOT(FBNT_GetTime.ERR) THEN
				T_PartAnalysis.sEndOfProcess:=Fct_ConvertDateToString(3,FBNT_GetTime.TIMESTR);
			END_IF;
			iSetTimeStamp_End:=1;
			TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_StopAutomat:=FALSE;
		END_IF;
	END_CASE;
ELSE
	iSetTimeStamp_End:=1;
END_IF;
IF (diActual_NumberHoleToWork > 0) THEN
	FOR ii:=1 TO ciMaxWP DO
		IF (T_PartAnalysis.adiNumberHole[ii] = diActual_NumberHoleToWork) THEN
			diHoleNumber:=ii;
			EXIT;
		END_IF;
	END_FOR;
	IF (diHoleNumber = 0) OR (diHoleNumber > ciMaxWP) THEN
		diHoleNumber:=1;
	END_IF;
ELSE
	diHoleNumber:=1;
END_IF;
IF TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveCycle AND NOT(gT_SafetyStatus.xSetupOperateModeActive) THEN
	TONCycleTime(IN:=TRUE,PT:=T#999999s);
	IF NOT(xInitCycleTime) THEN
		xInitCycleTime:=TRUE;
		tSaveCycleTime:=DINT_TO_TIME(T_PartAnalysis.adiCycleTime[diHoleNumber]);
	END_IF;
	T_PartAnalysis.adiCycleTime[diHoleNumber]:=TIME_TO_DINT(TONCycleTime.ET+tSaveCycleTime);
	IF (gxCentringActive OR gxOnlyCentringActive) AND NOT(TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveWork) AND gxWP_Analyse_ActiveCentering THEN
		T_PartAnalysis.aiHCCounterCentering[diHoleNumber]:=iHCCounterCentering_Save + TStation_Work.THWWorkStation.TCtrlWork.iOverLimitCounterCentering;
	ELSE
		iHCCounterCentering_Save:=T_PartAnalysis.aiHCCounterCentering[diHoleNumber];
	END_IF;
ELSE
	TONCycleTime(IN:=FALSE);
	xInitCycleTime:=FALSE;
	tSaveCycleTime:=T#0s;
END_IF;

IF (TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveWork AND NOT(gT_SafetyStatus.xSetupOperateModeActive)) OR gxSetPartQuality THEN
	IF NOT(gxSetPartQuality) THEN
		TONWorkTime(IN:=TRUE,PT:=T#999999s);
		IF NOT(xInitWorkTime) THEN
			xInitWorkTime:=TRUE;
			tSaveWorkTime:=DINT_TO_TIME(T_PartAnalysis.adiWorkTime[diHoleNumber]);
		END_IF;
	END_IF;
	IF NOT(gxSetPartQuality) THEN
		T_PartAnalysis.adiWorkTime[diHoleNumber]:=TIME_TO_DINT(TONWorkTime.ET+tSaveWorkTime);
	END_IF;
	T_PartAnalysis.abWorkPartQuality[diHoleNumber]:=TStation_Work.THWWorkStation.TCtrlWork.bPartQuality;
	IF TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ReadyToReadData THEN
		IF (T_PartAnalysis.arFirstHC[diHoleNumber] = 0.0) THEN
			T_PartAnalysis.arFirstHC[diHoleNumber]:=TStation_Work.THWWorkStation.TCtrlWork.rActualFirstContactPosition;
		END_IF;
		T_PartAnalysis.aiHCCounter[diHoleNumber]:=iHCCounter_Save + TStation_Work.THWWorkStation.TCtrlWork.iOverLimitCounter;
		T_PartAnalysis.aiHCCounterTorque[diHoleNumber]:=iHCCounterTorque_Save + TStation_Work.THWWorkStation.TCtrlWork.iOverLimitCounterTorque;
		T_PartAnalysis.aiHCCounterSpeed[diHoleNumber]:=iHCCounterSpeed_Save + TStation_Work.THWWorkStation.TCtrlWork.iOverLimitCounterSpeed;
	ELSE
		iHCCounter_Save:=T_PartAnalysis.aiHCCounter[diHoleNumber];
		iHCCounterTorque_Save:=T_PartAnalysis.aiHCCounterTorque[diHoleNumber];
		iHCCounterSpeed_Save:=T_PartAnalysis.aiHCCounterSpeed[diHoleNumber];
	END_IF;
	gxSetPartQuality:=FALSE;
	IF TStation_Work_St1.THWWorkStation.TCtrlWork.xWorkingFinished THEN
		TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ActiveWork:=FALSE;
	END_IF;
ELSE
	TONWorkTime(IN:=FALSE);
	xInitWorkTime:=FALSE;
	tSaveWorkTime:=T#0s;
	TStation_Work.THWWorkStation.TCtrlWork.xWP_Analyse_ReadyToReadData:=FALSE;
END_IF;

IF gxAddInfeedZ THEN
	IF (diHoleNumber <> 0) THEN
		IF gxAddInfeedZ THEN
			T_PartAnalysis.abInfeedCounterZ[diHoleNumber]:=T_PartAnalysis.abInfeedCounterZ[diHoleNumber] + 1;
		END_IF;
	END_IF;
	gxAddInfeedZ:=FALSE;
END_IF;

IF gxResetDataAnalysis_St1 THEN
	gxResetDataAnalysis_St1:=FALSE;
	T_PartAnalysis.sEndOfProcess:='';
	T_PartAnalysis.sStartOfProcess:='';
	T_PartAnalysis.diActual_NumberHoleToWork:=0;
	FOR ii:=1 TO ciMaxWP DO
		T_PartAnalysis.abWorkPartQuality[ii]:=0;
		T_PartAnalysis.adiCycleTime[ii]:=0;
		T_PartAnalysis.adiWorkTime[ii]:=0;
		T_PartAnalysis.aiHCCounter[ii]:=0;
		T_PartAnalysis.aiHCCounterCentering[ii]:=0;
		T_PartAnalysis.aiHCCounterTorque[ii]:=0;
		T_PartAnalysis.aiHCCounterSpeed[ii]:=0;
		T_PartAnalysis.arFirstHC[ii]:=0.0;
		T_PartAnalysis.abInfeedCounterZ[ii]:=0;
		T_PartAnalysis.adiNumberHole[ii]:=ii;
	END_FOR;
	T_PartAnalysis.sFileName:='';
END_IF;
IF (T_PartAnalysis.adiNumberHole[1] = 0) THEN
	FOR ii:=1 TO ciMaxWP DO
		T_PartAnalysis.adiNumberHole[ii]:=ii;
	END_FOR;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER4_PROCESS\/FBPROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_WPCounter
VAR_INPUT
	iStationNr:INT;
END_VAR
VAR_IN_OUT
	T_Parameter:ST_RETAIN_DATA;
	T_CtrlWork:ST_CTRL_WORK;
END_VAR
VAR_OUTPUT
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
IF T_CtrlWork.xAddWPCounter_Machine_IO THEN
	T_CtrlWork.xAddWPCounter_Machine_IO:=FALSE;
	T_Parameter.T_StationWork[gciStationSt1].T_WPCounter.diWPCounter_IO_Actual:=
						T_Parameter.T_StationWork[gciStationSt1].T_WPCounter.diWPCounter_IO_Actual + 1;		(* Maschinen Wstk Zähler IO Tagesaktuell nicht rücksetzbar *)
	T_Parameter.T_StationWork[gciStationSt1].T_WPCounter.diWPCounter_IO_Reset:=
						T_Parameter.T_StationWork[gciStationSt1].T_WPCounter.diWPCounter_IO_Reset + 1;		(* Maschinen Wstk Zähler IO Rücksetzbar *)
END_IF;
IF T_CtrlWork.xAddWPCounter_Machine_NIO THEN
	T_CtrlWork.xAddWPCounter_Machine_NIO:=FALSE;
	T_Parameter.T_StationWork[gciStationSt1].T_WPCounter.diWPCounter_NIO_Actual:=
						T_Parameter.T_StationWork[gciStationSt1].T_WPCounter.diWPCounter_NIO_Actual + 1;		(* Maschinen Wstk Zähler NIO Tagesaktuell nicht rücksetzbar *)
	T_Parameter.T_StationWork[gciStationSt1].T_WPCounter.diWPCounter_NIO_Reset:=
						T_Parameter.T_StationWork[gciStationSt1].T_WPCounter.diWPCounter_NIO_Reset + 1;		(* Maschinen Wstk Zähler NIO Rücksetzbar *)
END_IF;

T_Parameter.T_StationWork[gciStationSt1].T_WPCounter.diWPCounter_IO_NIO:=		T_Parameter.T_StationWork[gciStationSt1].T_WPCounter.diWPCounter_IO_Actual +
																				T_Parameter.T_StationWork[gciStationSt1].T_WPCounter.diWPCounter_NIO_Actual;

IF T_CtrlWork.xAddToolCounter_Machine THEN
	T_CtrlWork.xAddToolCounter_Machine:=FALSE;
	IF (T_CtrlWork.bPartQuality >= 1) AND (T_CtrlWork.bPartQuality <= 5) AND NOT(T_NovRam.T_Parameter.T_Machine.xEndlessProcessActive) THEN
		T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter.diToolCycleCounter:=T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter.diToolCycleCounter + 1;	(* Station 1 Wz Zähler um 1 erhöhen *)
	END_IF;
END_IF;

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER4_PROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_PROCESS
VAR
	FBProcess: FB_PROCESS;
	xReady: BOOL;
	xDone: BOOL;
	xStop: BOOL;
	xReferenced: BOOL;
	xError: BOOL;
	diErrorNr: DINT;
	iFunctionNr: INT;
	FBPreWarningCtrlMessage: FB_PreWarning_Ctrl_Message;
	xEnergyON: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
_FBD_BODY
_NETWORKS : 3
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERATOR
_BOX_EXPR : 3
_OPERAND
_EXPRESSION
_POSITIV
gT_SafetyStatus.xEnergyONNormalMode
_OPERAND
_EXPRESSION
_POSITIV
gT_SafetyStatus.xEnergyONSetupModeASt1
_OPERAND
_EXPRESSION
_POSITIV
gT_SafetyStatus.xEnergyONSetupModeBSt1
_EXPRESSION
_POSITIV
OR
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
xEnergyON
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_FUNCTIONBLOCK
FBProcess
_BOX_EXPR : 6
_OPERAND
_EXPRESSION
_POSITIV
T_ExchgParam.T_Visu.xActiveProcessState_St1St2
_OPERAND
_EXPRESSION
_POSITIV
xEnergyON
_OPERAND
_EXPRESSION
_POSITIV
TProcess
_OPERAND
_EXPRESSION
_POSITIV
T_NovRam
_OPERAND
_EXPRESSION
_POSITIV
TStation_Work_St1
_OPERAND
_EXPRESSION
_POSITIV
T_ProcessData_St1
_EXPRESSION
_POSITIV
FB_PROCESS
_OUTPUTS : 6
_OUTPUT
_POSITIV
_NO_SET
xDone
_OUTPUT
_POSITIV
_NO_SET
xStop
_OUTPUT
_POSITIV
_NO_SET
xReferenced
_OUTPUT
_POSITIV
_NO_SET
xError
_OUTPUT
_POSITIV
_NO_SET
diErrorNr
_OUTPUT
_POSITIV
_NO_SET
iFunctionNr
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
xReady
_NETWORK

_COMMENT
''
_END_COMMENT
_FUNCTIONBLOCK
FBPreWarningCtrlMessage
_BOX_EXPR : 2
_OPERATOR
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
T_ExchgParam.T_SafetyCtrl.bStateMessagePreWarning
_OPERAND
_EXPRESSION
_POSITIV
0
_EXPRESSION
_NEGATIV
EQ
_OPERAND
_EXPRESSION
_POSITIV
gT_PreWarning
_EXPRESSION
_POSITIV
FB_PreWarning_Ctrl_Message
_OUTPUTS : 0

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION bFct_GetLedState : BYTE
VAR_INPUT
	iLampNumber:INT;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
IF (iLampNumber = 1) THEN
	bFct_GetLedState:=1;
ELSIF (iLampNumber = 2) THEN
	bFct_GetLedState:=2;
ELSIF (iLampNumber = 3) THEN
	bFct_GetLedState:=3;
ELSIF (iLampNumber = 4) THEN
	bFct_GetLedState:=4;
ELSIF (iLampNumber = 5) THEN
	bFct_GetLedState:=5;
ELSIF (iLampNumber = 13) THEN
	bFct_GetLedState:=1;
ELSIF (iLampNumber = 14) THEN
	bFct_GetLedState:=3;
ELSIF (iLampNumber = 15) THEN
	bFct_GetLedState:=2;
ELSIF (iLampNumber = 16) THEN
	bFct_GetLedState:=1;
END_IF;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION bFct_SetAxisStat : BYTE
(*Set/Reset bitxxx of StatusByte according to Bool-Input-State*)
VAR_INPUT
	xbit0			:BOOL;		(*Power*)
	xbit1			:BOOL;		(*Ref, 	Spez:@Spindle: busy*)
	xbit2			:BOOL;		(*Busyf, 	Spez:@Spindle: error*)
	xbit3			:BOOL;		(*Error*)
	xbit4			:BOOL;		(*HWlimNeg*)
	xbit5			:BOOL;		(*HWlimPos*)
	bState		:BYTE;		(*Use same Input byte as the output byte*)
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
bState.0:=xbit0 ;
bState.1:=xbit1 ;
bState.2:=xbit2 ;
bState.3:=xbit3 ;
bState.4:=xbit4 ;
bState.5:=xbit5 ;

bFct_SetAxisStat:= bState;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION bFct_SetCylStat : BYTE
(*Set/Reset bit0/ 1 of Byte according to Input-State*)
VAR_INPUT
	xON			:BOOL;
	xOFF		:BOOL;
	bState		:BYTE;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
bState.0:=xOFF ;
bState.1:=xON ;

bFct_SetCylStat:= bState;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_GetParameterList
VAR_INPUT
	xNormalModeActive:BOOL;
	iSetupMode:INT;
	wActiveTaskBar:WORD;
	iActLevel:INT;
END_VAR
VAR_IN_OUT
	aiTempActiveParaListState:ARRAY [0..3,1..6] OF INT;
END_VAR
VAR_OUTPUT
	iParameterList:INT;
	wNotMasktext:WORD;
	wState:WORD;
	aiSelectText:ARRAY [1..15] OF INT;
	bParameterListEditable:BYTE;
	bMessageParameter:BYTE;		(* 0=Unterdrücken der Parameter Nachricht, 1=Nur mittels Operator Level, 2=Nur mittels System Level, 3=Keine Parameterliste vorhanden *)
END_VAR
VAR
	xInit: BOOL;
	ii: INT;
	jj: INT;
	iTask: INT;
END_VAR
(* @END_DECLARATION := '0' *)
IF NOT(xInit) THEN
	xInit:=TRUE;
	FOR ii:=0 TO 3 DO
		FOR jj:=1 TO 6 DO
			aiTempActiveParaListState[ii,jj]:=1;
		END_FOR;
	END_FOR;
END_IF;
iParameterList:=0;
wNotMasktext:=16#FFF;
aiSelectText[1]:=aiSelectText[2]:=aiSelectText[3]:=aiSelectText[4]:=aiSelectText[5]:=0;
aiSelectText[6]:=aiSelectText[7]:=aiSelectText[8]:=aiSelectText[9]:=aiSelectText[10]:=0;
aiSelectText[11]:=aiSelectText[12]:=aiSelectText[13]:=aiSelectText[14]:=aiSelectText[15]:=0;
wState:=0;
bParameterListEditable:=0;
bMessageParameter:=3;
iTask:=iFct_GetBitNumber(wInputButton:=wActiveTaskBar);
IF xNormalModeActive THEN
	CASE iTask OF
	(* NormalBetrieb -->Task 1,2,3,4,5,6 *)
	1,2,3,4,5,6:	IF (aiTempActiveParaListState[0,iTask] > 3) THEN aiTempActiveParaListState[0,iTask]:=1; END_IF;
				CASE aiTempActiveParaListState[0,iTask] OF
				1:	iParameterList:=10;
					wState:=16#1;			(* Liste 1 ausgewählt *)
				2:	iParameterList:=11;
					wState:=16#2;			(* Liste 2 ausgewählt *)
				3:	iParameterList:=12;
					wState:=16#4;			(* Liste 3 ausgewählt *)
				END_CASE;
				wNotMasktext:=16#FFF8;	(* Liste 1,2,3 darf nicht unterdrückt werden *)
				aiSelectText[1]:=10;
				aiSelectText[2]:=11;
				aiSelectText[3]:=12;
				IF (iActLevel > 0) THEN
					bMessageParameter:=0;
				ELSE
					bMessageParameter:=1;
					iParameterList:=0;
				END_IF;
				bParameterListEditable:=1;	(* Parameterliste Editierbar *)
	END_CASE;
ELSE
	IF (iSetupMode = 1) THEN
		CASE iTask OF
		(* EinrichtBetrieb A-->Task 1,2,3,4,5,6 *)
		1,2,3,4,5,6:	IF (aiTempActiveParaListState[iSetupMode,iTask] > 15) THEN aiTempActiveParaListState[iSetupMode,iTask]:=1; END_IF;
					CASE aiTempActiveParaListState[iSetupMode,iTask] OF
					1:	iParameterList:=110;
						wState:=16#1;			(* Liste 1 ausgewählt *)
					2:	iParameterList:=111;
						wState:=16#2;			(* Liste 2 ausgewählt *)
					3:	iParameterList:=112;
						wState:=16#4;			(* Liste 3 ausgewählt *)
					4:	iParameterList:=113;
						wState:=16#8;			(* Liste 4 ausgewählt *)
					5:	iParameterList:=114;
						wState:=16#10;		(* Liste 5 ausgewählt *)
					6:	iParameterList:=115;
						wState:=16#20;		(* Liste 6 ausgewählt *)
					7:	iParameterList:=116;
						wState:=16#40;		(* Liste 7 ausgewählt *)
					8:	iParameterList:=117;
						wState:=16#80;		(* Liste 8 ausgewählt *)
					15:	iParameterList:=124;
						wState:=16#4000;		(* Liste 15 ausgewählt *)
					END_CASE;
					aiSelectText[1]:=110;
					aiSelectText[2]:=111;
					aiSelectText[3]:=112;
					aiSelectText[4]:=113;
					aiSelectText[5]:=114;
					aiSelectText[6]:=115;
					aiSelectText[7]:=116;
					aiSelectText[8]:=117;
					aiSelectText[15]:=124;
					wNotMasktext:=16#BF00;	(* Liste 1,2,3,4,5,6,15 dürfen nicht unterdrückt werden *)
					bParameterListEditable:=1;	(* Parameterliste Editierbar *)
					bMessageParameter:=0;
		END_CASE;
	ELSIF (iSetupMode = 2) THEN
		CASE iTask OF
		(* EinrichtBetrieb B-->Task 1,2,3,4,5,6 *)
		1,2,3,4,5,6:	IF (aiTempActiveParaListState[iSetupMode,iTask] > 8) THEN aiTempActiveParaListState[iSetupMode,iTask]:=1; END_IF;
					CASE aiTempActiveParaListState[iSetupMode,iTask] OF
					1:	iParameterList:=210;
						wState:=16#1;			(* Liste 1 ausgewählt *)
					2:	iParameterList:=211;
						wState:=16#2;			(* Liste 2 ausgewählt *)
					3:	iParameterList:=212;
						wState:=16#4;			(* Liste 3 ausgewählt *)
					4:	iParameterList:=213;
						wState:=16#8;			(* Liste 4 ausgewählt *)
					5:	iParameterList:=214;
						wState:=16#10;		(* Liste 5 ausgewählt *)
					6:	iParameterList:=215;
						wState:=16#20;		(* Liste 6 ausgewählt *)
					7:	iParameterList:=216;
						wState:=16#40;		(* Liste 7 ausgewählt *)
					8:	iParameterList:=217;
						wState:=16#80;		(* Liste 8 ausgewählt *)
					END_CASE;
					IF (aiTempActiveParaListState[iSetupMode,iTask] = 1) OR (aiTempActiveParaListState[iSetupMode,iTask] = 6) THEN
						bMessageParameter:=0;
					ELSE
						IF (iActLevel > 1) THEN
							bMessageParameter:=0;
						ELSE
							bMessageParameter:=2;	(* Nur mittels System Level *)
							iParameterList:=0;
						END_IF;
					END_IF;
					aiSelectText[1]:=210;
					aiSelectText[2]:=211;
					aiSelectText[3]:=212;
					aiSelectText[4]:=213;
					aiSelectText[5]:=214;
					aiSelectText[6]:=215;
					aiSelectText[7]:=216;
					aiSelectText[8]:=217;
					wNotMasktext:=16#FF00;	(* Liste 1,2,3,4,5,6,7 und 8 dürfen nicht unterdrückt werden *)
					bParameterListEditable:=1;	(* Parameterliste Editierbar *)
		END_CASE;
	END_IF;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_GetStationFunctionNr
VAR_INPUT
	iVisuFunctionNr:INT;
END_VAR
VAR_OUTPUT
	iWorkStation_FunctionNr:INT;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
iWorkStation_FunctionNr:=0;
CASE iVisuFunctionNr OF
(* < Grundstellungsfahrt BearbStation > *)
1:	iWorkStation_FunctionNr:=2;
(* < S Axis EIN > *)
2:	iWorkStation_FunctionNr:=3;
(* < Wz Einfädeln > *)
3:	iWorkStation_FunctionNr:=4;
(* < Wstk Zentrieren > *)
4:	iWorkStation_FunctionNr:=11;
(* < Bearbeitungsprozess > *)
5:	iWorkStation_FunctionNr:=5;
(* < S Axis AUS > *)
6:	iWorkStation_FunctionNr:=6;
END_CASE;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_TeachPosToHMI
(*Bearb-Station: Zuweisung der Teach-Werte zur HMI-Struct*)
VAR_INPUT
	iAxisNr				:INT;
	iSelectPos			:INT;
	rSetPos				:REAL;(*Input from HMI-Var: SetPos*)

	TeachPosWork		: ST_EXCHG_PARAM_STANDARDPROCESS;
END_VAR
VAR_OUTPUT
	rPosition				:REAL;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
IF NOT(T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.xConfigActive) THEN
		CASE iAxisNr OF
		(* Z Axis *)
		1:	CASE iSelectPos OF
			(* < Fahre zu man. Pos. > *)
			0:	rPosition:=rSetPos;
			(* < Z LadePos > *)
			1:	rPosition:=TeachPosWork.rPositionLoad;
			(* < Z Bearb StartPos > *)
			2:	rPosition:=TeachPosWork.rPositionStartProc;
			(* < Z ZentrierPos > *)
			3:	rPosition:=TeachPosWork.rCentringPosZ1Axis;
			(* < Z Bearb EndPos > *)
			4:	rPosition:=TeachPosWork.rPositionEndProc;
			(* < Z WzWechsel Pos > *)
			5:	rPosition:=TeachPosWork.rPositionToolChange;
			(* < Z Mech EndPos > *)
			6:	rPosition:=TeachPosWork.rPositionEndMech;
			(* < Z Bearb EndPos berechn. > *)
			7:	rPosition:=garPositionEndProcCalc[1];
			(* < Z Bearb EndPos Max > *)
			8:	rPosition:=TeachPosWork.rPositionEndProcMaxInc;
			(* < Z ZentrierPos berechn. > *)
			9:	rPosition:=garCentringEndProcCalc[1];
			(* < Z WzZylinder Pos > *)
			10:	rPosition:=TeachPosWork.rZPositionCylindricalArea;
			END_CASE;
		END_CASE;
ELSE
		CASE iAxisNr OF
		(* Z Axis *)
		1:	CASE iSelectPos OF
			(* < Fahre zu man. Pos. > *)
			0:	rPosition:=rSetPos;
			(* < Z LadePos > *)
			1:	rPosition:=grZ_LoadPos;
			(* < Z Bearb StartPos > *)
			2:	rPosition:=grZ_WorkStartPos;
			(* < Z ZentrierPos > *)
			3:	rPosition:=TeachPosWork.rCentringPosZ1Axis;
			(* < Z Bearb EndPos > *)
			4:	rPosition:=garPositionEndProcCalc[1];
			(* < Z WzWechsel Pos > *)
			5:	rPosition:=TeachPosWork.rPositionToolChange;
			(* < Z Mech EndPos > *)
			6:	rPosition:=TeachPosWork.rPositionEndMech;
			(* < Z Bearb EndPos berechn. > *)
			7:	rPosition:=garPositionEndProcCalc[1];
			(* < Z Bearb EndPos Max > *)
			8:	rPosition:=TeachPosWork.rPositionEndProcMaxInc;
			(* < Z ZentrierPos berechn. > *)
			9:	rPosition:=garCentringEndProcCalc[1];
			(* < Z WzZylinder Pos > *)
			10:	rPosition:=TeachPosWork.rZPositionCylindricalArea;
			END_CASE;
		END_CASE;
END_IF;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION iFct_GetBitNumber : INT
VAR_INPUT
	wInputButton:WORD;
END_VAR
VAR
	wTmp:WORD;
	ii: INT;
END_VAR
(* @END_DECLARATION := '0' *)
iFct_GetBitNumber:=0;
wTmp:=wInputButton;
FOR  ii:=1 TO 16 DO	(* Only for datatype WORD-->16Bit *)
	IF (wTmp AND 16#1) = 16#1 THEN
		iFct_GetBitNumber:=ii;	(* Only the first Bit from the right side  will be check-->be sure that it is settled only one bit *)
		EXIT;
	END_IF;
	wTmp:=ROR(wTmp,1);	(* Shift 1 Bit to right *)
END_FOR;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION iFct_GetLeftButtonNumber : INT
VAR_INPUT
	dwActualPage:DWORD;
END_VAR
VAR
	iTmpLeftButtonNumber:INT;
END_VAR
(* @END_DECLARATION := '0' *)
iFct_GetLeftButtonNumber:=iTmpLeftButtonNumber:=0;
IF ((dwActualPage >= 10) AND (dwActualPage <= 99)) THEN
	iTmpLeftButtonNumber:=0;	(* No Button active *)
	IF (dwActualPage = 70) THEN
		iTmpLeftButtonNumber:=iTmpLeftButtonNumber + 16;	(* Parameter Button active *)
	END_IF;
END_IF;
IF ((dwActualPage >= 100) AND (dwActualPage <= 199)) THEN
	iTmpLeftButtonNumber:=1;	(* Button 1 active *)
	IF (dwActualPage = 170) THEN
		iTmpLeftButtonNumber:=iTmpLeftButtonNumber + 16;	(* Button 1 and Parameter Button active *)
	END_IF;
END_IF;
IF ((dwActualPage >= 200) AND (dwActualPage <= 299)) THEN
	iTmpLeftButtonNumber:=2;	(* Button 2 active *)
	IF (dwActualPage = 270) THEN
		iTmpLeftButtonNumber:=iTmpLeftButtonNumber + 16;	(* Button 2 and Parameter Button active *)
	END_IF;
END_IF;
IF ((dwActualPage >= 300) AND (dwActualPage <= 399)) THEN
	iTmpLeftButtonNumber:=4;	(* Button 3 active *)
	IF (dwActualPage = 370) THEN
		iTmpLeftButtonNumber:=iTmpLeftButtonNumber + 16;	(* Button 3 and Parameter Button active *)
	END_IF;
END_IF;
IF ((dwActualPage >= 400) AND (dwActualPage <= 499)) THEN
	iTmpLeftButtonNumber:=8;	(* Button 1 active *)
	IF (dwActualPage = 470) THEN
		iTmpLeftButtonNumber:=iTmpLeftButtonNumber + 16;	(* Button 4 and Parameter Button active *)
	END_IF;
END_IF;
iFct_GetLeftButtonNumber:=iTmpLeftButtonNumber;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION sFct_GetLampOrderNumberEngl : STRING(90)
VAR_INPUT
	xLampdefect:BOOL;
	iLampNumber:INT;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
sFct_GetLampOrderNumberEngl:='';
IF xLampdefect THEN
	IF (iLampNumber = 1) THEN
		sFct_GetLampOrderNumberEngl:='Microcut order no.: 986.03.03.001:   LED-Element 24VDC green(Start Button)';
	ELSIF (iLampNumber = 2) THEN
		sFct_GetLampOrderNumberEngl:='Microcut order no.: 986.03.03.003:   LED-Element 24VDC red(Stop Button)';
	ELSIF (iLampNumber = 3) THEN
		sFct_GetLampOrderNumberEngl:='Microcut order no.: 986.03.03.004:   LED-Element 24VDC white(Axislocking Button)';
	ELSIF (iLampNumber = 4) THEN
		sFct_GetLampOrderNumberEngl:='Microcut order no.: 986.03.03.002:   LED-Element 24VDC blue(Enabling Button)';
	ELSIF (iLampNumber = 5) THEN
		sFct_GetLampOrderNumberEngl:='Microcut order no.: 986.03.03.004:   LED-Element 24VDC yellow(SetupMode Lamp)';
	ELSIF (iLampNumber = 13) THEN
		sFct_GetLampOrderNumberEngl:='Microcut order no.: 986.06.04.025:   Control lamp (green)';
	ELSIF (iLampNumber = 14) THEN
		sFct_GetLampOrderNumberEngl:='Microcut order no.: 986.06.04.025:   Control lamp (yellow)';
	ELSIF (iLampNumber = 15) THEN
		sFct_GetLampOrderNumberEngl:='Microcut order no.: 986.06.04.025:   Control lamp (red)';
	ELSIF (iLampNumber = 16) THEN
		sFct_GetLampOrderNumberEngl:='Microcut order no.: 986.06.04.026:   Indoor Lamp';
	END_IF;
ELSE
	IF (iLampNumber = 1) THEN
		sFct_GetLampOrderNumberEngl:='LED-Element 24VDC green(Start Button)';
	ELSIF (iLampNumber = 2) THEN
		sFct_GetLampOrderNumberEngl:='LED-Element 24VDC red(Stop Button)';
	ELSIF (iLampNumber = 3) THEN
		sFct_GetLampOrderNumberEngl:='LED-Element 24VDC white(Axislocking Button)';
	ELSIF (iLampNumber = 4) THEN
		sFct_GetLampOrderNumberEngl:='LED-Element 24VDC blue(Enabling Button)';
	ELSIF (iLampNumber = 5) THEN
		sFct_GetLampOrderNumberEngl:='LED-Element 24VDC yellow(SetupMode Lamp)';
	ELSIF (iLampNumber = 13) THEN
		sFct_GetLampOrderNumberEngl:='Control lamp (green)';
	ELSIF (iLampNumber = 14) THEN
		sFct_GetLampOrderNumberEngl:='Control lamp (yellow)';
	ELSIF (iLampNumber = 15) THEN
		sFct_GetLampOrderNumberEngl:='Control lamp (red)';
	ELSIF (iLampNumber = 16) THEN
		sFct_GetLampOrderNumberEngl:='Indoor Lamp';
	END_IF;
END_IF;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION sFct_GetLampOrderNumberGer : STRING(90)
VAR_INPUT
	xLampdefect:BOOL;
	iLampNumber:INT;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
sFct_GetLampOrderNumberGer:='';
IF xLampdefect THEN
	IF (iLampNumber = 1) THEN
		sFct_GetLampOrderNumberGer:='Microcut BestellNr.: 986.03.03.001:   LED-Element 24VDC grün(Start Taste)';
	ELSIF (iLampNumber = 2) THEN
		sFct_GetLampOrderNumberGer:='Microcut BestellNr.: 986.03.03.003:   LED-Element 24VDC rot(Stopp Taste)';
	ELSIF (iLampNumber = 3) THEN
		sFct_GetLampOrderNumberGer:='Microcut BestellNr.: 986.03.03.004:   LED-Element 24VDC weiss(Achsensperr Taste)';
	ELSIF (iLampNumber = 4) THEN
		sFct_GetLampOrderNumberGer:='Microcut BestellNr.: 986.03.03.002:   LED-Element 24VDC blau(Freigabe Taste)';
	ELSIF (iLampNumber = 5) THEN
		sFct_GetLampOrderNumberGer:='Microcut BestellNr.: 986.03.03.004:   LED-Element 24VDC gelb(Einrichtlampe)';
	ELSIF (iLampNumber = 13) THEN
		sFct_GetLampOrderNumberGer:='Microcut BestellNr.: 986.06.04.025:   Kontrolllampe (grün)';
	ELSIF (iLampNumber = 14) THEN
		sFct_GetLampOrderNumberGer:='Microcut BestellNr.: 986.06.04.025:   Kontrolllampe (gelb)';
	ELSIF (iLampNumber = 15) THEN
		sFct_GetLampOrderNumberGer:='Microcut BestellNr.: 986.06.04.025:   Kontrolllampe (rot)';
	ELSIF (iLampNumber = 16) THEN
		sFct_GetLampOrderNumberGer:='Microcut BestellNr.: 986.06.04.026:   Maschinenlampe';
	END_IF;
ELSE
	IF (iLampNumber = 1) THEN
		sFct_GetLampOrderNumberGer:='LED-Element 24VDC grün(Start Taste)';
	ELSIF (iLampNumber = 2) THEN
		sFct_GetLampOrderNumberGer:='LED-Element 24VDC rot(Stopp Taste)';
	ELSIF (iLampNumber = 3) THEN
		sFct_GetLampOrderNumberGer:='LED-Element 24VDC weiss(Achsensperr Taste)';
	ELSIF (iLampNumber = 4) THEN
		sFct_GetLampOrderNumberGer:='LED-Element 24VDC blau(Freigabe Taste)';
	ELSIF (iLampNumber = 5) THEN
		sFct_GetLampOrderNumberGer:='LED-Element 24VDC gelb(Einrichtlampe)';
	ELSIF (iLampNumber = 13) THEN
		sFct_GetLampOrderNumberGer:='Kontrolllampe (grün)';
	ELSIF (iLampNumber = 14) THEN
		sFct_GetLampOrderNumberGer:='Kontrolllampe (gelb)';
	ELSIF (iLampNumber = 15) THEN
		sFct_GetLampOrderNumberGer:='Kontrolllampe (rot)';
	ELSIF (iLampNumber = 16) THEN
		sFct_GetLampOrderNumberGer:='Maschinenlampe';
	END_IF;
END_IF;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION wFct_GetTaskNumber : WORD
VAR_INPUT
	dwActualPage:DWORD;
END_VAR
VAR
	wTmpTaskNumber: WORD;
END_VAR
(* @END_DECLARATION := '0' *)
wFct_GetTaskNumber:=wTmpTaskNumber:=1;
IF ((dwActualPage >= 10) AND (dwActualPage <= 19)) OR ((dwActualPage >= 110) AND (dwActualPage <= 119)) OR
     ((dwActualPage >= 210) AND (dwActualPage <= 219)) OR ((dwActualPage >= 310) AND (dwActualPage <= 319)) OR ((dwActualPage >= 410) AND (dwActualPage <= 419)) THEN
	wTmpTaskNumber:=1;	(* Task 1 *)
END_IF;
IF ((dwActualPage >= 20) AND (dwActualPage <= 29)) OR ((dwActualPage >= 120) AND (dwActualPage <= 129)) OR
     ((dwActualPage >= 220) AND (dwActualPage <= 229)) OR ((dwActualPage >= 320) AND (dwActualPage <= 329)) OR ((dwActualPage >= 420) AND (dwActualPage <= 429)) THEN
	wTmpTaskNumber:=2;	(* Task 2 *)
END_IF;
IF ((dwActualPage >= 30) AND (dwActualPage <= 39)) OR ((dwActualPage >= 130) AND (dwActualPage <= 139)) OR
     ((dwActualPage >= 230) AND (dwActualPage <= 239)) OR ((dwActualPage >= 330) AND (dwActualPage <= 339)) OR ((dwActualPage >= 430) AND (dwActualPage <= 439)) THEN
	wTmpTaskNumber:=4;	(* Task 3 *)
END_IF;
IF ((dwActualPage >= 40) AND (dwActualPage <= 49)) OR ((dwActualPage >= 140) AND (dwActualPage <= 149)) OR
     ((dwActualPage >= 240) AND (dwActualPage <= 249)) OR ((dwActualPage >= 340) AND (dwActualPage <= 349)) OR ((dwActualPage >= 440) AND (dwActualPage <= 449)) THEN
	wTmpTaskNumber:=8;	(* Task 4 *)
END_IF;
IF ((dwActualPage >= 50) AND (dwActualPage <= 59)) OR ((dwActualPage >= 150) AND (dwActualPage <= 159)) OR
     ((dwActualPage >= 250) AND (dwActualPage <= 259)) OR ((dwActualPage >= 350) AND (dwActualPage <= 359)) OR ((dwActualPage >= 450) AND (dwActualPage <= 459)) THEN
	wTmpTaskNumber:=16;	(* Task 5 *)
END_IF;
IF ((dwActualPage >= 60) AND (dwActualPage <= 69)) OR ((dwActualPage >= 160) AND (dwActualPage <= 169)) OR
     ((dwActualPage >= 260) AND (dwActualPage <= 269)) OR ((dwActualPage >= 360) AND (dwActualPage <= 369)) OR ((dwActualPage >= 460) AND (dwActualPage <= 469)) THEN
	wTmpTaskNumber:=32;	(* Task 6 *)
END_IF;
wFct_GetTaskNumber:=wTmpTaskNumber;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION xFct_CheckSingleButtonActivation : BOOL
VAR_INPUT
	wInputButton:WORD;
END_VAR
VAR
	wTmp:WORD;
	ii: INT;
	iCountNumberButtonActivation: INT;
END_VAR
(* @END_DECLARATION := '0' *)
(* Return TRUE if only one button is pressed *)
xFct_CheckSingleButtonActivation:=FALSE;
wTmp:=wInputButton;
iCountNumberButtonActivation:=0;
FOR  ii:=1 TO 16 DO	(* Only for datatype WORD-->16Bit *)
	IF (wTmp AND 16#1) = 16#1 THEN
		iCountNumberButtonActivation:=iCountNumberButtonActivation + 1;
	END_IF;
	wTmp:=ROR(wTmp,1);	(* Shift 1 Bit to right *)
END_FOR;
IF (iCountNumberButtonActivation = 1) THEN
	xFct_CheckSingleButtonActivation:=TRUE;
END_IF;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION xFct_GetJogMode : BOOL
VAR_INPUT
	iFunction:INT;		(* Übergabe der Visualisierungsfunktionsnummer *)
END_VAR
VAR
	xJogModeActive: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
xJogModeActive:=FALSE;
IF (iFunction = 216) THEN	(* Achse Jog/Ink Bewegung -/- - *)
	xJogModeActive:=TRUE;
ELSIF (iFunction = 217) THEN	(* Achse Jog/Ink Bewegung +/++ *)
	xJogModeActive:=TRUE;
END_IF;
xFct_GetJogMode:=xJogModeActive;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION xFct_GetNormalOperateActive : BOOL
VAR_INPUT
	dwActualPage:DWORD;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
xFct_GetNormalOperateActive:=FALSE;
IF (dwActualPage >= 10) AND (dwActualPage <= 99) THEN
	xFct_GetNormalOperateActive:=TRUE;
END_IF;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION xFct_GetParameterPageActive : BOOL
VAR_INPUT
	dwActualPage:DWORD;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
xFct_GetParameterPageActive:=FALSE;
IF (dwActualPage = 70) OR (dwActualPage = 170) OR (dwActualPage = 270) OR (dwActualPage = 370) OR (dwActualPage = 470) THEN
	xFct_GetParameterPageActive:=TRUE;
END_IF;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION xFct_GetSetupMode : BOOL
VAR_INPUT
	dwActualPage:DWORD;
	iSetupModeRequest:INT;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
xFct_GetSetupMode:=FALSE;
IF (iSetupModeRequest = 1) THEN
	IF (dwActualPage >= 110) AND (dwActualPage <= 199) THEN
		xFct_GetSetupMode:=TRUE;
	END_IF;
END_IF;
IF (iSetupModeRequest = 2) THEN
	IF (dwActualPage >= 210) AND (dwActualPage <= 299) THEN
		xFct_GetSetupMode:=TRUE;
	END_IF;
END_IF;
IF (iSetupModeRequest = 3) THEN
	IF (dwActualPage >= 310) AND (dwActualPage <= 399) THEN
		xFct_GetSetupMode:=TRUE;
	END_IF;
END_IF;
IF (iSetupModeRequest = 4) THEN
	IF (dwActualPage >= 410) AND (dwActualPage <= 499) THEN
		xFct_GetSetupMode:=TRUE;
	END_IF;
END_IF;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION xFct_GetSetupOperateActive : BOOL
VAR_INPUT
	dwActualPage:DWORD;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
xFct_GetSetupOperateActive:=FALSE;
IF (dwActualPage >= 110) AND (dwActualPage <= 499) THEN
	xFct_GetSetupOperateActive:=TRUE;
END_IF;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU\/Function' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION xFct_SetActualPageTask : BOOL
VAR_INPUT
	dwActualPage:DWORD;
	iTaskBarNumber:INT;
END_VAR
VAR_IN_OUT
	dwSaveActualPageTask:ARRAY [0..4,1..6] OF DWORD;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
IF ((dwActualPage >= 10) AND (dwActualPage <= 69)) THEN
	dwSaveActualPageTask[0,iTaskBarNumber]:=dwActualPage;
END_IF;
IF ((dwActualPage >= 110) AND (dwActualPage <= 169)) THEN
	dwSaveActualPageTask[1,iTaskBarNumber]:=dwActualPage;
END_IF;
IF ((dwActualPage >= 210) AND (dwActualPage <= 269)) THEN
	dwSaveActualPageTask[2,iTaskBarNumber]:=dwActualPage;
END_IF;
IF ((dwActualPage >= 310) AND (dwActualPage <= 369)) THEN
	dwSaveActualPageTask[3,iTaskBarNumber]:=dwActualPage;
END_IF;
IF ((dwActualPage >= 410) AND (dwActualPage <= 469)) THEN
	dwSaveActualPageTask[4,iTaskBarNumber]:=dwActualPage;
END_IF;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBQVIS
VAR_INPUT
	xStartButton:BOOL;		(* external start button *)
	xStopButton:BOOL;		(* external stop button *)
	wBtPanel:WORD;
	xSecurityKey:BOOL;		(* state of the keyswitch-->TRUE=EinrichtBetrieb *)
	iSetupMode:INT;			(* Turn switch --> 1=EinrichtBetriebA, 2=EinrichtBetriebB, 0=Normalbetrieb *)
END_VAR
VAR_IN_OUT
	T_Visu:ST_QVIS;
	T_CtrleQVis:ST_QVISCTRLE;
	T_ExchgParam:ST_QVIS_EXCHG_PARAM;
END_VAR
VAR_OUTPUT
END_VAR
VAR
(* variable ctrle QVis*)
	xActivFB:BOOL:=FALSE;
	xConfirmResetFB:BOOL:=FALSE;
	xQvisActiv:BOOL:=FALSE;
	xChangePage:BOOL:=FALSE;
	dwInCount_QVisCmd:DWORD:=0;
	TimerQVis:TON;
	RisingEdgeExecute:R_TRIG;
	RisingEdgeActiv:R_TRIG;
	RisingEdgeReset:R_TRIG;
	iStepCount: INT;
	fbQvisInitPage:FBQVIS_INITPAGE;
	T_ConfigPage:ST_CONFIGPAGE;
	wMaskBtPanelLeft: WORD;
	wMaskBtPanelRight:WORD;
	wForceMaskBtPanelRight:WORD;
	wMaskFunctionPanel:WORD;
	wForceMaskFunctionPanel:WORD;
	aiForceRTrigActionFunctionPanel:ARRAY [1..12] OF INT;
	aiDelectRTrigActionFunctionPanel:ARRAY [1..12] OF INT;
	aiForceRTrigActionPanelRight:ARRAY [1..5] OF INT;
	aiDeleteRTrigActionPanelRight:ARRAY [1..5] OF INT;
(* variable process *)
	RisingEdgeExecuteProcess:R_TRIG;
	RisingEdgeReseTProcess:R_TRIG;
	RisingEdgeProcessDone:R_TRIG;
	RisingEdgeProcessError:R_TRIG;
	iStepProcess:INT;
	xStepProcessDone:BOOL;
	xProcessMachine: BOOL;
	xProcessStation: BOOL;
(* variable touchscreen button navigation panel panel *)
	RisingEdgeTouchScreenNavPanel:R_TRIG;
	xTmp: BOOL;
	ii: INT;
(* Key panel button "Esc"/"Enter" *)
	RisingEdgeKeyPanel_Esc:R_TRIG;
	RisingEdgeKeyPanel_Enter:R_TRIG;
(* variable start action *)
	TimerAction:TON;
	TimerNotReady:TOF;
	tTimeOutAction:TIME;
	RisingEdgeExecuteAction:R_TRIG;
	RisingEdgeResetAction:R_TRIG;
	RisingEdgeActionDone:R_TRIG;
	RisingEdgeActionNotReady:R_TRIG;
	FallingEdgeActionNotReady:F_TRIG;
	RisingEdgeActionError:R_TRIG;
	RisingEdgeTimeOut:R_TRIG;
	iStepAction:INT;
	xStepActionDone:BOOL;
	xBlockConfirmMessage: BOOL;
	xSetNewPage: BOOL;
	RisingEdgeBtPanelRight:R_TRIG;
	FallingEdgeBtPanelRight:F_TRIG;
	xPreviousPageVertical: BOOL;
	xNextPageVertical: BOOL;
	iTmp: INT;
	RisingEdgeBtPanelLeft: R_TRIG;
	xSetParameterPage: BOOL;
	xSetPreviousPage: BOOL;
	awSaveStateTaskBar: ARRAY [0..4] OF WORD;
	dwSaveActualPageTask:ARRAY [0..4,1..6] OF DWORD;
	aiTempActiveParaListState:ARRAY [0..3,1..6] OF INT;	(* 0=NormalBetrieb,1=EinrichtBetriebA,2=EinrichtBetriebB,3=EinrichtBetriebC; 1=Task1, 2=Task2..6=Task6 *)
	iSaveSetupMode:INT;
	RisingEdgeSpecialLayer: R_TRIG;
	FallingEdgeSpecialLayer: F_TRIG;
	RisingEdgeSetupMode:R_TRIG;
	iTmpSetupMode: INT;
	xForceSetupMode: BOOL;
	xForceNormalOperate: BOOL;
	TONWaitForceChangeOperateMode: TON;
	iTestCounter: INT;
	TONWaitForceChangeSetupMode: TON;
	xForceSetupOperate: BOOL;
	iTestCounter1: INT;
	RisingEdgeBtFunctionPanel: R_TRIG;
	xLampTestOnOff: BOOL;
	xLampTestBlinkOnOff: BOOL;
	xLampTestActive: BOOL;
	xLedControlButtonON: BOOL;
	xLedControlButtonOFF: BOOL;
	xLedControlLampON: BOOL;
	xLedControlLampOFF: BOOL;
	xLedSetupLampON: BOOL;
	xLedSetupLampOFF: BOOL;
	xBlinkLampAcitve: BOOL;
	iStepBlinkLampActive: INT;
	TONWaitChangeState: TON;
	iStepCheckLamp: INT;
	iPtrText: INT;
	sLineNumber: STRING;
	iStepCheckLampNumber: INT;
	iTmpPtrText: INT;
	sCopyTextLinesLampIOEngl:ARRAY [1..18] OF STRING(90);
	sCopyTextLinesLampNIOEngl:ARRAY [1..18] OF STRING(90);
	sCopyTextLinesLampIO:ARRAY [1..18] OF STRING(90);
	sCopyTextLinesLampNIO:ARRAY [1..18] OF STRING(90);
	RisingEdgeCheckLampTestPage: R_TRIG;
	wActivBtRight:WORD;
	wActivBtLeft:WORD;
	xAction_CopyProfileToProcess: BOOL;
	xProfileFileNotFoundSt1: BOOL;
	xWrongProfilNameReadedSt1: BOOL;
	xProfileFileWrongSyntaxSt1: BOOL;
	xProfileFileWrongSyntax: BOOL;
	iToLoadProfileNrSt1: INT;
	sToLoadProfileNameSt1: STRING(30);
	xAction_LoadProfile: BOOL;
	xWrongProfilNameReaded: BOOL;
	xProfileFileNotFoundSt: BOOL;
	iToLoadProfileNrSt: INT;
	sToLoadProfileNameSt: STRING(30);
	xUpdateProfileList: BOOL;
	xAction_SaveNovRAM: BOOL;
	iStepActionNovRam: INT;
(* Pointer auf die Station und HW *)
	ptrActivStation:POINTER TO ST_STATION;
	ptrActivStation_Function1:POINTER TO ST_STATION;
	ptrActivStation_FunctionStop:POINTER TO ST_STATION;
	ptrTAxisZ_St1 : POINTER TO ST_AXIS;								(* Achse für die Hubachse *)
	ptrTAxisS_St1 : POINTER TO ST_AXIS;								(* Achse für die Spindel *)

	ptrTCylToolDeflection_St1				:POINTER TO ST_CYLINDER;	(* Servoventil für das bestimmen der vertikalen Auslenkraft *)
	ptrTSensorTorque_St1 				:POINTER TO ST_CYLINDER;	(* Analoger Sensor für Drehmoment detektion *)
	ptrTCylToolTorqueHC_St1 				:POINTER TO ST_CYLINDER;	(* Drehmomentüberwachung HC *)
	ptrTCylToolTorqueOverload_St1 		:POINTER TO ST_CYLINDER;	(* Drehmomentüberwachung Überlast *)
	ptrTCylBrakeReleaseZAxis_St1 			:POINTER TO ST_CYLINDER;	(* Zylinder für lösen der Bremse bei der Z Achse *)
	ptrTCylWorkpieceClamp				:POINTER TO ST_CYLINDER;	(* Ventil fuer Werkstückfixierzylinder *)
	ptrTValveAirTable						:POINTER TO ST_CYLINDER;	(* Ventil fuer die Luft des Tisches *)
	ptrTValveVacuumTable				:POINTER TO ST_CYLINDER;	(* Ventil fuer Vacuum des Tisches *)
	ptrTValveCleanNozzle					:POINTER TO ST_CYLINDER;	(* Ventil fuer die Reinigungsduese *)

	ptrTCommonAxis : POINTER TO ST_AXIS;
	ptrTCommonAxisActive		: POINTER TO ST_AXIS;
	TCommonTeachParameter:ST_EXCHG_PARAM_TEACHIN;
	ptrTCommonCylinderValve : POINTER TO ST_CYLINDER;
	ptrTCommonCylinderValveTmp : POINTER TO ST_CYLINDER;
	xAction_SaveProfile: BOOL;
	xActionDeleteProfile: BOOL;
(* activ state *)
 	T_TempActiveState:ST_TEMP_ACTIVE_STATE;
	jj: INT;
	fbCompareProfileProcessValue:FB_COMPAREPROFILEPROCESSVALUE;
	RisingEdgePtrProfileListUpDown: R_TRIG;
	iActualActiveProfile: INT;
	bOldChangeStation: BYTE;
	bOldActivStation: BYTE;
	xSetStationParameter: BOOL;
	xUpdateProfileCopyData: BOOL;
	xUpdateStationParameter: BOOL;
	RisingEdgeCheckPasswordPage: R_TRIG;
	FBPassword_SystemLevel: FB_Password_SystemLevel;
	fbGetCpuAccount:GETCPUCOUNTER;
	xChangeRandomValue: BOOL;
	RisingEdgeStandardLevel: R_TRIG;
	xChangeOperatorPassword: BOOL;
	bOldChangeSetupLevel: BYTE;
	xCylValveToggleOnOff: BOOL;
	xAxisStop: BOOL;
	xAxisTogglePower: BOOL;
	xAxisReset: BOOL;
	xAxisMoveAbsolut: BOOL;
	xAxisMoveRelative: BOOL;
	iStepActionRef: INT;
	xAxisTeachPosition: BOOL;
	xBlockSetNovRamAction_End: BOOL;
	xOnlineChange_Z_ForwardSpeedMore: BOOL;
	xOnlineChange_Z_ForwardSpeedLess: BOOL;
	xOnlineChange_Z_BackwardSpeedMore: BOOL;
	xOnlineChange_Z_BackwardSpeedLess: BOOL;
	rTmp: REAL;
	xOnlineChange_Z_BackwardOffsetMore: BOOL;
	xOnlineChange_Z_BackwardOffsetLess: BOOL;
	xOnlineChange_TorqueLevelHCMore: BOOL;
	xOnlineChange_TorqueLevelHCLess: BOOL;
	xOnlineChange_DeflectionForceMore: BOOL;
	xOnlineChange_DeflectionForceLess: BOOL;
	xOnlineChange_S_WorkSpeedMore: BOOL;
	xOnlineChange_S_WorkSpeedLess: BOOL;
	xStationWorkFunction: BOOL;
	iStationFunctionNr: INT;
	xActionProcStation: BOOL;
	xActionProcMachine: BOOL;
	xDeleteErrorList: BOOL;
	xResetErrorWarning: BOOL;
	iSaveStartedVisuFunction_St1St2: INT;
	xStationStop: BOOL;
	xProcStationStop: BOOL;
	xProcMachineStop: BOOL;
	wActivBtPanelRight: WORD;
	wTmp:WORD;
	iStationActive: INT;
	FBGetParameterList: FB_GetParameterList;
	RisingEdgeBtParameterList: R_TRIG;
	xProcessStation1ResetToolChange: BOOL;
	TONWaitReadyStartButton: TON;
	RisingEdgeCheckLampTestPage1: R_TRIG;
	RisingEdgeStartPartQualityPage: R_TRIG;
	iMessageSelected: INT:=1;
	sWrapTextEngl: STRING;
	sWrapTextGer: STRING;
	xOpenMessageWindow: BOOL;
	xCheckVisuFunctionPowerON: BOOL;
	iStepShowMessage: INT:=1;
	iSaveMessage: INT;
	TONWaitShowMessage: TON;
	xJogModeActive: BOOL;
	iStepJogModeActive: INT;
	wSaveBtPanelRight: WORD;
	xTmpJogModeActive: BOOL;
	xProcessAbordet: BOOL;
	FailingEdge_PowerSupply_NormalOperate_St1St2: F_TRIG;
	xDeleteProcessFlag_St1St2: BOOL;
	FailingEdge_PowerSupply_SetupOperateA: F_TRIG;
	xActivateLayer4_St1St2: BOOL;
	FailingEdge_PowerSupply_SetupOperateB: F_TRIG;
	xAxisMoveContinous:BOOL;
	xActivateMessage: BOOL;
	TONForceMessage: TON;
	xTmpProcMachineStop: BOOL;
	iStepActionStop: INT;
	xStepActionDoneStop: BOOL;
	xParameterButtonBlocked: BOOL;
	FBWrapWPQuality: FB_WRAP_WPQUALITY;
	xStationSetupAxisZFunction: BOOL;
	xTmpStationSetupAxisZFunction: BOOL;
	xStationSetupAxisZFunctionToolGuide: BOOL;
	xTmpStationSetupAxisZFunctionToolGuide: BOOL;
	iStepHelpVisuFunction: INT;
	xTmpStepActionDone: BOOL;
	xAxisLimitSwitchActive: BOOL;
	dwSaveVisuPage: DWORD;
	TONWaitCheckQVis: TON;
	iStepCheckQVis: INT;
	xBlockChangeVisuPage: BOOL;
	TONWaitLiftTime: TON;
	rTrigPageChanged	 :R_TRIG;
	iTmpOldPage		:DWORD;
	xNewPageInit: BOOL;
	iTmpSetupAxisSel: INT;
	xTrigAxisSelChanged: BOOL;
	xSetupPotentiometer: BOOL;
	iStepPotentiometer: INT;
	FBLinearization_Potentiometer: FB_Linearization_Potentiometer;
	xActive_Joystick: BOOL;
	xActive_EnableSwitch: BOOL;
	xReferenceState: BOOL;
	xAxisStopAll: BOOL;
	xUpdateHandlingConfig: BOOL;
	FBTeachPosToHMI:FB_TeachPosToHMI;
	rtmpAxisPosZ: REAL;
	FBGetStationFunctionNr: FB_GetStationFunctionNr;
	xInitJogVelocity: BOOL;
	lrJogVelocity: LREAL;
	xResetEnableJoystickAxisZ: BOOL;
	xSetEnableJoystickAxisZ: BOOL;
	RisingEdgeNormalMode: R_TRIG;
	RisingEdgeOperateMode: R_TRIG;
	xTriggerWait: BOOL;
	xProcessEnded: BOOL;
	sTokenString: STRING;
	FallingEdgeBtPanelLeft: F_TRIG;
	wActivBtPanelLeft: WORD;
	xDeleteProcessState: BOOL;
	xMachineDoorUpGuardControlTogOnOff: BOOL;
	xSecurityDoorUpCloseState: BOOL;
	xSecurityDoorUpOpenState: BOOL;
	xCylSetServoAnalogValue: BOOL;
	xCylPressurelessON: BOOL;
	xSpindelCalibrationONOFF: BOOL;
	rTrigButtonSt1: R_TRIG;
	rTrigButtonSt2: R_TRIG;
	rTrigButtonSt3: R_TRIG;
	rTrigButtonSt4: R_TRIG;
	xStationToolCalibrateFunction: BOOL;
	xStationSpindleBurnInFunction: BOOL;
	TONElapsedBurnInTime: TON;
	iCheckStationNr: INT;
	iStationNrReady: INT;
	iProcessFunctNr: INT;
	xStationStopWorkRight: BOOL;
	xSaveTorquePosition: BOOL;
	xSaveTorqueScale: BOOL;
	xTorqueOffsetPlus: BOOL;
	xTorqueOffsetMinus: BOOL;
	xCylTorqueOnOff: BOOL;
	xCylTorqueOverloadOnOff: BOOL;
	rZAxisSetPosition: REAL;
	TONWaitSwitchOffMessage: TON;
	xResetRockerValue: BOOL;
	xZAxisMoveToToolChangePos: BOOL;
	xZAxisMoveToLoadPos: BOOL;
(* Speichern Z EndPos Berechnet *)
	xZSaveEndPosCalc:BOOL;
	rZAxisSelectPosition: REAL;
	xSelectConfigPosition_1: BOOL;
	xSelectConfigPosition_2: BOOL;
	xSelectConfigPosition_3: BOOL;
	xSelectConfigPosition_4: BOOL;
	xSaveConfigPosition: BOOL;
	xConfigPosOnOff: BOOL;
	iSelectConfigPosition: INT;
	RisingEdgeMachineLamp: R_TRIG;
	xEndlessProcessOnOff: BOOL;

	(* .CtrlVisuFunction *)
	xCentringONOFF:BOOL;			(* IGS3 *)
	xOnlyCentringONOFF:BOOL;		(* IGS3 *)
	xSuspensionONOFF:BOOL;			(* IGS3 *)
	xCylWPUnfixONOFF:BOOL;			(* IGS3 *)

	(* .VisuFunction_SpecialFunction *)
	xRegulatorOverlaySave:BOOL;		(* IGS *)
	iTmpSelectedStationAutomat: INT;	(* IGS *)
	RisingEdgeCheckCentringProcess: R_TRIG;
	xRegulatorType1: BOOL;
	xRegulatorType2: BOOL;
	xRegulatorType3: BOOL;
	xSelectZInkWorkInfo: BOOL;
	xSelectZInkCentringInfo: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
ActivateFB;
IF (ABS(T_NovRam.T_Parameter.T_Machine.T_ParamSystem.iMachineNumber) < 10) THEN
	sTokenString:=CONCAT('0',INT_TO_STRING(ABS(T_NovRam.T_Parameter.T_Machine.T_ParamSystem.iMachineNumber)));
ELSIF (ABS(T_NovRam.T_Parameter.T_Machine.T_ParamSystem.iMachineNumber) < 100) THEN
	sTokenString:=INT_TO_STRING(ABS(T_NovRam.T_Parameter.T_Machine.T_ParamSystem.iMachineNumber));
ELSE
	sTokenString:='00';
END_IF;
T_ExchgParam.T_Visu.sQVisVersion:=CONCAT(T_ExchgParam.T_Visu.sSWVersion,sTokenString);
T_ExchgParam.T_Visu.sHWVersion:=CONCAT(T_ExchgParam.T_Visu.sSWVersion,sTokenString);

gxBlockChangeMovementVisuActiveMessage:=	xProcessStation OR xProcessMachine OR xStationSetupAxisZFunction OR xTmpStationSetupAxisZFunction OR xStationSetupAxisZFunctionToolGuide OR xTmpStationSetupAxisZFunctionToolGuide;

(* Exit FB if FB desactiv *)
	IF NOT(xActivFB)  THEN
		RETURN;
	END_IF
ResetVisu;
InitQVis;
(* exit FB if Qvis inactiv *)
IF NOT(T_Visu.T_CtrleVisu.xQvis) THEN RETURN; END_IF
(* Check UPS Power fail *)
IF T_CtrleUPS.xBlockSystem_PowerFail THEN RETURN; END_IF;
(* Monitor dynamic mask for button panel right and function panel *)
IF T_Visu.T_CtrleProcess.xDone OR T_Visu.T_CtrleProcess.xErr THEN
(* Set the standard mask *)
	wMaskBtPanelLeft:=T_ConfigPage.wMaskBtPanelLeft;
	wMaskBtPanelRight:=T_ConfigPage.wMaskBtPanelRight;
	wMaskFunctionPanel:=T_ConfigPage.wMaskFunctionPanel;
(* Set the dynamic mask *)
ELSE	wMaskBtPanelLeft:=T_ConfigPage.wMaskBtPanelLeft AND T_ConfigPage.wMaskProcBtPanelLeft;
		IF (T_ExchgParam.T_Visu.T_Message.iState <> 401) THEN
			wMaskBtPanelRight:=T_ConfigPage.wMaskProcBtPanelRight;
		ELSE
			wMaskBtPanelRight:=T_ConfigPage.wMaskBtPanelRight;	(* Fehler muss quittiert werden können *)
		END_IF;
		wMaskFunctionPanel:=T_ConfigPage.wMaskProcFunctionPanel;
END_IF
(* Update Page configuration *)
IF (T_Visu.T_PlcParam.dwActualPage >= 1) AND (T_Visu.T_PlcParam.dwActualPage <= 999) THEN
	T_ConfigPage:=T_Visu.T_ConfigPage[T_Visu.T_PageIndex[T_Visu.T_PlcParam.dwActualPage].iIndexConfigPage];
END_IF;
(* Config. divers mask *)
T_ExchgParam.T_TouchScreenBtPanel.iNotMaskTextBt
	:=(16#1F XOR wMaskBtPanelLeft) OR (16#3E0 XOR wMaskBtPanelRight);
IF xParameterButtonBlocked THEN
	T_ExchgParam.T_TouchScreenBtPanel.iNotMaskTextBt:=WORD_TO_INT(INT_TO_WORD(T_ExchgParam.T_TouchScreenBtPanel.iNotMaskTextBt) OR 16#10);	(* Falls Zugang zu Parameter gesperrt ist, dann wird die Anzeige für die Parameterebene gesperrt *)
END_IF;
(* management Fn button panel availability *)
T_ExchgParam.T_BtFunctionPanel.wNotMasktext:=16#FFF XOR wMaskFunctionPanel;
(* management navigation panel mask *)
T_ExchgParam.T_TouchScreenNavPanel.wNotMasktext:=T_ConfigPage.wMaskTouchScreenNavPanel;
T_ExchgParam.T_TouchScreenBtPanel.iStateBtLeft:=iFct_GetLeftButtonNumber(dwActualPage:=T_Visu.T_PlcParam.dwActualPage);
IF xFct_GetParameterPageActive(dwActualPage:=T_Visu.T_PlcParam.dwActualPage) THEN
	T_ExchgParam.T_TouchScreenNavPanel.wState:=awSaveStateTaskBar[T_ExchgParam.T_Visu.bActiveSetupMode];
ELSE
	T_ExchgParam.T_TouchScreenNavPanel.wState:=wFct_GetTaskNumber(dwActualPage:=T_Visu.T_PlcParam.dwActualPage);
END_IF;
T_ExchgParam.T_Visu.iHeaderTitlePageNumber:=DWORD_TO_INT(T_Visu.T_PlcParam.dwActualPage);
IF gT_SafetyStatus.xSetupOperateModeActive THEN
	IF (T_ExchgParam.T_TouchScreenBtPanel.iStateBtLeft >= 16) THEN
		T_ExchgParam.T_Visu.bActiveSetupMode:=INT_TO_BYTE(iFct_GetBitNumber(wInputButton:=INT_TO_BYTE(T_ExchgParam.T_TouchScreenBtPanel.iStateBtLeft - 16)));
	ELSE
		T_ExchgParam.T_Visu.bActiveSetupMode:=INT_TO_BYTE(iFct_GetBitNumber(wInputButton:=INT_TO_BYTE(T_ExchgParam.T_TouchScreenBtPanel.iStateBtLeft)));
	END_IF;
ELSE
	T_ExchgParam.T_Visu.bActiveSetupMode:=0;
END_IF;
xFct_SetActualPageTask(	dwActualPage:=T_Visu.T_PlcParam.dwActualPage,
							iTaskBarNumber:=(iFct_GetBitNumber(wInputButton:=T_ExchgParam.T_TouchScreenNavPanel.wState)),
							dwSaveActualPageTask:=dwSaveActualPageTask);
IF T_ExchgParam.T_Config.xNoTouchScreenBtPanel THEN
	wActivBtLeft:=wBtPanel AND 16#1F;
	wActivBtRight:=wBtPanel AND 16#3E0;
ELSE
	wActivBtLeft:=INT_TO_WORD(T_ExchgParam.T_TouchScreenBtPanel.iActivBtLeft);
	wActivBtRight:=INT_TO_WORD(T_ExchgParam.T_TouchScreenBtPanel.iActivBtRight);
END_IF;
TONWaitReadyStartButton(IN:=TRUE,PT:=T#1s);
IF T_StartUp.T_State.xCompleted THEN
	CtrlSetupKeySwitch;
	CtrlSetupOperateModeSwitch;
END_IF;
CheckSecurityDeactivate;
CtrlPanelLeftButton;
CtrlPanelRightButton;
CtrlParaListButton;
CtrlTaskBar;
CtrlFunctionButton;
CtrlStartStopButton;
CtrlSpindleTime;
MaskFunctionButton;
MaskRightButton;
Monitor_FctButton_Led;
UserLevel;
VisuUpdateParameter;
Monitor_Station;
ChangeStation;
Monitor_ActuatorState;
Monitor_Function;
ChangeWPQuality;
ProfileManagement;
CtrlVisuFunction;
VisuFunction_SetNewPageVertical;
VisuFunction_SetNewPage;
VisuFunction_SetParameterPage;
VisuFunction_SetPreviousPage;
VisuFunction_ErrorManagement;
VisuFunction_LampTest;
VisuFunction_MachineLamp;
VisuFunction_SetupPotentiometer;
VisuFunction_SetupTorque;
VisuFunction_SafetyDoor;
VisuFunction_ChangePassword;
VisuFunction_OnlineChange;
VisuFunction_Axis;
VisuFunction_AxisTeach;
VisuFunction_CylinderValve;
VisuFunction_StationStop;
VisuFunction_StationFunction;
VisuFunction_ToolChange;
VisuFunction_ToolCalibration;
VisuFunction_SpindleBurnIn;
VisuFunction_Setup_Z_Axis;
VisuFunction_Setup_Z_Axis_ToolGuide;
VisuFunction_SpecialFunction;
VisuFunction_ProcessState;
VisuFunction_ProcessStop;
VisuFunction_ProcessFunction;
VisuFunction_NovRAM;
VisuFunction_ProfileManagement;
CtrlProcessFunction;
CtrlPreWarning;
ChangeVisuPage;
T_ExchgParam.T_BtFunctionPanel.wActivBt:=0;
IF NOT(xTmpStationSetupAxisZFunction) AND NOT(xTmpStationSetupAxisZFunctionToolGuide) THEN
	gxSetupFunctionActive:=FALSE;
END_IF;
IF NOT(xAxisMoveAbsolut) AND NOT(xZAxisMoveToToolChangePos) AND NOT(xZAxisMoveToLoadPos) THEN
	gxAxisAbsolutMovementActive:=FALSE;
END_IF;

(* IGS wenn eine Overlay MessageBox aktiv ist: xMessageActive setzen *)
T_ExchgParam.T_SafetyCtrl.xMessageActive:=	(T_ExchgParam.T_SafetyCtrl.bStateMessageError<>0)
											OR (T_ExchgParam.T_SafetyCtrl.bStateMessageInfo<>0)
											OR (T_ExchgParam.T_SafetyCtrl.bStateMessagePreWarning<>0)
											OR (T_ExchgParam.T_SafetyCtrl.bStateMessageRequest<>0)
											OR (T_ExchgParam.T_SafetyCtrl.bStateMessageWarning<>0);
END_FUNCTION_BLOCK
ACTION	ActivateFB:
	RisingEdgeActiv(	CLK:=T_Visu.T_CtrleVisu.xActive);
	IF RisingEdgeActiv.Q THEN
		(* call functionblock init. *)
		fbQvisInitPage(	T_Visu:=T_Visu);
		(* Init. variable for visualisation action *)
		T_Visu.T_CtrleAction.xDone:=TRUE;
		T_Visu.T_CtrleAction.xNotReady:=FALSE;
		T_Visu.T_CtrleAction.xErr:=FALSE;
		T_Visu.T_CtrleAction.udiErrorID:=0;
		(* Initialisieren der Pointer der Station und Hardware *)
		ptrActivStation:=ADR(TStation_Work_St1);
		ptrTAxisZ_St1:=ADR(TStation_Work_St1.THWWorkStation.TAxisZ);
		ptrTAxisS_St1:=ADR(TStation_Work_St1.THWWorkStation.TAxisS);

		ptrTSensorTorque_St1						:=ADR(TStation_Work_St1.THWWorkStation.TSensorTorque);
		ptrTCylToolDeflection_St1					:=ADR(TStation_Work_St1.THWWorkStation.TCylToolDeflection);
		ptrTCylBrakeReleaseZAxis_St1 				:=ADR(TStation_Work_St1.THWWorkStation.TCylBrakeReleaseZAxis);

		ptrTCylToolTorqueHC_St1					:=ADR(TStation_Work_St1.THWWorkStation.TCylToolTorqueHC);
		ptrTCylToolTorqueOverload_St1			:=ADR(TStation_Work_St1.THWWorkStation.TCylToolTorqueOverload);
		ptrTCylWorkpieceClamp					:=ADR(TStation_Work_St1.THWWorkStation.TCylWorkpieceClamp);
		ptrTValveAirTable							:=ADR(TStation_Work_St1.THWWorkStation.TValveAirTable);
		ptrTValveVacuumTable					:=ADR(TStation_Work_St1.THWWorkStation.TValveVacuumTable);
		ptrTValveCleanNozzle						:=ADR(TStation_Work_St1.THWWorkStation.TValveCleanNozzle);

		ptrTCommonAxis:=ADR(TStation_Work_St1.THWWorkStation.TAxisZ);
		ptrTCommonAxisActive	:=ADR(TStation_Work_St1.THWWorkStation.TAxisZ);

		ptrTCommonCylinderValve:=ADR(TStation_Work_St1.THWWorkStation.TCylToolDeflection);
		ptrTCommonCylinderValveTmp:=ADR(TStation_Work_St1.THWWorkStation.TCylToolDeflection);

		(* Init. Temporary active state for station 1 to 3 *)
		T_TempActiveState.iActValve_SetupB1_St1:=5;
		T_TempActiveState.iActAxis_SetupB1_St1:=1;
		T_TempActiveState.iActCyl_SetupB1_St1:=1;
		T_TempActiveState.iActCylinderSetup_SetupB1:=2;
		T_TempActiveState.iActiveProfile:=1;
		T_TempActiveState.iPtrListProfile:=1;
		iActualActiveProfile:=-1;
		FOR ii:=1 TO 5 DO
			T_ExchgParam.T_ProfileCommon.T_ProfileList[ii].iNumber:=ii;
			T_ExchgParam.T_ProfileCommon.T_ProfileList[ii].sName:='';
		END_FOR
		(* init. variable *)
		T_ExchgParam.T_FunctionCommon.iFunctionNrMicrohead:=1;
		T_ExchgParam.T_TouchScreenBtPanel.iSelectStationNumber:=1;
		T_ExchgParam.T_StationCommon.bSelectCylinderConfig:=1;
		T_ExchgParam.T_StationCommon.bSelectZAxisProcedure:=1;
		T_ExchgParam.T_StationCommon.iSelectConfigPosition:=1;
		iSelectConfigPosition:=1;
		T_ExchgParam.T_Visu.bActivStation:=1;
		bOldChangeStation:=16#FF;
		bOldChangeSetupLevel:=16#FF;
		bOldActivStation:=1;
		T_ExchgParam.T_Visu.T_Level.iActLevel:=0;
		T_ExchgParam.T_Visu.T_Level.diPwUser:=-1;
		T_ExchgParam.T_Visu.T_Level.diPwOperator:=-1;
		T_ExchgParam.T_Visu.T_Level.diPwSystem:=-1;
		T_ExchgParam.T_StationCommon.xBlockSelectAutoMode:=FALSE;
		TONWaitCheckQVis(IN:=FALSE);
		(* set activation *)
		xActivFB:=TRUE;
		gxSpindelCalibrationONOFF_St1:=TRUE;
		T_ExchgParam.T_StationCommon.bSelectShowIncValue:=0;
	END_IF;
END_ACTION

ACTION	ChangeStation:
IF T_StartUp.T_State.xCompleted THEN
	RisingEdgeNormalMode(CLK:=NOT(gT_SafetyStatus.xSetupOperateModeActive));
	RisingEdgeOperateMode(CLK:=gT_SafetyStatus.xSetupOperateModeActive);
	IF RisingEdgeNormalMode.Q OR RisingEdgeOperateMode.Q THEN
		xSetStationParameter:=TRUE;
	END_IF;
END_IF;
IF xSetStationParameter OR rTrigButtonSt1.Q OR rTrigButtonSt2.Q OR rTrigButtonSt3.Q OR rTrigButtonSt4.Q THEN
	xSetStationParameter:=FALSE;
	(* Update display  list *)
	xUpdateProfileList:=TRUE;
	(* Update display copy data *)
	xUpdateProfileCopyData:=TRUE;
	xUpdateStationParameter:=TRUE;
END_IF;
IF xUpdateStationParameter THEN
	xUpdateStationParameter:=FALSE;
	T_ExchgParam.T_StationCommon.T_Param_Machine.T_ParamSystem:=T_NovRAM.T_Parameter.T_Machine.T_ParamSystem;
	T_ExchgParam.T_StationCommon.T_Param_Machine.adiPotentiometerValue:=T_NovRAM.T_Parameter.T_Machine.adiPotentiometerValue;
	T_ExchgParam.T_StationCommon.T_ToolCounter_St1:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter;
	T_ExchgParam.T_StationCommon.T_WPCounter_St1:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_WPCounter;
	T_ExchgParam.T_StationCommon.T_Param_StationWork:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1];
	IF T_StartUp.T_State.xCompleted THEN
		T_ExchgParam.T_ProfileCommon.T_Id.iNumber:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iProfile;
		T_ExchgParam.T_ProfileCommon.T_Id.sName:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.sProfileName;
	END_IF;
	T_ExchgParam.T_SpindleBurnIn.rTimeActive:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_Fct_SpindleBurnIn.rTimeSpindleActive;
	T_ExchgParam.T_SpindleBurnIn.rTimeInactive:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_Fct_SpindleBurnIn.rTimeSpindleInactive;
	T_ExchgParam.T_SpindleBurnIn.rTimeMaxActiveFunction:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_Fct_SpindleBurnIn.rTimeMaxActiveFunction;
	T_ExchgParam.T_SpindleBurnIn.rSpeed_Axis_S:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_Fct_SpindleBurnIn.rSpindleSpeed;
	CASE T_ExchgParam.bToolSpindleActive OF
	1:	(* Maxon Spindel *)
		T_ExchgParam.T_AnalogSensTorque.rMeasureDistance:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_TorqueSystem.rMeasureDistance;
		T_ExchgParam.T_AnalogSensTorque.rScaleFactor:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_TorqueSystem.rTorqueScaleFactor;
	2,3:	(* Beckhoff Spindel *)
		T_ExchgParam.T_AnalogSensTorque.rMeasureDistance:=0;
		T_ExchgParam.T_AnalogSensTorque.rScaleFactor:=0;
	END_CASE;
	IF (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iHandMode_Parameter)  AND (T_ExchgParam.T_BtParameterList.iEditParam <> 117) AND (T_Visu.T_PlcParam.dwActualPage <> gT_PageNumber.iWorkStation_Axis1) THEN
		T_ExchgParam.T_StationCommon.rPositionEndProcCalc:=garPositionEndProcCalc[1];
		T_ExchgParam.T_StationCommon.rCentringEndProcCalc:=garCentringEndProcCalc[1];
	END_IF;

END_IF;
(*Detect Page changed?*)
rTrigPageChanged(CLK:=iTmpOldPage <>T_Visu.T_PlcParam.dwActualPage);
iTmpOldPage:=T_Visu.T_PlcParam.dwActualPage;

IF rTrigPageChanged.Q THEN
	T_ExchgParam.T_BtFunctionPanel.wState:=0;(*Fxx->inaktiv*)
	xUpdateStationParameter:=TRUE;
	 xNewPageInit:=FALSE;
	xUpdateHandlingConfig:=TRUE;
END_IF
(* Nach Seitenwechsel:  Init Anwahl Achse oder Zylinder und Funktionsauswahl pro EinrichtSeite:*)
CASE T_Visu.T_PlcParam.dwActualPage OF
gT_PageNumber.iWorkStation_Axis1:
	IF rTrigPageChanged.Q THEN
		T_ExchgParam.T_TeachIn.iSetup_AxisSel:=T_TempActiveState.iActAxis_SetupB1_St1;
	END_IF
	IF (T_TempActiveState.iActAxis_SetupB1_St1 <> T_ExchgParam.T_TeachIn.iSetup_AxisSel) THEN
		T_TempActiveState.iActAxis_SetupB1_St1:=T_ExchgParam.T_TeachIn.iSetup_AxisSel;
	END_IF;
	IF (T_ExchgParam.T_TeachIn.iSetup_AxisSel = 2) THEN
		CASE T_ExchgParam.bToolSpindleActive OF
		2,3:	T_ExchgParam.T_TeachIn.iSetup_AxisSel:=3;
		END_CASE;
	END_IF;

gT_PageNumber.iWorkStation_Cylinder1:
	IF rTrigPageChanged.Q THEN
		T_ExchgParam.T_Cylinder.iSelCyl_Setup:=T_TempActiveState.iActCyl_SetupB1_St1;
	END_IF
	IF (T_TempActiveState.iActCyl_SetupB1_St1 <> T_ExchgParam.T_Cylinder.iSelCyl_Setup) THEN
		T_TempActiveState.iActCyl_SetupB1_St1:=T_ExchgParam.T_Cylinder.iSelCyl_Setup;
	END_IF;

gT_PageNumber.iWorkStation_Valve1:
	IF rTrigPageChanged.Q THEN
		T_ExchgParam.T_Cylinder.iSelCyl_Setup:=T_TempActiveState.iActValve_SetupB1_St1;
	END_IF
	IF (T_TempActiveState.iActValve_SetupB1_St1 <> T_ExchgParam.T_Cylinder.iSelCyl_Setup) THEN
		T_TempActiveState.iActValve_SetupB1_St1:=T_ExchgParam.T_Cylinder.iSelCyl_Setup;
	END_IF;

gT_PageNumber.iWorkStation_Setup4:
	IF rTrigPageChanged.Q THEN
		T_ExchgParam.T_Cylinder.iSelCyl_Setup:=T_TempActiveState.iActCylinderSetup_SetupB1;
	END_IF
	IF (T_TempActiveState.iActCylinderSetup_SetupB1 <> T_ExchgParam.T_Cylinder.iSelCyl_Setup) THEN
		T_TempActiveState.iActCylinderSetup_SetupB1:=T_ExchgParam.T_Cylinder.iSelCyl_Setup;
	END_IF;
END_CASE;
(*Check for Axis Selection Change*)
xTrigAxisSelChanged:=iTmpSetupAxisSel <>T_ExchgParam.T_TeachIn.iSetup_AxisSel OR rTrigPageChanged.Q;
iTmpSetupAxisSel:=T_ExchgParam.T_TeachIn.iSetup_AxisSel;
IF xTrigAxisSelChanged THEN (*Init Value at Selection change*)
	T_ExchgParam.T_TeachIn.arAxis[gciAxisZ_St1].rSetPos:=TStation_Work_St1.THWWorkStation.TAxisZ.T_LiveValue.lrActualPosition;
END_IF
(* Zuweisen der Datenstruktur der ausgewählten Achse *)
IF (T_Visu.T_PlcParam.dwActualPage =  gT_PageNumber.iWorkStation_Axis1) THEN
	CASE  T_ExchgParam.T_TeachIn.iSetup_AxisSel   OF
		1:	(*1=Z Achse *)
			ptrTCommonAxis:=ptrTAxisZ_St1;
			TCommonTeachParameter:=gcarAxisConfig[gciAxisZ_St1];
			ptrTCommonAxis^.T_CtrleSingle.xSlowFast:=FALSE;
			ptrTCommonAxis^.T_CtrleSingle.xJogInc:=T_ExchgParam.T_TeachIn.xJogInc_Common_Setup_Axis;
			IF T_ExchgParam.T_TeachIn.arAxis[gciAxisZ_St1].iTeachSelPos = 0 THEN(*eingabe-Wertt*)
				TCommonTeachParameter.rRefPosition:=
				T_ExchgParam.T_TeachIn.arAxis[gciAxisZ_St1].rSetPos ;
			ELSE(*oder gespeicherter Wert, siehe MonitorActuatorState*)
				TCommonTeachParameter.rRefPosition:=
				T_ExchgParam.T_TeachIn.arAxis[gciAxisZ_St1].rTeachPosStored;
			END_IF
		2,3:	(*2 & 3=S Achse *)
			ptrTCommonAxis:=ptrTAxisS_St1;
			TCommonTeachParameter:=gcarAxisConfig[gciAxisS_St1];
			ptrTCommonAxis^.T_CtrleSingle.xSlowFast:=FALSE;
			ptrTCommonAxis^.T_CtrleSingle.xJogInc:=T_ExchgParam.T_TeachIn.xJogInc_Common_Setup_Axis;
			TCommonTeachParameter.rPositionSpeed:=
				T_ExchgParam.T_TeachIn.arAxis[gciAxisS_St1].rSetSpeed;
	END_CASE
END_IF;

(* Zuweisen der Datenstruktur der ausgewählten Zylinder oder Ventile *)
IF (T_Visu.T_PlcParam.dwActualPage =  gT_PageNumber.iWorkStation_Cylinder1) OR
    (T_Visu.T_PlcParam.dwActualPage =  gT_PageNumber.iWorkStation_Valve1) OR
    (T_Visu.T_PlcParam.dwActualPage =  gT_PageNumber.iWorkStation_Setup4) THEN
	CASE  T_ExchgParam.T_Cylinder.iSelCyl_Setup   OF
(*
01	Zylinder-->Wz Auslenkung
02	Zylinder-->Wz Drehmoment HC
03	Zylinder-->Wz Drehmoment Überl.
04	Zylinder-->Bremse Z Achse
05	Zylinder-->Wstk Spannung
06	Ventil-->Luft Tisch
07	Ventil-->Vakuum Tisch*)
		1:	ptrTCommonCylinderValve:=ptrTCylToolDeflection_St1;
		2:	ptrTCommonCylinderValve:=ptrTCylToolTorqueHC_St1;
		3:	ptrTCommonCylinderValve:=ptrTCylToolTorqueOverload_St1;
		4:	ptrTCommonCylinderValve:=ptrTCylBrakeReleaseZAxis_St1;
		5:	ptrTCommonCylinderValve:=ptrTCylWorkpieceClamp;
		6:	ptrTCommonCylinderValve:=ptrTValveAirTable;
		7:	ptrTCommonCylinderValve:=ptrTValveVacuumTable;
		8:	ptrTCommonCylinderValve:=ptrTValveCleanNozzle;
	END_CASE
END_IF

IF T_StartUp.T_State.xCompleted THEN
	T_ExchgParam.T_StationCommon.T_Param_StationWork.T_InfoProcess:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess;
	T_ExchgParam.T_TeachIn.arAxisCommon.rActPos:=										TStation_Work_St1.THWWorkStation.TAxisZ.T_LiveValue.lrActualPosition;
	T_ExchgParam.T_TeachIn.arAxisCommon.rActSpeed:=										TStation_Work_St1.THWWorkStation.TAxisZ.T_LiveValue.lrActualVelocity;
	T_ExchgParam.T_TeachIn.rAxisSSpeedCommon:=											TStation_Work_St1.THWWorkStation.TAxisS.T_LiveValue.lrActualVelocity;

	IF NOT(xSecurityKey) THEN
		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_InfoProcess:=						T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess;
		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_InfoProcess.iHCTorquePos:=		TStation_Work_St1.THWWorkStation.TCtrlWork.iHCTorquePos;
		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_InfoProcess.iHCDeflectionPos:=		TStation_Work_St1.THWWorkStation.TCtrlWork.iHCDeflectionPos;

		IF NOT(xFct_GetParameterPageActive(dwActualPage:=T_Visu.T_PlcParam.dwActualPage)) THEN
			T_ExchgParam.T_StationCommon.T_Param_StationWork.T_WPCounter:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_WPCounter;
			T_ExchgParam.T_StationCommon.T_Param_StationWork.T_ToolCounter:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter;
		END_IF;
	END_IF;
END_IF;
END_ACTION

ACTION	ChangeVisuPage:
(* waiting for changing page *)
	RisingEdgeExecute(CLK:=T_Visu.T_CtrleVisu.xExecute);
	IF RisingEdgeExecute.Q THEN
		iStepCount:=iStepCount + 1;
		CASE T_Visu.T_CtrleVisu.iFunction OF
		(* change page *)
		1:	xChangePage:=TRUE;
			dwInCount_QVisCmd:=T_CtrleQVis.dwInCount;
		ELSE
		(* function not implemented *)
			T_Visu.T_CtrleVisu.xDone:=FALSE;
			T_Visu.T_CtrleVisu.xErr:=TRUE;
			T_Visu.T_CtrleVisu.udiErrorID:=16#F000;
		END_CASE
		(* Init. variable *)
		T_Visu.T_CtrleVisu.xDone:=FALSE;
		T_Visu.T_CtrleVisu.xErr:=FALSE;
		T_Visu.T_CtrleVisu.udiErrorID:=0;
		(* exit FB *)
		RETURN;
	END_IF

(* waiting for changing page from the PLC *)
	IF xChangePage AND NOT(xBlockChangeVisuPage) THEN
		IF dwInCount_QVisCmd = T_CtrleQVis.dwInCount THEN
			(* Init. command *)
			T_CtrleQVis.dwInCommand:=1;
			T_CtrleQVis.dwInQVisCtrlAddress:=ADR(T_CtrleQVis);
			T_CtrleQVis.dwInParameterAddress:=ADR(T_Visu.T_PlcParam.dwSetNewPage);
			(* start command *)
			T_CtrleQVis.dwInCount:=T_CtrleQVis.dwInCount+1;
		ELSE
			IF T_CtrleQVis.dwInCount = T_CtrleQVis.dwOutCount THEN
			(* command done *)
				T_Visu.T_CtrleVisu.xExecute:=FALSE;
				IF T_CtrleQVis.diOutStatus = 0 THEN
				(* command done without error *)
					T_Visu.T_CtrleVisu.xDone:=TRUE;
					T_Visu.T_CtrleVisu.xErr:=FALSE;
					T_Visu.T_CtrleVisu.udiErrorID:=0;
					T_Visu.T_PlcParam.dwPreviousPage:=T_Visu.T_PlcParam.dwActualPage;
					T_Visu.T_PlcParam.dwActualPage:=T_Visu.T_PlcParam.dwSetNewPage;
					T_ExchgParam.T_Visu.T_Message.iState:=0;
				ELSE
				(* command done with error *)
					T_Visu.T_CtrleVisu.xDone:=FALSE;
					T_Visu.T_CtrleVisu.xErr:=TRUE;
					T_Visu.T_CtrleVisu.udiErrorID:=16#F400 + DINT_TO_UDINT(T_CtrleQVis.diOutStatus);
				END_IF
				(* reset variable 'xChangePage' *)
				xChangePage:=FALSE;
			END_IF
		END_IF
	END_IF
END_ACTION

ACTION	ChangeWPQuality:
RisingEdgeStartPartQualityPage(CLK:=(T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iAutoMode_PartQuality));
IF (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iAutoMode_PartQuality) THEN

(* Auswahl des Wstk für die Analyse *)
(* Part Quality *)


	IF T_ExchgParam.T_StationCommon.T_Button_Quality_Backward.xActive THEN
		T_ExchgParam.T_StationCommon.T_Button_Quality_Backward.xActive:=FALSE;
		T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInput1:=T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInput1 - 1;
		IF (T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInput1 < T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiNumberHole[1]) THEN
			T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInput1:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiNumberHole[1];
		END_IF;
	END_IF;
	IF T_ExchgParam.T_StationCommon.T_Button_Quality_Forward.xActive THEN
		T_ExchgParam.T_StationCommon.T_Button_Quality_Forward.xActive:=FALSE;
		T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInput1:=T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInput1 + 1;
		IF (T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInput1 > T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiNumberHole[ciMaxWP]) THEN
			T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInput1:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiNumberHole[ciMaxWP];
		END_IF;
	END_IF;

	IF (T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInput1 = 0) THEN
		T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInput1:=1;
	END_IF;
	T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.xChangeColour:=FALSE;
	T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.xDisable:=FALSE;
	T_ExchgParam.T_StationCommon.T_Button_Quality_Backward.xDisable:=FALSE;
	T_ExchgParam.T_StationCommon.T_Button_Quality_Forward.xDisable:=FALSE;

	T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInputMin:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiNumberHole[1];
	T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInputMax:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].adiNumberHole[ciMaxWP];

	IF (T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInput1 < T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInputMin) THEN
		T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInput1:=T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInputMin;
	END_IF;
	IF (T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInput1 > T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInputMax) THEN
		T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInput1:=T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInputMax;
	END_IF;

	FBWrapWPQuality(	diHoleNumber:= T_ExchgParam.T_StationCommon.T_Input_Quality_HoleNumber.diInput1,
						T_PartAnalysis:= T_NovRAM.T_Parameter.T_PartAnalysis[gciStationSt1]);

(* Ausgabe der Parameter für die Part Analysis *)
	T_ExchgParam.T_PartQuality.bPartQualityStation:=FBWrapWPQuality.T_DataOut.bHole_WorkPartQuality;
	T_ExchgParam.T_PartQuality.rActualFirstHCPositionStation:=FBWrapWPQuality.T_DataOut.rHole_FirstHC;
	T_ExchgParam.T_PartQuality.iHCCounterStation:=FBWrapWPQuality.T_DataOut.iHole_HCCounter;
	T_ExchgParam.T_PartQuality.iHCCounterCenteringStation:=FBWrapWPQuality.T_DataOut.iHole_HCCounterCentering;
	T_ExchgParam.T_PartQuality.iHCCounterTorqueStation:=FBWrapWPQuality.T_DataOut.iHole_HCCounterTorque;
	T_ExchgParam.T_PartQuality.iHCCounterSpeedStation:=FBWrapWPQuality.T_DataOut.iHole_HCCounterSpeed;
	T_ExchgParam.T_PartQuality.tCycleTimeStation:=DINT_TO_TIME(FBWrapWPQuality.T_DataOut.diHole_CycleTime);
	T_ExchgParam.T_PartQuality.tWorkTimeStation:=DINT_TO_TIME(FBWrapWPQuality.T_DataOut.diHole_WorkTime);
	T_ExchgParam.T_PartQuality.bInfeedCounterZ:=FBWrapWPQuality.T_DataOut.bHole_InfeedCounterZ;
END_IF;

END_ACTION

ACTION	CheckSecurityDeactivate:
IF xActivateLayer4_St1St2 THEN
	xActivateLayer4_St1St2:=FALSE;
	TProcess.T_Ctrle.xEnable:=TRUE;
END_IF;

FailingEdge_PowerSupply_NormalOperate_St1St2(CLK:=gT_SafetyStatus.xEnergyONNormalMode AND NOT(xSecurityKey));
IF FailingEdge_PowerSupply_NormalOperate_St1St2.Q THEN
	gxWP_Analyse_ActiveWork:=FALSE;
	gxWP_Analyse_ActiveInfeed:=FALSE;
	gxWP_Analyse_ActiveCentering:=FALSE;
	IF (NOT(TProcess.T_Ctrle.xDone) AND NOT(TProcess.T_Ctrle.xError)) OR NOT(T_Visu.T_CtrleProcess.xDone) THEN
		TProcess.T_Ctrle.xEnable:=FALSE;
		T_Visu.T_CtrleProcess.xReset:=TRUE;
		RisingEdgeReseTProcess(CLK:=FALSE);
		T_Visu.T_CtrleAction.xDeleteVisuFunction:=TRUE;
		T_StartUp.T_Ctrle.xDeleteAllMessageOverlay:=TRUE;
		T_Visu.T_CtrleAction.xFunctionActive:=FALSE;
		T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
		xActivateLayer4_St1St2:=TRUE;
		xDeleteProcessFlag_St1St2:=TRUE;
		xActivateMessage:=TRUE;
		IF NOT(TProcess.T_Ctrle.xDone) AND NOT(TProcess.T_Ctrle.xError) AND T_StartUp.T_State.xCompleted THEN
			xProcessEnded:=TRUE;
		END_IF;
	ELSE
		xActivateMessage:=TRUE;
	END_IF;
END_IF;

FailingEdge_PowerSupply_SetupOperateA(CLK:=	(gT_SafetyStatus.xEnergyONSetupModeASt1) AND xSecurityKey AND (iSetupMode = 1));
IF FailingEdge_PowerSupply_SetupOperateA.Q THEN
	gxWP_Analyse_ActiveWork:=FALSE;
	gxWP_Analyse_ActiveInfeed:=FALSE;
	gxWP_Analyse_ActiveCentering:=FALSE;
	IF ((NOT(TProcess.T_Ctrle.xDone) AND NOT(TProcess.T_Ctrle.xError)) OR NOT(T_Visu.T_CtrleProcess.xDone)) THEN
		IF NOT(T_ExchgParam.T_SafetyCtrl.xSetupOperateA_EnergyON) THEN
			TProcess.T_Ctrle.xEnable:=FALSE;
			T_Visu.T_CtrleProcess.xReset:=TRUE;
			RisingEdgeReseTProcess(CLK:=FALSE);
			T_Visu.T_CtrleAction.xDeleteVisuFunction:=TRUE;
			T_StartUp.T_Ctrle.xDeleteAllMessageOverlay:=TRUE;
			T_Visu.T_CtrleAction.xFunctionActive:=FALSE;
			T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
			xActivateLayer4_St1St2:=TRUE;
			xDeleteProcessFlag_St1St2:=TRUE;
		END_IF;
		xActivateMessage:=TRUE;
	ELSE
		xActivateMessage:=TRUE;
	END_IF;
END_IF;

FailingEdge_PowerSupply_SetupOperateB(CLK:=	(gT_SafetyStatus.xEnergyONSetupModeBSt1) AND xSecurityKey AND (iSetupMode = 2));
IF FailingEdge_PowerSupply_SetupOperateB.Q THEN
	gxWP_Analyse_ActiveWork:=FALSE;
	gxWP_Analyse_ActiveInfeed:=FALSE;
	gxWP_Analyse_ActiveCentering:=FALSE;
	T_Visu.T_CtrleAction.xDeleteVisuFunction:=TRUE;
	T_StartUp.T_Ctrle.xDeleteAllMessageOverlay:=TRUE;
	T_Visu.T_CtrleAction.xFunctionActive:=FALSE;
	T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
	xActivateMessage:=TRUE;
END_IF;

IF xActivateMessage AND T_StartUp.T_State.xCompleted THEN
	TONForceMessage(IN:=TRUE,PT:=T#1s);
	IF (T_ExchgParam.T_Visu.T_Message.iState <> 228) AND (T_ExchgParam.T_Visu.T_Message.iState <> 401) AND
	     NOT((T_ExchgParam.T_Visu.T_Message.iState >= 310) AND (T_ExchgParam.T_Visu.T_Message.iState <= 314)) THEN
		T_ExchgParam.T_Visu.T_Message.iState:=279;	(* Warnung: Sicherheitskreis angesprochen ! *)
	END_IF;
	IF TONForceMessage.Q THEN
		IF NOT(gT_SafetyStatus.xEnergyONNormalMode) THEN
			T_ExchgParam.T_SafetyCtrl.xOpenSecurityDoorMachine:=TRUE;
		END_IF;
		TONForceMessage(IN:=FALSE);
		xActivateMessage:=FALSE;
	END_IF;
ELSE
	TONForceMessage(IN:=FALSE);
	xActivateMessage:=FALSE;
END_IF;

IF xDeleteProcessFlag_St1St2 THEN
	xDeleteProcessFlag_St1St2:=FALSE;
	TProcess.T_Ctrle.xAbordProcess:=FALSE;
	TProcess.T_Ctrle.xStop:=FALSE;
END_IF;
END_ACTION

ACTION	CtrlFunctionButton:
(* Bt Function Button *)
	xTmp:=	NOT(xChangePage)
			AND T_Visu.T_CtrleAction.xDone
			AND NOT(T_Visu.T_CtrleAction.xExecute);
	IF (wForceMaskFunctionPanel <> 0) THEN
		(* Wurde von einer Funktion überschrieben *)
		T_ConfigPage.wMaskFunctionPanel:=wForceMaskFunctionPanel;
		T_ConfigPage.wMaskProcFunctionPanel:=wForceMaskFunctionPanel;
		wMaskFunctionPanel:=wForceMaskFunctionPanel;
		wForceMaskFunctionPanel:=0;
	END_IF;
	FOR ii:=1 TO 12 DO
		IF (aiForceRTrigActionFunctionPanel[ii] <> 0) THEN
			(* Wurde von einer Funktion überschrieben *)
			T_ConfigPage.aiRTrigActionFunctionPanel:=aiForceRTrigActionFunctionPanel;
			EXIT;
		END_IF;
	END_FOR;
	aiForceRTrigActionFunctionPanel:=aiDelectRTrigActionFunctionPanel;
	RisingEdgeBtFunctionPanel(CLK:=	(T_ExchgParam.T_BtFunctionPanel.wActivBt
									AND wMaskFunctionPanel) <> 16#0);
	IF xTmp THEN
		(* check if more than one button is pressed-->if only one Button than start the procedure *)
		IF xFct_CheckSingleButtonActivation(wInputButton:=T_ExchgParam.T_BtFunctionPanel.wActivBt) THEN
		(* activ action of rising edge *)
			IF RisingEdgeBtFunctionPanel.Q AND NOT(xTriggerWait) THEN
				ii:=iFct_GetBitNumber(wInputButton:=T_ExchgParam.T_BtFunctionPanel.wActivBt);
				IF (T_ConfigPage.aiRTrigActionFunctionPanel[ii] <> 0) THEN
					T_Visu.T_CtrleAction.iFunction:=T_ConfigPage.aiRTrigActionFunctionPanel[ii];
					T_Visu.T_CtrleAction.xExecute:=TRUE;
				END_IF;
			END_IF;
		END_IF;
	END_IF
END_ACTION

ACTION	CtrlPanelLeftButton:
(* Bt Panel left *)
	xTmp:=	NOT(xChangePage)
			AND T_Visu.T_CtrleAction.xDone
			AND NOT(T_Visu.T_CtrleAction.xExecute)
			AND NOT(T_StartUp.T_State.xBlockChangeMovementVisu)
			AND NOT(T_Visu.T_CtrleAction.xFunctionActive)
			AND (T_ExchgParam.T_Visu.T_Message.iState <> 401)
			AND ((T_ExchgParam.T_Visu.bMachineState AND 16#2) <> 16#2);
	xParameterButtonBlocked:=NOT(xTmp);
	RisingEdgeBtPanelLeft(CLK:=		(wActivBtLeft
									AND wMaskBtPanelLeft) <> 16#0);

	FallingEdgeBtPanelLeft(CLK:=		(wActivBtLeft
									AND wMaskBtPanelLeft) <> 16#0);
	IF RisingEdgeBtPanelLeft.Q THEN
		wActivBtPanelLeft:=wActivBtLeft;
	END_IF;
	IF xTmp THEN
		(* check if more than one button is pressed-->if only one Button than start the procedure *)
		IF xFct_CheckSingleButtonActivation(wInputButton:=wActivBtPanelLeft) THEN
		(* activ action of rising edge *)
			IF RisingEdgeBtPanelLeft.Q THEN
				ii:=iFct_GetBitNumber(wInputButton:=wActivBtPanelLeft);
				IF (T_ConfigPage.aiRTrigActionPanelLeft[ii] <> 0) THEN
					T_Visu.T_CtrleAction.iFunction:=T_ConfigPage.aiRTrigActionPanelLeft[ii];
					T_Visu.T_CtrleAction.xExecute:=TRUE;
				END_IF;
			END_IF;
		END_IF;
	END_IF

(* Aktivierungsanzeige für Maschinen Lampe *)
	IF TMachineLamp.T_CtrleCyl.T_Standard.xActivOn THEN
		T_ExchgParam.T_TouchScreenBtPanel.iStateSetupLamp:=1;
	ELSE
		T_ExchgParam.T_TouchScreenBtPanel.iStateSetupLamp:=0;
	END_IF;

(* Auswahl der Seiten über die Recht Sondertasten *)
T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=0;
CASE T_Visu.T_PlcParam.dwActualPage OF
(* NormalMode	Task 1 *)
gT_PageNumber.iAutoMode_Process:				T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#20;
gT_PageNumber.iAutoMode_ProcessValue1:			T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#40;		(* IGS *)
gT_PageNumber.iAutoMode_ProcessValue2:			T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#80;		(* IGS *)
gT_PageNumber.iAutoMode_PartQuality:				T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#100;		(* alt 80 *)
(* NormalMode	Task 4 *)
gT_PageNumber.iAutoMode_ToolChange:			T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#20;
gT_PageNumber.iAutoMode_UserLevel:				T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#40;
gT_PageNumber.iAutoMode_Language:				T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#80;
(* NormalMode	Task 5 *)
gT_PageNumber.iAutoMode_WPCounter:				T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#20;
gT_PageNumber.iAutoMode_LampTest:				T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#40;
gT_PageNumber.iAutoMode_SafetyCheck:			T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#80;
gT_PageNumber.iAutoMode_SysInfo:				T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#100;

(* SetupMode A	Task 1 *)
gT_PageNumber.iHandMode_Process:				T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#20;
gT_PageNumber.iHandMode_WorkParameter:		T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#40;
gT_PageNumber.iHandMode_RegulatorPara:			T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#80;
gT_PageNumber.iHandMode_OnlineChange:			T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#100;	(* alt 40 *)
gT_PageNumber.iHandMode_ConfigPosition:			T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#200;	(* alt 80 *)

(* SetupMode B	Task 5 *)
gT_PageNumber.iWorkStation_Setup1:				T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#20;
gT_PageNumber.iWorkStation_Setup2:				T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#40;
gT_PageNumber.iWorkStation_Setup3:				T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#80;
gT_PageNumber.iWorkStation_Setup4:				T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#100;
gT_PageNumber.iWorkStation_Setup5:				T_ExchgParam.T_TouchScreenBtPanel.iStateButtonPage:=16#200;
END_CASE;
END_ACTION

ACTION	CtrlPanelRightButton:
(* Bt Panel right *)
	xTmp:=	NOT(xChangePage)
			AND T_Visu.T_CtrleAction.xDone
			AND NOT(T_Visu.T_CtrleAction.xExecute);
	IF (wForceMaskBtPanelRight <> 0) THEN
		(* Wurde von einer Funktion überschrieben *)
		T_ConfigPage.wMaskBtPanelRight:=wForceMaskBtPanelRight;
		T_ConfigPage.wMaskProcBtPanelRight:=wForceMaskBtPanelRight;
		wMaskBtPanelRight:=wForceMaskBtPanelRight;
		wForceMaskBtPanelRight:=0;
	END_IF;
	FOR ii:=1 TO 5 DO
		IF (aiForceRTrigActionPanelRight[ii] <> 0) THEN
			(* Wurde von einer Funktion überschrieben *)
			T_ConfigPage.aiRTrigActionPanelRight:=aiForceRTrigActionPanelRight;
			EXIT;
		END_IF;
	END_FOR;
	aiForceRTrigActionPanelRight:=aiDeleteRTrigActionPanelRight;

	xActive_Joystick:=			IxJoystick_X_Plus OR IxJoystick_X_Minus OR IxJoystick_Y_Plus OR IxJoystick_Y_Minus;
	xActive_EnableSwitch:=		IxEnablingSwitchPlusButton OR IxEnablingSwitchMinusButton;

	IF (wActivBtRight = 0) AND NOT(xActive_EnableSwitch) THEN
		(* Achsenbewegung mit dem Joystick *)
		IF IxJoystick_Y_Plus AND NOT(IxJoystick_Y_Minus) AND gxEnable_Joystick_Axis_Z THEN
			wActivBtRight:=16#40;
			T_ConfigPage.aiRTrigActionPanelRight[2]:=216;
			wMaskBtPanelRight:=wActivBtRight;
		END_IF;
		IF NOT(IxJoystick_Y_Plus) AND IxJoystick_Y_Minus AND gxEnable_Joystick_Axis_Z THEN
			wActivBtRight:=16#20;
			T_ConfigPage.aiRTrigActionPanelRight[1]:=217;
			wMaskBtPanelRight:=wActivBtRight;
		END_IF;
		IF (IxJoystick_Y_Plus OR IxJoystick_Y_Minus) AND NOT(gxEnable_Joystick_Axis_Z) AND (T_ExchgParam.T_Visu.T_Message.iState <> 401) THEN
			T_ExchgParam.T_Visu.T_Message.iState:=306;	(* Warnung: Z Achse darf auf dieser Seite nicht verfahren werden ! *)
		END_IF;
	END_IF;

	IF (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iWorkStation_Axis1) THEN
		gxReleaseEnableSwitch:=TRUE;
	ELSE
		gxReleaseEnableSwitch:=FALSE;
	END_IF;

	IF gxReleaseEnableSwitch AND (wActivBtRight = 0) AND NOT(xActive_Joystick) AND gT_SafetyStatus.xSecurityDoorOpen THEN
		(* Achsenbewegung mit dem Zustimmschalter *)
		IF IxEnablingSwitchPlusButton AND NOT(IxEnablingSwitchMinusButton) THEN
			wActivBtRight:=16#40;
			T_ConfigPage.aiRTrigActionPanelRight[2]:=216;
		END_IF;
		IF NOT(IxEnablingSwitchPlusButton) AND IxEnablingSwitchMinusButton THEN
			wActivBtRight:=16#20;
			T_ConfigPage.aiRTrigActionPanelRight[1]:=217;
		END_IF;
	END_IF;

	RisingEdgeBtPanelRight(CLK:=		(wActivBtRight
									AND wMaskBtPanelRight) <> 16#0);
	FallingEdgeBtPanelRight(CLK:=		(wActivBtRight
									AND wMaskBtPanelRight) <> 16#0);
	IF xTmp THEN
		(* check if more than one button is pressed-->if only one Button than start the procedure *)
		IF xFct_CheckSingleButtonActivation(wInputButton:=wActivBtRight) THEN
		(* activ action of rising edge *)
			IF RisingEdgeBtPanelRight.Q THEN
				ii:=iFct_GetBitNumber(wInputButton:=wActivBtRight) - 5;
				wActivBtPanelRight:=INT_TO_WORD(ii);
				IF (T_ConfigPage.aiRTrigActionPanelRight[ii] <> 0) THEN
					T_Visu.T_CtrleAction.iFunction:=T_ConfigPage.aiRTrigActionPanelRight[ii];
					T_Visu.T_CtrleAction.xExecute:=TRUE;
					xJogModeActive:=xFct_GetJogMode(iFunction:=T_Visu.T_CtrleAction.iFunction);
					wSaveBtPanelRight:=wActivBtRight;
				END_IF;
			END_IF;
		END_IF;
		(* activ action of failling edge *)
		IF FallingEdgeBtPanelRight.Q THEN
			ii:=WORD_TO_INT(wActivBtPanelRight);
			IF (T_ConfigPage.aiFTrigActionPanelRight[ii] <> 0) THEN
				T_Visu.T_CtrleAction.iFunction:=T_ConfigPage.aiFTrigActionPanelRight[ii];
				T_Visu.T_CtrleAction.xExecute:=TRUE;
			END_IF;
		END_IF;
	END_IF

(* Überprüfe wenn Jog Betrieb gestartet ist, dass wenn die Taste nicht mehr gedrückt ist, dass die Achse auch gestoppt wird-->Falls nicht, dann muss es explizit gestoppt werden *)
	IF xJogModeActive OR xTmpJogModeActive THEN
		CASE iStepJogModeActive OF
		1:	IF NOT(xInitJogVelocity) THEN
				xInitJogVelocity:=TRUE;
				lrJogVelocity:=T_ExchgParam.T_TeachIn.arTeachSelVel[ptrTCommonAxisActive^.T_Config_Gen.iTyp];
			END_IF;
			xJogModeActive:=FALSE;
			xTmpJogModeActive:=TRUE;
			IF ((wSaveBtPanelRight AND wActivBtRight) = 16#0) THEN
				(* Taste wurde losgelassen *)
				iStepJogModeActive:=iStepJogModeActive + 1;
				RETURN;
			END_IF;
			IF T_ExchgParam.T_TeachIn.xJogInc_Common_Setup_Axis AND (lrJogVelocity <> T_ExchgParam.T_TeachIn.arTeachSelVel[ptrTCommonAxisActive^.T_Config_Gen.iTyp]) THEN
				lrJogVelocity:=T_ExchgParam.T_TeachIn.arTeachSelVel[ptrTCommonAxisActive^.T_Config_Gen.iTyp];
				(* Jog-Betrieb ist ausgewählt-->Geschwindigkeit in Abhängigkeit des Poti einstellen *)
				IF NOT(ptrTCommonAxisActive^.T_CtrleSingle.xExecute) AND ptrTCommonAxisActive^.T_CtrleSingle.xDone AND
				     NOT(ptrTCommonAxisActive^.T_CtrleSingle.xErr) AND NOT(ptrTCommonAxisActive^.T_CtrleSingle.xNotMoving) THEN
					ptrTCommonAxisActive^.T_CtrleSingle.iFunction:=12;
					gxSetSpeedInMovement:=TRUE;
					IF ptrTCommonAxisActive^.T_CtrleSingle.xMovingForward THEN
						ptrTCommonAxisActive^.T_CtrleSingle.lrVelocity:=T_ExchgParam.T_TeachIn.arTeachSelVel[ptrTCommonAxisActive^.T_Config_Gen.iTyp];
					ELSE
						ptrTCommonAxisActive^.T_CtrleSingle.lrVelocity:=T_ExchgParam.T_TeachIn.arTeachSelVel[ptrTCommonAxisActive^.T_Config_Gen.iTyp]*-1.0;
					END_IF;
					ptrTCommonAxisActive^.T_CtrleSingle.xExecute:=TRUE;
				END_IF;
			END_IF;
		2:	IF ((ptrTCommonAxisActive^.T_CtrleSingle.iFunction = 6) OR (ptrTCommonAxisActive^.T_CtrleSingle.iFunction = 12)) AND NOT(ptrTCommonAxisActive^.T_CtrleSingle.xNotMoving) AND NOT(xJogModeActive) THEN
				T_Visu.T_CtrleAction.iFunction:=202;	(* Stoppen aller Achse *)
				T_Visu.T_CtrleAction.xExecute:=TRUE;
				xTmpJogModeActive:=FALSE;
				iStepJogModeActive:=1;
			END_IF
			IF (ptrTCommonAxisActive^.T_CtrleSingle.iFunction <> 6) AND (ptrTCommonAxisActive^.T_CtrleSingle.iFunction <> 12) AND NOT(xJogModeActive) THEN
				(* Es wurde ein Inkrementfahrt ausgelöst und daher muss es nicht explizit gestoppt werden *)
				xTmpJogModeActive:=FALSE;
				iStepJogModeActive:=1;
			END_IF;
			IF xJogModeActive THEN
				iStepJogModeActive:=1;	(* Jog wurde vor dem beenden wieder gestartet, daher muss es wieder überprüft werden *)
				xInitJogVelocity:=FALSE;
			END_IF;
		END_CASE;
	ELSE
		iStepJogModeActive:=1;
		xInitJogVelocity:=FALSE;
	END_IF;

(* Verwaltung der Freigabe für den Joystick *)
	IF NOT(T_StartUp.T_State.xCompleted) THEN
		(* Solange die Maschine nicht aufgestartet ist, ist die manuelle Achsenbewegung nicht erlaubt *)
		xResetEnableJoystickAxisZ:=TRUE;
		xSetEnableJoystickAxisZ:=FALSE;
	ELSIF NOT(gT_SafetyStatus.xSetupOperateModeActive) THEN
		(* Im NormalBetrieb ist die manuelle Achsenbewegung nicht erlaubt *)
		xResetEnableJoystickAxisZ:=TRUE;
		xSetEnableJoystickAxisZ:=FALSE;
	ELSIF gT_SafetyStatus.xSetupOperateModeActive AND (gT_SafetyStatus.iSetupMode = 1) THEN
		(* Im EinrichtBetrieb A ist die manuelle Achsenbewegung nur unter dem Task HandBetrieb erlaubt *)
		xResetEnableJoystickAxisZ:=TRUE;
		xSetEnableJoystickAxisZ:=FALSE;
		IF TStation_Work_St1.TControl.xEnable AND TStation_Work_St1.TControl.xRdy AND TStation_Work_St1.TControl.xDone AND NOT(TStation_Work_St1.TControl.xError) THEN
			IF (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iHandMode_Process)
			OR (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iHandMode_WorkParameter) OR (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iHandMode_RegulatorPara)
			OR (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iHandMode_OnlineChange) OR (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iHandMode_ConfigPosition) THEN
				xResetEnableJoystickAxisZ:=FALSE;
				xSetEnableJoystickAxisZ:=TRUE;
			END_IF;
		END_IF;
	ELSIF gT_SafetyStatus.xSetupOperateModeActive AND (gT_SafetyStatus.iSetupMode = 2) THEN
		(* Im EinrichtBetrieb B ist die manuelle Achsenbewegung erlaubt sofern nicht eine Funktion am ausführen ist *)
		IF NOT(TStation_Work_St1.TControl.xEnable) OR NOT(TStation_Work_St1.TControl.xRdy) OR NOT(TStation_Work_St1.TControl.xDone) OR  TStation_Work_St1.TControl.xError THEN
			xResetEnableJoystickAxisZ:=TRUE;
			xSetEnableJoystickAxisZ:=FALSE;
		ELSE
			xResetEnableJoystickAxisZ:=FALSE;
			xSetEnableJoystickAxisZ:=TRUE;
		END_IF;
		IF xTmpStationSetupAxisZFunction AND (T_ExchgParam.T_StationCommon.iZAxisFirstSetup_ShowObjectNr = 3) THEN
			xResetEnableJoystickAxisZ:=FALSE;
			xSetEnableJoystickAxisZ:=TRUE;
		END_IF;
		IF xTmpStationSetupAxisZFunction AND (T_ExchgParam.T_StationCommon.iZAxisFirstSetup_ShowObjectNr <> 3) THEN
			xResetEnableJoystickAxisZ:=TRUE;
			xSetEnableJoystickAxisZ:=FALSE;
		END_IF;
		IF xTmpStationSetupAxisZFunctionToolGuide AND (T_ExchgParam.T_StationCommon.iZAxisGuideTube_ShowObjectNr = 6) THEN
			xResetEnableJoystickAxisZ:=FALSE;
			xSetEnableJoystickAxisZ:=TRUE;
		END_IF;
		IF xTmpStationSetupAxisZFunctionToolGuide AND (T_ExchgParam.T_StationCommon.iZAxisGuideTube_ShowObjectNr <> 6) THEN
			xResetEnableJoystickAxisZ:=TRUE;
			xSetEnableJoystickAxisZ:=FALSE;
		END_IF;
	ELSE
		(* Alles restliche ist nicht erlaubt *)
		xResetEnableJoystickAxisZ:=TRUE;
		xSetEnableJoystickAxisZ:=FALSE;
	END_IF;

	IF xSetEnableJoystickAxisZ THEN
		gxEnable_Joystick_Axis_Z:=TRUE;
	END_IF;
	IF xResetEnableJoystickAxisZ OR NOT(T_StartUp.T_Ctrle.xDone) THEN
		gxEnable_Joystick_Axis_Z:=FALSE;
	END_IF;
END_ACTION

ACTION	CtrlParaListButton:
IF NOT(xSecurityKey) THEN
	iStationActive:=0;
ELSE
	iStationActive:=iSetupMode;
END_IF;
(* Bt Parameter List Button *)
	xTmp:=	NOT(xChangePage)
			AND T_Visu.T_CtrleAction.xDone
			AND NOT(T_Visu.T_CtrleAction.xExecute);
	RisingEdgeBtParameterList(CLK:=	(T_ExchgParam.T_BtParameterList.wActivBt<>0));
	IF xTmp THEN
		(* check if more than one button is pressed-->if only one Button than start the procedure *)
		IF xFct_CheckSingleButtonActivation(wInputButton:=T_ExchgParam.T_BtParameterList.wActivBt) THEN
		(* activ action of rising edge *)
			IF RisingEdgeBtParameterList.Q THEN
				ii:=iFct_GetBitNumber(wInputButton:=T_ExchgParam.T_BtParameterList.wActivBt);
				jj:=iFct_GetBitNumber(wInputButton:=awSaveStateTaskBar[iStationActive]);
(*				aiTempActiveParaListState[iStationActive,jj]:=ii;*)
				(* Da diese Software keine Parameterlisten bezogen auf Task hat, sind alle gleichgestellt *)
				aiTempActiveParaListState[iStationActive,1]:=ii;
				aiTempActiveParaListState[iStationActive,2]:=ii;
				aiTempActiveParaListState[iStationActive,3]:=ii;
				aiTempActiveParaListState[iStationActive,4]:=ii;
				aiTempActiveParaListState[iStationActive,5]:=ii;
				aiTempActiveParaListState[iStationActive,6]:=ii;
				xUpdateStationParameter:=TRUE;
			END_IF;
		END_IF;
		T_ExchgParam.T_BtParameterList.wActivBt:=0;
	ELSE
		T_ExchgParam.T_BtParameterList.wActivBt:=0;
	END_IF

FBGetParameterList(	xNormalModeActive:= NOT(xSecurityKey),
					iSetupMode:= iSetupMode,
					wActiveTaskBar:= awSaveStateTaskBar[iStationActive],
					aiTempActiveParaListState:= aiTempActiveParaListState,
					iActLevel:=T_ExchgParam.T_Visu.T_Level.iActLevel);
T_ExchgParam.T_BtParameterList.iEditParam:=FBGetParameterList.iParameterList;
T_ExchgParam.T_BtParameterList.wNotMasktext:=FBGetParameterList.wNotMasktext;
T_ExchgParam.T_BtParameterList.wState:=FBGetParameterList.wState;
T_ExchgParam.T_BtParameterList.aiSelectText:=FBGetParameterList.aiSelectText;
T_ExchgParam.T_BtParameterList.bParameterListEditable:=FBGetParameterList.bParameterListEditable;
T_ExchgParam.T_BtParameterList.bMessageParameter:=FBGetParameterList.bMessageParameter;
END_ACTION

ACTION	CtrlPreWarning:
(* Ausgabe der Vorwarnungsmeldungen *)
IF T_ExchgParam.T_SafetyCtrl.xReadNextPreWarningMessage THEN
	T_ExchgParam.T_SafetyCtrl.xReadNextPreWarningMessage:=FALSE;
	IF gT_PreWarning.xPreWarningActive THEN
		iMessageSelected:=iMessageSelected + 1;
		IF (iMessageSelected > gT_PreWarning.iNumberOfMessage) THEN
			iMessageSelected:=gT_PreWarning.iNumberOfMessage;
		END_IF;
	END_IF;
END_IF;
IF T_ExchgParam.T_SafetyCtrl.xReadPreviousPreWarningMessage THEN
	T_ExchgParam.T_SafetyCtrl.xReadPreviousPreWarningMessage:=FALSE;
	IF gT_PreWarning.xPreWarningActive THEN
		iMessageSelected:=iMessageSelected - 1;
		IF (iMessageSelected < 1) THEN
			iMessageSelected:=1;
		END_IF;
	END_IF;
END_IF;
IF (iMessageSelected > gT_PreWarning.iNumberOfMessage) THEN
	iMessageSelected:=gT_PreWarning.iNumberOfMessage;
END_IF;
IF (iMessageSelected = 0) AND (gT_PreWarning.iNumberOfMessage > 0) THEN
	iMessageSelected:=1;
END_IF;
IF NOT(gT_PreWarning.xPreWarningActive) THEN
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine1Engl:=gT_PreWarning.asEmptyMessageEngl[1];
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine2Engl:=gT_PreWarning.asEmptyMessageEngl[2];
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine3Engl:=gT_PreWarning.asEmptyMessageEngl[3];
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine4Engl:=gT_PreWarning.asEmptyMessageEngl[4];
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine5Engl:=gT_PreWarning.asEmptyMessageEngl[5];
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine1Ger:=gT_PreWarning.asEmptyMessageGer[1];
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine2Ger:=gT_PreWarning.asEmptyMessageGer[2];
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine3Ger:=gT_PreWarning.asEmptyMessageGer[3];
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine4Ger:=gT_PreWarning.asEmptyMessageGer[4];
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine5Ger:=gT_PreWarning.asEmptyMessageGer[5];
ELSE
	sWrapTextEngl:='Message ';
	sWrapTextEngl:=CONCAT(sWrapTextEngl, INT_TO_STRING(iMessageSelected));
	sWrapTextEngl:=CONCAT(sWrapTextEngl, ' of ');
	sWrapTextEngl:=CONCAT(sWrapTextEngl, INT_TO_STRING(gT_PreWarning.iNumberOfMessage));
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine1Engl:=sWrapTextEngl;
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine2Engl:=gT_PreWarning.asMessageBufferEngl[iMessageSelected,2];
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine3Engl:=gT_PreWarning.asMessageBufferEngl[iMessageSelected,3];
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine4Engl:=gT_PreWarning.asMessageBufferEngl[iMessageSelected,4];
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine5Engl:=gT_PreWarning.asMessageBufferEngl[iMessageSelected,5];
	sWrapTextGer:='Meldung ';
	sWrapTextGer:=CONCAT(sWrapTextGer, INT_TO_STRING(iMessageSelected));
	sWrapTextGer:=CONCAT(sWrapTextGer, ' von ');
	sWrapTextGer:=CONCAT(sWrapTextGer, INT_TO_STRING(gT_PreWarning.iNumberOfMessage));
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine1Ger:=sWrapTextGer;
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine2Ger:=gT_PreWarning.asMessageBufferGer[iMessageSelected,2];
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine3Ger:=gT_PreWarning.asMessageBufferGer[iMessageSelected,3];
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine4Ger:=gT_PreWarning.asMessageBufferGer[iMessageSelected,4];
	T_ExchgParam.T_SafetyCtrl.sDynMsgPreWarningLine5Ger:=gT_PreWarning.asMessageBufferGer[iMessageSelected,5];
END_IF;
IF T_ExchgParam.T_SafetyCtrl.xResetMsgPreWarning THEN
	T_ExchgParam.T_SafetyCtrl.xResetMsgPreWarning:=FALSE;
	IF gT_PreWarning.xPreWarningActive AND (iMessageSelected <> 0) THEN
		giDeleteMessageNumber:=giDeleteMessageNumber + 1;
		gT_PreWarning.aiDeleteMessage[giDeleteMessageNumber]:=gT_PreWarning.aiMessageNrBuffer[iMessageSelected];
	END_IF;
END_IF;
IF T_ExchgParam.T_SafetyCtrl.xConfirmMsgPreWarning THEN
	T_ExchgParam.T_SafetyCtrl.xConfirmMsgPreWarning:=FALSE;
	T_ExchgParam.T_SafetyCtrl.bStateMessagePreWarning:=0;
END_IF;
IF (T_ExchgParam.T_SafetyCtrl.bStateMessageError <> 0) OR (T_ExchgParam.T_SafetyCtrl.bStateMessageInfo <> 0) OR (T_ExchgParam.T_SafetyCtrl.bStateMessageWarning <> 0) THEN
	T_ExchgParam.T_SafetyCtrl.xConfirmMsgPreWarning:=FALSE;
	T_ExchgParam.T_SafetyCtrl.bStateMessagePreWarning:=0;
END_IF;
END_ACTION

ACTION	CtrlProcessFunction:
(* Manage process execution *)
	(* ...done *)
	RisingEdgeProcessDone(CLK:=T_Visu.T_CtrleProcess.xDone);
	IF RisingEdgeProcessDone.Q THEN
		;
	END_IF
	(* ...error *)
	RisingEdgeProcessError(CLK:=T_Visu.T_CtrleProcess.xErr);
	IF RisingEdgeProcessError.Q THEN
		(* Init. variable *)
		T_Visu.T_CtrleProcess.xExecute:=FALSE;
		T_Visu.T_CtrleProcess.xDone:=TRUE;
		T_Visu.T_CtrleProcess.xErr:=FALSE;
		T_Visu.T_CtrleProcess.udiErrorID:=0;
		iStepProcess:=1;
		xStepProcessDone:=FALSE;
	END_IF
	(* ...reset *)
	RisingEdgeReseTProcess(CLK:=T_Visu.T_CtrleProcess.xReset);
	IF RisingEdgeReseTProcess.Q THEN
		(* Init. variable *)
		T_Visu.T_CtrleProcess.xExecute:=FALSE;
		T_Visu.T_CtrleProcess.xDone:=TRUE;
		T_Visu.T_CtrleProcess.xErr:=FALSE;
		T_Visu.T_CtrleProcess.udiErrorID:=0;
		iStepProcess:=1;
		xStepProcessDone:=FALSE;
		(* Release process *)
		T_Visu.T_CtrleProcess.xReset:=FALSE;
		xProcessMachine:=FALSE;
		xProcessStation:=FALSE;
	END_IF
	RisingEdgeExecuteProcess(CLK:=T_Visu.T_CtrleProcess.xExecute);
	IF RisingEdgeExecuteProcess.Q THEN
		(* Release execution *)
		T_Visu.T_CtrleProcess.xExecute:=FALSE;
		CASE T_Visu.T_CtrleProcess.iFunction OF
		(* Process machine *)
		1:	xProcessMachine:=TRUE;
		(* Process station mit WstkTeller *)
		2:	xProcessStation:=TRUE;
		(* process not implemented *)
		ELSE	T_Visu.T_CtrleProcess.xDone:=FALSE;
				T_Visu.T_CtrleProcess.xErr:=TRUE;
				T_Visu.T_CtrleProcess.udiErrorID:=16#E000;
				(* exit FB *)
				RETURN;
		END_CASE
		(* Init. variable *)
		T_Visu.T_CtrleProcess.xDone:=FALSE;
		T_Visu.T_CtrleProcess.xErr:=FALSE;
		T_Visu.T_CtrleProcess.udiErrorID:=0;
		iStepProcess:=1;
		xStepProcessDone:=FALSE;
		(* exit FB *)
		RETURN;
	END_IF

(* Prozesse die im Einrichtbetrieb ausgelöst werden mit dem WstkTeller *)
	IF xProcessStation THEN
		IF NOT(TProcess.T_Ctrle.xExecute)  AND TProcess.T_Ctrle.xError AND TProcess.T_Ctrle.xErrorReady THEN
			iStepProcess:=90;
		END_IF;
		CASE iStepProcess OF
		1:	TProcess.T_Ctrle.xExecute:=TRUE;	(* Starten des Prozesses *)
			iStepProcess:=90;
		(* Abwarten auf das Prozessende *)
		90:	IF NOT(TProcess.T_Ctrle.xExecute)  AND (TProcess.T_Ctrle.xDone OR TProcess.T_Ctrle.xError) THEN
				T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
				xProcessStation:=FALSE;
				T_Visu.T_CtrleProcess.xDone:=TRUE;
				T_Visu.T_CtrleProcess.xErr:=FALSE;
				T_Visu.T_CtrleProcess.udiErrorID:=0;
			END_IF;
			IF (T_ExchgParam.byOverride = 0) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=330;	(* Override ist auf 0% gesetzt-->Keine Achsenbewegung ! *)
			ELSE
				IF (T_ExchgParam.T_Visu.T_Message.iState = 330) THEN
					T_ExchgParam.T_Visu.T_Message.iState:=0;
				END_IF;
			END_IF;
		END_CASE;
	END_IF;

(* Prozesse die im Automat ausgelöst werden *)
	IF xProcessMachine THEN
		CASE iStepProcess OF
		(* Überprüfe zuerst den WzWechsel der Bearbeitungsstationen *)
		1:	xProcessEnded:=FALSE;
			IF (TProcess.T_Ctrle.iFunctNr = 2) THEN
				(* Gilt nur für den Automat *)
				T_ExchgParam.T_Visu.T_Message.iState:=0;
				T_ExchgParam.T_StationCommon.T_ToolCounter_St1.diToolCycleCounter:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter.diToolCycleCounter;
				T_ExchgParam.T_StationCommon.T_ToolCounter_St1.diMaxNumberToolCycle:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter.diMaxNumberToolCycle;
				xTmp:=	((T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter.diMaxNumberToolCycle <> 0) AND
						(T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter.diToolCycleCounter >= T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter.diMaxNumberToolCycle));
				IF xTmp THEN
					T_ExchgParam.T_SafetyCtrl.bStateMessageRequest:=1;
					T_ExchgParam.T_SafetyCtrl.bStateMessagePreWarning:=0;
					T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;
					iStepProcess:=iStepProcess + 1;
				ELSE
					iStepProcess:=4;	(* Überprüfen des Namen für die Prozessanalyse *)
				END_IF;
			ELSE
					iStepProcess:=19;	(* Prozess kann gestartet werden *)
			END_IF;
			xProcessAbordet:=FALSE;
		(* Aufforderung an Operator für Eingabe ob WzWechsel stattgefunden hat oder nicht *)
		2:	IF T_ExchgParam.T_SafetyCtrl.xConfirmMsgRequest THEN
				T_ExchgParam.T_SafetyCtrl.xConfirmMsgRequest:=FALSE;
				T_ExchgParam.T_SafetyCtrl.bStateMessageRequest:=0;
				IF (T_ExchgParam.T_SafetyCtrl.bState_Select_St1 = 1) THEN
					T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter.diToolCycleCounter:=0;
					T_ExchgParam.T_StationCommon.T_ToolCounter_St1.diToolCycleCounter:=0;
				END_IF;
				TONWaitReadyStartButton(IN:=FALSE);
				T_ExchgParam.T_Visu.T_Message.iState:=101;	(* Aufforderung: Bitte StartTaste drücken um Prozess zu starten *)
				iStepProcess:=iStepProcess + 1;
			END_IF;
		(* Auffordern erneut die StartTaste zu drücken *)
		3:	T_CtrleBtStartStop.xForceSetStartButton:=TONWaitReadyStartButton.Q;
			T_CtrleBtStartStop.xForceSetStopButton:=TONWaitReadyStartButton.Q;
			T_ExchgParam.T_Visu.T_Message.iState:=101;	(* Aufforderung: Bitte StartTaste drücken um Prozess zu starten *)
			IF xStartButton THEN
				TONWaitReadyStartButton(IN:=FALSE);
				T_ExchgParam.T_Visu.T_Message.iState:=0;		(* Meldung zurücksetzen *)
				T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
				iStepProcess:=4;
			END_IF;
			IF xStopButton THEN
				TONWaitReadyStartButton(IN:=FALSE);
				T_ExchgParam.T_Visu.T_Message.iState:=0;		(* Meldung zurücksetzen *)
				T_ExchgParam.T_Visu.T_Message.iState:=0;
				xProcessMachine:=FALSE;
				T_Visu.T_CtrleProcess.xDone:=TRUE;
				T_Visu.T_CtrleProcess.xErr:=FALSE;
				T_Visu.T_CtrleProcess.udiErrorID:=0;
				T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
			END_IF;
		(* Überprüfe ob der Name für die Prozessanalyse eingegeben werden muss *)
		4:	IF (T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].sStartOfProcess = '') THEN
				TStation_Work_St1.THWWorkStation.TCtrlWork.xWP_Analyse_StartAutomat:=TRUE;			(* Gilt für die Aufzeichnungsdatei, um festzulegen wann der Automat für die jeweilige Datei gestartet wurde *)
			END_IF;
			iStepProcess:=19;
		(* Sicherheitstüren Zuhaltung aktivieren *)
		19:	T_ExchgParam.T_SafetyCtrl.xCloseSecurityDoorMachine:=TRUE;
			iStepProcess:=20;
		20:	IF NOT(T_ExchgParam.T_SafetyCtrl.xCloseSecurityDoorMachine) THEN
				iStepProcess:=30;
			END_IF;
		(* Prozess starten *)
		30:	TProcess.T_Ctrle.xExecute:=TRUE;	(* Starten des Prozesses *)
			iStepProcess:=90;
		90:	IF NOT(TProcess.T_Ctrle.xExecute)  AND TProcess.T_Ctrle.xDone THEN
				xProcessEnded:=TRUE;
				IF NOT(xProcessAbordet) THEN
					IF (TProcess.T_Ctrle.iFunctNr = 1) THEN
						T_StartUp.T_Ctrle.iMsgNumber:=3;	(* Die Maschine wurde Referenziert/Grundstellung! Bestätigen Sie die Meldung und die Zuhaltung der MaschinenTüre wird deaktiviert! *)
						T_StartUp.T_Ctrle.iFunction:=11;
						T_StartUp.T_Ctrle.xExecute:=TRUE;
					ELSIF (TProcess.T_Ctrle.iFunctNr = 2) THEN
						T_StartUp.T_Ctrle.iMsgNumber:=10;	(* Das Leerfahren im Automat ist beendet! Bestätigen Sie die Meldung und die Zuhaltung der MaschinenTüre wird deaktiviert! *)
						T_StartUp.T_Ctrle.iFunction:=11;
						T_StartUp.T_Ctrle.xExecute:=TRUE;
					END_IF;
				ELSE
					xProcessAbordet:=FALSE;
					T_StartUp.T_Ctrle.iMsgNumber:=10;	(* Prozess wurde abgebrochen! Bestätigen Sie die Meldung und die Zuhaltung der MaschinenTüre wird deaktiviert! *)
					T_StartUp.T_Ctrle.iFunction:=12;
					T_StartUp.T_Ctrle.xExecute:=TRUE;
				END_IF;
				T_StartUp.T_Ctrle.xUnlockSecurityDoor:=TRUE;	(* Auffordern Sicherheitstüren zu öffnen, nachdem die Meldung vom Operator Quittiert wurde *)
				xProcessMachine:=FALSE;
				T_Visu.T_CtrleProcess.xDone:=TRUE;
				T_Visu.T_CtrleProcess.xErr:=FALSE;
				T_Visu.T_CtrleProcess.udiErrorID:=0;
				T_ExchgParam.T_StationCommon.xBlockSelectAutoMode:=FALSE;
			END_IF;
			IF NOT(TProcess.T_Ctrle.xExecute)  AND TProcess.T_Ctrle.xError AND TProcess.T_Ctrle.xErrorReady THEN
				xProcessEnded:=TRUE;
				IF (TProcess.T_Ctrle.iFunctNr = 1) THEN
					T_StartUp.T_Ctrle.iMsgNumber:=58;	(* Während der Maschinen Ref./Grundstellung ist ein Fehler/Error aufgetreten! Bestätigen Sie die Meldung und Überprüfen Sie den entsprechenden Fehler/Error *)
				ELSIF (TProcess.T_Ctrle.iFunctNr = 2) THEN
					T_StartUp.T_Ctrle.iMsgNumber:=55;	(* Während des Automat ist ein Fehler/Error aufgetreten! Bestätigen Sie die Meldung und Überprüfen Sie den entsprechenden Fehler/Error *)
				END_IF;
				T_StartUp.T_Ctrle.iFunction:=10;
				T_StartUp.T_Ctrle.xUnlockSecurityDoor:=TRUE;	(* Auffordern Sicherheitstüren zu öffnen, nachdem die Meldung vom Operator Quittiert wurde *)
				T_StartUp.T_Ctrle.xExecute:=TRUE;
				xProcessMachine:=FALSE;
				T_Visu.T_CtrleProcess.xDone:=TRUE;
				T_Visu.T_CtrleProcess.xErr:=FALSE;
				T_Visu.T_CtrleProcess.udiErrorID:=0;
				T_ExchgParam.T_StationCommon.xBlockSelectAutoMode:=FALSE;
			END_IF;
			IF (T_ExchgParam.byOverride = 0) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=330;	(* Override ist auf 0% gesetzt-->Keine Achsenbewegung ! *)
			ELSE
				IF (T_ExchgParam.T_Visu.T_Message.iState = 330) THEN
					T_ExchgParam.T_Visu.T_Message.iState:=0;
				END_IF;
			END_IF;
		END_CASE;
	END_IF;

	IF (T_StartUp.T_Ctrle.iMsgNumber = 10) AND (T_StartUp.T_Ctrle.iFunction = 11) AND NOT(T_StartUp.T_Ctrle.xDone) AND T_StartUp.T_State.xCompleted AND NOT(gT_SafetyStatus.xSetupOperateModeActive) AND NOT(T_ExchgParam.T_SafetyCtrl.xConfirmMsgInfo) THEN
		TONWaitSwitchOffMessage(IN:=TRUE,PT:=T#3s);
		IF TONWaitSwitchOffMessage.Q THEN
			T_ExchgParam.T_SafetyCtrl.xConfirmMsgInfo:=TRUE;
			TONWaitSwitchOffMessage(IN:=FALSE);
		END_IF;
	ELSE
		TONWaitSwitchOffMessage(IN:=FALSE);
	END_IF;

(* Ausgabe ob der Prozesszustand Aktiv ist *)
	T_ExchgParam.T_Visu.xActiveProcessState_St1St2:=	(T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].sFileName <> '') OR (T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].diActual_NumberHoleToWork <> 0);
	TProcess.T_Ctrle.xActiveProcessState:=T_ExchgParam.T_Visu.xActiveProcessState_St1St2;

(* Ausgabe der abgelaufenen Automat Prozesszeit *)
T_ExchgParam.T_StationCommon.T_Param_Machine.T_ParamAutomat.tAutoProcessTime_St1St2:=
										T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.tAutoProcessTime_St1St2;
T_ExchgParam.T_StationCommon.T_Param_Machine.T_ParamAutomat.iAutoProcessDay_St1St2:=
										T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.iAutoProcessDay_St1St2;

(* Ausgabe der Anzahl bearbeitenden Wstk *)
T_ExchgParam.T_StationCommon.T_Param_Machine.T_ParamAutomat.diNumberPartWorked_St1St2:=
										T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.diNumberPartWorked_St1St2;

(* Eingabe WzWechsel *)
IF (T_ExchgParam.T_SafetyCtrl.bStateMessageRequest <> 0) THEN
	IF T_ExchgParam.T_SafetyCtrl.xSelect_ToolChange_St1 THEN
		T_ExchgParam.T_SafetyCtrl.xSelect_ToolChange_St1:=FALSE;
		IF (T_ExchgParam.T_SafetyCtrl.bState_Select_St1 = 0) THEN
			T_ExchgParam.T_SafetyCtrl.bState_Select_St1:=1;
		ELSIF (T_ExchgParam.T_SafetyCtrl.bState_Select_St1 = 1) THEN
			T_ExchgParam.T_SafetyCtrl.bState_Select_St1:=0;
		END_IF;
	END_IF;
ELSE
	T_ExchgParam.T_SafetyCtrl.bState_Select_St1:=0;
	T_ExchgParam.T_SafetyCtrl.xSelect_ToolChange_St1:=FALSE;
END_IF;

T_ExchgParam.T_StationCommon.T_Param_StationWork.T_TorqueSystem.rActual_Torque:=T_NovRam.T_Parameter.T_StationWork[1].T_TorqueSystem.rActual_Torque;
T_ExchgParam.T_StationCommon.T_Param_StationWork.T_TorqueSystem_L.rActual_Torque:=T_NovRam.T_Parameter.T_StationWork[1].T_TorqueSystem_L.rActual_Torque;
T_ExchgParam.T_StationCommon.T_Param_StationWork.T_TorqueSystem_M.rActual_Torque:=T_NovRam.T_Parameter.T_StationWork[1].T_TorqueSystem_M.rActual_Torque;
END_ACTION

ACTION	CtrlSetupKeySwitch:
(* Ctrl SecurityKey-->Switch from NormalOperate to SetupOperate or SetupOperate to NormalOperate *)
	xTmp:=	NOT(xChangePage)
			(*AND T_Visu.T_CtrleAction.xDone*)
			AND NOT(T_Visu.T_CtrleAction.xExecute);
	RisingEdgeSpecialLayer(CLK:=xSecurityKey);
	FallingEdgeSpecialLayer(CLK:=xSecurityKey);
	IF xTmp THEN
		IF RisingEdgeSpecialLayer.Q THEN
			iSaveSetupMode:=iSetupMode;
			T_Visu.T_CtrleAction.iFunction:=2;
			T_Visu.T_CtrleAction.xExecute:=TRUE;
		END_IF;
		IF FallingEdgeSpecialLayer.Q THEN
			T_Visu.T_CtrleAction.iFunction:=1;
			T_Visu.T_CtrleAction.xExecute:=TRUE;
		END_IF;
	END_IF;
(* Check if the State from NormalOperate to SetupOperate or SetupOperate to NormalOperate has changed *)
	IF NOT(xFct_GetNormalOperateActive(dwActualPage:=T_Visu.T_PlcParam.dwActualPage)) AND NOT(xFct_GetSetupOperateActive(dwActualPage:=T_Visu.T_PlcParam.dwActualPage)) THEN
		(* Disable the force of set to a OperateMode *)
		xForceSetupOperate:=FALSE;
		xForceNormalOperate:=FALSE;
	END_IF;
	IF xSecurityKey AND xFct_GetNormalOperateActive(dwActualPage:=T_Visu.T_PlcParam.dwActualPage) THEN
		xForceSetupOperate:=TRUE;
	END_IF;
	IF xSecurityKey AND xFct_GetSetupOperateActive(dwActualPage:=T_Visu.T_PlcParam.dwActualPage) THEN
		xForceSetupOperate:=FALSE;
		xForceNormalOperate:=FALSE;
	END_IF;
	IF NOT(xSecurityKey) AND xFct_GetSetupOperateActive(dwActualPage:=T_Visu.T_PlcParam.dwActualPage) THEN
		xForceNormalOperate:=TRUE;
	END_IF;
	IF NOT(xSecurityKey) AND xFct_GetNormalOperateActive(dwActualPage:=T_Visu.T_PlcParam.dwActualPage) THEN
		xForceSetupOperate:=FALSE;
		xForceNormalOperate:=FALSE;
	END_IF;
	IF xForceNormalOperate OR xForceSetupOperate THEN
		TONWaitForceChangeOperateMode(IN:=TRUE,PT:=T#0.2s);
		IF TONWaitForceChangeOperateMode.Q THEN
				iTestCounter:=iTestCounter+1;
				TONWaitForceChangeOperateMode(IN:=FALSE);
				xTmp:=	NOT(xChangePage)
						AND T_Visu.T_CtrleAction.xDone
						AND NOT(T_Visu.T_CtrleAction.xExecute);
				IF xTmp THEN
					IF xForceNormalOperate THEN
						T_Visu.T_CtrleAction.iFunction:=1;
					END_IF;
					IF xForceSetupOperate THEN
						iSaveSetupMode:=iSetupMode;
						T_Visu.T_CtrleAction.iFunction:=2;
					END_IF;
					T_Visu.T_CtrleAction.xExecute:=TRUE;
				END_IF;
		END_IF;
	ELSE
		TONWaitForceChangeOperateMode(IN:=FALSE);
	END_IF;
END_ACTION

ACTION	CtrlSetupOperateModeSwitch:
(* Ctrl SetupOperateModeSwitch --> switch from one SetupOperate Mode to the other *)
	xTmp:=	NOT(xChangePage)
			AND T_Visu.T_CtrleAction.xDone
			AND NOT(T_Visu.T_CtrleAction.xExecute);
	IF xTmp THEN
		RisingEdgeSetupMode(CLK:=(iSaveSetupMode <> iSetupMode));
		IF (T_ExchgParam.T_Visu.bActiveSetupMode <> 0) THEN
			IF RisingEdgeSetupMode.Q THEN
				iSaveSetupMode:=iSetupMode;
				T_Visu.T_CtrleAction.iFunction:=2;
				T_Visu.T_CtrleAction.xExecute:=TRUE;
			END_IF;
		ELSE
			iSaveSetupMode:=iSetupMode;
		END_IF;
	END_IF;
(* Check if the State of the SetupMode has changed *)
	IF xFct_GetSetupOperateActive(dwActualPage:=T_Visu.T_PlcParam.dwActualPage) THEN
		IF (iSetupMode = 1) AND xFct_GetSetupMode(dwActualPage:=T_Visu.T_PlcParam.dwActualPage, iSetupModeRequest:=1) THEN
			(* Disable the force of set to a SetupMode *)
			xForceSetupMode:=FALSE;
		END_IF;
		IF (iSetupMode = 2) AND xFct_GetSetupMode(dwActualPage:=T_Visu.T_PlcParam.dwActualPage, iSetupModeRequest:=2) THEN
			(* Disable the force of set to a SetupMode *)
			xForceSetupMode:=FALSE;
		END_IF;
		IF (iSetupMode = 1) AND NOT(xFct_GetSetupMode(dwActualPage:=T_Visu.T_PlcParam.dwActualPage, iSetupModeRequest:=1)) THEN
			xForceSetupMode:=TRUE;
		END_IF;
		IF (iSetupMode = 2) AND NOT(xFct_GetSetupMode(dwActualPage:=T_Visu.T_PlcParam.dwActualPage, iSetupModeRequest:=2)) THEN
			xForceSetupMode:=TRUE;
		END_IF;

		IF xForceSetupMode THEN
			TONWaitForceChangeSetupMode(IN:=TRUE,PT:=T#0.2s);
			IF TONWaitForceChangeSetupMode.Q THEN
					iTestCounter1:=iTestCounter1+1;
					TONWaitForceChangeSetupMode(IN:=FALSE);
					xTmp:=	NOT(xChangePage)
							AND T_Visu.T_CtrleAction.xDone
							AND NOT(T_Visu.T_CtrleAction.xExecute);
					IF xTmp THEN
						IF xForceSetupMode THEN
							iSaveSetupMode:=iSetupMode;
							T_Visu.T_CtrleAction.iFunction:=2;
						END_IF;
						T_Visu.T_CtrleAction.xExecute:=TRUE;
					END_IF;
			END_IF;
		ELSE
			TONWaitForceChangeSetupMode(IN:=FALSE);
		END_IF;
	ELSE
		TONWaitForceChangeSetupMode(IN:=FALSE);
	END_IF;
END_ACTION

ACTION	CtrlSpindleTime:
(* Gilt für die Aufzeichnung der Dauer der Spindelrotation *)
CASE T_ExchgParam.bToolSpindleActive OF
1:	(* Maxon Spindel *)
	T_ExchgParam.T_StationCommon.iSpindelActiveRotationDay:=TStation_Work_St1.THWWorkStation.TCtrlWork.iSpindelActiveRotationDay;
	T_ExchgParam.T_StationCommon.tSpindelActiveRotationTime:=TStation_Work_St1.THWWorkStation.TCtrlWork.tSpindelActiveRotationTime;
2:	(* Beckhoff Spindel L *)
	T_ExchgParam.T_StationCommon.iSpindelActiveRotationDay:=TStation_Work_St1.THWWorkStation.TCtrlWork.iSpindel2ActiveRotationDay;
	T_ExchgParam.T_StationCommon.tSpindelActiveRotationTime:=TStation_Work_St1.THWWorkStation.TCtrlWork.tSpindel2ActiveRotationTime;
3:	(* Beckhoff Spindel M *)
	T_ExchgParam.T_StationCommon.iSpindelActiveRotationDay:=TStation_Work_St1.THWWorkStation.TCtrlWork.iSpindel3ActiveRotationDay;
	T_ExchgParam.T_StationCommon.tSpindelActiveRotationTime:=TStation_Work_St1.THWWorkStation.TCtrlWork.tSpindel3ActiveRotationTime;
END_CASE;
IF T_StartUp.T_State.xCompleted THEN
	T_NovRAM.T_Parameter.T_StationWork[1].iSpindelActiveRotationDay:=TStation_Work_St1.THWWorkStation.TCtrlWork.iSpindelActiveRotationDay;
	T_NovRAM.T_Parameter.T_StationWork[1].tSpindelActiveRotationTime:=TStation_Work_St1.THWWorkStation.TCtrlWork.tSpindelActiveRotationTime;
	T_NovRAM.T_Parameter.T_StationWork[1].iSpindel2ActiveRotationDay:=TStation_Work_St1.THWWorkStation.TCtrlWork.iSpindel2ActiveRotationDay;
	T_NovRAM.T_Parameter.T_StationWork[1].tSpindel2ActiveRotationTime:=TStation_Work_St1.THWWorkStation.TCtrlWork.tSpindel2ActiveRotationTime;
	T_NovRAM.T_Parameter.T_StationWork[1].iSpindel3ActiveRotationDay:=TStation_Work_St1.THWWorkStation.TCtrlWork.iSpindel3ActiveRotationDay;
	T_NovRAM.T_Parameter.T_StationWork[1].tSpindel3ActiveRotationTime:=TStation_Work_St1.THWWorkStation.TCtrlWork.tSpindel3ActiveRotationTime;
END_IF;
END_ACTION

ACTION	CtrlStartStopButton:
(* Externe StartTaste *)
	xTmp:=	NOT(xChangePage)
			AND T_Visu.T_CtrleAction.xDone
			AND NOT(T_Visu.T_CtrleAction.xExecute)
			AND NOT(T_StartUp.T_State.xBlockChangeMovementVisu)
			AND TProcess.T_Ctrle.xDone;
	IF xTmp THEN
		(* manage rising edge start button *)
		IF xStartButton THEN
			dwSaveVisuPage:=T_Visu.T_PlcParam.dwActualPage;
			CASE T_Visu.T_PlcParam.dwActualPage OF
			gT_PageNumber.iAutoMode_Process, gT_PageNumber.iAutoMode_ProcessValue1, gT_PageNumber.iAutoMode_ProcessValue2, gT_PageNumber.iAutoMode_PartQuality:
					T_Visu.T_CtrleAction.iFunction:=700 + 2;		(* Automat Prozess-->Wstk bearbeiten *)

			gT_PageNumber.iAutoMode_Referencing:			(* Maschinenreferenzierung Prozess *)
					T_Visu.T_CtrleAction.iFunction:=700 + 1;

			gT_PageNumber.iHandMode_Process, gT_PageNumber.iHandMode_WorkParameter, gT_PageNumber.iHandMode_RegulatorPara,
			gT_PageNumber.iHandMode_OnlineChange, gT_PageNumber.iHandMode_ConfigPosition:				(* HandBetrieb Prozess *)
					T_Visu.T_CtrleAction.iFunction:=600 + 3;

			gT_PageNumber.iWorkStation_Axis1:
				(* Abfragen ob die Achse eine Absolute Position oder Geschwindigkeitsbewegung ausführen kann *)
				CASE T_ExchgParam.T_TeachIn.iSetup_AxisSel OF
				gciAxisZ_St1:		T_Visu.T_CtrleAction.iFunction:=210;			(* Absolute Bewegung einer ausgewählten Achse auf ausgewählte Position *)
				gciAxisS_St1,3:	T_Visu.T_CtrleAction.iFunction:=207;			(* Achse Geschwindigkeitsmodus für Spindel *)
				END_CASE;

			gT_PageNumber.iWorkStation_Function1:
					T_Visu.T_CtrleAction.iFunction:=401;			(* Ausführen von Stationsfunktionen der Bearbeitungsstation *)

			gT_PageNumber.iWorkStation_Setup3:
				IF (T_ExchgParam.T_StationCommon.bSelectZAxisProcedure <= 1) THEN
					T_Visu.T_CtrleAction.iFunction:=405;			(* Ausführen von Stationsfunktionen der Bearbeitungsstation für die Einrichtung der Z Achse und des oberen Führungsrohr *)
				ELSE
					T_Visu.T_CtrleAction.iFunction:=402;			(* Ausführen von Stationsfunktionen der Bearbeitungsstation für Ersteinrichtung der Z Achse *)
				END_IF;

			gT_PageNumber.iWorkStation_Setup1:
					T_Visu.T_CtrleAction.iFunction:=403;			(* Ausführen der Stationsfunktion für das Kalibrieren des ToolDefelction und ToolTorque *)

			gT_PageNumber.iWorkStation_Setup2:
					T_Visu.T_CtrleAction.iFunction:=404;			(* Ausführen der Stationsfunktion für den BurnIn der Spindeln über ausgewählte Stationen *)

			END_CASE;
			T_Visu.T_CtrleAction.xExecute:=TRUE;
			iSaveStartedVisuFunction_St1St2:=T_Visu.T_CtrleAction.iFunction;
		END_IF;
	END_IF;

	xTmp:=	NOT(T_Visu.T_CtrleAction.xExecute) AND T_Visu.T_CtrleAction.xDone AND
			NOT(T_Visu.T_CtrleProcess.xExecute) AND T_Visu.T_CtrleProcess.xDone AND
			NOT(xTmpStationSetupAxisZFunction) AND NOT(xTmpStationSetupAxisZFunctionToolGuide) AND
			TProcess.T_Ctrle.xDone;
	IF xTmp THEN
		iSaveStartedVisuFunction_St1St2:=0;
	END_IF;
(* Externe StoppTaste *)
	xTmp:=	NOT(T_Visu.T_CtrleAction.xExecute);
	IF xStopButton AND xTmp THEN
		T_Visu.T_CtrleAction.iFunction:=0;
		IF (NOT(TProcess.T_Ctrle.xDone) AND NOT(TProcess.T_Ctrle.xError)) THEN
			(* Prozess ist aktiv *)
			IF (iSaveStartedVisuFunction_St1St2 >= 600) AND (iSaveStartedVisuFunction_St1St2 <= 698) THEN
				(* Prozess welches im HandBetrieb aktiviert wurde, ist aktiv *)
				T_Visu.T_CtrleAction.iFunction:=699;
			END_IF;
			IF (iSaveStartedVisuFunction_St1St2 >= 700) AND (iSaveStartedVisuFunction_St1St2 <= 796) THEN
				IF (T_ExchgParam.T_Visu.T_Message.iState <> 110) THEN	(* Aufforderung: Leerfahren aktivieren <StartTaste>, abbr. <StopTaste> ? *)
					(* Prozess welches im Automat aktiviert wurde, ist aktiv *)
					T_Visu.T_CtrleAction.iFunction:=799;
				END_IF;
			END_IF;
		ELSE
			(* Prozess ist nicht Aktiv *)
			IF ((iSaveStartedVisuFunction_St1St2 >= 400) AND (iSaveStartedVisuFunction_St1St2 <= 496)) OR
			    (T_Visu.T_CtrleAction.xFunctionActive AND (T_Visu.T_PlcParam.dwActualPage <> gT_PageNumber.iWorkStation_Axis1)) THEN
				(* Stationsfunktion muss gestoppt werden *)
				T_Visu.T_CtrleAction.iFunction:=499;
			ELSE
				(* Prozess und Stationsfunktionen sind nicht Aktiv-->Achsen stoppen *)
				CASE T_Visu.T_PlcParam.dwActualPage OF
				gT_PageNumber.iWorkStation_Axis1:
					T_Visu.T_CtrleAction.iFunction:=202;
				gT_PageNumber.iAutoMode_ToolChange:
					T_Visu.T_CtrleAction.iFunction:=201;
				END_CASE;
			END_IF;
		END_IF;
		IF (T_Visu.T_CtrleAction.iFunction <> 0) THEN
			T_Visu.T_CtrleAction.xExecute:=TRUE;
		END_IF;
	END_IF;
END_ACTION

ACTION	CtrlTaskBar:
(* Bt navigation panel *)
	xTmp:=	NOT(xChangePage)
			AND T_Visu.T_CtrleAction.xDone
			AND NOT(T_Visu.T_CtrleAction.xExecute)
			AND NOT(T_StartUp.T_State.xBlockChangeMovementVisu);
	IF xTmp THEN
		RisingEdgeTouchScreenNavPanel(CLK:=		(T_ExchgParam.T_TouchScreenNavPanel.wActivBt
												AND T_ConfigPage.wMaskTouchScreenNavPanel) <> 16#0);
		(* check if more than one button is pressed-->if only one Button than start the procedure *)
		IF xFct_CheckSingleButtonActivation(wInputButton:=T_ExchgParam.T_TouchScreenNavPanel.wActivBt) THEN
		(* activ action of rising edge *)
			IF RisingEdgeTouchScreenNavPanel.Q THEN
				IF xFct_GetParameterPageActive(dwActualPage:=T_Visu.T_PlcParam.dwActualPage) THEN
					(* Do not change the page, if the Parameter page is active-->change only the Task *)
					awSaveStateTaskBar[T_ExchgParam.T_Visu.bActiveSetupMode]:=T_ExchgParam.T_TouchScreenNavPanel.wActivBt;
					ii:=iFct_GetBitNumber(wInputButton:=T_ExchgParam.T_TouchScreenNavPanel.wActivBt);
					(* Da diese Software keine Parameterlisten bezogen auf Task hat, sind alle gleichgestellt und muss beim Taskwechsel nicht mehr ein Update Parameter durchgeführt werden *)
					(*
					xUpdateStationParameter:=TRUE;
					*)
				ELSE
					ii:=iFct_GetBitNumber(wInputButton:=T_ExchgParam.T_TouchScreenNavPanel.wActivBt);
					IF (T_ConfigPage.aiRTrigActionTouchScreenNavPanel[ii,1] <> 0) THEN
						T_Visu.T_CtrleAction.iFunction:=10000 + DWORD_TO_INT(dwSaveActualPageTask[T_ExchgParam.T_Visu.bActiveSetupMode,ii]);
						T_Visu.T_CtrleAction.xExecute:=TRUE;
					END_IF;
					awSaveStateTaskBar[T_ExchgParam.T_Visu.bActiveSetupMode]:=T_ExchgParam.T_TouchScreenNavPanel.wActivBt;
				END_IF;
			END_IF;
		END_IF;
		T_ExchgParam.T_TouchScreenNavPanel.wActivBt:=0;
	ELSE
		T_ExchgParam.T_TouchScreenNavPanel.wActivBt:=0;
		(* Init. rising and falling edge *)
		RisingEdgeTouchScreenNavPanel(CLK:=FALSE);
	END_IF
END_ACTION

ACTION	CtrlVisuFunction:
(* waiting for executing action *)
	(* ...monitor Key panel "Enter" *)
	RisingEdgeKeyPanel_Enter(CLK:=T_ExchgParam.T_Visu.xKey_Enter);
	(* ...monitor Key panel "Esc" *)
	RisingEdgeKeyPanel_Esc(CLK:=T_ExchgParam.T_Visu.xKey_Escape);
	(*... not ready *)
	TimerNotReady(IN:=FALSE, PT:=T#2s);
	T_Visu.T_CtrleAction.xNotReady:=TimerNotReady.Q;
	(* ...message *)
	RisingEdgeActionNotReady(CLK:=T_Visu.T_CtrleAction.xNotReady);
	IF RisingEdgeActionNotReady.Q AND T_ExchgParam.T_Visu.T_Message.iState < 350 THEN
		T_ExchgParam.T_Visu.T_Message.iState:=201;	(* Warnung: Nicht bereit auszuführen ! *)
	END_IF
	(* Release 'Not ready' action control structure *)
	FallingEdgeActionNotReady(CLK:=T_Visu.T_CtrleAction.xNotReady);
	IF FallingEdgeActionNotReady.Q THEN
		T_Visu.T_CtrleAction.xExecute:=FALSE;
		T_Visu.T_CtrleAction.xDone:=TRUE;
		T_Visu.T_CtrleAction.xErr:=FALSE;
		T_Visu.T_CtrleAction.udiErrorID:=0;
		iStepAction:=1;
		iStepActionRef:=1;
		iStepActionNovRam:=1;
		xStepActionDone:=FALSE;
		TimerAction(IN:=FALSE);
	END_IF
	(* ...done *)
	RisingEdgeActionDone(CLK:=T_Visu.T_CtrleAction.xDone);
	IF RisingEdgeActionDone.Q THEN
		IF (T_ExchgParam.T_Visu.T_Message.iState = 0) AND NOT(xBlockConfirmMessage) THEN
			T_ExchgParam.T_Visu.T_Message.iState:=32;	(* Info: Aktion beendet ! *)
		END_IF
		xBlockConfirmMessage:=FALSE;
	END_IF
	(* ...error *)
	RisingEdgeActionError(CLK:=T_Visu.T_CtrleAction.xErr);
	IF RisingEdgeActionError.Q THEN
	(* call function bloc action error *)
		(* Init. variable *)
		T_Visu.T_CtrleAction.xExecute:=FALSE;
		T_Visu.T_CtrleAction.xDone:=TRUE;
		T_Visu.T_CtrleAction.xErr:=FALSE;
		T_Visu.T_CtrleAction.xNotReady:=FALSE;
		T_Visu.T_CtrleAction.udiErrorID:=0;
		iStepAction:=1;
		iStepActionNovRam:=1;
		iStepActionRef:=1;
		xStepActionDone:=FALSE;
	END_IF
	(* ...reset *)
	RisingEdgeResetAction(CLK:=T_Visu.T_CtrleAction.xReset);
	IF RisingEdgeResetAction.Q THEN
		(* Init. variable *)
		T_Visu.T_CtrleAction.xExecute:=FALSE;
		T_Visu.T_CtrleAction.xDone:=TRUE;
		T_Visu.T_CtrleAction.xErr:=FALSE;
		T_Visu.T_CtrleAction.xNotReady:=FALSE;
		T_Visu.T_CtrleAction.udiErrorID:=0;
		iStepAction:=1;
		iStepActionNovRam:=1;
		iStepActionRef:=1;
		xStepActionDone:=FALSE;
		TimerAction(IN:=FALSE);
		(* Release reset *)
		T_Visu.T_CtrleAction.xReset:=FALSE;
	END_IF
	(* Ausgabe der Zeilen Meldungen *)
	IF (T_ExchgParam.T_Visu.T_Message.iState >= 1) AND (T_ExchgParam.T_Visu.T_Message.iState <= 100) THEN
		T_ExchgParam.T_Visu.T_Message.xShowMessageInfo:=TRUE;
		T_ExchgParam.T_SafetyCtrl.xHideSafetyCtrlMessage:=TRUE;
	ELSE T_ExchgParam.T_Visu.T_Message.xShowMessageInfo:=FALSE; END_IF;
	IF (T_ExchgParam.T_Visu.T_Message.iState >= 101) AND (T_ExchgParam.T_Visu.T_Message.iState <= 200) THEN
		T_ExchgParam.T_Visu.T_Message.xShowMessageInput:=TRUE;
		T_ExchgParam.T_SafetyCtrl.xHideSafetyCtrlMessage:=TRUE;
	ELSE T_ExchgParam.T_Visu.T_Message.xShowMessageInput:=FALSE; END_IF;
	IF (T_ExchgParam.T_Visu.T_Message.iState >= 201) AND (T_ExchgParam.T_Visu.T_Message.iState <= 350) THEN
		T_ExchgParam.T_Visu.T_Message.xShowMessageWarning:=TRUE;
		T_ExchgParam.T_SafetyCtrl.xHideSafetyCtrlMessage:=TRUE;
	ELSE T_ExchgParam.T_Visu.T_Message.xShowMessageWarning:=FALSE; END_IF;
	(* Ausblenden der Zeilen Meldungen *)
	CASE iStepShowMessage OF
	1:	IF ((T_ExchgParam.T_Visu.T_Message.iState >= 1) AND (T_ExchgParam.T_Visu.T_Message.iState <= 100)) OR
		     ((T_ExchgParam.T_Visu.T_Message.iState >= 201) AND (T_ExchgParam.T_Visu.T_Message.iState <= 350)) THEN
			(* Dies gilt für Info und Warnungsmeldung *)
			iSaveMessage:=T_ExchgParam.T_Visu.T_Message.iState;
			iStepShowMessage:=iStepShowMessage + 1;
			TONWaitShowMessage(IN:=FALSE);
		END_IF;
	2:	IF T_StartUp.T_State.xCompleted OR (T_ExchgParam.T_Visu.T_Message.iState =225) OR (T_ExchgParam.T_Visu.T_Message.iState = 226) THEN
			TONWaitShowMessage(IN:=TRUE,PT:=T#3s);
		ELSE
			TONWaitShowMessage(IN:=TRUE,PT:=T#0.5s);
		END_IF;
		IF TONWaitShowMessage.Q THEN
			T_ExchgParam.T_Visu.T_Message.iState:=0;	(* Meldung löschen *)
			iStepShowMessage:=1;
		END_IF;
		(* Überprüfe ob nicht die Aktuelle Meldung überschrieben wurde *)
		IF (iSaveMessage <> T_ExchgParam.T_Visu.T_Message.iState) THEN
			iSaveMessage:=T_ExchgParam.T_Visu.T_Message.iState;
			iStepShowMessage:=1;	(* Erneute Ausgabe für neue Meldung mit der gleichen Anzeige Zeit *)
		END_IF;
	ELSE
		iStepShowMessage:=1;
	END_CASE;

	RisingEdgeExecuteAction(CLK:=T_Visu.T_CtrleAction.xExecute);
	IF RisingEdgeExecuteAction.Q THEN
		(* confirm action execution *)
		IF (NOT(T_StartUp.T_State.xBlockChangeMovementVisu) OR (T_Visu.T_CtrleAction.iFunction = 499)) AND
		     NOT(xTmpProcMachineStop)  THEN
			T_Visu.T_CtrleAction.xDeleteVisuFunction:=TRUE;
			CtrlVisuFunctionDelete;
		END_IF;
		T_Visu.T_CtrleAction.xExecute:=FALSE;
		CASE T_Visu.T_CtrleAction.iFunction OF
		(* Set NormalOperate *)
		1:	xSetNewPage:=TRUE;
			T_Visu.T_PlcParam.dwSetNewPage:=dwSaveActualPageTask[0,iFct_GetBitNumber(wInputButton:=awSaveStateTaskBar[0])];
			tTimeOutAction:=T#3s;
		(* Set SetupOperate *)
		2:	xSetNewPage:=TRUE;
			iTmpSetupMode:=iSetupMode;
			IF (iTmpSetupMode<1) OR (iTmpSetupMode>3) THEN iTmpSetupMode:=1; END_IF;
			T_Visu.T_PlcParam.dwSetNewPage:=dwSaveActualPageTask[iTmpSetupMode,iFct_GetBitNumber(wInputButton:=awSaveStateTaskBar[iTmpSetupMode])];
			tTimeOutAction:=T#3s;
		(* Set parameter page *)
		3:	xSetParameterPage:=TRUE;
			tTimeOutAction:=T#2s;
		(* Set previous page *)
		5:	xSetPreviousPage:=TRUE;
			tTimeOutAction:=T#3s;
		(* previous  page vertical *)
		11:	xPreviousPageVertical:=TRUE;
			tTimeOutAction:=T#3s;
		(* next page vertical *)
		12:	xNextPageVertical:=TRUE;
			tTimeOutAction:=T#3s;
		(* Löschen der Fehlerliste *)
		97:	xDeleteErrorList:=TRUE;
			tTimeOutAction:=T#5s;

		(* Quittieren des Fehler/Warnung *)
		99:	xResetErrorWarning:=TRUE;
			tTimeOutAction:=T#5s;
		(* LampTest-->Lamp ON/OFF *)
		100:	xLampTestOnOff:=TRUE;
			tTimeOutAction:=T#999999s;
		(* LampTest-->Lamp Blink ON/OFF *)
		101:	xLampTestBlinkOnOff:=TRUE;
			tTimeOutAction:=T#999999s;
		(* LampTest-->LampTest ON *)
		102:	xLampTestActive:=TRUE;
			tTimeOutAction:=T#999999s;

		(* Meldungsfenster Öffnen *)
		104:	xOpenMessageWindow:=TRUE;
			tTimeOutAction:=T#3s;
		(* Maschinen Tür Zuhaltun EIN/AUS *)
		105:	xMachineDoorUpGuardControlTogOnOff:=TRUE;
			tTimeOutAction:=T#5s;

		(* Ändern des Operator Passwortes *)
		110:	xChangeOperatorPassword:=TRUE;
			tTimeOutAction:=T#20s;

		(* Umschalten Z Ink Wert für Bearbeitung *)
		113:xSelectZInkWorkInfo:=TRUE;
			tTimeOutAction:=T#5s;
		(* Umschalten Z Ink Wert für Zentrierung *)
		114:xSelectZInkCentringInfo:=TRUE;
			tTimeOutAction:=T#5s;

		(* Resetten des Werkzeugwechsel für den Automatik für Station 1-->braucht mindestens den OperatorLevel *)
		115:	xProcessStation1ResetToolChange:=TRUE;
			tTimeOutAction:=T#5s;
		(* Z Achse auf WzWechsel Pos setzen *)
		116:	xZAxisMoveToToolChangePos:=TRUE;
			tTimeOutAction:=T#5s;
			ptrTCommonAxisActive:=ptrTAxisZ_St1;
			rZAxisSelectPosition:=T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.rPositionToolChange;
			ptrTCommonAxisActive^.T_CtrleSingle.lrVelocity:=gcarAxisConfig[1].rPositionSpeed;
		(* Z Achse auf LadePos setzen *)
		117: xZAxisMoveToLoadPos:=TRUE;
			tTimeOutAction:=T#5s;
			ptrTCommonAxisActive:=ptrTAxisZ_St1;
			rZAxisSelectPosition:=grZ_LoadPos;
			ptrTCommonAxisActive^.T_CtrleSingle.lrVelocity:=gcarAxisConfig[1].rPositionSpeed;
		(* Speichern Z EndPos Berechnet *)
		118:	xZSaveEndPosCalc:=TRUE;
			tTimeOutAction:=T#5s;

		(* OnlineChange Parameter ToolTorque Drehmoment Schwellwert HC + *)
		120:	xOnlineChange_TorqueLevelHCMore:=TRUE;
			tTimeOutAction:=T#3s;
		(* OnlineChange Parameter ToolTorque Drehmoment Schwellwert HC - *)
		121:	xOnlineChange_TorqueLevelHCLess:=TRUE;
			tTimeOutAction:=T#3s;

		(* OnlineChange Parameter Zylinder ToolDeflection Auslenkkraft + *)
		126:	xOnlineChange_DeflectionForceMore:=TRUE;
			tTimeOutAction:=T#3s;
		(* OnlineChange Parameter Zylinder ToolDeflection Auslenkkraft - *)
		127:	xOnlineChange_DeflectionForceLess:=TRUE;
			tTimeOutAction:=T#3s;
		(* OnlineChange Parameter Z Achse Bearbeitungsgeschwindigkeit vorwärts + *)
		128:	xOnlineChange_Z_ForwardSpeedMore:=TRUE;
			tTimeOutAction:=T#3s;
		(* OnlineChange Parameter Z Achse Bearbeitungsgeschwindigkeit vorwärts - *)
		129:	xOnlineChange_Z_ForwardSpeedLess:=TRUE;
			tTimeOutAction:=T#3s;
		(* OnlineChange Parameter Z Achse Bearbeitungsgeschwindigkeit rückwärts + *)
		130:	xOnlineChange_Z_BackwardSpeedMore:=TRUE;
			tTimeOutAction:=T#3s;
		(* OnlineChange Parameter Z Achse Bearbeitungsgeschwindigkeit rückwärts - *)
		131:	xOnlineChange_Z_BackwardSpeedLess:=TRUE;
			tTimeOutAction:=T#3s;
		(* OnlineChange Parameter Z Achse rückwärts Offset + *)
		132:	xOnlineChange_Z_BackwardOffsetMore:=TRUE;
			tTimeOutAction:=T#3s;
		(* OnlineChange Parameter Z Achse rückwärts Offset - *)
		133:	xOnlineChange_Z_BackwardOffsetLess:=TRUE;
			tTimeOutAction:=T#3s;
		(* OnlineChange Parameter S Achse Bearbeitungsgeschwindigkeit + *)
		134:	xOnlineChange_S_WorkSpeedMore:=TRUE;
			tTimeOutAction:=T#3s;
		(* OnlineChange Parameter S Achse Bearbeitungsgeschwindigkeit - *)
		135:	xOnlineChange_S_WorkSpeedLess:=TRUE;
			tTimeOutAction:=T#3s;

		(* Löschen des Prozesszustandspeicher *)
		150:	xDeleteProcessState:=TRUE;
			tTimeOutAction:=T#5s;
		(* Endlos Prozess EIN/AUS *)
		151:	xEndlessProcessOnOff:=TRUE;
			tTimeOutAction:=T#5s;
		(* Zentrieren EIN/AUS *)
		152:	xCentringONOFF:=TRUE;
			tTimeOutAction:=T#5s;
		(* NurZentrieren EIN/AUS *)
		153:	xOnlyCentringONOFF:=TRUE;
			tTimeOutAction:=T#5s;
		(* Suspension EIN/AUS *)
		154:	xSuspensionONOFF:=TRUE;
			tTimeOutAction:=T#5s;
		(* ZylWPUnfix EIN/AUS *)
		155:	xCylWPUnfixONOFF:=TRUE;
			tTimeOutAction:=T#5s;

		(* Setup Potentiometer *)
		170:	xSetupPotentiometer:=TRUE;
			tTimeOutAction:=T#0s;
		(* Torque Offset - *)
		171:	xTorqueOffsetMinus:=TRUE;
			tTimeOutAction:=T#0s;
		(* Torque Offset + *)
		172:	xTorqueOffsetPlus:=TRUE;
			tTimeOutAction:=T#0s;
		(* Save Torque Scale *)
		173:	xSaveTorqueScale:=TRUE;
			tTimeOutAction:=T#5s;
		(* Save Torque Position *)
		174:	xSaveTorquePosition:=TRUE;
			tTimeOutAction:=T#5s;

		(* Auswahl Position Führungsrohr *)
		181:	xSelectConfigPosition_1:=TRUE;
			tTimeOutAction:=T#3s;
		(* Auswahl Abstand Führungsrohr *)
		182:	xSelectConfigPosition_2:=TRUE;
			tTimeOutAction:=T#3s;
		(* Auswahl Werkzeug *)
		183:	xSelectConfigPosition_3:=TRUE;
			tTimeOutAction:=T#3s;
		(* Auswahl Führungsrohreinsatz *)
		184:	xSelectConfigPosition_4:=TRUE;
			tTimeOutAction:=T#3s;
		(* KonfigPos EIN/AUS *)
		185:	xConfigPosOnOff:=TRUE;
			tTimeOutAction:=T#5s;
		(* Speichern der Positionskonfiguration *)
		186:	xSaveConfigPosition:=TRUE;
			tTimeOutAction:=T#5s;

		(* Konventioneller Regler *)
		190:	xRegulatorType1:=TRUE;
			tTimeOutAction:=T#5s;
		(* Adaptive Voschub Regler *)
		191:	xRegulatorType2:=TRUE;
			tTimeOutAction:=T#5s;
		(* Konventioneller PD Regler *)
		192:	xRegulatorType3:=TRUE;
			tTimeOutAction:=T#5s;
		(* Regler Parameter speichern *)
		195:	xRegulatorOverlaySave:=TRUE;
			tTimeOutAction:=T#5s;

		(* Spindelkalibrierung EIN/AUS *)
		198:	xSpindelCalibrationONOFF:=TRUE;
			tTimeOutAction:=T#5s;

		200..299:
			CASE T_Visu.T_CtrleAction.iFunction OF
				(* Bewegung einer Achse stoppen *)
				201:	xAxisStop:=TRUE;
					tTimeOutAction:=T#3s;
				(* Bewegung aller Achse stoppen *)
				202:	xAxisStopAll:=TRUE;
					tTimeOutAction:=T#3s;
				(* Achsen Drehmoment Ein/Aus Toggeln *)
				203:	xAxisTogglePower:=TRUE;
					tTimeOutAction:=T#3s;
				(* Achse Resetten *)
				204:	xAxisReset:=TRUE;
					tTimeOutAction:=T#3s;
				(* Achse Geschwindigkeitsmodus *)
				207:	xAxisMoveContinous:=TRUE;
					tTimeOutAction:=T#5s;
					CASE T_ExchgParam.T_TeachIn.iSetup_AxisSel OF
					2,3:	ptrTCommonAxisActive:=ptrTAxisS_St1;
					END_CASE;
					ptrTCommonAxisActive^.T_CtrleSingle.lrVelocity:=TCommonTeachParameter.rPositionSpeed;
				(* Achse Absolute Positionsbewegung *)
				210:	xAxisMoveAbsolut:=TRUE;
					tTimeOutAction:=T#999s;
				(* Achse Teach Position *)
				214:	xAxisTeachPosition:=TRUE;
					tTimeOutAction:=T#5s;
				(* Achse Jog/Ink Bewegung +/++ mit Joystick *)
				216:	tTimeOutAction:=T#999s;
					IF xActive_Joystick THEN
						ptrTCommonAxisActive:=ptrTAxisZ_St1;
						ptrTCommonAxisActive^.T_CtrleSingle.lrVelocity:=T_ExchgParam.T_TeachIn.arTeachSelVel[gciAxisZ_St1];
						ptrTCommonAxisActive^.T_CtrleSingle.lrDistance:=T_ExchgParam.T_TeachIn.arTeachSelStep[gciAxisZ_St1];
					ELSE
						ptrTCommonAxisActive:=ptrTCommonAxis;
						ptrTCommonAxisActive^.T_CtrleSingle.lrVelocity:=TCommonTeachParameter.rVelFast;
						ptrTCommonAxisActive^.T_CtrleSingle.lrDistance:=TCommonTeachParameter.rIncFast;
					END_IF;
					IF T_ExchgParam.T_TeachIn.xJogInc_Common_Setup_Axis THEN
						(* Jog Mode *)
						xAxisMoveContinous:=TRUE;
					ELSE
						(* Ink Mode *)
						xAxisMoveRelative:=TRUE;
					END_IF;
				(* Achse Jog/Ink Bewegung -/- - mit Joystick *)
				217:	tTimeOutAction:=T#999s;
					IF xActive_Joystick THEN
						ptrTCommonAxisActive:=ptrTAxisZ_St1;
						IF T_ExchgParam.T_TeachIn.xJogInc_Common_Setup_Axis THEN
							ptrTCommonAxisActive^.T_CtrleSingle.lrVelocity:=T_ExchgParam.T_TeachIn.arTeachSelVel[gciAxisZ_St1] * -1.0;
						ELSE
							ptrTCommonAxisActive^.T_CtrleSingle.lrVelocity:=T_ExchgParam.T_TeachIn.arTeachSelVel[gciAxisZ_St1];
							ptrTCommonAxisActive^.T_CtrleSingle.lrDistance:=T_ExchgParam.T_TeachIn.arTeachSelStep[gciAxisZ_St1] * -1.0;
						END_IF;
					ELSE
						ptrTCommonAxisActive:=ptrTCommonAxis;
						IF T_ExchgParam.T_TeachIn.xJogInc_Common_Setup_Axis THEN
							ptrTCommonAxisActive^.T_CtrleSingle.lrVelocity:=TCommonTeachParameter.rVelFast * -1.0;
						ELSE
							ptrTCommonAxisActive^.T_CtrleSingle.lrVelocity:=TCommonTeachParameter.rVelFast;
							ptrTCommonAxisActive^.T_CtrleSingle.lrDistance:=TCommonTeachParameter.rIncFast * -1.0;
						END_IF;
					END_IF;
					IF T_ExchgParam.T_TeachIn.xJogInc_Common_Setup_Axis THEN
						(* Jog Mode *)
						xAxisMoveContinous:=TRUE;
					ELSE
						(* Ink Mode *)
						xAxisMoveRelative:=TRUE;
					END_IF;
				(* Löschen der berechnete Wert für Wippe des Drehmoment Detection *)
				230:	xResetRockerValue:=TRUE;
					tTimeOutAction:=T#2s;
			END_CASE;
		(* Analogen Wert für Servoventil setzen *)
		300:	xCylSetServoAnalogValue:=TRUE;
			tTimeOutAction:=T#3s;
		(* Zylinder/Ventile Ein/Aus Toggeln *)
		301:	xCylValveToggleOnOff:=TRUE;
			tTimeOutAction:=T#3s;
		(* Zylinder Drucklos schalten *)
		302:	xCylPressurelessON:=TRUE;
			tTimeOutAction:=T#3s;
		(* Zyl WzDrehmoment EIN/AUS *)
		303:	xCylTorqueOnOff:=TRUE;
			tTimeOutAction:=T#3s;
		(* Zyl WzDrehmomentÜberlast EIN/AUS *)
		304:	xCylTorqueOverloadOnOff:=TRUE;
			tTimeOutAction:=T#3s;
		(* Ausführen von Stationsfunktionen der Bearbeitungsstation *)
		401:		xStationWorkFunction:=TRUE;
				tTimeOutAction:=T#0s;
		(* Ausführen von Stationsfunktionen der Bearbeitungsstation für Ersteinrichtung der Z Achse *)
		402:		xStationSetupAxisZFunction:=TRUE;
				tTimeOutAction:=T#0s;
		(* Ausführen der Stationsfunktion für das Kalibrieren des ToolDefelction und ToolTorque *)
		403:		xStationToolCalibrateFunction:=TRUE;
				tTimeOutAction:=T#0s;
		(* Ausführen der Stationsfunktion für den BurnIn der Spindeln über ausgewählte Stationen *)
		404:		xStationSpindleBurnInFunction:=TRUE;
				tTimeOutAction:=T#0s;
		(* Ausführen von Stationsfunktionen der Bearbeitungsstation für Einrichtung der Z Achse und oberes Führungsrohr *)
		405:		xStationSetupAxisZFunctionToolGuide:=TRUE;
				tTimeOutAction:=T#0s;
		(* Stoppen von Stationsfunktionen der rechten Arbeitsstation *)
		497:		xStationStopWorkRight:=TRUE;
				tTimeOutAction:=T#0s;
		(* Stoppen von Stationsfunktionen *)
		499:		xStationStop:=TRUE;
				xStationWorkFunction:=xStationToolCalibrateFunction:=xStationSpindleBurnInFunction:=FALSE;
				xTmpStationSetupAxisZFunction:=xTmpStationSetupAxisZFunctionToolGuide:=FALSE;
				tTimeOutAction:=T#0s;
		(* Prozesse die aus der Stationsebene ausgelöst werden *)
		600..698:	TProcess.T_Ctrle.iFunctNr:=T_Visu.T_CtrleAction.iFunction - 600;
				xActionProcStation:=TRUE;
				tTimeOutAction:=T#1s;
		(* Stoppen vom Prozess welches über den HandBetrieb ausgelöst wurde *)
		699:		xProcStationStop:=TRUE;
				tTimeOutAction:=T#0s;
		(* Prozesse die aus der Maschinenebene ausgelöst werden *)
		701..796:	TProcess.T_Ctrle.iFunctNr:=T_Visu.T_CtrleAction.iFunction - 700;
				xActionProcMachine:=TRUE;
				tTimeOutAction:=T#0s;
		(* Stoppen vom Prozess welches über den Automat ausgelöst wurde *)
		799:		xProcMachineStop:=TRUE;
				tTimeOutAction:=T#0s;
		(* Save NovRAM without confirmation *)
		1001:	xAction_SaveNovRAM:=TRUE;
				tTimeOutAction:=T#10s;
		(* Erstmalige Kopiervorgang der Profile *)
		1002:	xAction_CopyProfileToProcess:=TRUE;
				tTimeOutAction:=T#60s;
		(* Laden eines ausgewählten Profil in den Prozessabbild *)
		1003:	xAction_LoadProfile:=TRUE;
				tTimeOutAction:=T#6s;
		(* Speichern eines ausgewählten Profils *)
		1004:	xAction_SaveProfile:=TRUE;
				tTimeOutAction:=T#6s;
		(* Löschen eines ausgewählten Profil *)
		1005:	xActionDeleteProfile:=TRUE;
				tTimeOutAction:=T#6s;
		(* change page from Taskbar *)
		10001..10999:	xSetNewPage:=TRUE;
					T_Visu.T_PlcParam.dwSetNewPage:=INT_TO_DWORD(T_Visu.T_CtrleAction.iFunction - 10000);
					tTimeOutAction:=T#3s;
		(* change page from Panel left Button *)
		11001..11999:	xSetParameterPage:=TRUE;
					T_Visu.T_PlcParam.dwSetNewPage:=INT_TO_DWORD(T_Visu.T_CtrleAction.iFunction - 11000);
					tTimeOutAction:=T#3s;
		ELSE
		(* function not implemented *)
			T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F000;
			(* exit FB *)
			RETURN;
		END_CASE
		(* Init. variable *)
		IF (T_ExchgParam.T_Visu.T_Message.iState = 401) THEN
			IF NOT(xSetNewPage) AND NOT(xSetPreviousPage) AND NOT(xPreviousPageVertical) AND
				NOT(xNextPageVertical) AND NOT(xResetErrorWarning) THEN
				(* Im Fehlerfall dürfen nur noch die Navigierung aktiviert sein und den Fehler zu Quittieren *)
					tTimeOutAction:=T#0s;
					T_Visu.T_CtrleAction.xDeleteVisuFunction:=TRUE;
					RETURN;
			END_IF;
		END_IF;
		T_Visu.T_CtrleAction.xDone:=FALSE;
		T_Visu.T_CtrleAction.xNotReady:=FALSE;
		T_Visu.T_CtrleAction.xErr:=FALSE;
		T_Visu.T_CtrleAction.udiErrorID:=0;
		iStepAction:=1;
		iStepActionNovRam:=1;
		iStepActionRef:=1;
		xStepActionDone:=FALSE;
		xBlockSetNovRamAction_End:=FALSE;	(* Mittels diesem Flag kann verhindert werden, dass die VisuFunktion für das speichern der Daten in den NovRam das EndFlag nicht gesetzt wird *)
		IF tTimeOutAction <> T#0s THEN TimerAction(IN:=FALSE); END_IF
		(* exit FB *)
		RETURN;
	END_IF;
(* Timer action *)
	IF tTimeOutAction <> T#0s THEN TimerAction(IN:=TRUE,PT:=tTimeOutAction); END_IF
	RisingEdgeTimeOut(CLK:=TimerAction.Q);
	IF RisingEdgeTimeOut.Q AND NOT(T_Visu.T_CtrleAction.xDone) AND NOT(T_Visu.T_CtrleAction.xErr) THEN
	(* Timeout action activ *)
		(* call confirmation message *)
		IF NOT(T_Visu.T_CtrleAction.xFunctionActive) THEN
			T_ExchgParam.T_Visu.T_Message.iState:=203;	(* Warnung: Ausführungszeit überschritten ! *)
			(* exit FB, do not continue the execution of action! *)
			T_Visu.T_CtrleAction.xDeleteVisuFunction:=TRUE;
			RETURN;
		END_IF;
	END_IF

(* Überprüfe für aufgerufene Visu Funktion ob die Energieversorgung eingeschaltet ist *)
	xCheckVisuFunctionPowerON:=FALSE;
	IF NOT(gT_SafetyStatus.xSetupOperateModeActive) THEN
		IF NOT(T_ExchgParam.T_SafetyCtrl.xNormalOperate_EnergyON)THEN
			xCheckVisuFunctionPowerON:=TRUE;
		END_IF;
	ELSE
		IF (gT_SafetyStatus.iSetupMode = 1) THEN
			IF NOT(T_ExchgParam.T_SafetyCtrl.xSetupOperateA_EnergyON)THEN
				xCheckVisuFunctionPowerON:=TRUE;
			END_IF;
		ELSIF (gT_SafetyStatus.iSetupMode = 2) THEN
			IF NOT(T_ExchgParam.T_SafetyCtrl.xSetupOperateB_EnergyON)THEN
				xCheckVisuFunctionPowerON:=TRUE;
			END_IF;
		END_IF;
	END_IF;
	IF xCheckVisuFunctionPowerON AND NOT(gxHardwareOFF) THEN
		xCheckVisuFunctionPowerON:=	xAxisStop OR xAxisStopAll OR xAxisTogglePower OR xAxisReset OR xZAxisMoveToToolChangePos OR xZAxisMoveToLoadPos;
		xCheckVisuFunctionPowerON:=	xCheckVisuFunctionPowerON OR xAxisMoveContinous OR xAxisMoveAbsolut OR xAxisMoveRelative;
		xCheckVisuFunctionPowerON:=	xCheckVisuFunctionPowerON OR xAxisTeachPosition OR xStationSetupAxisZFunction OR xStationSetupAxisZFunctionToolGuide;
		xCheckVisuFunctionPowerON:=	xCheckVisuFunctionPowerON OR xTmpStationSetupAxisZFunction OR xTmpStationSetupAxisZFunctionToolGuide;
		xCheckVisuFunctionPowerON:=	xCheckVisuFunctionPowerON OR xCylValveToggleOnOff OR xCylSetServoAnalogValue OR xCylPressurelessON OR xCylTorqueOnOff OR xCylTorqueOverloadOnOff;
		xCheckVisuFunctionPowerON:=	xCheckVisuFunctionPowerON OR xStationWorkFunction OR xSuspensionONOFF;
		xCheckVisuFunctionPowerON:=	xCheckVisuFunctionPowerON OR xStationToolCalibrateFunction OR xStationSpindleBurnInFunction;
		xCheckVisuFunctionPowerON:=	xCheckVisuFunctionPowerON OR xStationStop OR xStationStopWorkRight;
		xCheckVisuFunctionPowerON:=	xCheckVisuFunctionPowerON OR xActionProcStation OR xProcStationStop OR xActionProcMachine;
		xCheckVisuFunctionPowerON:=	xCheckVisuFunctionPowerON OR xTmpProcMachineStop;
		IF xCheckVisuFunctionPowerON THEN
			tTimeOutAction:=T#0s;
			TimerAction(IN:=FALSE);
			T_ExchgParam.T_Visu.T_Message.iState:=230;	(* Warnung: Zuerst die Energieversorgung einschalten ! *)
			T_Visu.T_CtrleAction.xDeleteVisuFunction:=TRUE;
			T_Visu.T_CtrleAction.xFunctionActive:=FALSE;
		END_IF;
	END_IF;

	IF (T_ExchgParam.T_Visu.T_Message.iState = 401) THEN
		IF NOT(xSetNewPage) AND NOT(xSetPreviousPage) AND NOT(xPreviousPageVertical) AND
		     NOT(xNextPageVertical) AND NOT(xResetErrorWarning) THEN
			(* Im Fehlerfall dürfen nur noch die Navigierung aktiviert sein und den Fehler zu Quittieren *)
			tTimeOutAction:=T#0s;
			T_Visu.T_CtrleAction.xDeleteVisuFunction:=TRUE;
			T_Visu.T_CtrleAction.xFunctionActive:=FALSE;
		END_IF;
	END_IF;

CtrlVisuFunctionDelete;
END_ACTION

ACTION	CtrlVisuFunctionDelete:
(* Löschen aller Visu Funktionen *)
	IF T_Visu.T_CtrleAction.xDeleteVisuFunction THEN
		T_Visu.T_CtrleAction.xDeleteVisuFunction:=FALSE;
		T_Visu.T_CtrleAction.xExecute:=FALSE;
		T_Visu.T_CtrleAction.xDone:=TRUE;
		T_Visu.T_CtrleAction.xNotReady:=FALSE;
		T_Visu.T_CtrleAction.xErr:=FALSE;
		T_Visu.T_CtrleAction.udiErrorID:=16#0;
		T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
		xSetNewPage:=FALSE;
		xSetParameterPage:=FALSE;
		xSetPreviousPage:=FALSE;
		xPreviousPageVertical:=FALSE;
		xNextPageVertical:=FALSE;
		xDeleteErrorList:=FALSE;
		xResetErrorWarning:=FALSE;
		xLampTestOnOff:=FALSE;
		xLampTestBlinkOnOff:=FALSE;
		xLampTestActive:=FALSE;
		xOpenMessageWindow:=FALSE;
		xMachineDoorUpGuardControlTogOnOff:=FALSE;
		xChangeOperatorPassword:=FALSE;
		xProcessStation1ResetToolChange:=FALSE;
		xOnlineChange_TorqueLevelHCMore:=FALSE;
		xOnlineChange_TorqueLevelHCLess:=FALSE;
		xOnlineChange_DeflectionForceMore:=FALSE;
		xOnlineChange_DeflectionForceLess:=FALSE;
		xOnlineChange_Z_ForwardSpeedMore:=FALSE;
		xOnlineChange_Z_ForwardSpeedLess:=FALSE;
		xOnlineChange_Z_BackwardSpeedMore:=FALSE;
		xOnlineChange_Z_BackwardSpeedLess:=FALSE;
		xOnlineChange_Z_BackwardOffsetMore:=FALSE;
		xOnlineChange_Z_BackwardOffsetLess:=FALSE;
		xOnlineChange_S_WorkSpeedMore:=FALSE;
		xOnlineChange_S_WorkSpeedLess:=FALSE;
		xTorqueOffsetMinus:=FALSE;
		xTorqueOffsetPlus:=FALSE;
		xSaveTorqueScale:=FALSE;
		xSaveTorquePosition:=FALSE;
		xSelectConfigPosition_1:=FALSE;
		xSelectConfigPosition_2:=FALSE;
		xSelectConfigPosition_3:=FALSE;
		xSelectConfigPosition_4:=FALSE;
		xSaveConfigPosition:=FALSE;
		xConfigPosOnOff:=FALSE;
		xSpindelCalibrationONOFF:=FALSE;
		xStationToolCalibrateFunction:=FALSE;
		xStationSpindleBurnInFunction:=FALSE;
		xDeleteProcessState:=FALSE;
		xEndlessProcessOnOff:=FALSE;
		xCentringONOFF:=FALSE;
		xOnlyCentringONOFF:=FALSE;
		xSuspensionONOFF:=FALSE;
		xSetupPotentiometer:=FALSE;
		xZAxisMoveToToolChangePos:=FALSE;
		xZAxisMoveToLoadPos:=FALSE;
		xZSaveEndPosCalc:=FALSE;
		xSelectZInkWorkInfo:=FALSE;
		xSelectZInkCentringInfo:=FALSE;
		xAxisStop:=FALSE;
		xAxisStopAll:=FALSE;
		xAxisTogglePower:=FALSE;
		xAxisReset:=FALSE;
		xAxisMoveContinous:=FALSE;
		xAxisMoveAbsolut:=FALSE;
		xAxisMoveRelative:=FALSE;
		xAxisTeachPosition:=FALSE;
		xResetRockerValue:=FALSE;
		xCylValveToggleOnOff:=FALSE;
		xCylTorqueOnOff:=FALSE;
		xCylTorqueOverloadOnOff:=FALSE;
		xCylSetServoAnalogValue:=FALSE;
		xCylPressurelessON:=FALSE;
		xStationWorkFunction:=FALSE;
		xStationStop:=FALSE;
		xStationStopWorkRight:=FALSE;
		xActionProcStation:=FALSE;
		xProcStationStop:=FALSE;
		xActionProcMachine:=FALSE;
		xProcMachineStop:=FALSE;
		xTmpProcMachineStop:=FALSE;
		xAction_SaveNovRAM:=FALSE;
		xAction_CopyProfileToProcess:=FALSE;
		xAction_LoadProfile:=FALSE;
		xAction_SaveProfile:=FALSE;
		xActionDeleteProfile:=FALSE;
		xStationSetupAxisZFunction:=FALSE;
		xTmpStationSetupAxisZFunction:=FALSE;
		xStationSetupAxisZFunctionToolGuide:=FALSE;
		xTmpStationSetupAxisZFunctionToolGuide:=FALSE;
		xRegulatorOverlaySave:=FALSE;
		xRegulatorType1:=FALSE;
		xRegulatorType2:=FALSE;
		xRegulatorType3:=FALSE;
	END_IF;
END_ACTION

ACTION	InitQVIS:
(* determin if qvis activ *)
	IF xQvisActiv THEN
		(* timer time off  *)
		TimerQVis(IN:=TRUE,PT:=T#2s);
		IF dwInCount_QVisCmd = T_CtrleQVis.dwInCount THEN
			(* Init. command *)
			T_CtrleQVis.dwInCommand:=1;
			T_CtrleQVis.dwInQVisCtrlAddress:=ADR(T_CtrleQVis);
			T_CtrleQVis.dwInParameterAddress:=ADR(T_Visu.T_PlcParam.dwSetNewPage);
			(* start command *)
			T_CtrleQVis.dwInCount:=T_CtrleQVis.dwInCount+1;
			(* Activ Timer *)
			TimerQVis(IN:=FALSE);
		ELSE
			IF T_CtrleQVis.dwInCount = T_CtrleQVis.dwOutCount THEN
			(* command done *)
				IF T_CtrleQVis.diOutStatus = 0 THEN
				(* command done without error *)
					xQvisActiv:=FALSE;
					T_Visu.T_CtrleVisu.xQvis:=TRUE;
					T_Visu.T_PlcParam.dwActualPage:=T_Visu.T_PlcParam.dwSetNewPage;
				END_IF
			ELSE
			(* test time off, restart command *)
				IF TimerQVis.Q THEN
					dwInCount_QVisCmd:=T_CtrleQVis.dwInCount;
				END_IF
			END_IF
		END_IF
	END_IF

(* Überprüfe ob die QVisRuntime noch am leben ist *)
IF T_StartUp.T_State.xPLCReady THEN
	TONWaitCheckQVis(IN:=TRUE,PT:=T#5s);
	IF TONWaitCheckQVis.Q THEN
		CASE iStepCheckQVis OF
		1:	IF NOT(T_Visu.T_CtrleVisu.xExecute) AND T_Visu.T_CtrleVisu.xDone AND NOT(xChangePage) THEN	(* Abwarten bis Visu Ressource frei steht *)
				xBlockChangeVisuPage:=TRUE;
				IF (T_CtrleQVis.dwInCount > 4294967295) THEN
					T_CtrleQVis.dwInCount:=0;
				END_IF;
				T_CtrleQVis.dwInCount:=T_CtrleQVis.dwInCount + 1;
				iStepCheckQVis:=iStepCheckQVis + 1;
				TONWaitLiftTime(IN:=FALSE);
			END_IF;
		2:	TONWaitLiftTime(IN:=TRUE,PT:=T#2000ms);
			IF TONWaitLiftTime.Q THEN
				TONWaitLiftTime(IN:=FALSE);
				xBlockChangeVisuPage:=FALSE;
				T_StartUp.T_Ctrle.iFunction:=5;	(* Booting Funktion *)
				T_StartUp.T_Ctrle.xExecute:=TRUE;
				T_Visu.T_CtrleVisu.xReset:=TRUE;
				T_Visu.T_CtrleVisu.xQvis:=FALSE;
				xQvisActiv:=TRUE;
			END_IF;
			IF T_CtrleQVis.dwInCount = T_CtrleQVis.dwOutCount THEN
				TONWaitCheckQVis(IN:=FALSE);
				TONWaitLiftTime(IN:=FALSE);
				xBlockChangeVisuPage:=FALSE;
			END_IF;
		END_CASE;
	ELSE
		iStepCheckQVis:=1;
	END_IF;
ELSE
	iStepCheckQVis:=1;
	TONWaitCheckQVis(IN:=FALSE);
	TONWaitLiftTime(IN:=FALSE);
	xBlockChangeVisuPage:=FALSE;
END_IF;





END_ACTION

ACTION	InitSavePages:
dwSaveActualPageTask[0,1]:=10;
dwSaveActualPageTask[0,2]:=20;
dwSaveActualPageTask[0,3]:=30;
dwSaveActualPageTask[0,4]:=40;
dwSaveActualPageTask[0,5]:=50;
dwSaveActualPageTask[0,6]:=60;

dwSaveActualPageTask[1,1]:=110;
dwSaveActualPageTask[1,2]:=120;
dwSaveActualPageTask[1,3]:=130;
dwSaveActualPageTask[1,4]:=140;
dwSaveActualPageTask[1,5]:=150;
dwSaveActualPageTask[1,6]:=160;

dwSaveActualPageTask[2,1]:=210;
dwSaveActualPageTask[2,2]:=220;
dwSaveActualPageTask[2,3]:=230;
dwSaveActualPageTask[2,4]:=240;
dwSaveActualPageTask[2,5]:=250;
dwSaveActualPageTask[2,6]:=260;

dwSaveActualPageTask[3,1]:=310;
dwSaveActualPageTask[3,2]:=320;
dwSaveActualPageTask[3,3]:=330;
dwSaveActualPageTask[3,4]:=340;
dwSaveActualPageTask[3,5]:=350;
dwSaveActualPageTask[3,6]:=360;
END_ACTION

ACTION	MaskFunctionButton:
	IF (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iAutoMode_UserLevel) AND (T_ExchgParam.T_Visu.T_Level.iActLevel = 1) THEN
		(* Wenn der OperatorLevel Aktiv ist, dann muss die F1 Funktionstaste zur Verfügung gestellt werden um den Passwort ändern zu können *)
		IF TProcess.T_Ctrle.xDone AND NOT(TProcess.T_Ctrle.xError) THEN
			wForceMaskFunctionPanel:=16#1;
		END_IF;
	END_IF;

	CASE T_Visu.T_PlcParam.dwActualPage OF

	gT_PageNumber.iAutoMode_PartQuality:
		IF (T_ExchgParam.T_Visu.T_Level.iActLevel >= 1) THEN
			wForceMaskFunctionPanel:=16#1;
		END_IF;

	gT_PageNumber.iAutoMode_SafetyCheck:
		IF NOT(TProcess.T_Ctrle.xDone) THEN
			(* Wenn mindestens ein Prozess Aktiv ist von einer Arbeitsstation dann darf unabhängig der ausgewählten Arbeitsstation die Türzuhaltung mittels der F1 Taste nicht geöffnet werden *)
			wForceMaskFunctionPanel:=2#1000000;	(* F1 unterdrücken, dazu wird F7 freigegeben (F7 gibt es auf dieser Seite nicht) weil sonst mit Null die Maske nicht überschrieben wird *)
		END_IF;

	gT_PageNumber.iAutoMode_ToolChange:
		IF NOT(T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.xPositionEndProcIncOnOff) AND (T_ExchgParam.T_StationCommon.bSelectShowIncValue = 0) THEN
			wForceMaskFunctionPanel:=16#1F;
		END_IF;
		IF NOT(T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.xCentringEndProcIncOnOff) AND (T_ExchgParam.T_StationCommon.bSelectShowIncValue = 1) THEN
			wForceMaskFunctionPanel:=16#1F;
		END_IF;

	gT_PageNumber.iWorkStation_Axis1:
		CASE T_ExchgParam.T_TeachIn.iSetup_AxisSel OF
		gciAxisZ_St1:			(* Z Achse: *)
			wForceMaskFunctionPanel:=16#33;
			aiForceRTrigActionFunctionPanel[1]:=203;
			aiForceRTrigActionFunctionPanel[2]:=204;
			aiForceRTrigActionFunctionPanel[3]:=0;
			aiForceRTrigActionFunctionPanel[4]:=0;
			aiForceRTrigActionFunctionPanel[5]:=185;	(* KonfigPos EIN/AUS *)
			aiForceRTrigActionFunctionPanel[6]:=214;
		gciAxisS_St1:			(* Maxon Spindel: *)
			wForceMaskFunctionPanel:=16#3B;
			aiForceRTrigActionFunctionPanel[1]:=203;
			aiForceRTrigActionFunctionPanel[2]:=204;
			aiForceRTrigActionFunctionPanel[3]:=0;
			aiForceRTrigActionFunctionPanel[4]:=121;		(* OnlineChange Parameter Zylinder ToolTorque Drehmoment Schwellwert 1 Start Position - *)
			aiForceRTrigActionFunctionPanel[5]:=120;		(* OnlineChange Parameter Zylinder ToolTorque Drehmoment Schwellwert 1 Start Position + *)
			aiForceRTrigActionFunctionPanel[6]:=230;		(* Löschen der berechnete Wert für Wippe des Drehmoment Detection *)
		3:					(* Beckhoff Spindel: *)
			wForceMaskFunctionPanel:=16#3;
			aiForceRTrigActionFunctionPanel[1]:=203;
			aiForceRTrigActionFunctionPanel[2]:=204;
			aiForceRTrigActionFunctionPanel[3]:=0;
			aiForceRTrigActionFunctionPanel[4]:=0;
			aiForceRTrigActionFunctionPanel[5]:=0;
			aiForceRTrigActionFunctionPanel[6]:=0;
		END_CASE;

	gT_PageNumber.iHandMode_OnlineChange:
		wForceMaskFunctionPanel:=16#FFF;
		aiForceRTrigActionFunctionPanel[1]:=120;		(* OnlineChange Parameter Zylinder ToolTorque Drehmoment Schwellwert HC + *)
		aiForceRTrigActionFunctionPanel[2]:=126;		(* OnlineChange Parameter Zylinder ToolDeflection Auslenkkraft + *)
		aiForceRTrigActionFunctionPanel[3]:=128;		(* OnlineChange Parameter Z Achse Bearbeitungsgeschwindigkeit vorwärts + *)
		aiForceRTrigActionFunctionPanel[4]:=132;		(* OnlineChange Parameter Z Achse rückwärts Offset + *)
		aiForceRTrigActionFunctionPanel[5]:=130;		(* OnlineChange Parameter Z Achse Bearbeitungsgeschwindigkeit rückwärts + *)
		aiForceRTrigActionFunctionPanel[6]:=134;		(* OnlineChange Parameter S Achse Bearbeitungsgeschwindigkeit + *)
		aiForceRTrigActionFunctionPanel[7]:=121;		(* OnlineChange Parameter Zylinder ToolTorque Drehmoment Schwellwert HC - *)
		aiForceRTrigActionFunctionPanel[8]:=127;		(* OnlineChange Parameter Zylinder ToolDeflection Auslenkkraft - *)
		aiForceRTrigActionFunctionPanel[9]:=129;		(* OnlineChange Parameter Z Achse Bearbeitungsgeschwindigkeit vorwärts - *)
		aiForceRTrigActionFunctionPanel[10]:=133;		(* OnlineChange Parameter Z Achse rückwärts Offset - *)
		aiForceRTrigActionFunctionPanel[11]:=131;		(* OnlineChange Parameter Z Achse Bearbeitungsgeschwindigkeit rückwärts - *)
		aiForceRTrigActionFunctionPanel[12]:=135;		(* OnlineChange Parameter S Achse Bearbeitungsgeschwindigkeit + *)

	gT_PageNumber.iHandMode_Setup1:
		IF TProcess.T_Ctrle.xDone AND NOT(TProcess.T_Ctrle.xError) THEN
			IF xSetupPotentiometer THEN
				IF (iStepAction = 20) THEN
					wForceMaskFunctionPanel:=16#20;
				END_IF;
			ELSE
				wForceMaskFunctionPanel:=16#1;
			END_IF;
		ELSE
			wForceMaskFunctionPanel:=16#1000;
		END_IF;

	gT_PageNumber.iWorkStation_Setup4:
		CASE T_ExchgParam.bToolSpindleActive OF
		1:	(* Maxon Spindel *)
			wForceMaskFunctionPanel:=16#3F;
			aiForceRTrigActionFunctionPanel[1]:=171;	(* Torque Offset - *)
			aiForceRTrigActionFunctionPanel[2]:=172;	(* Torque Offset - *)
			aiForceRTrigActionFunctionPanel[3]:=303;	(* Zyl WzDrehmoment EIN/AUS *)
			aiForceRTrigActionFunctionPanel[4]:=304;	(* Zyl WzDrehmomentÜberlast EIN/AUS *)
			aiForceRTrigActionFunctionPanel[5]:=173;	(* Save Torque Scale *)
			aiForceRTrigActionFunctionPanel[6]:=174;	(* Save Torque Position *)
		2,3:	(* Beckhoff Spindel *)
			wForceMaskFunctionPanel:=16#F000;
			aiForceRTrigActionFunctionPanel[1]:=0;
			aiForceRTrigActionFunctionPanel[2]:=0;
			aiForceRTrigActionFunctionPanel[3]:=0;
			aiForceRTrigActionFunctionPanel[4]:=0;
			aiForceRTrigActionFunctionPanel[5]:=0;
			aiForceRTrigActionFunctionPanel[6]:=0;
		END_CASE;


	END_CASE;
END_ACTION

ACTION	MaskRightButton:
	IF (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iWorkStation_Axis1) THEN
		CASE T_ExchgParam.T_TeachIn.iSetup_AxisSel OF
		gciAxisZ_St1:		wForceMaskBtPanelRight:=16#60;
		gciAxisS_St1,3:	wForceMaskBtPanelRight:=16#0;
		END_CASE;
	END_IF;
END_ACTION

ACTION	Monitor_ActuatorState:
(*******************************************************************************************************************************************************************************************)
(*************************************************			                                   Zylinder Zustand abfragen                                                     ******************************************)
(*******************************************************************************************************************************************************************************************)
(* 01 WzAuslenkung St1 *)
	T_ExchgParam.T_Cylinder.arStat[1].xOff:=	FALSE;
	T_ExchgParam.T_Cylinder.arStat[1].xOn:=	TStation_Work_St1.THWWorkStation.TCylToolDeflection.T_CtrleCyl.T_Analog.xActiv;
	T_ExchgParam.T_Cylinder.arStat[1].bStat:=	bFct_SetCylStat(	TStation_Work_St1.THWWorkStation.TCylToolDeflection.T_CtrleCyl.xStatePosOff,
														 		TStation_Work_St1.THWWorkStation.TCylToolDeflection.T_CtrleCyl.xStatePosOn,
											 					T_ExchgParam.T_Cylinder.arStat[1].bStat);
(* 02 Servoventil für Drehmomentüberwachung HC *)
	T_ExchgParam.T_Cylinder.arStat[2].xOff:=	FALSE;
	T_ExchgParam.T_Cylinder.arStat[2].xOn:=	TStation_Work_St1.THWWorkStation.TCylToolTorqueHC.T_CtrleCyl.T_Analog.xActiv;
	T_ExchgParam.T_Cylinder.arStat[2].bStat:=	bFct_SetCylStat(	TStation_Work_St1.THWWorkStation.TCylToolTorqueHC.T_CtrleCyl.xStatePosOff,
														 		TStation_Work_St1.THWWorkStation.TCylToolTorqueHC.T_CtrleCyl.xStatePosOn,
											 					T_ExchgParam.T_Cylinder.arStat[2].bStat);
(* 03 Servoventil für Drehmomentüberwachung Überlast *)
	T_ExchgParam.T_Cylinder.arStat[3].xOff:=	FALSE;
	T_ExchgParam.T_Cylinder.arStat[3].xOn:=	TStation_Work_St1.THWWorkStation.TCylToolTorqueOverload.T_CtrleCyl.T_Analog.xActiv;
	T_ExchgParam.T_Cylinder.arStat[3].bStat:=	bFct_SetCylStat(	TStation_Work_St1.THWWorkStation.TCylToolTorqueOverload.T_CtrleCyl.xStatePosOff,
														 		TStation_Work_St1.THWWorkStation.TCylToolTorqueOverload.T_CtrleCyl.xStatePosOn,
											 					T_ExchgParam.T_Cylinder.arStat[3].bStat);
(* 04 Bremse Z Achse St1 *)
	T_ExchgParam.T_Cylinder.arStat[4].xOff:=	TStation_Work_St1.THWWorkStation.TCylBrakeReleaseZAxis.T_CtrleCyl.T_Standard.xActivOff;
	T_ExchgParam.T_Cylinder.arStat[4].xOn:=	TStation_Work_St1.THWWorkStation.TCylBrakeReleaseZAxis.T_CtrleCyl.T_Standard.xActivOn;
	T_ExchgParam.T_Cylinder.arStat[4].bStat:=	bFct_SetCylStat(	TStation_Work_St1.THWWorkStation.TCylBrakeReleaseZAxis.T_CtrleCyl.xStatePosOff,
														 		TStation_Work_St1.THWWorkStation.TCylBrakeReleaseZAxis.T_CtrleCyl.xStatePosOn,
											 					T_ExchgParam.T_Cylinder.arStat[4].bStat);
(* 05 Werkstück Spannung *)
	T_ExchgParam.T_Cylinder.arStat[5].xOff:=	FALSE;
	T_ExchgParam.T_Cylinder.arStat[5].xOn:=	TStation_Work_St1.THWWorkStation.TCylWorkpieceClamp.T_CtrleCyl.T_Standard.xActivOn;
	T_ExchgParam.T_Cylinder.arStat[5].bStat:=	bFct_SetCylStat(	TStation_Work_St1.THWWorkStation.TCylWorkpieceClamp.T_CtrleCyl.xStatePosOff,
														 		TStation_Work_St1.THWWorkStation.TCylWorkpieceClamp.T_CtrleCyl.xStatePosOn,
											 					T_ExchgParam.T_Cylinder.arStat[5].bStat);
(* 06 Ventil Luft Tisch *)
	T_ExchgParam.T_Cylinder.arStat[6].xOff:=	TStation_Work_St1.THWWorkStation.TValveAirTable.T_CtrleCyl.T_Standard.xActivOff;
	T_ExchgParam.T_Cylinder.arStat[6].xOn:=	TStation_Work_St1.THWWorkStation.TValveAirTable.T_CtrleCyl.T_Standard.xActivOn;
	T_ExchgParam.T_Cylinder.arStat[6].bStat:=	bFct_SetCylStat(	TStation_Work_St1.THWWorkStation.TValveAirTable.T_CtrleCyl.xStatePosOff,
														 		TStation_Work_St1.THWWorkStation.TValveAirTable.T_CtrleCyl.xStatePosOn,
											 					T_ExchgParam.T_Cylinder.arStat[6].bStat);
(* 07 Ventil Vakuum Tisch *)
	T_ExchgParam.T_Cylinder.arStat[7].xOff:=	TStation_Work_St1.THWWorkStation.TValveVacuumTable.T_CtrleCyl.T_Standard.xActivOff;
	T_ExchgParam.T_Cylinder.arStat[7].xOn:=	TStation_Work_St1.THWWorkStation.TValveVacuumTable.T_CtrleCyl.T_Standard.xActivOn;
	T_ExchgParam.T_Cylinder.arStat[7].bStat:=	bFct_SetCylStat(	TStation_Work_St1.THWWorkStation.TValveVacuumTable.T_CtrleCyl.xStatePosOff,
														 		TStation_Work_St1.THWWorkStation.TValveVacuumTable.T_CtrleCyl.xStatePosOn,
											 					T_ExchgParam.T_Cylinder.arStat[7].bStat);

(* 08 Ventil Reinigungsduese *)
	T_ExchgParam.T_Cylinder.arStat[8].xOff:=	FALSE;
	T_ExchgParam.T_Cylinder.arStat[8].xOn:=	TStation_Work_St1.THWWorkStation.TValveCleanNozzle.T_CtrleCyl.T_Standard.xActivOn;
	T_ExchgParam.T_Cylinder.arStat[8].bStat:=	bFct_SetCylStat(	TStation_Work_St1.THWWorkStation.TValveCleanNozzle.T_CtrleCyl.xStatePosOff,
														 		TStation_Work_St1.THWWorkStation.TValveCleanNozzle.T_CtrleCyl.xStatePosOn,
											 					T_ExchgParam.T_Cylinder.arStat[8].bStat);
(*******************************************************************************************************************************************************************************************)
(*************************************************			                                   Achsen Zustand abfragen                                                      ******************************************)
(*******************************************************************************************************************************************************************************************)
(*  Reihenfolge Achsen Anwahl: *)
(*1:Achse Z,*)
T_ExchgParam.T_TeachIn.arAxis[gciAxisZ_St1].bActState	:=
		bFct_SetAxisStat(	TStation_Work_St1.THWWorkStation.TAxisZ.T_CtrleSingle.xPower,
							TStation_Work_St1.THWWorkStation.TAxisZ.T_CtrleSingle.xRef,
							NOT TStation_Work_St1.THWWorkStation.TAxisZ.T_CtrleSingle.xNotMoving ,
							TStation_Work_St1.THWWorkStation.TAxisZ.T_CtrleSingle.xErr,
							TStation_Work_St1.THWWorkStation.TAxisZ.T_CtrleSingle.xStateHWLimitNeg,
							TStation_Work_St1.THWWorkStation.TAxisZ.T_CtrleSingle.xStateHWLimitPos,
							T_ExchgParam.T_TeachIn.arAxis[gciAxisZ_St1].bActState);
T_ExchgParam.T_TeachIn.arAxis[gciAxisZ_St1].rActPos		:=TStation_Work_St1.THWWorkStation.TAxisZ.T_LiveValue.lrActualPosition;
T_ExchgParam.T_TeachIn.arAxis[gciAxisZ_St1].rActSpeed	:=TStation_Work_St1.THWWorkStation.TAxisZ.T_LiveValue.lrActualVelocity;
(*5:Achse S,*)
T_ExchgParam.T_TeachIn.arAxis[gciAxisS_St1].bActState	:=
		bFct_SetAxisStat(	TStation_Work_St1.THWWorkStation.TAxisS.T_CtrleSingle.xPower,
							TStation_Work_St1.THWWorkStation.TAxisS.T_CtrleSingle.xRef,
							NOT TStation_Work_St1.THWWorkStation.TAxisS.T_CtrleSingle.xNotMoving ,
							TStation_Work_St1.THWWorkStation.TAxisS.T_CtrleSingle.xErr,
							TStation_Work_St1.THWWorkStation.TAxisS.T_CtrleSingle.xStateHWLimitNeg,
							TStation_Work_St1.THWWorkStation.TAxisS.T_CtrleSingle.xStateHWLimitPos,
							T_ExchgParam.T_TeachIn.arAxis[gciAxisS_St1].bActState);
T_ExchgParam.T_TeachIn.arAxis[gciAxisS_St1].rActPos		:=TStation_Work_St1.THWWorkStation.TAxisS.T_LiveValue.lrActualPosition;
T_ExchgParam.T_TeachIn.arAxis[gciAxisS_St1].rActSpeed	:=TStation_Work_St1.THWWorkStation.TAxisS.T_LiveValue.lrActualVelocity;
CASE T_ExchgParam.T_TeachIn.iSetup_AxisSel OF
gciAxisZ_St1:		T_ExchgParam.T_TeachIn.rTeachSelStep:=T_ExchgParam.T_TeachIn.arTeachSelStep[gciAxisZ_St1];
				T_ExchgParam.T_TeachIn.rTeachSelVel:=T_ExchgParam.T_TeachIn.arTeachSelVel[gciAxisZ_St1];
gciAxisS_St1,3:	T_ExchgParam.T_TeachIn.rTeachSelStep:=T_ExchgParam.T_TeachIn.arTeachSelStep[gciAxisS_St1];
				T_ExchgParam.T_TeachIn.rTeachSelVel:=T_ExchgParam.T_TeachIn.arTeachSelVel[gciAxisS_St1];
END_CASE;
(*++++++++++++++++Teach Positions WorkStation++++++++++++++++
POSITIONS FOR  Z Axis!
0:=< Fahre zu man. Pos. >
1:=< Z LadePos >
2:=< Z Bearb StartPos >
3:=< Z Bearb EndPos >
4:=< Z WzWechsel Pos >
5:=< Z Mech EndPos > *)
(*Call Function selected Teach Pos to HMI *)
FBTeachPosToHMI(	iAxisNr:= 1,
					iSelectPos:= T_ExchgParam.T_TeachIn.arAxis[gciAxisZ_St1].iTeachSelPos,
					rSetPos:= T_ExchgParam.T_TeachIn.arAxis[gciAxisZ_St1].rSetPos,
					TeachPosWork:= T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess);
T_ExchgParam.T_TeachIn.arAxis[gciAxisZ_St1].rTeachPosStored:=FBTeachPosToHMI.rPosition;
END_ACTION

ACTION	Monitor_FctButton_Led:
(* Aktivierungsanzeige der Funktionstasten *)
wTmp:=0;
CASE T_Visu.T_PlcParam.dwActualPage OF
	gT_PageNumber.iAutoMode_Process:
		(* F1-->Endlos Prozess EIN/AUS *)
		IF T_NovRAM.T_Parameter.T_Machine.xEndlessProcessActive THEN wTmp:=wTmp OR 16#1; END_IF;
		(* F2-->Zentrieren EIN/AUS *)
		IF gxCentringActive THEN wTmp:=wTmp OR 16#2; END_IF;
		(* F3-->NurZentrieren EIN/AUS *)
		IF gxOnlyCentringActive THEN wTmp:=wTmp OR 16#4; END_IF;
		(* F4-->Suspension EIN/AUS *)
		IF NOT(TStation_Work_St1.THWWorkStation.TAxisBubbler.T_CtrleDCAxis.xNotMoving) OR NOT(TStation_Work_St1.THWWorkStation.TAxisFeedPump.T_CtrleDCAxis.xNotMoving) THEN wTmp:=wTmp OR 16#8; END_IF;
		(* F5-->ZylWPUnfix EIN/AUS *)
		IF QxCylWPUnfix_St1 THEN wTmp:=wTmp OR 16#10; END_IF;
	gT_PageNumber.iAutoMode_Referencing:
		(* F1-->Spindelkalibrierung EIN/AUS St1 *)
		IF  gxSpindelCalibrationONOFF_St1 THEN
			wTmp:=wTmp OR 16#1;
		END_IF;
	gT_PageNumber.iAutoMode_ToolChange:
		(* F1-->Station 1 WzWechsel Zähler zurücksetzen *)
		IF xProcessStation1ResetToolChange THEN wTmp:=wTmp OR 16#1; END_IF
		(* F2-->Z WzWechselPos *)
		IF xZAxisMoveToToolChangePos THEN wTmp:=wTmp OR 16#2; END_IF
		(* F3-->Z LadePos *)
		IF xZAxisMoveToLoadPos THEN wTmp:=wTmp OR 16#4; END_IF
		(* F4-->Auswahl Anzeige Ink Werte Bearbeitung *)
		IF (T_ExchgParam.T_StationCommon.bSelectShowIncValue = 0) THEN wTmp:=wTmp OR 16#8; END_IF;
		(* F5-->Auswahl Anzeige Ink Werte Bearbeitung *)
		IF (T_ExchgParam.T_StationCommon.bSelectShowIncValue = 1) THEN wTmp:=wTmp OR 16#10; END_IF;
		(* F6-->Speichern Z EndPos Berechnet *)
		IF xZSaveEndPosCalc THEN wTmp:=wTmp OR 16#20; END_IF;
	gT_PageNumber.iAutoMode_SafetyCheck:
		(* F1-->Türzuhaltung *)
		IF QxCabinDoorLock THEN wTmp:=wTmp OR 16#1; END_IF

	gT_PageNumber.iHandMode_RegulatorPara:
		(* F1-->Konv.Regler *)
		IF (T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.iWorkControlType <= 1) THEN wTmp:=wTmp OR 16#1; END_IF
		(* F2-->Adapt.Vorschub Regler *)
		IF (T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.iWorkControlType = 2) THEN wTmp:=wTmp OR 16#2; END_IF
		(* F1-->Konv.PD Regler *)
		IF (T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.iWorkControlType = 3) THEN wTmp:=wTmp OR 16#4; END_IF

	gT_PageNumber.iHandMode_ConfigPosition:
		(* F1-->Position Führungsrohr *)
		IF (T_ExchgParam.T_StationCommon.iSelectConfigPosition = 1) THEN wTmp:=wTmp OR 16#1; END_IF
		(* F2-->Abstand Führungsrohr *)
		IF (T_ExchgParam.T_StationCommon.iSelectConfigPosition = 2) THEN wTmp:=wTmp OR 16#2; END_IF
		(* F3-->Werkzeug *)
		IF (T_ExchgParam.T_StationCommon.iSelectConfigPosition = 3) THEN wTmp:=wTmp OR 16#4; END_IF
		(* F4-->Führungsrohr Einsatz *)
		IF (T_ExchgParam.T_StationCommon.iSelectConfigPosition = 4) THEN wTmp:=wTmp OR 16#8; END_IF
		(* F5-->KonfigPos EIN/AUS *)
		IF T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.xConfigActive THEN wTmp:=wTmp OR 16#10; END_IF
	gT_PageNumber.iWorkStation_Axis1:
		(* F1-->Zustand Achsenstrom ON/OFF *)
		IF ptrTCommonAxis^.T_CtrleSingle.xPower THEN wTmp:=wTmp OR 16#1; END_IF;
		(* F2-->Achse ist am resetten *)
		IF  (ptrTCommonAxis^.T_CtrleSingle.iFunction = 1) AND NOT( ptrTCommonAxis^.T_CtrleSingle.xDone) AND NOT( ptrTCommonAxis^.T_CtrleSingle.xErr) THEN
			wTmp:=wTmp OR 16#2;
		END_IF;
		IF (ptrTCommonAxis^.T_Config_Gen.iTyp = 1) THEN
			(* F5-->KonfigPos EIN/AUS *)
			IF T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.xConfigActive THEN wTmp:=wTmp OR 16#10; END_IF
			(* F6-->Speichervorgang aktiv *)
			IF xAxisTeachPosition THEN wTmp:=wTmp OR 16#20; END_IF;
		END_IF;
	gT_PageNumber.iWorkStation_Setup4:
		(* F3-->Zustand Zyl Drehmoment *)
		IF TStation_Work_St1.THWWorkStation.TCylToolTorqueHC.T_CtrleCyl.T_Analog.xActiv THEN wTmp:=wTmp OR 16#4; END_IF;
		(* F4-->Zustand Zyl Drehmoment Überlast *)
		IF TStation_Work_St1.THWWorkStation.TCylToolTorqueOverload.T_CtrleCyl.T_Analog.xActiv THEN wTmp:=wTmp OR 16#8; END_IF;
END_CASE;
T_ExchgParam.T_BtFunctionPanel.wState:=wTmp;
END_ACTION

ACTION	Monitor_Function:
IF (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iHandMode_Setup1) THEN
(* Setup Potentiometer *)
	T_ExchgParam.T_FunctionCommon.adiPotentiometerValue:=
										T_NovRam.T_Parameter.T_Machine.adiPotentiometerValue;
	T_ExchgParam.T_FunctionCommon.adiPotentiometerValue[11]:=
										T_NovRam.T_Parameter.T_Machine.adiPotentiometerValue[11]:=
										IiASpeedServoDrive;
END_IF;
END_ACTION

ACTION	Monitor_Station:
(* Monitoring von Station 1-->Bearbeitungsstation MicroHead *)
IF (TStation_Work_St1.TControl.diErrorNr <> 0) THEN
	T_ExchgParam.T_Station1.diErrorNr:=TStation_Work_St1.TControl.diErrorNr;
ELSE
	T_ExchgParam.T_Station1.diErrorNr:=0;
END_IF;
T_ExchgParam.T_Station1.iProfile:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iProfile;
T_ExchgParam.T_Station1.sProfileName:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.sProfileName;
T_ExchgParam.T_StationCommon.T_Param_Machine.T_ParamAutomat.tActualActiveTime_St1:=T_NovRAM.T_Parameter.T_Machine.T_ParamAutomat.tActualActiveTime_St1;
T_ExchgParam.T_StationCommon.T_Param_Machine.T_ParamAutomat.iActualActiveTime_St1:=T_NovRAM.T_Parameter.T_Machine.T_ParamAutomat.iActualActiveTime_St1;
T_ExchgParam.T_Station1.xExist:=TRUE;
T_ExchgParam.T_Station1.xActiv:=TRUE;
T_ExchgParam.T_Station1.wState:=16#0;
IF TStation_Work_St1.TControl.xEnable AND TStation_Work_St1.TControl.xRdy AND TStation_Work_St1.TControl.xReferenced THEN
	T_ExchgParam.T_Station1.wState:=T_ExchgParam.T_Station1.wState OR 16#1;		(* Maschine ist Referenziert *)
ELSE
	T_ExchgParam.T_Station1.wState:=T_ExchgParam.T_Station1.wState AND 16#FE;
END_IF;
IF (NOT(TStation_Work_St1.TControl.xDone) AND NOT(TStation_Work_St1.TControl.xError)) THEN
	T_ExchgParam.T_Station1.wState:=T_ExchgParam.T_Station1.wState OR 16#2;		(* Stationsfunktion Aktiv *)
ELSE
	T_ExchgParam.T_Station1.wState:=T_ExchgParam.T_Station1.wState AND 16#FD;
END_IF;
IF TStation_Work_St1.TControl.xError THEN
	T_ExchgParam.T_Station1.wState:=T_ExchgParam.T_Station1.wState OR 16#4;		(* Stationsfehler Aktiv *)
ELSE
	T_ExchgParam.T_Station1.wState:=T_ExchgParam.T_Station1.wState AND 16#FB;
END_IF;

ptrActivStation:=ADR(TStation_Work_St1);
T_ExchgParam.T_StationCommon.wState:=T_ExchgParam.T_Station1.wState;
END_ACTION

ACTION	ProfileManagement:
(* Pointer Profile List Up/Down *)
	RisingEdgePtrProfileListUpDown(CLK:=	T_ExchgParam.T_ProfileCommon.T_ProfileManage.xListProfileUp
										OR T_ExchgParam.T_ProfileCommon.T_ProfileManage.xListProfileDown);
	IF RisingEdgePtrProfileListUpDown.Q THEN
		IF T_ExchgParam.T_ProfileCommon.T_ProfileManage.xListProfileUp THEN
			T_TempActiveState.iPtrListProfile:=T_TempActiveState.iPtrListProfile-5;
			ELSE T_TempActiveState.iPtrListProfile:=T_TempActiveState.iPtrListProfile+5; END_IF
		(* min/max=1/6 *)
		IF T_TempActiveState.iPtrListProfile>(csiMaxProfile - 5) THEN T_TempActiveState.iPtrListProfile:=(csiMaxProfile - 4); END_IF
		IF T_TempActiveState.iPtrListProfile<0 THEN T_TempActiveState.iPtrListProfile:=1; END_IF
		T_ExchgParam.T_ProfileCommon.T_ProfileManage.xListProfileUp:=FALSE;
		T_ExchgParam.T_ProfileCommon.T_ProfileManage.xListProfileDown:=FALSE;
		(* Update display  list *)
		xUpdateProfileList:=TRUE;
	END_IF

(* Update profile list *)
	IF xUpdateProfileList THEN
		xTmp:= 	T_TempActiveState.iPtrListProfile > 0
				AND (T_TempActiveState.iPtrListProfile+4) <= csiMaxProfile;
		IF xTmp THEN
			jj:=1;
			FOR ii:=T_TempActiveState.iPtrListProfile TO T_TempActiveState.iPtrListProfile+4 DO
				T_ExchgParam.T_ProfileCommon.T_ProfileList[jj].iNumber:=ii;
				T_ExchgParam.T_ProfileCommon.T_ProfileList[jj].sName:=T_Profile.T_IDProfileStation[ii].sName;
				jj:=jj+1;
			END_FOR
		END_IF
		(* confirm update *)
		xUpdateProfileList:=FALSE;
		FOR ii:=1 TO 100 DO
			IF (T_Profile.T_IDProfileStation[ii].sName = '') THEN
				T_NovRam.T_Parameter.arZ1AxisCalcEndPosSaveProfile[1,ii]:=0;		(* Wenn kein Profil gespeichert ist, dann kann das zugehörige Inkrementzähler gelöscht werden *)
				T_NovRam.T_Parameter.arZ1CentringCalcEndPosSaveProfile[1,ii]:=0;	(* Wenn kein Profil gespeichert ist, dann kann das zugehörige Inkrementzähler gelöscht werden *)
			END_IF;
		END_FOR;
	END_IF

(* monitor change actual profile common *)
	IF (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iHandMode_ProfileMngmt1) OR (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iAutoMode_Profile) THEN
		IF T_ExchgParam.T_ProfileCommon.T_Id.iNumber<>iActualActiveProfile THEN
			IF T_Visu.T_CtrleAction.xDone THEN
				(* set value from selected profile *)
				(* save value *)
				T_TempActiveState.iActiveProfile:=T_ExchgParam.T_ProfileCommon.T_Id.iNumber;
				T_ExchgParam.T_ProfileCommon.T_Id.sName
					:=T_Profile.T_IDProfileStation[T_ExchgParam.T_ProfileCommon.T_Id.iNumber].sName;
				iActualActiveProfile:=T_ExchgParam.T_ProfileCommon.T_Id.iNumber;
			END_IF
		END_IF
	END_IF

(* Compare Profile and Process value *)
	T_Profile.T_ProcProfileParameter.T_ProzessData:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess;
	T_Profile.T_ProcProfileParameter.T_ProfileOnlineChange:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange;

	fbCompareProfileProcessValue(	T_LoadProfileParameter:=T_Profile.T_LoadProfileParameter,
									T_ProfileParameter:=T_Profile.T_ProcProfileParameter);
	T_ExchgParam.T_StationCommon.T_Param_StationWork.T_InfoProcess.xOnlineValueModified:=fbCompareProfileProcessValue.xProcessValueModified;


	T_Profile.T_ProcProfileParameter.T_ProzessData:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess;
	T_Profile.T_ProcProfileParameter.T_ProfileOnlineChange:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange;

	fbCompareProfileProcessValue(	T_LoadProfileParameter:=T_Profile.T_LoadProfileParameter,
									T_ProfileParameter:=T_Profile.T_ProcProfileParameter);

	T_ExchgParam.T_StationCommon.xOnlineValueModified_St1:=fbCompareProfileProcessValue.xProcessValueModified;



END_ACTION

ACTION	ResetVisu:
(* waiting for reset *)
	RisingEdgeReset(CLK:=T_Visu.T_CtrleVisu.xReset);
	IF RisingEdgeReset.Q THEN
		(* call functionblock init. *)
		fbQvisInitPage(	T_Visu:=T_Visu);
		T_Visu.T_CtrleVisu.xDone:=FALSE;
		T_Visu.T_CtrleVisu.iFunction:=0;
		T_Visu.T_CtrleVisu.xErr:=FALSE;
		T_Visu.T_CtrleVisu.udiErrorID:=0;
		T_Visu.T_PlcParam.dwSetNewPage:=0;
		T_Visu.T_PlcParam.dwActualPage:=0;
		T_Visu.T_PlcParam.dwPreviousPage:=0;
		T_ExchgParam.T_Visu.iQVisActivNewPage:=0;
		T_ExchgParam.T_TeachIn.iSetup_AxisSel:=1;
		T_ExchgParam.T_StationCommon.xBlockSelectAutoMode:=FALSE;
		InitSavePages;
		awSaveStateTaskBar[0]:=awSaveStateTaskBar[1]:=awSaveStateTaskBar[2]:=awSaveStateTaskBar[3]:=awSaveStateTaskBar[4]:=1;
		iSaveSetupMode:=1;
		(* Activ reset structure control action *)
		T_Visu.T_CtrleAction.xReset:=TRUE;
		(* Activ reset structure control process *)
		T_Visu.T_CtrleProcess.xReset:=TRUE;
		RisingEdgeReseTProcess(CLK:=FALSE);
		(* active confirmation *)
		xConfirmResetFB:=TRUE;
		(* exit function bloc *)
		RETURN;
	ELSE
		IF xConfirmResetFB THEN
			(* confirm reset FB *)
			T_Visu.T_CtrleVisu.xDone:=TRUE;
			T_Visu.T_CtrleVisu.xErr:=FALSE;
			T_Visu.T_CtrleVisu.udiErrorID:=0;
			(* reset variable *)
			xConfirmResetFB:=FALSE;
			(* activ research if Qvis is activ *)
			xQvisActiv:=TRUE;
			T_Visu.T_CtrleVisu.xQvis:=FALSE;
			dwInCount_QVisCmd:=T_CtrleQVis.dwInCount;
		END_IF
	END_IF;
END_ACTION

ACTION	UserLevel:
	RisingEdgeCheckPasswordPage(CLK:=(T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iAutoMode_UserLevel));
	IF RisingEdgeCheckPasswordPage.Q OR xChangeRandomValue THEN
		xChangeRandomValue:=FALSE;
		(* Der Counter respektive Random muss 9 Stellig sein welches aus dem Zyklusticker der CPU ausgelesen wird *)
		fbGetCpuAccount;
		FBPassword_SystemLevel(	dwCounterHI:= fbGetCpuAccount.cpuCntHiDW,
								dwCounterLOW:=fbGetCpuAccount.cpuCntLoDW);
		T_ExchgParam.T_Visu.T_Level.diRandom:=FBPassword_SystemLevel.diRandom;
	END_IF;
(* Monitor password divers level *)
	(* set Standard Level *)
	RisingEdgeStandardLevel(CLK:=(T_ExchgParam.T_Visu.T_Level.iActLevel = 0));
	IF RisingEdgeStandardLevel.Q THEN
		xChangeRandomValue:=TRUE;
		T_ExchgParam.T_Visu.T_Message.iState:=31;			(* Info: Sie sind nun als Standard angemeldet *)
	END_IF;
	(* set Operator Level *)
	IF T_ExchgParam.T_Visu.T_Level.diPwOperator <> -1 THEN
		IF T_ExchgParam.T_Visu.T_Level.diPwOperator = T_ExchgParam.T_Visu.T_Level.diPwOperatorSaved THEN
		(* pw correct *)
			T_ExchgParam.T_Visu.T_Level.iActLevel:=1;
			T_ExchgParam.T_Visu.T_Message.iState:=1;			(* Info: Sie sind nun als Operator angemeldet *)
		(* wrong pw *)
		ELSE 	T_ExchgParam.T_Visu.T_Message.iState:=204;	(* Warnung: Falsches Operator Passwort *) END_IF
		T_ExchgParam.T_Visu.T_Level.diPwOperator:=-1;
		xChangeRandomValue:=TRUE;
	END_IF;
	(* set system level *)
	IF T_ExchgParam.T_Visu.T_Level.diPwSystem <> -1 THEN
		IF T_ExchgParam.T_Visu.T_Level.diPwSystem = FBPassword_SystemLevel.diPwSystem THEN
		(* pw correct *)
			T_ExchgParam.T_Visu.T_Level.iActLevel:=2;
			T_ExchgParam.T_Visu.T_Message.iState:=2;			(* Info: Sie sind nun als System angemeldet *)
		(* wrong pw *)
		ELSE 	T_ExchgParam.T_Visu.T_Message.iState:=205; 		(* Warnung: Falsches System Passwort *) END_IF
		T_ExchgParam.T_Visu.T_Level.diPwSystem:=-1;
		xChangeRandomValue:=TRUE;
	END_IF

	IF (T_ExchgParam.T_Visu.T_Level.iActLevel > 1) THEN
		T_ExchgParam.T_StationCommon.xSystemLevelActive:=TRUE;
	ELSE
		T_ExchgParam.T_StationCommon.xSystemLevelActive:=FALSE;
	END_IF;
END_ACTION

ACTION	VisuFunction_Axis:
	xTmp:=	xAxisStop OR xAxisStopAll OR xAxisTogglePower OR
			xAxisReset OR xAxisMoveContinous OR xAxisMoveAbsolut OR
			xAxisMoveRelative OR xAxisTeachPosition;

	T_ExchgParam.T_TeachIn.xDisableAxisSelectButton:=xTmp;	(* Auswahl der Achsen muss gesperrt werden im Fall einer Aktiven VisuFunktion für Achsen *)

	IF IxJoystick_X_Plus THEN
		T_ExchgParam.T_TeachIn.xJogInc_Common_Setup_Axis:=TRUE;
		T_ExchgParam.T_Visu.T_Message.iState:=35;	(* Info: Achsen auf Jog Bewegung gesetzt ! *)
	END_IF;
	IF IxJoystick_X_Minus THEN
		T_ExchgParam.T_TeachIn.xJogInc_Common_Setup_Axis:=FALSE;
		T_ExchgParam.T_Visu.T_Message.iState:=34;	(* Info: Achsen auf Ink Bewegung gesetzt ! *)
	END_IF;

(* Bewegung einer Achse stoppen *)
	IF xAxisStop THEN
		(* Step stop axis *)
		CASE iStepAction OF
		(* check Ressource *)
		1:	xTmp:=	TRUE;
			IF xTmp THEN
				(* next Step *)
				iStepAction :=10;
				xStepActionDone:=FALSE;
			(* activ error *)
			ELSE
				iStepAction:=95;
			END_IF
			xAxisMoveContinous:=FALSE;
		(* stop axis *)
		10:	ptrTCommonAxis^.T_CtrleSingle.iFunction:=5;
			ptrTCommonAxis^.T_CtrleSingle.xExecute:=TRUE;
			(* next step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* waiting stop confirmation *)
		20:	IF NOT(xStepActionDone) THEN
			(* release execution *)
				ptrTCommonAxis^.T_CtrleSingle.xExecute:=FALSE;
				(* confirm step *)
				xStepActionDone:=TRUE;
			ELSE
				IF ptrTCommonAxis^.T_CtrleSingle.xDone THEN
				(* next step *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
					T_ExchgParam.T_Visu.T_Message.iState:=277;	(* Warnung: Achse wurde gestoppt ! *)
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xAxisStop:=FALSE;
		(* axis not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xAxisStop:=FALSE;
		END_CASE
	END_IF;

(* Bewegung aller Achse stoppen *)
	IF xAxisStopAll THEN
		(* Step stop axis *)
		CASE iStepAction OF
		(* check Ressource *)
		1:	xTmp:=	TRUE;
			IF xTmp THEN
				(* next Step *)
				iStepAction :=10;
				xStepActionDone:=FALSE;
			(* activ error *)
			ELSE
				iStepAction:=95;
			END_IF
			xAxisMoveContinous:=FALSE;
		(* stop axis *)
		10:	IF xAxisStopAll THEN
				ptrTAxisZ_St1^.T_CtrleSingle.iFunction:=5;
				ptrTAxisZ_St1^.T_CtrleSingle.xExecute:=TRUE;
				ptrTAxisS_St1^.T_CtrleSingle.iFunction:=5;
				ptrTAxisS_St1^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			(* next step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* waiting stop confirmation *)
		20:	IF NOT(xStepActionDone) THEN
			(* release execution *)
				(* confirm step *)
				xStepActionDone:=TRUE;
			ELSE
				IF ptrTAxisZ_St1^.T_CtrleSingle.xDone AND ptrTAxisS_St1^.T_CtrleSingle.xDone THEN
				(* next step *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
					T_ExchgParam.T_Visu.T_Message.iState:=277;	(* Warnung: Achse wurde gestoppt ! *)
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xAxisStopAll:=FALSE;
		(* axis not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xAxisStopAll:=FALSE;
		END_CASE
	END_IF;

(* Achsen Drehmoment Ein/Aus Toggeln *)
	IF xAxisTogglePower THEN
		(* Step toogle axis power *)
		CASE iStepAction OF
		(* check axis *)
		1:	xTmp:=	ptrTCommonAxis^.T_CtrleSingle.xDone
					AND ptrTCommonAxis^.T_CtrleSingle.xNotMoving
					AND NOT(ptrTCommonAxis^.T_CtrleSingle.xErr)
					AND NOT(ptrTCommonAxis^.T_CtrleSingle.xExecute);
			IF xTmp THEN
				iStepAction:=10;
			ELSE
				iStepAction:=95;
			END_IF
		(* activ function axis *)
		10:	IF ptrTCommonAxis^.T_CtrleSingle.xPower THEN ptrTCommonAxis^.T_CtrleSingle.iFunction:=4;
				ELSE ptrTCommonAxis^.T_CtrleSingle.iFunction:=3; END_IF
			ptrTCommonAxis^.T_CtrleSingle.xExecute:=TRUE;
			(* next step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		20:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				ptrTCommonAxis^.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF ptrTCommonAxis^.T_CtrleSingle.xDone THEN
					IF (ptrTCommonAxis^.T_CtrleSingle.iFunction = 3) THEN
						T_ExchgParam.T_Visu.T_Message.iState:=7;	(* Info: Achsenstrom EIN ! *)
					ELSE
						T_ExchgParam.T_Visu.T_Message.iState:=8;	(* Info: Achsenstrom AUS ! *)
					END_IF
				(* confirm action next step *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xAxisTogglePower:=FALSE;
		(* Axis not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xAxisTogglePower:=FALSE;
		END_CASE
	END_IF

(* Achse Resetten *)
	IF xAxisReset THEN
		(* Step reset axis *)
		CASE iStepAction OF
		(* check axis *)
		1:	xTmp:=	NOT(ptrTCommonAxis^.T_CtrleSingle.xExecute);
			IF xTmp THEN
				iStepAction:=10;
			ELSE iStepAction:=95;
			END_IF
		(* activ function axis *)
		10:	ptrTCommonAxis^.T_CtrleSingle.iFunction:=1;
			ptrTCommonAxis^.T_CtrleSingle.xExecute:=TRUE;
			(* next step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		20:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				ptrTCommonAxis^.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF ptrTCommonAxis^.T_CtrleSingle.xDone THEN
					T_ExchgParam.T_Visu.T_Message.iState:=9;	(* Info: Achse erfolgreich Zurückgesetzt ! *)
				(* confirm action next step *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xAxisReset:=FALSE;
		(* Axis not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xAxisReset:=FALSE;
		END_CASE
	END_IF

(* Achse Geschwindigkeitsmodus *)
	IF xAxisMoveContinous THEN
		(* Step move continuous velocity *)
		CASE iStepAction OF
		(* check axis *)
		1:	xTmp:=	ptrTCommonAxisActive^.T_CtrleSingle.xDone
					AND ptrTCommonAxisActive^.T_CtrleSingle.xReady
					AND ptrTCommonAxisActive^.T_CtrleSingle.xNotMoving
					AND NOT(ptrTCommonAxisActive^.T_CtrleSingle.xErr)
					AND NOT(ptrTCommonAxisActive^.T_CtrleSingle.xExecute);
			IF (ptrTCommonAxisActive^.T_CtrleSingle.lrVelocity = 0) THEN
				(* Geschwindigkeit darf nicht 0 sein *)
				iStepAction:=90;
				T_ExchgParam.T_Visu.T_Message.iState:=288;	(* Warnung: Geschwindigkeit muss grösser als 0 sein ! *)
				RETURN;
			END_IF;
			IF xTmp THEN
				iStepAction:=10;
			ELSE
				iStepAction:=95;
			END_IF
		(* activ function axis *)
		10:	ptrTCommonAxisActive^.T_CtrleSingle.iFunction:=6;
			ptrTCommonAxisActive^.T_CtrleSingle.xExecute:=TRUE;
			ptrTCommonAxisActive^.T_CtrleSingle.lrAcceleration:=TCommonTeachParameter.rAcceleration;
			ptrTCommonAxisActive^.T_CtrleSingle.lrDecceleration:=TCommonTeachParameter.rDeceleration;
			ptrTCommonAxisActive^.T_CtrleSingle.lrJerk:=TCommonTeachParameter.rJerk;
			(* next step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
			T_ExchgParam.T_Visu.T_Message.iState:=14;	(* Info: Achsenbewegung gestartet ! *)
		(* confirm execution *)
		20:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				ptrTCommonAxisActive^.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF ptrTCommonAxisActive^.T_CtrleSingle.xDone THEN
					xStepActionDone:=FALSE;
					(* confirm action next step *)
					iStepAction:=90;
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xAxisMoveContinous:=FALSE;
		(* axis not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xAxisMoveContinous:=FALSE;
		END_CASE
	END_IF

(* Achse Absolute Positionsbewegung *)
	IF xAxisMoveAbsolut THEN
		(* Step move abs position *)
		CASE iStepAction OF
		(* check axis *)
		1:	xTmp:=	ptrTCommonAxis^.T_CtrleSingle.xDone
					AND ptrTCommonAxis^.T_CtrleSingle.xReady
					AND ptrTCommonAxis^.T_CtrleSingle.xNotMoving
					AND NOT(ptrTCommonAxis^.T_CtrleSingle.xErr)
					AND NOT(ptrTCommonAxis^.T_CtrleSingle.xExecute);
			IF xTmp THEN
				IF NOT(ptrTCommonAxis^.T_CtrleSingle.xRef) THEN
					T_ExchgParam.T_Visu.T_Message.iState:=206;	(* Warnung: Ausgewählte Achse ist nicht referenziert ! *)
					iStepAction:=90;
				ELSE
					iStepAction:=10;
				END_IF
			ELSE
				iStepAction:=95;
			END_IF;
		(* waiting confirmation *)
		10:	(* init. acc/dec/jerk *)
			ptrTCommonAxis^.T_CtrleSingle.lrAcceleration:=TCommonTeachParameter.rAcceleration;
			ptrTCommonAxis^.T_CtrleSingle.lrDecceleration:=TCommonTeachParameter.rDeceleration;
			ptrTCommonAxis^.T_CtrleSingle.lrJerk:=TCommonTeachParameter.rJerk;
			ptrTCommonAxis^.T_CtrleSingle.lrVelocity:=TCommonTeachParameter.rPositionSpeed;
			ptrTCommonAxis^.T_CtrleSingle.lrPosition:=TCommonTeachParameter.rRefPosition;
			ptrTCommonAxis^.T_CtrleSingle.xExecute:=TRUE;
			ptrTCommonAxis^.T_CtrleSingle.iFunction:=7;
			iStepAction:=20;
			xStepActionDone:=FALSE;
			IF NOT(xAxisLimitSwitchActive) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=15;	(* Info: Achse fährt auf ausgewählte Position ! *)
			END_IF;
			gxAxisAbsolutMovementActive:=TRUE;	(* Damit die Achsen mit dem Override gesetzt werden bezüglich der Absoluten Bewegung *)
		(* confirm execution *)
		20:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				ptrTCommonAxis^.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF ptrTCommonAxis^.T_CtrleSingle.xDone THEN
					xStepActionDone:=FALSE;
					(* confirm action next step *)
					iStepAction:=90;
					IF NOT(xAxisLimitSwitchActive) THEN
						T_ExchgParam.T_Visu.T_Message.iState:=16;	(* Info: Achsenposition erreicht ! *)
					END_IF;
				END_IF
			END_IF;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xAxisMoveAbsolut:=FALSE;
		(* axis not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xAxisMoveAbsolut:=FALSE;
		END_CASE
	END_IF

(* Achse Relative Positionsbewegung *)
	IF xAxisMoveRelative THEN
		(* Step move abs position *)
		CASE iStepAction OF
		(* check axis *)
		1:	xTmp:=	ptrTCommonAxisActive^.T_CtrleSingle.xDone
					AND ptrTCommonAxisActive^.T_CtrleSingle.xReady
					AND ptrTCommonAxisActive^.T_CtrleSingle.xNotMoving
					AND NOT(ptrTCommonAxisActive^.T_CtrleSingle.xErr)
					AND NOT(ptrTCommonAxisActive^.T_CtrleSingle.xExecute);
			IF xTmp THEN
				iStepAction:=10;
			ELSE
				iStepAction:=95;
			END_IF;
		(* Überprüfe Software Endschalter *)
		10:	IF ptrTCommonAxisActive^.T_CtrleSingle.xSWLimitSwitchPosActivated THEN
				IF ((ptrTCommonAxisActive^.T_LiveValue.lrActualPosition + ptrTCommonAxisActive^.T_CtrleSingle.lrDistance) > 0.1) THEN
					(* Überschreibe den Inkrement, damit die Achse nicht einen Fehler auswertet! Melde es dann als Softwareendschalter *)
					ptrTCommonAxisActive^.T_CtrleSingle.lrDistance:=0.09 - ptrTCommonAxisActive^.T_LiveValue.lrActualPosition;
					IF ((ptrTCommonAxisActive^.T_LiveValue.lrActualPosition + 0.01) >= 0.1) THEN
						ptrTCommonAxisActive^.T_CtrleSingle.lrDistance:=0.0;
					END_IF;
				END_IF;
			END_IF;
			iStepAction:=20;
		(* waiting confirmation *)
		20:	(* init. acc/dec/jerk *)
			ptrTCommonAxisActive^.T_CtrleSingle.lrAcceleration:=TCommonTeachParameter.rAcceleration;
			ptrTCommonAxisActive^.T_CtrleSingle.lrDecceleration:=TCommonTeachParameter.rDeceleration;
			ptrTCommonAxisActive^.T_CtrleSingle.lrJerk:=TCommonTeachParameter.rJerk;
			ptrTCommonAxisActive^.T_CtrleSingle.iFunction:=8;	(* Relative Bewegung *)
			ptrTCommonAxisActive^.T_CtrleSingle.xExecute:=TRUE;
			iStepAction:=30;
			xStepActionDone:=FALSE;
			IF NOT(xAxisLimitSwitchActive) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=21;	(* Info: Achse relative Bewegung gestartet ! *)
			END_IF;
		(* confirm execution *)
		30:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				ptrTCommonAxisActive^.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF ptrTCommonAxisActive^.T_CtrleSingle.xDone THEN
					xStepActionDone:=FALSE;
					(* confirm action next step *)
					iStepAction:=90;
					IF NOT(xAxisLimitSwitchActive) THEN
						T_ExchgParam.T_Visu.T_Message.iState:=22;	(* Info: Achse relative Bewegung durchgeführt ! *)
					END_IF;
				END_IF
			END_IF;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xAxisMoveRelative:=FALSE;
		(* axis not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xAxisMoveRelative:=FALSE;
		END_CASE
	END_IF

(* Z Achse auf WzWechsel Pos oder auf Z Achse auf LadePos setzen *)
	IF xZAxisMoveToToolChangePos OR xZAxisMoveToLoadPos THEN
		(* Step move abs position *)
		CASE iStepAction OF
		(* check axis *)
		1:	xTmp:=	ptrTCommonAxisActive^.T_CtrleSingle.xDone
					AND ptrTCommonAxisActive^.T_CtrleSingle.xReady
					AND ptrTCommonAxisActive^.T_CtrleSingle.xNotMoving
					AND NOT(ptrTCommonAxisActive^.T_CtrleSingle.xErr)
					AND NOT(ptrTCommonAxisActive^.T_CtrleSingle.xExecute);
			IF xTmp THEN
				IF NOT(ptrTCommonAxisActive^.T_CtrleSingle.xRef) THEN
					T_ExchgParam.T_Visu.T_Message.iState:=206;	(* Warnung: Ausgewählte Achse ist nicht referenziert ! *)
					iStepAction:=90;
				ELSE
					iStepAction:=5;
					T_ExchgParam.T_Visu.T_Message.iState:=109;	(* Aufforderung: Z Achse Position anfahren <Enter>, abbrechen <Esc> ? *)
				END_IF
			ELSE
				iStepAction:=95;
			END_IF;
		(* Set Value *)
		5:	IF RisingEdgeKeyPanel_Enter.Q THEN
				(* Display message *)
				tTimeOutAction:=T#999999s;
				iStepAction:=10;
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN
					iStepAction:=90;
					T_ExchgParam.T_Visu.T_Message.iState:=202;	(* Warnung: Aktion abgebrochen ! *)
				END_IF
			END_IF
			(* An other message has been displayed *)
			IF (T_ExchgParam.T_Visu.T_Message.iState<>3) AND (T_ExchgParam.T_Visu.T_Message.iState<>109) AND (T_ExchgParam.T_Visu.T_Message.iState<>202) THEN iStepAction:=90; END_IF
		(* waiting confirmation *)
		10:	(* init. acc/dec/jerk *)
			ptrTCommonAxisActive^.T_CtrleSingle.xExecute:=TRUE;
			ptrTCommonAxisActive^.T_CtrleSingle.iFunction:=7;
			ptrTCommonAxisActive^.T_CtrleSingle.lrPosition:=rZAxisSelectPosition;
			iStepAction:=20;
			xStepActionDone:=FALSE;
			IF NOT(xAxisLimitSwitchActive) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=15;	(* Info: Achse fährt auf ausgewählte Position ! *)
			END_IF;
			gxAxisAbsolutMovementActive:=TRUE;	(* Damit die Achsen mit dem Override gesetzt werden bezüglich der Absoluten Bewegung *)
		(* confirm execution *)
		20:	IF NOT(xStepActionDone) THEN
			(* confirm execution *)
				ptrTCommonAxisActive^.T_CtrleSingle.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF ptrTCommonAxisActive^.T_CtrleSingle.xDone THEN
					xStepActionDone:=FALSE;
					(* confirm action next step *)
					iStepAction:=90;
					IF NOT(xAxisLimitSwitchActive) THEN
						T_ExchgParam.T_Visu.T_Message.iState:=16;	(* Info: Achsenposition erreicht ! *)
					END_IF;
				END_IF
			END_IF;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xZAxisMoveToToolChangePos:=xZAxisMoveToLoadPos:=FALSE;
		(* axis not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xZAxisMoveToToolChangePos:=xZAxisMoveToLoadPos:=FALSE;
		END_CASE
	END_IF

(* Meldung ausgeben, falls bei den Achse Z  Endschalter angefahren werden *)
	IF T_StartUp.T_State.xCompleted THEN
		IF ptrTAxisZ_St1^.T_CtrleSingle.xHWLimitNeg THEN
			T_ExchgParam.T_Visu.T_Message.iState:=209;	(* Warnung: Z-Achse negativer HW Endschalter angefahren ! *)
		END_IF;
		IF ptrTAxisZ_St1^.T_CtrleSingle.xHWLimitPos THEN
			T_ExchgParam.T_Visu.T_Message.iState:=210;	(* Warnung: Z-Achse positiver HW Endschalter angefahren ! *)
		END_IF;
	END_IF;

	IF (T_ExchgParam.T_Visu.T_Message.iState >= 209) AND (T_ExchgParam.T_Visu.T_Message.iState <= 210) THEN
		xAxisLimitSwitchActive:=TRUE;
	ELSE
		xAxisLimitSwitchActive:=FALSE;
	END_IF;

(* Löschen der berechnete Wert für Wippe des Drehmoment Detection *)
IF xResetRockerValue THEN
	grRockerQualityMin:=grRockerQuality;
	grRockerQualityMax:=grRockerQuality;
	grRockerAmplitudeMin:=grRockerAmplitude;
	grRockerAmplitudeMax:=grRockerAmplitude;
	T_ExchgParam.T_StationCommon.rRockerQuality:=grRockerQuality:=0.0;
	T_ExchgParam.T_StationCommon.rRockerAmplitude:=grRockerAmplitude:=0.0;
	T_ExchgParam.T_StationCommon.diRockerCountHC:=gdiRockerCountHC:=0;
	T_ExchgParam.T_StationCommon.diRockerCountHCTime:=gdiRockerCountHCTime:=0;
	T_Visu.T_CtrleAction.xDone:=TRUE;
	T_Visu.T_CtrleAction.xNotReady:=FALSE;
	T_Visu.T_CtrleAction.xErr:=FALSE;
	T_Visu.T_CtrleAction.udiErrorID:=0;
	xResetRockerValue:=FALSE;
END_IF;

END_ACTION

ACTION	VisuFunction_AxisTeach:
(* Achse Teach Position *)
	IF xAxisTeachPosition THEN
		CASE iStepAction OF
		(* check axis *)
		1:	xTmp:=	ptrTCommonAxis^.T_CtrleSingle.xDone
					AND ptrTCommonAxis^.T_CtrleSingle.xReady
					AND ptrTCommonAxis^.T_CtrleSingle.xNotMoving
					AND NOT(ptrTCommonAxis^.T_CtrleSingle.xErr)
					AND NOT(ptrTCommonAxis^.T_CtrleSingle.xExecute);
			xReferenceState:=ptrTCommonAxis^.T_CtrleSingle.xRef;
			IF xTmp OR gxHardwareOFF OR gxAxisOFF THEN
				IF NOT(xReferenceState) AND NOT(gxHardwareOFF) AND NOT(gxAxisOFF) THEN
					T_ExchgParam.T_Visu.T_Message.iState:=206;	(* Warnung: Ausgewählte Achse ist nicht referenziert ! *)
					iStepAction:=90;
				ELSE
					iStepAction:=2;
				END_IF
			ELSE
				iStepAction:=95;
			END_IF;
		(* Überprüfe zuerst ob die ausgewählte Position teach bar ist *)
		2:	 T_ExchgParam.T_Visu.T_Message.iState:=0;
			CASE T_ExchgParam.T_TeachIn.iSetup_AxisSel  OF
			1:	(* Z Axis *)
				IF NOT(T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.xConfigActive) THEN
					IF (T_ExchgParam.T_TeachIn.arAxis[T_ExchgParam.T_TeachIn.iSetup_AxisSel].iTeachSelPos = 0) THEN
						T_ExchgParam.T_Visu.T_Message.iState:=207;			(* Warnung: Neue Position kann nicht versetzt werden ! *)
					ELSIF (T_ExchgParam.T_TeachIn.arAxis[T_ExchgParam.T_TeachIn.iSetup_AxisSel].iTeachSelPos = 6) THEN
						T_ExchgParam.T_Visu.T_Message.iState:=208;			(* Warnung: Ausgewählte Position kann nicht gespeichert werden ! *)
					END_IF;
				ELSE
					IF (T_ExchgParam.T_TeachIn.arAxis[T_ExchgParam.T_TeachIn.iSetup_AxisSel].iTeachSelPos = 0) THEN
						T_ExchgParam.T_Visu.T_Message.iState:=207;			(* Warnung: Neue Position kann nicht versetzt werden ! *)
					ELSIF (T_ExchgParam.T_TeachIn.arAxis[T_ExchgParam.T_TeachIn.iSetup_AxisSel].iTeachSelPos <= 4) THEN
						T_ExchgParam.T_Visu.T_Message.iState:=208;			(* Warnung: Ausgewählte Position kann nicht gespeichert werden ! *)
					ELSIF (T_ExchgParam.T_TeachIn.arAxis[T_ExchgParam.T_TeachIn.iSetup_AxisSel].iTeachSelPos = 6) THEN
						T_ExchgParam.T_Visu.T_Message.iState:=208;			(* Warnung: Ausgewählte Position kann nicht gespeichert werden ! *)
					END_IF;
				END_IF;
			END_CASE
			IF (T_ExchgParam.T_Visu.T_Message.iState = 0) THEN
				iStepAction:=10;
			ELSE
				(* Action has been cancelled *)
				iStepAction:=90;
			END_IF;
		(* Display message to ask for confirmation *)
		10:	T_ExchgParam.T_Visu.T_Message.iState:=103;	(* Aufforderung: Speichern bestätigen <Enter>, abbrechen <Esc> ? *)
			iStepAction:=20;
		(* waiting for key <Enter> or <Esc> *)
		20:	IF RisingEdgeKeyPanel_Enter.Q THEN
					iStepAction:=30;
			ELSIF RisingEdgeKeyPanel_Esc.Q THEN
					 iStepAction:=90;
					T_ExchgParam.T_Visu.T_Message.iState:=202;	(* Warnung: Aktion abgebrochen ! *)
			 END_IF
			(* An other message has been displayed *)
			IF (T_ExchgParam.T_Visu.T_Message.iState<>103) AND (T_ExchgParam.T_Visu.T_Message.iState<>202) THEN iStepAction:=90; END_IF
		30:	T_ExchgParam.T_Visu.T_Message.iState:=0;
			(*copy actual value to tmp variable*)
			rtmpAxisPosZ:=LREAL_TO_REAL(TStation_Work_St1.THWWorkStation.TAxisZ.T_LiveValue.lrActualPosition);
			CASE T_ExchgParam.T_TeachIn.iSetup_AxisSel  OF
			1:	(* Z Axis *)
				CASE T_ExchgParam.T_TeachIn.arAxis[T_ExchgParam.T_TeachIn.iSetup_AxisSel].iTeachSelPos OF
				(* < Z LadePos > *)
				1:	T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rPositionLoad:=rtmpAxisPosZ;
				(* < Z Bearb StartPos > *)
				2:	T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rPositionStartProc:=rtmpAxisPosZ;
				(* < Z ZentrierPos > *)
				3:	T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rCentringPosZ1Axis:=rtmpAxisPosZ;
				(* < Z Bearb EndPos > *)
				4:	T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rPositionEndProc:=rtmpAxisPosZ;
				(* < Z WzWechsel Pos > *)
				5:	T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rPositionToolChange:=rtmpAxisPosZ;
				(* < Z Bearb EndPos berechn. > *)
				7:	garPositionEndProcCalc[1]:=rtmpAxisPosZ;
					T_ExchgParam.T_StationCommon.rPositionEndProcCalc:=rtmpAxisPosZ;
				(* < Z Bearb EndPos Max > *)
				8:	T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rPositionEndProcMaxInc:=rtmpAxisPosZ;
				(* < Z ZentrierPos berechn. > *)
				9:	garCentringEndProcCalc[1]:=rtmpAxisPosZ;
					T_ExchgParam.T_StationCommon.rCentringEndProcCalc:=rtmpAxisPosZ;
				(* < Z WzZylinder Pos > *)
				10:	T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rZPositionCylindricalArea:=rtmpAxisPosZ;
				END_CASE;
				xUpdateStationParameter:=TRUE;
			END_CASE;
			(* Speichern der Daten in den NovRAM *)
			iStepAction:=70;
		70:	IF (garPositionEndProcCalc[1] <> T_ExchgParam.T_StationCommon.rPositionEndProcCalc) THEN
				T_ExchgParam.T_StationCommon.rPositionEndProcCalc:=garPositionEndProcCalc[1];
			END_IF;
			IF (garCentringEndProcCalc[1] <> T_ExchgParam.T_StationCommon.rCentringEndProcCalc) THEN
				T_ExchgParam.T_StationCommon.rCentringEndProcCalc:=garCentringEndProcCalc[1];
			END_IF;
			xAction_SaveNovRAM:=TRUE;
			xBlockSetNovRamAction_End:=TRUE;
			iStepActionNovRam:=1;
			iStepAction:=80;
		80:	IF NOT(xAction_SaveNovRAM) THEN
				iStepAction:=90;
				T_ExchgParam.T_Visu.T_Message.iState:=25;	(* Info: Ausgewählte Position ist nun gespeichert ! *)
			END_IF;
		(* axis not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xAxisTeachPosition:=FALSE;
		(* slow/fast configuration done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xAxisTeachPosition:=FALSE;
		END_CASE
	END_IF
END_ACTION

ACTION	VisuFunction_ChangePassword:
(* Ändern des Operator Passwortes *)
	IF xChangeOperatorPassword THEN
		CASE iStepAction OF
		(* Display message to ask for confirmation *)
		1:	T_ExchgParam.T_Visu.T_Level.xShow_Overlay_NewPassword:=TRUE;
			T_ExchgParam.T_Visu.T_Level.diInputOldPasword:=0;
			T_ExchgParam.T_Visu.T_Level.diInputNewPasword:=0;
			T_ExchgParam.T_Visu.T_Level.diInputRepeatPasword:=0;
			T_ExchgParam.T_Visu.T_Level.xButton_OK:=FALSE;
			T_ExchgParam.T_Visu.T_Level.xButton_Abord:=FALSE;
			iStepAction:=10;
		10:	IF T_ExchgParam.T_Visu.T_Level.xButton_OK THEN
				T_ExchgParam.T_Visu.T_Level.xButton_OK:=FALSE;
				 tTimeOutAction:=TimerAction.ET+T#3s;
				iStepAction:=20;
			END_IF;
			IF T_ExchgParam.T_Visu.T_Level.xButton_Abord THEN
				T_ExchgParam.T_Visu.T_Level.xButton_Abord:=FALSE;
				iStepAction:=90;
			END_IF;
			IF TimerAction.Q THEN iStepAction:=90; END_IF;
		(* Überprüfe Eingabe des alten Passwort *)
		20:	IF (T_ExchgParam.T_Visu.T_Level.diInputOldPasword = T_ExchgParam.T_Visu.T_Level.diPwOperatorSaved) THEN
				(* Eingabe Korrekt *)
				iStepAction:=30;
			ELSE
				T_ExchgParam.T_Visu.T_Message.iState:=214;	(* Warnung: Altes Operator Passwort falsch eingegeben ! *)
				iStepAction:=90;
			END_IF;
		(* Überprüfe Eingabe des neuen Passwort mit der Eingabe des bestätigten neuen Passwortes *)
		30:	IF (T_ExchgParam.T_Visu.T_Level.diInputNewPasword = T_ExchgParam.T_Visu.T_Level.diInputRepeatPasword) THEN
				(* Eingabe Korrekt *)
				iStepAction:=40;
			ELSE
				T_ExchgParam.T_Visu.T_Message.iState:=215;	(* Warnung: Keine Übereinstimmung der beiden neuen Operator Passwörter ! *)
				iStepAction:=90;
			END_IF;
		(* Speichern des neuen Passwortes *)
		40:	T_Password.T_Ctrle.udiSetOperatorPassword:=T_ExchgParam.T_Visu.T_Level.diInputNewPasword;
			T_Password.T_Ctrle.xExecute:=TRUE;
			T_Password.T_Ctrle.iFunction:=2;
			(* next Step *)
			iStepAction :=50;
			xStepActionDone:=FALSE;
		(* wait save confirmation *)
		50:	IF NOT(xStepActionDone) THEN
				T_Password.T_Ctrle.xExecute:=FALSE;
				(* Überschreiben des alten Passwortes *)
				T_ExchgParam.T_Visu.T_Level.diPwOperatorSaved:=T_ExchgParam.T_Visu.T_Level.diInputNewPasword;
				(* confirm Step *)
				xStepActionDone:=TRUE;
			ELSE
				IF T_Password.T_Ctrle.xDone THEN
				(* next Step *)
					iStepAction :=90;
					xStepActionDone:=FALSE;
					T_ExchgParam.T_Visu.T_Message.iState:=36;	(* Info: Neues Operator Passwort wurde gespeichert und ist Aktiv ! *)
				ELSE	IF T_Password.T_Ctrle.xErr THEN
							iStepAction:=99;
							xStepActionDone:=FALSE;
						END_IF
				END_IF
			END_IF
		(* save done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xChangeOperatorPassword:=FALSE;
			T_ExchgParam.T_Visu.T_Level.xShow_Overlay_NewPassword:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F1000 + T_Password.T_Ctrle.iFunction;
			xChangeOperatorPassword:=FALSE;
			T_ExchgParam.T_Visu.T_Level.xShow_Overlay_NewPassword:=FALSE;
			T_Password.T_Ctrle.xReset:=TRUE;
		END_CASE
	ELSE
		T_ExchgParam.T_Visu.T_Level.xShow_Overlay_NewPassword:=FALSE;
	END_IF
END_ACTION

ACTION	VisuFunction_CylinderValve:
(* Set cylinder analog value *)
	IF xCylSetServoAnalogValue THEN
		(* Step analog Wert *)
		CASE iStepAction OF
		(* check cylinder state *)
		1:	xTmp:=	ptrTCommonCylinderValve^.T_CtrleCyl.xDone
					AND NOT(ptrTCommonCylinderValve^.T_CtrleCyl.xExecute)
					AND NOT(ptrTCommonCylinderValve^.T_CtrleCyl.xErr);
			(* next step *)
			IF xTmp THEN iStepAction:=10; ELSE iStepAction:=95; END_IF
		(* activ function set analog value *)
		10:	ptrTCommonCylinderValve^.T_CtrleCyl.iFunction:=4;
			ptrTCommonCylinderValve^.T_CtrleCyl.xExecute:=TRUE;
			(* next step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* wait confirmation *)
		20:	IF NOT(xStepActionDone) THEN
			(* release execution *)
				ptrTCommonCylinderValve^.T_CtrleCyl.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF ptrTCommonCylinderValve^.T_CtrleCyl.xDone THEN
				(* action done *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
					T_ExchgParam.T_Visu.T_Message.iState:=37;	(* Info: Kraft wurde gesetzt ! *)
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xCylSetServoAnalogValue:=FALSE;
		(* cylinder not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xCylSetServoAnalogValue:=FALSE;
		END_CASE
	END_IF;

(* Zylinder/Ventile Ein/Aus Toggeln *)
	IF xCylValveToggleOnOff THEN
		(* Step toggle Zustand *)
		CASE iStepAction OF
		(* check cylinder state *)
		1:	xTmp:=	ptrTCommonCylinderValve^.T_CtrleCyl.xDone
					AND NOT(ptrTCommonCylinderValve^.T_CtrleCyl.xExecute)
					AND NOT(ptrTCommonCylinderValve^.T_CtrleCyl.xErr);
			(* next step *)
			IF xTmp THEN iStepAction:=10; ELSE iStepAction:=95; END_IF
		(* toggle cylinder state *)
		10:	ptrTCommonCylinderValve^.T_CtrleCyl.iFunction:=51;
			ptrTCommonCylinderValve^.T_CtrleCyl.xExecute:=TRUE;
			IF (ptrTCommonCylinderValve^.iCylinderTpye = 1) THEN
				ptrTCommonCylinderValve^.T_CtrleCyl.T_Analog.rForceIn:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rForceDeflection;
			END_IF;
			IF (ptrTCommonCylinderValve^.iCylinderTpye = 2) THEN
				ptrTCommonCylinderValve^.T_CtrleCyl.T_Analog.rForceIn:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rTorqueLevelHC;
			END_IF;
			IF (ptrTCommonCylinderValve^.iCylinderTpye = 3) THEN
				ptrTCommonCylinderValve^.T_CtrleCyl.T_Analog.rForceIn:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rTorqueLevel_Overload;
				TStation_Work_St1.THWWorkStation.TCylToolTorqueHC.T_CtrleCyl.T_Analog.rForceIn:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rTorqueLevelHC;
			END_IF;
			(* next step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* wait confirmation *)
		20:	IF NOT(xStepActionDone) THEN
			(* release execution *)
				ptrTCommonCylinderValve^.T_CtrleCyl.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF ptrTCommonCylinderValve^.T_CtrleCyl.xDone THEN
				(* action done *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
					T_ExchgParam.T_Visu.T_Message.iState:=38;	(* Info: Zustand des Zylinderausganges wurde gewechselt ! *)
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xCylValveToggleOnOff:=FALSE;
		(* cylinder not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xCylValveToggleOnOff:=FALSE;
		END_CASE
	END_IF;

(* Zylinder Drucklos schalten *)
	IF xCylPressurelessON THEN
		(* Step toggle Zustand *)
		CASE iStepAction OF
		(* check cylinder state *)
		1:	xTmp:=	ptrTCommonCylinderValve^.T_CtrleCyl.xDone
					AND NOT(ptrTCommonCylinderValve^.T_CtrleCyl.xExecute)
					AND NOT(ptrTCommonCylinderValve^.T_CtrleCyl.xErr);
			(* next step *)
			IF xTmp THEN iStepAction:=10; ELSE iStepAction:=95; END_IF
		(* toggle cylinder state *)
		10:	ptrTCommonCylinderValve^.T_CtrleCyl.xReset:=TRUE;	(* Drucklos setzen *)
			(* next step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* wait confirmation *)
		20:	IF NOT(xStepActionDone) THEN
			(* release execution *)
				ptrTCommonCylinderValve^.T_CtrleCyl.xReset:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF ptrTCommonCylinderValve^.T_CtrleCyl.xDone THEN
				(* action done *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
					T_ExchgParam.T_Visu.T_Message.iState:=73;	(* Info: Zylinder ist Drucklos geschaltet ! *)
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xCylPressurelessON:=FALSE;
		(* cylinder not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xCylPressurelessON:=FALSE;
		END_CASE
	END_IF;

(* Zyl WzDrehmoment oder WzDrehmomentÜberlast EIN/AUS *)
	IF xCylTorqueOnOff OR xCylTorqueOverloadOnOff THEN
		(* Step toggle Zustand *)
		IF xCylTorqueOnOff THEN
			ptrTCommonCylinderValveTmp:=ADR(TStation_Work_St1.THWWorkStation.TCylToolTorqueHC);
		ELSE
			ptrTCommonCylinderValveTmp:=ADR(TStation_Work_St1.THWWorkStation.TCylToolTorqueOverload);
		END_IF;
		CASE iStepAction OF
		(* check cylinder state *)
		1:	xTmp:=	ptrTCommonCylinderValveTmp^.T_CtrleCyl.xDone
					AND NOT(ptrTCommonCylinderValveTmp^.T_CtrleCyl.xExecute)
					AND NOT(ptrTCommonCylinderValveTmp^.T_CtrleCyl.xErr);
			(* next step *)
			IF xTmp THEN iStepAction:=10; ELSE iStepAction:=95; END_IF
		(* toggle cylinder state *)
		10:	ptrTCommonCylinderValveTmp^.T_CtrleCyl.iFunction:=51;
			ptrTCommonCylinderValveTmp^.T_CtrleCyl.xExecute:=TRUE;
			IF (ptrTCommonCylinderValveTmp^.iCylinderTpye = 2) THEN
				ptrTCommonCylinderValveTmp^.T_CtrleCyl.T_Analog.rForceIn:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rTorqueLevelHC;
			END_IF;
			IF (ptrTCommonCylinderValveTmp^.iCylinderTpye = 3) THEN
				ptrTCommonCylinderValveTmp^.T_CtrleCyl.T_Analog.rForceIn:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rTorqueLevel_Overload;
				TStation_Work_St1.THWWorkStation.TCylToolTorqueHC.T_CtrleCyl.T_Analog.rForceIn:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rTorqueLevelHC;
			END_IF;
			(* next step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* wait confirmation *)
		20:	IF NOT(xStepActionDone) THEN
			(* release execution *)
				ptrTCommonCylinderValveTmp^.T_CtrleCyl.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF ptrTCommonCylinderValveTmp^.T_CtrleCyl.xDone THEN
				(* action done *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
					T_ExchgParam.T_Visu.T_Message.iState:=38;	(* Info: Zustand des Zylinderausganges wurde gewechselt ! *)
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xCylTorqueOnOff:=xCylTorqueOverloadOnOff:=FALSE;
		(* cylinder not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xCylTorqueOnOff:=xCylTorqueOverloadOnOff:=FALSE;
		END_CASE
	END_IF;
END_ACTION

ACTION	VisuFunction_ErrorManagement:
(* Löschen der Fehlerliste *)
	IF xDeleteErrorList THEN
		(* Step saving NovRAM *)
		CASE iStepAction OF
		(* check NovRAM *)
		1:	xTmp:=	T_NovRAM.T_Ctrle.xDone
					AND NOT(T_NovRAM.T_Ctrle.xExecute)
					AND NOT(T_NovRAM.T_Ctrle.xErr);
			IF xTmp THEN
				(* next Step *)
				iStepAction :=10;
			(* activ error *)
			ELSE iStepAction:=95; END_IF
		10:	(* For delete the error, it need the system level *)
			IF (T_ExchgParam.T_Visu.T_Level.iActLevel <> 2) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=216;	(* Warnung: Diese Parameter können nur auf SystemLevel geändert werden ! *)
				iStepAction:=90;
				RETURN;
			END_IF;
			T_ExchgParam.T_Visu.T_Message.iState:=103;	(* Aufforderung: Speichern bestätigen <Enter>, abbrechen <Esc> ? *)
			(* next Step *)
			iStepAction :=20;
		(* waiting for saving confirmation key <Enter> or <Esc> *)
		20:	IF RisingEdgeKeyPanel_Enter.Q THEN
			(* Display message *)
				T_ExchgParam.T_Visu.T_Message.iState:=3;	(* Info: Start speichern... *)
				(* next step *)
				iStepAction:=30;
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN
					iStepAction:=90;
					T_ExchgParam.T_Visu.T_Message.iState:=202;	(* Warnung: Aktion abgebrochen ! *)
				END_IF
			END_IF
			(* An other message has been displayed *)
			IF (T_ExchgParam.T_Visu.T_Message.iState<>3) AND (T_ExchgParam.T_Visu.T_Message.iState<>103) AND (T_ExchgParam.T_Visu.T_Message.iState<>202) THEN iStepAction:=90; END_IF
		30:	FOR ii:=1 TO 20 DO
				T_NovRAM.T_Parameter.T_ErrorNrList.adiErrorListMachine[ii]:=0;
				T_NovRAM.T_Parameter.T_ErrorNrList.asErrorTimeStampMachine[ii]:='';
			END_FOR;
			(* activ save *)
			T_NovRAM.T_Ctrle.xExecute:=TRUE;
			T_NovRAM.T_Ctrle.iFunction:=2;
			(* next Step *)
			iStepAction :=40;
			xStepActionDone:=FALSE;
		(* wait save confirmation *)
		40:	IF NOT(xStepActionDone) THEN
				T_NovRAM.T_Ctrle.xExecute:=FALSE;
				(* confirm Step *)
				xStepActionDone:=TRUE;
			ELSE
				IF T_NovRAM.T_Ctrle.xDone THEN
				(* next Step *)
					iStepAction :=90;
					xStepActionDone:=FALSE;
					T_ExchgParam.T_SafetyCtrl.xUpdateErrorList:=TRUE;
					T_ExchgParam.T_Visu.T_Message.iState:=39;	(* Info: Fehlerliste wurde gelöscht ! *)
				END_IF
			END_IF
		(* save done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xDeleteErrorList:=FALSE;
		(* NovRAM not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xDeleteErrorList:=FALSE;
		END_CASE;
	END_IF;
(* Quittieren des Fehler/Warnung *)
	IF xResetErrorWarning THEN
		CASE iStepAction OF
		1:	T_ExchgParam.T_SafetyCtrl.xResetErrorWarning:=TRUE;
			iStepAction:=10;
		10:	IF NOT(T_ExchgParam.T_SafetyCtrl.xResetErrorWarning) THEN
				iStepAction:=90;
				T_ExchgParam.T_Visu.T_Message.iState:=41;	(* Info: Fehler wurde quittiert ! *)
			END_IF;
		(* save done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xResetErrorWarning:=FALSE;
		95:	TimerNotReady(IN:=TRUE);
			xResetErrorWarning:=FALSE;
		END_CASE;
	END_IF;
(* Meldungsfenster Öffnen *)
	IF xOpenMessageWindow THEN
		CASE iStepAction OF
		1:	IF (T_ExchgParam.T_SafetyCtrl.bStateMessageError=0) AND (T_ExchgParam.T_SafetyCtrl.bStateMessageInfo=0) AND (T_ExchgParam.T_SafetyCtrl.bStateMessageWarning=0) THEN
				iStepAction:=10;
			ELSE
				T_ExchgParam.T_SafetyCtrl.bStateMessagePreWarning:=0;
				iStepAction:=95;
			END_IF;
		10:	T_ExchgParam.T_SafetyCtrl.bStateMessagePreWarning:=1;
			iStepAction:=90;
		(* not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xOpenMessageWindow:=FALSE;
		(* configuration done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xOpenMessageWindow:=FALSE;
		END_CASE
	END_IF;

END_ACTION

ACTION	VisuFunction_LampTest:
(* LampTest *)
	IF xLampTestOnOff OR xLampTestBlinkOnOff OR xLampTestActive THEN
		(* set new page *)
		CASE iStepAction OF
		(* check ctrle visu *)
		1: 	(* activ next step *)
			iStepAction:=10;
			xStepActionDone:=FALSE;
		(* Set new page *)
		10:	IF xLampTestOnOff THEN
				xBlinkLampAcitve:=FALSE;
				IF (T_ExchgParam.T_LampTest.abLedControlButton[1] = 0) THEN
					T_ExchgParam.T_BtFunctionPanel.wState:=1;
					xLedControlButtonON:=TRUE;
				ELSE
					T_ExchgParam.T_BtFunctionPanel.wState:=0;
					xLedControlButtonOFF:=TRUE;
				END_IF;
				IF (T_ExchgParam.T_LampTest.abLedControlLamp[1] = 0) THEN
					xLedControlLampON:=TRUE;
				ELSE
					xLedControlLampOFF:=TRUE;
				END_IF;
				IF (T_ExchgParam.T_LampTest.abLedSetupLamp[1] = 0) THEN
					xLedSetupLampON:=TRUE;
				ELSE
					xLedSetupLampOFF:=TRUE;
				END_IF;
				IF xLedControlButtonON AND xLedControlLampON AND xLedSetupLampON THEN
					T_ExchgParam.T_Visu.T_Message.iState:=42;	(* Info: Alle Lampen sind EIN ! *)
				ELSE
					T_ExchgParam.T_Visu.T_Message.iState:=43;	(* Info: Alle Lampen sind AUS ! *)
				END_IF;
				iStepAction:=90;
			END_IF;
			IF xLampTestBlinkOnOff THEN
				IF xBlinkLampAcitve THEN
					T_ExchgParam.T_BtFunctionPanel.wState:=0;
					xLedControlButtonOFF:=xLedControlLampOFF:=xLedSetupLampOFF:=TRUE;
					xBlinkLampAcitve:=FALSE;
					T_ExchgParam.T_Visu.T_Message.iState:=43;	(* Info: Alle Lampen sind AUS ! *)
				ELSE
					T_ExchgParam.T_BtFunctionPanel.wState:=2;
					xBlinkLampAcitve:=TRUE;
					T_ExchgParam.T_Visu.T_Message.iState:=44;	(* Info: Alle Lampen blinken ! *)
				END_IF;
				iStepAction:=90;
			END_IF;
			IF xLampTestActive THEN
				FOR ii:=1 TO 18 DO
					sCopyTextLinesLampIOEngl[ii]:='';
					sCopyTextLinesLampNIOEngl[ii]:='';
					sCopyTextLinesLampIO[ii]:='';
					sCopyTextLinesLampNIO[ii]:='';
				END_FOR;
				T_ExchgParam.T_BtFunctionPanel.wState:=4;
				xBlinkLampAcitve:=FALSE;
				iStepCheckLamp:=1;
				iStepCheckLampNumber:=0;
				iPtrText:=1;
				iTmpPtrText:=1;
				iStepAction:=20;
				T_ExchgParam.T_Visu.T_Message.iState:=45;	(* Info: Lampentest wurde aktiviert ! *)
			END_IF;
			(* activ step *)
			xStepActionDone:=FALSE;
		20:	xLedControlButtonOFF:=xLedControlLampOFF:=xLedSetupLampOFF:=TRUE;
			iStepAction:=30;
		30:	IF NOT(xLedControlButtonOFF) AND NOT(xLedControlLampOFF) AND NOT(xLedSetupLampOFF) THEN
				IF (iStepCheckLamp <= 16) THEN
					iStepCheckLampNumber:=iStepCheckLampNumber + 1;
					T_ExchgParam.T_LampTest.xShowSelectIONIOButton:=TRUE;
					T_ExchgParam.T_LampTest.sControlMessage1Engl:=CONCAT('Please check the ',INT_TO_STRING(iStepCheckLampNumber));
					T_ExchgParam.T_LampTest.sControlMessage1Engl:=CONCAT(T_ExchgParam.T_LampTest.sControlMessage1Engl,'. Lamp!');
					T_ExchgParam.T_LampTest.sControlMessage2Engl:='Is the Lamp lighting? Confirm with Yes or No';
					T_ExchgParam.T_LampTest.sControlMessage1:=CONCAT('Bitte überprüfe die ',INT_TO_STRING(iStepCheckLampNumber));
					T_ExchgParam.T_LampTest.sControlMessage1:=CONCAT(T_ExchgParam.T_LampTest.sControlMessage1,'. Lampe!');
					T_ExchgParam.T_LampTest.sControlMessage2:='Leuchtet die Lampe? Bestätige mit Ja oder Nein';
					iStepAction:=40;
				ELSE
					T_ExchgParam.T_LampTest.xShowSelectIONIOButton:=FALSE;
					T_ExchgParam.T_LampTest.xShowLampTestResult:=TRUE;
					iStepAction:=60;
				END_IF;
			END_IF;
		40:	IF (iStepCheckLamp >= 1) AND (iStepCheckLamp <= 7) THEN
				IF (iStepCheckLamp > 5) THEN
					iStepCheckLamp:=iStepCheckLamp + 1;
				ELSE
					T_ExchgParam.T_LampTest.abLedControlButton[iStepCheckLamp]:=bFct_GetLedState(iLampNumber:=iStepCheckLamp);
				END_IF;
			END_IF;
			IF (iStepCheckLamp >= 7) AND (iStepCheckLamp <= 12) THEN
				iStepCheckLamp:=13;
			END_IF;
			IF (iStepCheckLamp >= 13) AND (iStepCheckLamp <= 15) THEN
				T_ExchgParam.T_LampTest.abLedControlLamp[iStepCheckLamp - 12]:=bFct_GetLedState(iLampNumber:=iStepCheckLamp);
			END_IF;
			IF (iStepCheckLamp >= 16) THEN
				IF (iStepCheckLamp = 16) THEN
					T_ExchgParam.T_LampTest.abLedSetupLamp[iStepCheckLamp - 15]:=bFct_GetLedState(iLampNumber:=iStepCheckLamp);
				ELSE
					iStepCheckLamp:=iStepCheckLamp + 1;
				END_IF;
			END_IF;
			iStepAction:=50;
		50:	IF (iStepCheckLamp <= 16) THEN
				IF T_ExchgParam.T_LampTest.xButtonLampIO THEN
					iTmpPtrText:=iTmpPtrText + 1;
					T_ExchgParam.T_LampTest.xButtonLampIO:=FALSE;
					IF ((iStepCheckLampNumber) < 10) THEN
						sLineNumber:=CONCAT('0',INT_TO_STRING(iStepCheckLampNumber));
					ELSE
						sLineNumber:=INT_TO_STRING(iStepCheckLampNumber);
					END_IF;
					sCopyTextLinesLampIOEngl[iTmpPtrText]:=CONCAT(sLineNumber,'. ');
					sCopyTextLinesLampIOEngl[iTmpPtrText]:=CONCAT(sCopyTextLinesLampIOEngl[iTmpPtrText],sFct_GetLampOrderNumberEngl(xLampdefect:=FALSE,iLampNumber:=iStepCheckLamp));
					sCopyTextLinesLampIO[iTmpPtrText]:=CONCAT(sLineNumber,'. ');
					sCopyTextLinesLampIO[iTmpPtrText]:=CONCAT(sCopyTextLinesLampIO[iTmpPtrText],sFct_GetLampOrderNumberGer(xLampdefect:=FALSE,iLampNumber:=iStepCheckLamp));
					iStepCheckLamp:=iStepCheckLamp + 1;
					iStepAction:=20;
				END_IF;
				IF T_ExchgParam.T_LampTest.xButtonLampNIO THEN
					iPtrText:=iPtrText + 1;
					IF ((iStepCheckLampNumber) < 10) THEN
						sLineNumber:=CONCAT('0',INT_TO_STRING(iStepCheckLampNumber));
					ELSE
						sLineNumber:=INT_TO_STRING(iStepCheckLampNumber);
					END_IF;
					sCopyTextLinesLampNIOEngl[iPtrText]:=CONCAT(sLineNumber,'. ');
					sCopyTextLinesLampNIOEngl[iPtrText]:=CONCAT(sCopyTextLinesLampNIOEngl[iPtrText],sFct_GetLampOrderNumberEngl(xLampdefect:=TRUE,iLampNumber:=iStepCheckLamp));
					sCopyTextLinesLampNIO[iPtrText]:=CONCAT(sLineNumber,'. ');
					sCopyTextLinesLampNIO[iPtrText]:=CONCAT(sCopyTextLinesLampNIO[iPtrText],sFct_GetLampOrderNumberGer(xLampdefect:=TRUE,iLampNumber:=iStepCheckLamp));
					T_ExchgParam.T_LampTest.xButtonLampNIO:=FALSE;
					iStepCheckLamp:=iStepCheckLamp + 1;
					iStepAction:=20;
				END_IF;
			ELSE
				iStepCheckLamp:=iStepCheckLamp + 1;
				iStepAction:=20;
			END_IF;
		60:	IF (iPtrText = 1) THEN
				(* Test Erfolgreich *)
				T_ExchgParam.T_LampTest.sTextLinesEngl:=sCopyTextLinesLampIOEngl;
				T_ExchgParam.T_LampTest.sTextLinesEngl[1]:='All lamps are okay!';
				T_ExchgParam.T_LampTest.sTextLines:=sCopyTextLinesLampIO;
				T_ExchgParam.T_LampTest.sTextLines[1]:='Alle Lampen sind okay!';
			ELSE
				(* mindestens eine Lampe defekt *)
				T_ExchgParam.T_LampTest.sTextLinesEngl:=sCopyTextLinesLampNIOEngl;
				T_ExchgParam.T_LampTest.sTextLinesEngl[1]:='Replace the follow lamps:';
				T_ExchgParam.T_LampTest.sTextLines:=sCopyTextLinesLampNIO;
				T_ExchgParam.T_LampTest.sTextLines[1]:='Folgende Lampen müssen ersetzt werden:';
			END_IF;
			iStepAction:=70;
		70:	IF T_ExchgParam.T_LampTest.xButtonOK THEN
				T_ExchgParam.T_LampTest.xButtonOK:=FALSE;
				T_ExchgParam.T_LampTest.xShowSelectIONIOButton:=FALSE;
				T_ExchgParam.T_LampTest.xShowLampTestResult:=FALSE;
				T_ExchgParam.T_BtFunctionPanel.wState:=0;
				iStepAction:=90;
				T_ExchgParam.T_Visu.T_Message.iState:=46;	(* Info: Lampentest wurde beendet ! *)
			END_IF;
		(* override done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xLampTestOnOff:=xLampTestBlinkOnOff:=xLampTestActive:=FALSE;
			T_ExchgParam.T_SafetyCtrl.xDeactivateLamp:=FALSE;
		END_CASE
	END_IF

	IF (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iAutoMode_LampTest) THEN
		IF ((NOT(TProcess.T_Ctrle.xExecute) AND TProcess.T_Ctrle.xDone AND NOT(TProcess.T_Ctrle.xError))) THEN
			T_ExchgParam.T_SafetyCtrl.xDeactivateLamp:=TRUE;	(* Ausgänge für die Lampen dürfen überschrieben werden *)
		ELSE
			T_ExchgParam.T_SafetyCtrl.xDeactivateLamp:=FALSE;	(* Wenn diese Seite verlassen wird, dann dürfen die Ausgänge nicht mehr überschrieben werden *)
		END_IF;
	ELSE
		T_ExchgParam.T_SafetyCtrl.xDeactivateLamp:=FALSE;	(* Wenn diese Seite verlassen wird, dann dürfen die Ausgänge nicht mehr überschrieben werden *)
	END_IF;

	IF (T_ExchgParam.T_Visu.xKey_Escape) AND (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iAutoMode_LampTest) AND xLampTestActive THEN
		xLedControlButtonOFF:=xLedControlLampOFF:=xLedSetupLampOFF:=TRUE;
		T_ExchgParam.T_LampTest.xShowSelectIONIOButton:=FALSE;
		T_ExchgParam.T_LampTest.xShowLampTestResult:=FALSE;
		T_ExchgParam.T_LampTest.xButtonOK:=FALSE;
		T_ExchgParam.T_LampTest.xButtonLampIO:=FALSE;
		T_ExchgParam.T_LampTest.xButtonLampNIO:=FALSE;
		T_ExchgParam.T_BtFunctionPanel.wState:=0;
		T_Visu.T_CtrleAction.xDone:=TRUE;
		T_Visu.T_CtrleAction.xNotReady:=FALSE;
		T_Visu.T_CtrleAction.xErr:=FALSE;
		T_Visu.T_CtrleAction.udiErrorID:=0;
		xLampTestOnOff:=xLampTestBlinkOnOff:=xLampTestActive:=FALSE;
	END_IF;

	RisingEdgeCheckLampTestPage(CLK:=T_Visu.T_PlcParam.dwActualPage <> gT_PageNumber.iAutoMode_LampTest);
	RisingEdgeCheckLampTestPage1(CLK:=T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iAutoMode_LampTest);
	IF RisingEdgeCheckLampTestPage.Q OR RisingEdgeCheckLampTestPage1.Q THEN
		xLedControlButtonOFF:=xLedControlLampOFF:=xLedSetupLampOFF:=TRUE;
		xBlinkLampAcitve:=FALSE;
		T_ExchgParam.T_LampTest.xShowSelectIONIOButton:=FALSE;
		T_ExchgParam.T_LampTest.xShowLampTestResult:=FALSE;
		T_ExchgParam.T_LampTest.xButtonOK:=FALSE;
		T_ExchgParam.T_LampTest.xButtonLampIO:=FALSE;
		T_ExchgParam.T_LampTest.xButtonLampNIO:=FALSE;
		T_ExchgParam.T_BtFunctionPanel.wState:=0;
		xLampTestOnOff:=xLampTestBlinkOnOff:=xLampTestActive:=FALSE;
	END_IF;

	IF xBlinkLampAcitve THEN
		CASE iStepBlinkLampActive OF
		1:	TONWaitChangeState(IN:=FALSE);
			xLedControlButtonON:=xLedControlLampON:=xLedSetupLampON:=TRUE;
			iStepBlinkLampActive:=iStepBlinkLampActive + 1;
		2:	TONWaitChangeState(IN:=TRUE,PT:=T#0.5s);
			IF TONWaitChangeState.Q THEN
				TONWaitChangeState(IN:=FALSE);
				xLedControlButtonOFF:=xLedControlLampOFF:=xLedSetupLampOFF:=TRUE;
				iStepBlinkLampActive:=iStepBlinkLampActive + 1;
			END_IF;
		3:	TONWaitChangeState(IN:=TRUE,PT:=T#0.5s);
			IF TONWaitChangeState.Q THEN
				TONWaitChangeState(IN:=FALSE);
				iStepBlinkLampActive:=1;
			END_IF;
		END_CASE;
	ELSE
		TONWaitChangeState(IN:=FALSE);
		iStepBlinkLampActive:=1;
	END_IF;

	IF xLedControlButtonON THEN
		T_ExchgParam.T_LampTest.abLedControlButton[1]:=bFct_GetLedState(iLampNumber:=1);
		T_ExchgParam.T_LampTest.abLedControlButton[2]:=bFct_GetLedState(iLampNumber:=2);
		T_ExchgParam.T_LampTest.abLedControlButton[3]:=bFct_GetLedState(iLampNumber:=3);
		T_ExchgParam.T_LampTest.abLedControlButton[4]:=bFct_GetLedState(iLampNumber:=4);
		T_ExchgParam.T_LampTest.abLedControlButton[5]:=bFct_GetLedState(iLampNumber:=5);
		xLedControlButtonON:=FALSE;
	END_IF;
	IF xLedControlButtonOFF THEN
		T_ExchgParam.T_LampTest.abLedControlButton[1]:=0;
		T_ExchgParam.T_LampTest.abLedControlButton[2]:=0;
		T_ExchgParam.T_LampTest.abLedControlButton[3]:=0;
		T_ExchgParam.T_LampTest.abLedControlButton[4]:=0;
		T_ExchgParam.T_LampTest.abLedControlButton[5]:=0;
		xLedControlButtonOFF:=FALSE;
	END_IF;
	IF xLedControlLampON THEN
		T_ExchgParam.T_LampTest.abLedControlLamp[1]:=bFct_GetLedState(iLampNumber:=13);
		T_ExchgParam.T_LampTest.abLedControlLamp[2]:=bFct_GetLedState(iLampNumber:=14);
		T_ExchgParam.T_LampTest.abLedControlLamp[3]:=bFct_GetLedState(iLampNumber:=15);
		xLedControlLampON:=FALSE;
	END_IF;
	IF xLedControlLampOFF THEN
		T_ExchgParam.T_LampTest.abLedControlLamp[1]:=0;
		T_ExchgParam.T_LampTest.abLedControlLamp[2]:=0;
		T_ExchgParam.T_LampTest.abLedControlLamp[3]:=0;
		xLedControlLampOFF:=FALSE;
	END_IF;
	IF xLedSetupLampON THEN
		T_ExchgParam.T_LampTest.abLedSetupLamp[1]:=bFct_GetLedState(iLampNumber:=16);
		xLedSetupLampON:=FALSE;
	END_IF;
	IF xLedSetupLampOFF THEN
		T_ExchgParam.T_LampTest.abLedSetupLamp[1]:=0;
		xLedSetupLampOFF:=FALSE;
	END_IF;

(* Ausgang für Lampen setzen *)
IF T_ExchgParam.T_SafetyCtrl.xDeactivateLamp THEN
	IF (T_ExchgParam.T_LampTest.abLedControlButton[1] <> 0) THEN
		QxCtrlLampStartButton:=TRUE;
	ELSE
		QxCtrlLampStartButton:=FALSE;
	END_IF;
	IF (T_ExchgParam.T_LampTest.abLedControlButton[2] <> 0) THEN
		QxCtrlLampStopButton:=TRUE;
	ELSE
		QxCtrlLampStopButton:=FALSE;
	END_IF;
	IF (T_ExchgParam.T_LampTest.abLedControlButton[3] <> 0) THEN
		QxCtrlLampAxesCurrentOff:=TRUE;
	ELSE
		QxCtrlLampAxesCurrentOff:=FALSE;
	END_IF;
	IF (T_ExchgParam.T_LampTest.abLedControlButton[4] <> 0) THEN
		QxCtrlLampReleaseButton:=TRUE;
	ELSE
		QxCtrlLampReleaseButton:=FALSE;
	END_IF;
	IF (T_ExchgParam.T_LampTest.abLedControlButton[5] <> 0) THEN
		QxSetupModeLamp:=TRUE;
	ELSE
		QxSetupModeLamp:=FALSE;
	END_IF;
	IF (T_ExchgParam.T_LampTest.abLedControlLamp[1] <> 0) THEN
		QxSignalLampGreen:=TRUE;
	ELSE
		QxSignalLampGreen:=FALSE;
	END_IF;
	IF (T_ExchgParam.T_LampTest.abLedControlLamp[2] <> 0) THEN
		QxSignalLampYellow:=TRUE;
	ELSE
		QxSignalLampYellow:=FALSE;
	END_IF;
	IF (T_ExchgParam.T_LampTest.abLedControlLamp[3] <> 0) THEN
		QxSignalLampRed:=TRUE;
	ELSE
		QxSignalLampRed:=FALSE;
	END_IF;
	IF (T_ExchgParam.T_LampTest.abLedSetupLamp[1] <> 0) THEN
		QxMachineLamp:=TRUE;
	ELSE
		QxMachineLamp:=FALSE;
	END_IF;
END_IF;
END_ACTION

ACTION	VisuFunction_MachineLamp:
(* MaschinenLampe ON/OFF *)
	RisingEdgeMachineLamp(CLK:=(UDINT_TO_WORD(T_CtrlePanel.udiButton) = 16#8));
	IF RisingEdgeMachineLamp.Q AND T_StartUp.T_State.xCompleted AND (T_Visu.T_PlcParam.dwActualPage <> gT_PageNumber.iAutoMode_LampTest) THEN
		xTmp:=	TMachineLamp.T_CtrleCyl.xFBActiv
				AND TMachineLamp.T_CtrleCyl.xDone
				AND NOT(TMachineLamp.T_CtrleCyl.xExecute);
		IF xTmp THEN
			TMachineLamp.T_CtrleCyl.iFunction:=51;
			TMachineLamp.T_CtrleCyl.xExecute:=TRUE;
			IF NOT(TMachineLamp.T_CtrleCyl.T_Standard.xActivOn) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=61;	(* Info: Maschinenlampe EIN ! *)
			ELSE
				T_ExchgParam.T_Visu.T_Message.iState:=62;	(* Info: Maschinenlampe AUS ! *)
			END_IF;
		END_IF;
	END_IF;

END_ACTION

ACTION	VisuFunction_NovRAM:
(* Action Save NovRAM *)
	IF xAction_SaveNovRAM THEN
		(* Step saving NovRAM *)
		CASE iStepActionNovRam OF
		(* check NovRAM *)
		1:	xTmp:=	T_NovRAM.T_Ctrle.xDone
					AND NOT(T_NovRAM.T_Ctrle.xExecute)
					AND NOT(T_NovRAM.T_Ctrle.xErr);
			IF xTmp THEN
				(* next Step *)
				iStepActionNovRam :=10;
				xStepActionDone:=FALSE;
				IF (T_Visu.T_CtrleAction.iFunction = 1001) AND (T_ExchgParam.T_BtParameterList.bMessageParameter <> 0) THEN
					(* Beim speichern der Parameterliste besteht keine Parameterliste oder man hat nicht die berechtigung dazu *)
					IF (T_ExchgParam.T_BtParameterList.bMessageParameter = 1) THEN
						T_ExchgParam.T_Visu.T_Message.iState:=217;	(* Warnung: Mindestens OperatorLevel wird benötigt ! *)
					ELSIF (T_ExchgParam.T_BtParameterList.bMessageParameter = 2) THEN
						T_ExchgParam.T_Visu.T_Message.iState:=216;	(* Warnung: Diese Parameter können nur auf SystemLevel geändert werden ! *)
					ELSE
						T_ExchgParam.T_Visu.T_Message.iState:=273;	(* Kann nicht gespeichert werden, da keine Parameterliste besteht ! *)
					END_IF;
					iStepActionNovRam:=90;
					RETURN;
				END_IF;
				(* Display message *)
				T_ExchgParam.T_Visu.T_Message.iState:=3;	(* Info: Start speichern... *)
			(* activ error *)
			ELSE
				iStepActionNovRam:=95;
			END_IF
		(* copy value *)
		10:	(* Update visu exchange variable, aber nur falls die Parameterliste angewählt ist *)
			xTmp:=	(T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iAutoMode_Parameter) OR
					(T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iHandMode_Parameter) OR
					(T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iWorkStation_Parameter);
			IF xTmp THEN
				T_NovRAM.T_Parameter.T_Machine.T_ParamSystem:=T_ExchgParam.T_StationCommon.T_Param_Machine.T_ParamSystem;
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1]:=T_ExchgParam.T_StationCommon.T_Param_StationWork;
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_ToolCounter:=T_ExchgParam.T_StationCommon.T_ToolCounter_St1;
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_WPCounter:=T_ExchgParam.T_StationCommon.T_WPCounter_St1;
				xUpdateStationParameter:=TRUE;
			END_IF;
			IF (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iHandMode_Parameter)  AND (T_ExchgParam.T_BtParameterList.iEditParam = 117) THEN
				garPositionEndProcCalc[1]:=T_ExchgParam.T_StationCommon.rPositionEndProcCalc;
				garCentringEndProcCalc[1]:=T_ExchgParam.T_StationCommon.rCentringEndProcCalc;
			END_IF;
			(* next Step *)
			iStepActionNovRam :=20;
			xStepActionDone:=FALSE;
		(* activ save *)
		20:	IF NOT(gxHardwareOFF) THEN
				T_NovRAM.T_Ctrle.xExecute:=TRUE;
				T_NovRAM.T_Ctrle.iFunction:=2;
			END_IF;
			IF (garPositionEndProcCalc[1] <> T_ExchgParam.T_StationCommon.rPositionEndProcCalc) THEN
				T_ExchgParam.T_StationCommon.rPositionEndProcCalc:=garPositionEndProcCalc[1];
			END_IF;
			IF (garCentringEndProcCalc[1] <> T_ExchgParam.T_StationCommon.rCentringEndProcCalc) THEN
				T_ExchgParam.T_StationCommon.rCentringEndProcCalc:=garCentringEndProcCalc[1];
			END_IF;
			(* next Step *)
			iStepActionNovRam :=30;
			xStepActionDone:=FALSE;
		(* wait save confirmation *)
		30:	IF NOT(xStepActionDone) THEN
				T_NovRAM.T_Ctrle.xExecute:=FALSE;
				(* confirm Step *)
				xStepActionDone:=TRUE;
			ELSE
				IF T_NovRAM.T_Ctrle.xDone THEN
				(* next Step *)
					iStepActionNovRam :=90;
					xStepActionDone:=FALSE;
					IF (T_ExchgParam.T_Visu.T_Message.iState = 3) THEN
						T_ExchgParam.T_Visu.T_Message.iState:=47;	(* Info: Parameter gespeichert ! *)
					END_IF;
				ELSE	IF T_NovRAM.T_Ctrle.xErr THEN
							iStepActionNovRam:=99;
							xStepActionDone:=FALSE;
						END_IF
				END_IF
			END_IF
		(* save done *)
		90:	IF NOT(xBlockSetNovRamAction_End) THEN
				T_Visu.T_CtrleAction.xDone:=TRUE;
				T_Visu.T_CtrleAction.xNotReady:=FALSE;
				T_Visu.T_CtrleAction.xErr:=FALSE;
				T_Visu.T_CtrleAction.udiErrorID:=0;
			END_IF;
			xAction_SaveNovRAM:=FALSE;
		(* NovRAM not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xAction_SaveNovRAM:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F0000 + T_Visu.T_CtrleAction.iFunction;
			IF T_HDD.T_Ctrle.xErr THEN T_Visu.T_CtrleAction.udiErrorID:=16#F1000 + T_HDD.T_Ctrle.iFunction; T_HDD.T_Ctrle.xReset:=TRUE; END_IF
			IF T_Profile.T_Ctrle.xErr THEN T_Visu.T_CtrleAction.udiErrorID:=16#F1000 + T_Visu.T_CtrleAction.iFunction; T_Profile.T_Ctrle.xReset:=TRUE; END_IF
			xAction_SaveNovRAM:=FALSE;
		END_CASE
	END_IF
END_ACTION

ACTION	VisuFunction_OnlineChange:
(* OnlineChange Parameter Z Achse Bearbeitungsgeschwindigkeit vorwärts +/- *)
	IF xOnlineChange_Z_ForwardSpeedMore OR xOnlineChange_Z_ForwardSpeedLess THEN
		(* Step set override *)
		CASE iStepAction OF
		(* modif value *)
		1:	rTmp:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChangeINC.rWorkingSpeedForward;
			IF xOnlineChange_Z_ForwardSpeedLess THEN rTmp:=rTmp *-1; END_IF
			T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpeedForward
				:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpeedForward + rTmp;
			IF T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpeedForward
			     > T_Profile.T_Profile_MinMax.T_Max.rWorkingSpeedForward THEN
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpeedForward
					:=T_Profile.T_Profile_MinMax.T_Max.rWorkingSpeedForward; END_IF
			IF T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpeedForward
			     < T_Profile.T_Profile_MinMax.T_Min.rWorkingSpeedForward THEN
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpeedForward
					:=T_Profile.T_Profile_MinMax.T_Min.rWorkingSpeedForward; END_IF
			iStepAction:=10;
			xStepActionDone:=FALSE;
		(* set new speed while axis is moving *)
		10:	IF NOT ptrActivStation^.THWWorkStation.TAxisZ.T_CtrleSingle.xNotMoving AND NOT ptrActivStation^.TCtrlOnlineChange.xLockChange_Z_WorkSpeedForward THEN
				ptrActivStation^.THWWorkStation.TAxisZ.T_CtrleSingle.lrVelocity:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpeedForward;
				ptrActivStation^.THWWorkStation.TAxisZ.T_CtrleSingle.xExecute:=TRUE;
				ptrActivStation^.THWWorkStation.TAxisZ.T_CtrleSingle.iFunction:=12;
				(* next step *)
				iStepAction:=20;
			ELSE
				(* next step *)
				iStepAction:=90;
			END_IF;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		20: IF NOT(xStepActionDone) THEN
				ptrActivStation^.THWWorkStation.TAxisZ.T_CtrleSingle.xExecute:=FALSE;
				(* confirm step *)
				xStepActionDone:=TRUE;
			ELSE
			(* no confirmation will be sended, confirm override *)
				iStepAction:=90;
				xStepActionDone:=FALSE;
				T_ExchgParam.T_Visu.T_Message.iState:=48;	(* Info: OnlineChange Wert gesetzt ! *)
			END_IF
		(* override done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xOnlineChange_Z_ForwardSpeedMore:=FALSE;
			xOnlineChange_Z_ForwardSpeedLess:=FALSE;
			xUpdateStationParameter:=TRUE;
		END_CASE
	END_IF

(* OnlineChange Parameter Z Achse Bearbeitungsgeschwindigkeit rückwärts +/- *)
	IF xOnlineChange_Z_BackwardSpeedMore OR xOnlineChange_Z_BackwardSpeedLess THEN
		(* Step set override *)
		CASE iStepAction OF
		(* modif value *)
		1:	rTmp:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChangeINC.rWorkingSpeedBackward;
			IF xOnlineChange_Z_BackwardSpeedLess THEN rTmp:=rTmp *-1; END_IF
			T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpeedBackward
				:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpeedBackward + rTmp;
			IF T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpeedBackward
			     > T_Profile.T_Profile_MinMax.T_Max.rWorkingSpeedBackward THEN
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpeedBackward
					:=T_Profile.T_Profile_MinMax.T_Max.rWorkingSpeedBackward; END_IF
			IF T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpeedBackward
			     < T_Profile.T_Profile_MinMax.T_Min.rWorkingSpeedBackward THEN
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpeedBackward
					:=T_Profile.T_Profile_MinMax.T_Min.rWorkingSpeedBackward; END_IF
			iStepAction:=10;
			xStepActionDone:=FALSE;
		(* set new speed while axis is moving *)
		10:	IF NOT ptrActivStation^.THWWorkStation.TAxisZ.T_CtrleSingle.xNotMoving AND NOT ptrActivStation^.TCtrlOnlineChange.xLockChange_Z_WorkSpeedBackward THEN
				ptrActivStation^.THWWorkStation.TAxisZ.T_CtrleSingle.lrVelocity:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpeedBackward;
				ptrActivStation^.THWWorkStation.TAxisZ.T_CtrleSingle.xExecute:=TRUE;
				ptrActivStation^.THWWorkStation.TAxisZ.T_CtrleSingle.iFunction:=12;
				(* next step *)
				iStepAction:=20;
			ELSE
				(* next step *)
				iStepAction:=90;
			END_IF;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		20: IF NOT(xStepActionDone) THEN
				ptrActivStation^.THWWorkStation.TAxisZ.T_CtrleSingle.xExecute:=FALSE;
				(* confirm step *)
				xStepActionDone:=TRUE;
			ELSE
			(* no confirmation will be sended, confirm override *)
				iStepAction:=90;
				xStepActionDone:=FALSE;
				T_ExchgParam.T_Visu.T_Message.iState:=48;	(* Info: OnlineChange Wert gesetzt ! *)
			END_IF
		(* override done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xOnlineChange_Z_BackwardSpeedMore:=FALSE;
			xOnlineChange_Z_BackwardSpeedLess:=FALSE;
			xUpdateStationParameter:=TRUE;
		END_CASE
	END_IF

(* OnlineChange Parameter Z Achse rückwärts Offset +/- *)
	IF xOnlineChange_Z_BackwardOffsetMore OR xOnlineChange_Z_BackwardOffsetLess THEN
		(* Step set override *)
		CASE iStepAction OF
		(* modif value *)
		1:	rTmp:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChangeINC.rWorkingOffsetBackward;
			IF xOnlineChange_Z_BackwardOffsetLess THEN rTmp:=rTmp *-1; END_IF
			T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingOffsetBackward
				:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingOffsetBackward + rTmp;
			IF T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingOffsetBackward
			     > T_Profile.T_Profile_MinMax.T_Max.rWorkingOffsetBackward THEN
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingOffsetBackward
					:=T_Profile.T_Profile_MinMax.T_Max.rWorkingOffsetBackward; END_IF
			IF T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingOffsetBackward
			     < T_Profile.T_Profile_MinMax.T_Min.rWorkingOffsetBackward THEN
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingOffsetBackward
					:=T_Profile.T_Profile_MinMax.T_Min.rWorkingOffsetBackward; END_IF
			iStepAction:=90;
			T_ExchgParam.T_Visu.T_Message.iState:=48;	(* Info: OnlineChange Wert gesetzt ! *)
		(* override done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xOnlineChange_Z_BackwardOffsetMore:=FALSE;
			xOnlineChange_Z_BackwardOffsetLess:=FALSE;
			xUpdateStationParameter:=TRUE;
		END_CASE
	END_IF

(* OnlineChange Parameter ToolTorque Drehmoment HC +/- *)
	IF xOnlineChange_TorqueLevelHCMore OR xOnlineChange_TorqueLevelHCLess THEN
		(* Step set override *)
		CASE iStepAction OF
		(* modif value *)
		1:	rTmp:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChangeINC.rTorqueLevelHC;
			IF xOnlineChange_TorqueLevelHCLess THEN rTmp:=rTmp *-1; END_IF
			T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rTorqueLevelHC
				:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rTorqueLevelHC + rTmp;
			IF T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rTorqueLevelHC
			     > T_Profile.T_Profile_MinMax.T_Max.rTorqueLevelHC THEN
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rTorqueLevelHC
					:=T_Profile.T_Profile_MinMax.T_Max.rTorqueLevelHC; END_IF
			IF T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rTorqueLevelHC
			     < T_Profile.T_Profile_MinMax.T_Min.rTorqueLevelHC THEN
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rTorqueLevelHC
					:=T_Profile.T_Profile_MinMax.T_Min.rTorqueLevelHC; END_IF
			iStepAction:=10;
		(* set new speed while axis is moving *)
		10:	IF ptrTCylToolTorqueHC_St1^.T_CtrleCyl.xDone AND ptrTCylToolTorqueOverload_St1^.T_CtrleCyl.xDone AND NOT ptrActivStation^.TCtrlOnlineChange.xLockChangeCylToolTorqueLevel THEN
				ptrTCylToolTorqueHC_St1^.T_CtrleCyl.T_Analog.rForceIn:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rTorqueLevelHC;
				ptrTCylToolTorqueHC_St1^.T_CtrleCyl.iFunction:=4;
				ptrTCylToolTorqueHC_St1^.T_CtrleCyl.xExecute:=TRUE;
				ptrTCylToolTorqueOverload_St1^.T_CtrleCyl.T_Analog.rForceIn:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rTorqueLevel_Overload;
				ptrTCylToolTorqueOverload_St1^.T_CtrleCyl.iFunction:=4;
				ptrTCylToolTorqueOverload_St1^.T_CtrleCyl.xExecute:=TRUE;
				(* next step *)
				iStepAction:=20;
			ELSE
				(* next step *)
				iStepAction:=90;
			END_IF;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		20: IF NOT(xStepActionDone) THEN
				ptrTCylToolTorqueHC_St1^.T_CtrleCyl.xExecute:=FALSE;
				(* confirm step *)
				xStepActionDone:=TRUE;
			ELSE
			(* no confirmation will be sended, confirm override *)
				IF ptrTCylToolTorqueHC_St1^.T_CtrleCyl.xDone THEN
					iStepAction:=90;
					xStepActionDone:=FALSE;
					T_ExchgParam.T_Visu.T_Message.iState:=48;	(* Info: OnlineChange Wert gesetzt ! *)
				END_IF;
			END_IF
		(* override done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xOnlineChange_TorqueLevelHCMore:=FALSE;
			xOnlineChange_TorqueLevelHCLess:=FALSE;
			xUpdateStationParameter:=TRUE;
		END_CASE
	END_IF

(* OnlineChange Parameter ToolDeflection Auslenkkraft +/- *)
	IF xOnlineChange_DeflectionForceMore OR xOnlineChange_DeflectionForceLess THEN
		(* Step set override *)
		CASE iStepAction OF
		(* modif value *)
		1:	rTmp:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChangeINC.rForceDeflection;
			IF xOnlineChange_DeflectionForceLess THEN rTmp:=rTmp *-1; END_IF
			T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rForceDeflection
				:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rForceDeflection + rTmp;
			IF T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rForceDeflection
			     > T_Profile.T_Profile_MinMax.T_Max.rForceDeflection THEN
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rForceDeflection
					:=T_Profile.T_Profile_MinMax.T_Max.rForceDeflection; END_IF
			IF T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rForceDeflection
			     < T_Profile.T_Profile_MinMax.T_Min.rForceDeflection THEN
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rForceDeflection
					:=T_Profile.T_Profile_MinMax.T_Min.rForceDeflection; END_IF
			iStepAction:=10;
			xStepActionDone:=FALSE;
		(* set new speed while axis is moving *)
		10:	IF ptrActivStation^.THWWorkStation.TCylToolDeflection.T_CtrleCyl.xDone AND NOT ptrActivStation^.TCtrlOnlineChange.xLockChangeCylToolDeflectionForce THEN
				ptrActivStation^.THWWorkStation.TCylToolDeflection.T_CtrleCyl.T_Analog.rForceIn:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rForceDeflection;
				ptrActivStation^.THWWorkStation.TCylToolDeflection.T_CtrleCyl.iFunction:=4;
				ptrActivStation^.THWWorkStation.TCylToolDeflection.T_CtrleCyl.xExecute:=TRUE;
				(* next step *)
				iStepAction:=20;
			ELSE
				(* next step *)
				iStepAction:=90;
			END_IF;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		20: IF NOT(xStepActionDone) THEN
				ptrActivStation^.THWWorkStation.TCylToolDeflection.T_CtrleCyl.xExecute:=FALSE;
				(* confirm step *)
				xStepActionDone:=TRUE;
			ELSE
			(* no confirmation will be sended, confirm override *)
				IF ptrActivStation^.THWWorkStation.TCylToolDeflection.T_CtrleCyl.xDone THEN
					iStepAction:=90;
					xStepActionDone:=FALSE;
					T_ExchgParam.T_Visu.T_Message.iState:=48;	(* Info: OnlineChange Wert gesetzt ! *)
				END_IF;
			END_IF
		(* override done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xOnlineChange_DeflectionForceMore:=FALSE;
			xOnlineChange_DeflectionForceLess:=FALSE;
			xUpdateStationParameter:=TRUE;
		END_CASE
	END_IF

(* OnlineChange Parameter S Achse Bearbeitungsgeschwindigkeit +/- *)
	IF xOnlineChange_S_WorkSpeedMore OR xOnlineChange_S_WorkSpeedLess THEN
		(* Step set override *)
		CASE iStepAction OF
		(* modif value *)
		1:	rTmp:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChangeINC.rWorkingSpindleSpeed;
			IF xOnlineChange_S_WorkSpeedLess THEN rTmp:=rTmp *-1; END_IF
			T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpindleSpeed
				:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpindleSpeed + rTmp;
			IF T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpindleSpeed
			     > T_Profile.T_Profile_MinMax.T_Max.rWorkingSpindleSpeed THEN
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpindleSpeed
					:=T_Profile.T_Profile_MinMax.T_Max.rWorkingSpindleSpeed; END_IF
			IF T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpindleSpeed
			     < T_Profile.T_Profile_MinMax.T_Min.rWorkingSpindleSpeed THEN
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpindleSpeed
					:=T_Profile.T_Profile_MinMax.T_Min.rWorkingSpindleSpeed; END_IF
			iStepAction:=10;
			xStepActionDone:=FALSE;
		(* set new speed while axis is moving *)
		10:	IF NOT ptrActivStation^.THWWorkStation.TAxisS.T_CtrleSingle.xNotMoving AND NOT ptrActivStation^.TCtrlOnlineChange.xLockChange_S_WorkSpindleSpeed THEN
				ptrActivStation^.THWWorkStation.TAxisS.T_CtrleSingle.lrVelocity:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rWorkingSpindleSpeed;
				ptrActivStation^.THWWorkStation.TAxisS.T_CtrleSingle.xExecute:=TRUE;
				ptrActivStation^.THWWorkStation.TAxisS.T_CtrleSingle.iFunction:=12;
				(* next step *)
				iStepAction:=20;
			ELSE
				(* next step *)
				iStepAction:=90;
			END_IF;
			xStepActionDone:=FALSE;
		(* confirm execution *)
		20: IF NOT(xStepActionDone) THEN
				ptrActivStation^.THWWorkStation.TAxisS.T_CtrleSingle.xExecute:=FALSE;
				(* confirm step *)
				xStepActionDone:=TRUE;
			ELSE
			(* no confirmation will be sended, confirm override *)
				iStepAction:=90;
				xStepActionDone:=FALSE;
				T_ExchgParam.T_Visu.T_Message.iState:=48;	(* Info: OnlineChange Wert gesetzt ! *)
			END_IF
		(* override done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xOnlineChange_S_WorkSpeedMore:=FALSE;
			xOnlineChange_S_WorkSpeedLess:=FALSE;
			xUpdateStationParameter:=TRUE;
		END_CASE
	END_IF

	(* Max Werte für Online Change Parameter *)
	IF T_StartUp.T_State.xCompleted THEN
		CASE T_ExchgParam.bToolSpindleActive OF
		1:	(* Maxon Spindel *)
			xFctSetOnlineChangeMaxMin(	ptrProfileOnlineChange:=ADR(T_Profile.T_Profile_MinMax),
										rMaxToolSpindleSpeed:=TStation_Work_St1.THWWorkStation.TCtrlWork.rMaxToolSpindleSpeed,
										rMaxForceDeflection:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_SpindleSystem.rMaxDeflectionForce,
										rMaxTorqueLevel:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_TorqueSystem.rMaxTorque,
										rMinTorqueLevel:=0.0);
		2:	(* Beckhoff Spindel L *)
			xFctSetOnlineChangeMaxMin(	ptrProfileOnlineChange:=ADR(T_Profile.T_Profile_MinMax),
										rMaxToolSpindleSpeed:=TStation_Work_St1.THWWorkStation.TCtrlWork.rMaxToolSpindleSpeed,
										rMaxForceDeflection:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_SpindleSystem_L.rMaxDeflectionForce,
										rMaxTorqueLevel:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_TorqueSystem_L.rMaxTorque,
										rMinTorqueLevel:=0.0);
		3:	(* Beckhoff Spindel M *)
			xFctSetOnlineChangeMaxMin(	ptrProfileOnlineChange:=ADR(T_Profile.T_Profile_MinMax),
										rMaxToolSpindleSpeed:=TStation_Work_St1.THWWorkStation.TCtrlWork.rMaxToolSpindleSpeed,
										rMaxForceDeflection:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_SpindleSystem_M.rMaxDeflectionForce,
										rMaxTorqueLevel:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_TorqueSystem_M.rMaxTorque,
										rMinTorqueLevel:=0.0);
		END_CASE;

		T_ExchgParam.T_ProfileCommon.T_OnlineChange.T_Max:=T_Profile.T_Profile_MinMax.T_Max;
		T_ExchgParam.T_ProfileCommon.T_OnlineChange.T_Min:=T_Profile.T_Profile_MinMax.T_Min;
	END_IF;
END_ACTION

ACTION	VisuFunction_ProcessFunction:
(* Prozesse die aus der Stationsebene ausgelöst werden *)
	IF xActionProcStation THEN
		(* Step process machine *)
		CASE iStepAction OF
		(* check process state *)
		1:	iProcessFunctNr:=TProcess.T_Ctrle.iFunctNr;
			xTmp:=	(TProcess.T_Ctrle.xRdy AND TProcess.T_Ctrle.xDone AND NOT(TProcess.T_Ctrle.xError));
			(* next step *)
			IF xTmp THEN
				IF NOT(T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.xReferencedZAxis) THEN
					T_ExchgParam.T_Visu.T_Message.iState:=294;	(* Warnung: Z Achse Ersteinrichtung zuerst durchführen ! *)
					iStepAction:=90;
				ELSE
					IF gxInitialStateActivated THEN
						IF (gxCentringActive OR gxOnlyCentringActive) AND NOT(IxCylWPUnfixAtWorkPos_St1) THEN
							T_ExchgParam.T_Visu.T_Message.iState:=211;	(* Warnung: Zentr.Schlitten von Hand auf Bearb.Position setzen ! *)
							iStepAction:=90;
						ELSE
							iStepAction:=10;
						END_IF;
					ELSE
						T_ExchgParam.T_Visu.T_Message.iState:=293;	(* Warnung: Grundstellungsfahrt zuerst ausführen ! *)
						iStepAction:=90;
					END_IF;
				END_IF;
			ELSE
				iStepAction:=95;
			END_IF;
		(* check process number and start process machine *)
		10:	CASE iProcessFunctNr OF
			(* process available *)
			(*	3=HandBetrieb 1 Loch bearbeitung
				4=WstkEntlade Prozedur
			*)
			3:	T_Visu.T_CtrleProcess.iFunction:=2;
				T_Visu.T_CtrleProcess.xExecute:=TRUE;
				iStepAction:=90;
				T_ExchgParam.T_Visu.T_Message.iState:=49;	(* Info: HandBetrieb Prozess gestartet ! *)
			(* unknown process *)
			ELSE	iStepAction:=95;
			END_CASE
			(* next step *)
			xStepActionDone:=FALSE;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xActionProcStation:=FALSE;
		(* cylinder not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xActionProcStation:=FALSE;
		END_CASE
	END_IF;

(* Prozesse die aus der Maschinenebene ausgelöst werden *)
	IF xActionProcMachine THEN
		(* Step process machine *)
		CASE iStepAction OF
		(* check process state *)
		1:	iProcessFunctNr:=TProcess.T_Ctrle.iFunctNr;
			xTmp:=	(TProcess.T_Ctrle.xRdy AND TProcess.T_Ctrle.xDone AND NOT(TProcess.T_Ctrle.xError));
			(* next step *)
			IF xTmp THEN
				IF NOT(T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.xReferencedZAxis) THEN
					T_ExchgParam.T_Visu.T_Message.iState:=294;	(* Warnung: Z Achse Ersteinrichtung zuerst durchführen ! *)
					iStepAction:=90;
				ELSE
					IF (iProcessFunctNr = 1) THEN
						iStepAction:=10;
					ELSIF gxInitialStateActivated THEN
						IF (gxCentringActive OR gxOnlyCentringActive) AND NOT(IxCylWPUnfixAtWorkPos_St1) THEN
							T_ExchgParam.T_Visu.T_Message.iState:=211;	(* Warnung: Zentr.Schlitten von Hand auf Bearb.Position setzen ! *)
							iStepAction:=90;
						ELSE
							iStepAction:=10;
						END_IF;
					ELSE
						T_ExchgParam.T_Visu.T_Message.iState:=293;	(* Warnung: Grundstellungsfahrt zuerst ausführen ! *)
						iStepAction:=90;
					END_IF;
				END_IF;
			ELSE
				iStepAction:=95;
			END_IF;
		(* check process number and start process machine *)
		10:	CASE iProcessFunctNr OF
			(* process available *)
			(*	1=Maschinen Referenzierung
				2=Automat 
			*)
			1..2:	T_Visu.T_CtrleProcess.iFunction:=1;
					T_Visu.T_CtrleProcess.xExecute:=TRUE;
				iStepAction:=90;
				IF (iProcessFunctNr = 1) THEN
					T_ExchgParam.T_Visu.T_Message.iState:=50;	(* Info: Modul Referenzierung gestartet ! *)
				ELSIF (iProcessFunctNr = 2) THEN
					T_ExchgParam.T_Visu.T_Message.iState:=51;	(* Info: Automat gestartet ! *)
					T_ExchgParam.T_StationCommon.xBlockSelectAutoMode:=TRUE;
				END_IF;
			(* unknown process *)
			ELSE	iStepAction:=95;
			END_CASE
			(* next step *)
			xStepActionDone:=FALSE;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xActionProcMachine:=FALSE;
		(* cylinder not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xActionProcMachine:=FALSE;
		END_CASE
	END_IF;


	IF TProcess.T_Ctrle.xDone AND NOT(TProcess.T_Ctrle.xError) THEN
		T_ExchgParam.T_StationCommon.bActiveStation_St1St2:=0;	(* Automat nicht Aktiv *)
	ELSIF TProcess.T_Ctrle.xError THEN
		T_ExchgParam.T_StationCommon.bActiveStation_St1St2:=2;	(* Automat Fehler *)
	ELSE
		T_ExchgParam.T_StationCommon.bActiveStation_St1St2:=1;	(* Automat Aktiv *)
	END_IF;
END_ACTION

ACTION	VisuFunction_ProcessState:
(* Löschen des Prozesszustandspeicher  *)
	IF xDeleteProcessState THEN
		(* Step  function station  *)
		CASE iStepAction OF
		(* Überprüfe zuerst ob mindestens der OperatorLevel gesetzt ist *)
		1:	xTmp:=	TRUE;
			IF (T_ExchgParam.T_Visu.T_Level.iActLevel < 1) AND NOT(gT_SafetyStatus.xSetupOperateModeActive) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=217;	(* Warnung: Mindestens OperatorLevel wird benötigt ! *)
				iStepAction:=90;
			ELSE
				IF xTmp THEN
					iStepAction:=10;
				ELSE
					iStepAction:=95;
				END_IF;
			END_IF;
		(* Display message to ask for confirmation *)
		10:	T_ExchgParam.T_Visu.T_Message.iState:=103;	(* Aufforderung: Speichern bestätigen <Enter>, abbrechen <Esc> ? *)
			iStepAction:=20;
		(* waiting for key <Enter> or <Esc> *)
		20:	IF RisingEdgeKeyPanel_Enter.Q THEN
				tTimeOutAction:=TimerAction.ET+T#600s;
				iStepAction:=30;
				T_ExchgParam.T_Visu.T_Message.iState:=77;	(* Info: Löschvorgang Automatik Prozesszustand gestartet ! *)
				xStepActionDone:=FALSE;
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN
					iStepAction:=90;
					T_ExchgParam.T_Visu.T_Message.iState:=202;	(* Warnung: Aktion abgebrochen ! *)
				END_IF
			END_IF
			(* An other message has been displayed *)
			IF (T_ExchgParam.T_Visu.T_Message.iState<>103) AND (T_ExchgParam.T_Visu.T_Message.iState<>77) AND (T_ExchgParam.T_Visu.T_Message.iState<>202) THEN iStepAction:=90; END_IF
		(* wait confirmation *)
		30:	T_ExchgParam.T_Visu.T_Message.iState:=78;	(* Info: Automatik Prozesszustand gelöscht ! *)
			gxResetDataAnalysis_St1:=TRUE;
			T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.tAutoProcessTime_St1St2:=T#0s;
			T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.iAutoProcessDay_St1St2:=0;
			T_NovRam.T_Parameter.T_Machine.T_ParamAutomat.diNumberPartWorked_St1St2:=0;
			T_ExchgParam.T_StationCommon.T_Param_Machine.T_ParamAutomat.diNumberPartWorked_St1St2:=0;
			(* action done *)
			iStepAction:=90;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xDeleteProcessState:=FALSE;
			T_Visu.T_CtrleAction.xFunctionActive:=FALSE;
		(* function not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xDeleteProcessState:=FALSE;
			T_Visu.T_CtrleAction.xFunctionActive:=FALSE;
		END_CASE
	END_IF

	T_ExchgParam.T_PartQuality.diActual_NumberHoleToWork:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].diActual_NumberHoleToWork;
	T_ExchgParam.T_PartQuality.sFileName:=T_NovRam.T_Parameter.T_PartAnalysis[gciStationSt1].sFileName;
	T_ExchgParam.T_StationCommon.T_Param_StationWork.T_InfoProcess.diWPNumber:=T_ExchgParam.T_PartQuality.diActual_NumberHoleToWork;

(* Endlos Prozess EIN/AUS *)
(* Zentrieren EIN/AUS *)
(* NurZentrieren EIN/AUS *)
(* Suspenstion EIN/AUS *)
(* ZylWPUnfix EIN/AUS *)
	IF xEndlessProcessOnOff OR xCentringONOFF OR xOnlyCentringONOFF OR xSuspensionONOFF OR xCylWPUnfixONOFF THEN
		(* Step  function station  *)
		CASE iStepAction OF
		(* Überprüfe zuerst ob mindestens der OperatorLevel gesetzt ist *)
		1:	xTmp:=	TRUE;
			IF xEndlessProcessOnOff AND (T_ExchgParam.T_Visu.T_Level.iActLevel < 1) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=217;	(* Warnung: Mindestens OperatorLevel wird benötigt ! *)
				iStepAction:=90;
			ELSE
				IF xTmp THEN
					IF xCentringONOFF OR xOnlyCentringONOFF OR xSuspensionONOFF OR xCylWPUnfixONOFF THEN
						iStepAction:=70;
					ELSE
						iStepAction:=10;
					END_IF
				ELSE
					iStepAction:=95;
				END_IF;
			END_IF;
		(* Display message to ask for confirmation *)
		10:	T_ExchgParam.T_Visu.T_Message.iState:=103;	(* Aufforderung: Speichern bestätigen <Enter>, abbrechen <Esc> ? *)
			iStepAction:=20;
		(* waiting for key <Enter> or <Esc> *)
		20:	IF RisingEdgeKeyPanel_Enter.Q THEN
				iStepAction:=30;
				(* Display message *)
				T_ExchgParam.T_Visu.T_Message.iState:=3;	(* Info: Start speichern... *)
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN
					iStepAction:=90;
					T_ExchgParam.T_Visu.T_Message.iState:=202;	(* Warnung: Aktion abgebrochen ! *)
				END_IF
			END_IF
			(* An other message has been displayed *)
			IF (T_ExchgParam.T_Visu.T_Message.iState<>3) AND (T_ExchgParam.T_Visu.T_Message.iState<>103) AND (T_ExchgParam.T_Visu.T_Message.iState<>202) THEN iStepAction:=90; END_IF
		30:	T_NovRam.T_Parameter.T_Machine.xEndlessProcessActive:=NOT(T_NovRam.T_Parameter.T_Machine.xEndlessProcessActive);
			iStepAction:=40;
		40:	xAction_SaveNovRAM:=TRUE;
			xBlockSetNovRamAction_End:=TRUE;
			iStepActionNovRam:=1;
			iStepAction:=50;
		50:	IF NOT xAction_SaveNovRAM THEN
				iStepAction:=90;
				T_ExchgParam.T_Visu.T_Message.iState:=59;	(* Info: Funktion beendet ! *)
			END_IF;



		70:	IF xCentringONOFF THEN
				gxCentringActive:=NOT(gxCentringActive);
				gxOnlyCentringActive:=FALSE;
			ELSIF xOnlyCentringONOFF THEN
				gxCentringActive:=FALSE;
				gxOnlyCentringActive:=NOT(gxOnlyCentringActive);
			ELSIF xSuspensionONOFF THEN
				IF (T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rSuspensionBubblerSpeed = 0.0) AND (T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rSuspensionFeederSpeed = 0.0) THEN
					IF NOT(gxSuspensionONOFF) THEN
						T_ExchgParam.T_Visu.T_Message.iState:=212;	(* Warnung: Suspensionsparameter sind beide auf Null gesetzt ! *)
					ELSE
						gxSuspensionONOFF:=FALSE;
					END_IF;
				ELSE
					gxSuspensionONOFF:=NOT(gxSuspensionONOFF);
				END_IF;
			ELSIF xCylWPUnfixONOFF THEN
				IF NOT(IxCylWPUnfixAtWorkPos_St1) THEN
					IF NOT(QxCylWPUnfix_St1) THEN
						T_ExchgParam.T_Visu.T_Message.iState:=211;	(* Warnung: Zentr.Schlitten von Hand auf Bearb.Position setzen ! *)
					ELSE
						QxCylWPUnfix_St1:=FALSE;
					END_IF;
				ELSE
					QxCylWPUnfix_St1:=NOT(QxCylWPUnfix_St1);
				END_IF;
			END_IF
			T_NovRam.T_Parameter.T_Machine.xEndlessProcessActive:=FALSE;
			iStepAction:=90;

		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xEndlessProcessOnOff:=FALSE;
			xCentringONOFF:=xOnlyCentringONOFF:=FALSE;
			xSuspensionONOFF:=FALSE;
			xCylWPUnfixONOFF:=FALSE;
			T_Visu.T_CtrleAction.xFunctionActive:=FALSE;
		(* function not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xEndlessProcessOnOff:=FALSE;
			xCentringONOFF:=xOnlyCentringONOFF:=FALSE;
			xSuspensionONOFF:=FALSE;
			xCylWPUnfixONOFF:=FALSE;
			T_Visu.T_CtrleAction.xFunctionActive:=FALSE;
		END_CASE
	END_IF

	IF gxCentringActive OR gxOnlyCentringActive THEN
		T_ExchgParam.T_StationCommon.xShowSelectCentringProcess:=TRUE;
	ELSE
		T_ExchgParam.T_StationCommon.xShowSelectCentringProcess:=FALSE;
	END_IF;
	RisingEdgeCheckCentringProcess(CLK:=	(T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.iCentringSelectProcess <> T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.iCentringSelectProcess));
	IF T_StartUp.T_State.xCompleted AND (T_Visu.T_PlcParam.dwActualPage <> gT_PageNumber.iHandMode_Parameter) THEN
		IF RisingEdgeCheckCentringProcess.Q THEN
			T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.iCentringSelectProcess:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.iCentringSelectProcess;
		END_IF;
	END_IF;
END_ACTION

ACTION	VisuFunction_ProcessStop:
(* Stoppen vom Prozess welches über den HandBetrieb ausgelöst wurde *)
	IF xProcStationStop THEN
		(* Step  function station stop  *)
		CASE iStepAction OF
		(* Überprüfe zuerst den Zustand des Prozesses ob es überhaupt zulässt, den Prozess zu stoppen *)
		1:	xTmp:=	TProcess.T_Ctrle.xRdy
					AND NOT(TProcess.T_Ctrle.xStop)
					AND NOT(TProcess.T_Ctrle.xDone)
					AND NOT(TProcess.T_Ctrle.xError)
					AND NOT(TProcess.T_Ctrle.xAbordProcess);
			T_Visu.T_CtrleProcess.xReset:=TRUE;
			IF xTmp THEN
				iStepAction:=10;
			(* not ready to execute stop *)
			ELSE iStepAction:=95; END_IF
		10:	TProcess.T_Ctrle.xStop:=TRUE;
			(* next step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* wait confirmation *)
		20:	T_ExchgParam.T_Visu.T_Message.iState:=232;	(* Warnung: Unverzüglicher Zyklus-Stopp ! *)
			IF NOT(xStepActionDone) THEN
			(* release execution *)
				xStepActionDone:=TRUE;
			ELSE
				(* Warten bis Prozess beendet ist *)
				IF NOT(TProcess.T_Ctrle.xStop) AND TProcess.T_Ctrle.xDone THEN
					(* action done *)
					iStepAction:=30;
					xStepActionDone:=FALSE;
					T_ExchgParam.T_Visu.T_Message.iState:=236;	(* Warnung: Prozess wurde gestoppt ! *)
					T_VisuQVis.T_CtrleVisu.iFunction:=1;
					T_VisuQVis.T_PlcParam.dwSetNewPage:=dwSaveVisuPage;
					T_VisuQVis.T_CtrleVisu.xExecute:=TRUE;
				END_IF;
			END_IF;
		30:	IF NOT(T_VisuQVis.T_CtrleVisu.xExecute) AND T_VisuQVis.T_CtrleVisu.xDone THEN
				iStepAction:=90;
			END_IF;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xProcStationStop:=FALSE;
			T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
		(* function not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xProcStationStop:=FALSE;
		END_CASE;
	END_IF;

	IF xProcMachineStop THEN
		(* Step  function station stop  *)
		CASE iStepAction OF
		1:	iStepAction:=90;
			IF xProcMachineStop THEN
				iStepActionStop:=1;
				xTmpProcMachineStop:=TRUE;
			END_IF;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xProcMachineStop:=FALSE;
		END_CASE;
	END_IF;

(* Stoppen vom Prozess welches über den Automat ausgelöst wurde *)
	IF xTmpProcMachineStop THEN
		(* Step  function station stop  *)
		CASE iStepActionStop OF
		(* Überprüfe zuerst den Zustand des Prozesses ob es überhaupt zulässt, den Prozess zu stoppen *)
		1:	xTmp:=	TProcess.T_Ctrle.xRdy
					AND NOT(TProcess.T_Ctrle.xStop)
					AND NOT(TProcess.T_Ctrle.xDone)
					AND NOT(TProcess.T_Ctrle.xError)
					AND NOT(TProcess.T_Ctrle.xAbordProcess);
			IF xTmp THEN
				iStepActionStop:=10;
			(* not ready to execute stop *)
			ELSE iStepActionStop:=95; END_IF
		10:	TProcess.T_Ctrle.xStop:=TRUE;
			(* next step *)
			iStepActionStop:=20;
			xStepActionDoneStop:=FALSE;
		(* wait confirmation *)
		20:	T_ExchgParam.T_Visu.T_Message.iState:=232;	(* Warnung: Unverzüglicher Zyklus-Stopp ! *)
			IF NOT(xStepActionDoneStop) THEN
			(* release execution *)
				xStepActionDoneStop:=TRUE;
			ELSE
				IF NOT(TProcess.T_Ctrle.xStop) AND TProcess.T_Ctrle.xDone THEN
					(* Für Maschinenreferenzieren und Wstk Entlade Prozess wird der Prozess beendet *)
					xProcessAbordet:=TRUE;
					iStepActionStop:=90;
					xStepActionDoneStop:=FALSE;
					T_ExchgParam.T_Visu.T_Message.iState:=236;	(* Warnung: Prozess wurde gestoppt ! *)
				END_IF;
			END_IF;
		(* action done *)
		90:	xTmpProcMachineStop:=FALSE;
		(* function not ready *)
		95:	xTmpProcMachineStop:=FALSE;
		END_CASE;
	END_IF;
END_ACTION

ACTION	VisuFunction_ProfileManagement:
(* Erstmalige Kopiervorgang der Profile *)
	IF xAction_CopyProfileToProcess THEN
		(* Set copy action *)
		CASE iStepAction OF
		(* Set default value *)
		1:	xFctSetDefaultValueStaticProfile(ptrT_DefaultProfileParameter:=ADR(T_Profile.T_DefaultProfileParameter));
			(* Init. display value *)
			xProfileFileNotFoundSt1:=FALSE;
			xWrongProfilNameReadedSt1:=FALSE;
			xProfileFileWrongSyntaxSt1:=FALSE;
			xProfileFileWrongSyntax:=FALSE;
			iStepAction:=2; (* Überprüfe zuerst als nächstes ob das USB Stick ansprechbar ist *)
		(* check first if USB-Stick exist *)
		2:	T_Profile.T_Ctrle.iFunction:=3;	(* check if the USB-Stick exist *)
			T_Profile.T_Ctrle.xExecute:=TRUE;
			iStepAction:=3;
		3:	IF NOT(T_Profile.T_Ctrle.xExecute) AND T_Profile.T_Ctrle.xDone THEN
				(* USB Stick exist *)
				iStepAction:=4;
			END_IF;
			IF NOT(T_Profile.T_Ctrle.xExecute) AND T_Profile.T_Ctrle.xErr THEN
				(* USB-Stick does not exist *)
				T_ExchgParam.T_Visu.T_Message.iState:=0;	(* Meldung zurücksetzen *)
				T_Profile.T_Ctrle.xReset:=TRUE;
				iStepAction:=98;
			END_IF;
		(* Read First all exist Profilname for manage the profile  *)
		4:	T_Profile.T_Ctrle.sPathAndFileName:='PROFILE\';
			T_Profile.T_Ctrle.iFunction:=6;
			T_Profile.T_Ctrle.xExecute:=TRUE;
			iStepAction:=5;
		5:	IF NOT(T_Profile.T_Ctrle.xExecute) AND T_Profile.T_Ctrle.xDone THEN
				(* all readed profile are ok *)
				iStepAction:=10;
			END_IF;
			IF NOT(T_Profile.T_Ctrle.xExecute) AND T_Profile.T_Ctrle.xErr THEN
				(* Wrong Syntax-->1 File of Profile is corrupted *)
				T_ExchgParam.T_Visu.T_Message.iState:=0;	(* Meldung zurücksetzen *)
				T_Profile.T_IDProfileStation[1].iNumber:=1;
				T_Profile.T_IDProfileStation[1].sName:='Default';
				T_Profile.T_Ctrle.xReset:=TRUE;
				xProfileFileWrongSyntax:=TRUE;
				iStepAction:=90;
			END_IF;
		(* activ reading profile file *)
		10:	IF T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iProfile > 0 AND T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iProfile <= csiMaxProfile THEN
				T_Profile.T_Ctrle.sPathAndFileName:='PROFILE\';
				T_Profile.T_Id.iNumber:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iProfile;
				T_Profile.T_Id.sName:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.sProfileName;
				T_Profile.T_Ctrle.iFunction:=4;	(* read the profile file *)
				T_Profile.T_Ctrle.xExecute:=TRUE;
				(* next step *)
				iStepAction:=20;
			ELSE iStepAction:=25; END_IF
		20:	IF NOT T_Profile.T_Ctrle.xExecute AND T_Profile.T_Ctrle.xDone THEN
				(* Setzen des aktuellen Prozessabbild welches vom NovRAM ist *)
				T_Profile.T_LoadProfileParameter:=T_Profile.T_CopyProfileParameter;
				T_ExchgParam.T_StationCommon.T_Param_StationWork.T_InfoProcess.iProfile:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iProfile;
				T_ExchgParam.T_StationCommon.T_Param_StationWork.T_InfoProcess.sProfileName:=T_Profile.T_Id.sName;
				garPositionEndProcCalc[gciStationSt1]:=T_NovRam.T_Parameter.arZ1AxisCalcEndPosSaveProfile[gciStationSt1,T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iProfile];
				garCentringEndProcCalc[gciStationSt1]:=T_NovRam.T_Parameter.arZ1CentringCalcEndPosSaveProfile[gciStationSt1,T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iProfile];
				(* check if the read name of the profil file is the same as the save name *)
				IF (T_Profile.T_Ctrle.sProfileName <> T_Profile.T_Id.sName) THEN
					(* overwrite the profilname with the name wrote in the file *)
					T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.sProfileName:=T_Profile.T_Ctrle.sProfileName;
					T_Profile.T_IDProfileStation[T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iProfile].sName:=T_Profile.T_Ctrle.sProfileName;
					xWrongProfilNameReadedSt1:=TRUE;
				END_IF;
				(* next step *)
				iStepAction:=90;
			END_IF
			IF T_Profile.T_Ctrle.xErr THEN
				iToLoadProfileNrSt1:=T_Profile.T_Id.iNumber;
				sToLoadProfileNameSt1:=T_Profile.T_Id.sName;
				IF (T_Profile.T_Ctrle.udiErrorID <> 16#F2000) THEN
					(* Profile file not founded *)
					xProfileFileNotFoundSt1:=TRUE;
				ELSE
					(* wrong syntax of readed Profile file *)
					xProfileFileWrongSyntaxSt1:=TRUE;
				END_IF;
				(* activ reset *)
				T_Profile.T_Ctrle.xReset:=TRUE;
				(* next step *)
				iStepAction:=25;
			END_IF
		(* waiting flag *)
		25:	IF NOT T_Profile.T_Ctrle.xReset AND T_Profile.T_Ctrle.xDone THEN
				IF (T_Profile.T_Id.iNumber = 1) THEN
					T_Profile.T_LoadProfileParameter:=T_Profile.T_DefaultProfileParameter;
					T_ExchgParam.T_StationCommon.T_Param_StationWork.T_InfoProcess.iProfile:=1;
					T_ExchgParam.T_StationCommon.T_Param_StationWork.T_InfoProcess.sProfileName:='Default';
					(* erase name *)
					T_Profile.T_IDProfileStation[1].sName:='Default';
					T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iProfile:=1;
					T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.sProfileName:='Default';
					iStepAction:=90;
				ELSE
					(* erase name *)
					T_Profile.T_IDProfileStation[1].sName:='Default';
					T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iProfile:=1;
					T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.sProfileName:='Default';
					iStepAction:=26;
				END_IF;
			END_IF
		(* activ reading profile file *)
		26:	T_Profile.T_Ctrle.sPathAndFileName:='PROFILE\';
			T_Profile.T_Id.iNumber:=1;
			T_Profile.T_Id.sName:='Default';
			T_Profile.T_Ctrle.iFunction:=4;	(* read the profile file *)
			T_Profile.T_Ctrle.xExecute:=TRUE;
			(* next step *)
			iStepAction:=20;
		(* End function *)
		90:	xTmp:=	xProfileFileNotFoundSt1 OR xWrongProfilNameReadedSt1 OR 	xProfileFileWrongSyntaxSt1 OR xProfileFileWrongSyntax;
			IF xTmp THEN
				IF xProfileFileNotFoundSt1 THEN
					T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=(gciStationSt1 * 1000000) + 16#F301;	(* Datei für zu ladendes Profil nicht gefunden *)
				ELSE
					IF xWrongProfilNameReadedSt1 THEN
						T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=(gciStationSt1 * 1000000) + 16#F303;	(* Profilname von Datei ist anders als geladenes Profil *)
					END_IF;
					IF xProfileFileWrongSyntaxSt1 THEN
						T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=(gciStationSt1 * 1000000) + 16#F304;	(* Syntaxfehler von zu ladendes Profil *)
					END_IF;
					IF xProfileFileWrongSyntax THEN
						T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=16#F303;	(* Syntaxfehler mindestens einer Profildatei beim lesen aller Profile *)
					END_IF;
				END_IF;
				T_ExchgParam.T_SafetyCtrl.xSetForceError:=TRUE;
				xProfileFileNotFoundSt1:=xWrongProfilNameReadedSt1:=xProfileFileWrongSyntaxSt1:=FALSE;
				xProfileFileWrongSyntax:=FALSE;
			END_IF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=16#0;
			xAction_CopyProfileToProcess:=FALSE;
			xUpdateProfileList:=TRUE;
		(* USB-Stick is missing  *)
		98:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Profile.T_Ctrle.xReset:=T_Profile.T_Ctrle.xErr;
			T_ExchgParam.T_SafetyCtrl.xSetForceError:=TRUE;
			T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=16#F300;	(* USB-Stick konnte nicht gefunden werden für Profil lesen/schreiben *)
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xAction_CopyProfileToProcess:=FALSE;
		END_CASE
	END_IF

(* Laden eines ausgewählten Profil in den Prozessabbild *)
	IF xAction_LoadProfile THEN
		(* Step import/export profile value *)
		CASE iStepAction OF
		1:	IF NOT(T_NovRAM.T_Parameter.T_Machine.T_ParamSystem.xActive_ProfilLoadNormalMode) AND
			     NOT(gT_SafetyStatus.xSetupOperateModeActive) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=250;	(* Warning: Laden Profile im Automat ist der Parameter gesperrt ! *)
				iStepAction:=90;
				RETURN;
			END_IF;
			T_ExchgParam.T_Visu.T_Message.iState:=104;	(* Aufforderung: Bestätigen Profil laden <Enter>, abbrechen <Esc> ? *)
			xWrongProfilNameReaded:=FALSE;
			xProfileFileNotFoundSt:=FALSE;
			xProfileFileWrongSyntax:=FALSE;
			(* next step *)
			iStepAction:=10;
		(* waiting for key <Enter> or <Esc> *)
		10:	IF RisingEdgeKeyPanel_Enter.Q THEN
				(* Display message transfering *)
				T_ExchgParam.T_Visu.T_Message.iState:=4;	(* Info: Übertragung von Werten... *)
				tTimeOutAction:=TimerAction.ET+T#10s;
				iStepAction:=11;
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN
					iStepAction:=90;
					T_ExchgParam.T_Visu.T_Message.iState:=202;	(* Warnung: Aktion abgebrochen ! *)
				END_IF
			END_IF
			(* An other message has been displayed *)
			IF (T_ExchgParam.T_Visu.T_Message.iState<>4) AND (T_ExchgParam.T_Visu.T_Message.iState<>104) AND (T_ExchgParam.T_Visu.T_Message.iState<>202) THEN iStepAction:=90; END_IF
		(* check first if USB-Stick exist *)
		11:	T_Profile.T_Ctrle.iFunction:=3;	(* check if the USB-Stick exist *)
			T_Profile.T_Ctrle.xExecute:=TRUE;
			iStepAction:=12;
		12:	IF NOT(T_Profile.T_Ctrle.xExecute) AND T_Profile.T_Ctrle.xDone THEN
				(* USB Stick exist *)
				IF (T_Profile.T_IDProfileStation[T_ExchgParam.T_ProfileCommon.T_Id.iNumber].sName = '') THEN
					T_ExchgParam.T_Visu.T_Message.iState:=218;		(* Warnung: Profil existiert nicht ! *)
					iStepAction:=90;
				ELSE
					iStepAction:=20;
				END_IF;
			END_IF;
			IF NOT(T_Profile.T_Ctrle.xExecute) AND T_Profile.T_Ctrle.xErr THEN
				(* USB-Stick does not exist *)
				T_ExchgParam.T_Visu.T_Message.iState:=0;	(* Meldung zurücksetzen *)
				T_Profile.T_Ctrle.xReset:=TRUE;
				iStepAction:=98;
			END_IF;
		(* Init. reading profile file *)
		20:	(* Save Old Slide Reference Position *)
			T_Profile.T_Ctrle.sPathAndFileName:='PROFILE\';
			T_Profile.T_Id.iNumber:=T_ExchgParam.T_ProfileCommon.T_Id.iNumber;
			T_Profile.T_Id.sName:=T_Profile.T_IDProfileStation[T_ExchgParam.T_ProfileCommon.T_Id.iNumber].sName;
			T_Profile.T_Ctrle.iFunction:=4;	(* read the profile file *)
			T_Profile.T_Ctrle.xExecute:=TRUE;
			(* Display info message *)
			T_ExchgParam.T_Visu.T_Message.iState:=4;	(* Info: Übertragung von Werten... *)
			(* next step *)
			iStepAction:=30;
		(* waiting confirmation signal *)
		30:	T_ExchgParam.T_Visu.T_Message.iState:=4;	(* Info: Übertragung von Werten... *)
			IF NOT T_Profile.T_Ctrle.xExecute AND T_Profile.T_Ctrle.xDone THEN
			(* Copy profile to online value *)
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess:=T_Profile.T_CopyProfileParameter.T_ProzessData;
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange:=T_Profile.T_CopyProfileParameter.T_ProfileOnlineChange;
				T_Profile.T_LoadProfileParameter:=T_Profile.T_CopyProfileParameter;
				IF (T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iProfile <> T_ExchgParam.T_ProfileCommon.T_Id.iNumber) THEN
					(* Anderes Profile geladen und deshalb muss der entsprechende Zählerstand des geladenen Profil übernommen werden *)
					garPositionEndProcCalc[gciStationSt1]:=T_NovRam.T_Parameter.arZ1AxisCalcEndPosSaveProfile[gciStationSt1,T_ExchgParam.T_ProfileCommon.T_Id.iNumber];
					garCentringEndProcCalc[gciStationSt1]:=T_NovRam.T_Parameter.arZ1CentringCalcEndPosSaveProfile[gciStationSt1,T_ExchgParam.T_ProfileCommon.T_Id.iNumber];
				END_IF;
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iProfile:=T_ExchgParam.T_ProfileCommon.T_Id.iNumber;
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.sProfileName:=T_Profile.T_Id.sName;
				T_ExchgParam.T_ProfileCommon.T_OnlineChange.T_Data:=T_Profile.T_LoadProfileParameter.T_ProfileOnlineChange;
				T_ExchgParam.T_ProfileCommon.T_Id.sName:=T_Profile.T_Id.sName;
				T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess:=T_Profile.T_LoadProfileParameter.T_ProzessData;
				(* check if the read name of the profil file is the same as the save name *)
				IF (T_Profile.T_Ctrle.sProfileName <> T_Profile.T_Id.sName) THEN
					(* overwrite the profilname with the name wrote in the file *)
					T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.sProfileName:=T_Profile.T_Ctrle.sProfileName;
					T_ExchgParam.T_ProfileCommon.T_Id.sName:=T_Profile.T_Ctrle.sProfileName;
					T_Profile.T_IDProfileStation[T_ExchgParam.T_ProfileCommon.T_Id.iNumber].sName:=T_Profile.T_Ctrle.sProfileName;
					xWrongProfilNameReaded:=TRUE;
				END_IF;
				(* next step *)
				iStepAction:=40;
			END_IF
			IF T_Profile.T_Ctrle.xErr THEN
				iToLoadProfileNrSt:=T_Profile.T_Id.iNumber;
				sToLoadProfileNameSt:=T_Profile.T_Id.sName;
				(* activ reset *)
				T_Profile.T_Ctrle.xReset:=TRUE;
				IF (T_Profile.T_Ctrle.udiErrorID <> 16#F2000) THEN
					(* Profile file not founded *)
					xProfileFileNotFoundSt:=TRUE;
					T_ExchgParam.T_ProfileCommon.T_Id.sName:='';
					(* Profile will be erased from the profile list *)
					T_Profile.T_IDProfileStation[T_ExchgParam.T_ProfileCommon.T_Id.iNumber].sName:='';
					xUpdateProfileList:=TRUE;
					(* next step *)
					iStepAction:=90;
				ELSE
					(* wrong syntax of readed Profile file *)
					xProfileFileWrongSyntax:=TRUE;
					(* next step *)
					iStepAction:=90;
				END_IF;
			END_IF
		(* save profile number *)
		40:	(* save profile number to process value *)
			T_ExchgParam.T_StationCommon.T_Param_StationWork.T_InfoProcess.iProfile:=T_ExchgParam.T_ProfileCommon.T_Id.iNumber;
			T_ExchgParam.T_StationCommon.T_Param_StationWork.T_InfoProcess.sProfileName:=T_ExchgParam.T_ProfileCommon.T_Id.sName;
			xUpdateHandlingConfig:=TRUE;
			(* activ next step *)
			iStepAction:=50;
		(* active saving data NovRAM *)
		50:	xAction_SaveNovRAM:=TRUE;
			xBlockSetNovRamAction_End:=TRUE;
			iStepActionNovRam:=1;
			(* next step *)
			iStepAction:=60;
		(* waiting confirm saving NovRAM action *)
		60:	IF NOT xAction_SaveNovRAM THEN
				T_ExchgParam.T_Visu.T_Message.iState:=54;	(* Info: Profil wurde geladen ! *)
				IF NOT(xProfileFileNotFoundSt) THEN
					iStepAction:=90;
				ELSE
					iStepAction:=90;
				END_IF;
			END_IF;
		(* save done *)
		90:	IF xProfileFileNotFoundSt OR xWrongProfilNameReaded OR xProfileFileWrongSyntax THEN
				IF xProfileFileNotFoundSt THEN
					T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=(gciStationSt1 * 1000000) + 16#F301;	(* Datei für zu ladendes Profil nicht gefunden *)
				ELSE
					IF xWrongProfilNameReaded THEN
						T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=(gciStationSt1 * 1000000) + 16#F303;	(* Profilname von Datei ist anders als geladenes Profil *)
					ELSE
						T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=(gciStationSt1 * 1000000) + 16#F304;	(* Syntaxfehler von zu ladendes Profil *)
					END_IF;
				END_IF;
				T_ExchgParam.T_SafetyCtrl.xSetForceError:=TRUE;
				xProfileFileNotFoundSt:=xWrongProfilNameReaded:=xProfileFileWrongSyntax:=FALSE;
			END_IF;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xAction_LoadProfile:=FALSE;
		(* USB-Stick is missing  *)
		98:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Profile.T_Ctrle.xReset:=T_Profile.T_Ctrle.xErr;
			T_ExchgParam.T_SafetyCtrl.xSetForceError:=TRUE;
			T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=(gciStationSt1 * 1000000) + 16#F300;	(* USB-Stick konnte nicht gefunden werden für Profil lesen/schreiben *)
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xAction_LoadProfile:=FALSE;
		END_CASE
	ELSE
		IF NOT(xAction_CopyProfileToProcess) THEN
			IF (T_NovRam.T_Parameter.T_StationWork[1].T_InfoProcess.iProfile >= 1) AND (T_NovRam.T_Parameter.T_StationWork[1].T_InfoProcess.iProfile <= 100) THEN
				T_NovRam.T_Parameter.arZ1AxisCalcEndPosSaveProfile[gciStationSt1,T_NovRam.T_Parameter.T_StationWork[1].T_InfoProcess.iProfile]:=garPositionEndProcCalc[gciStationSt1];
				T_NovRam.T_Parameter.arZ1CentringCalcEndPosSaveProfile[gciStationSt1,T_NovRam.T_Parameter.T_StationWork[1].T_InfoProcess.iProfile]:=garCentringEndProcCalc[gciStationSt1];
			END_IF;
		END_IF;
	END_IF

(* Speichern eines ausgewählten Profils *)
	IF xAction_SaveProfile THEN
		(* Step saving NovRAM *)
		CASE iStepAction OF
		(* check first if USB-Stick exist *)
		1:	T_Profile.T_Ctrle.iFunction:=3;	(* check if the USB-Stick exist *)
			T_Profile.T_Ctrle.xExecute:=TRUE;
			iStepAction:=2;
		2:	IF NOT(T_Profile.T_Ctrle.xExecute) AND T_Profile.T_Ctrle.xDone THEN
				(* USB Stick exist *)
				iStepAction:=10;
			END_IF;
			IF NOT(T_Profile.T_Ctrle.xExecute) AND T_Profile.T_Ctrle.xErr THEN
				(* USB-Stick does not exist *)
				T_ExchgParam.T_Visu.T_Message.iState:=0;	(* Meldung zurücksetzen *)
				T_Profile.T_Ctrle.xReset:=TRUE;
				iStepAction:=98;
			END_IF;
		(* Display message to ask for confirmation *)
		10:	IF T_ExchgParam.T_ProfileCommon.T_Id.iNumber > 1 THEN
				IF T_ExchgParam.T_ProfileCommon.T_Id.sName <> '' THEN
					iTmp:=  iFctExistProfileName(	sProfileName:=T_ExchgParam.T_ProfileCommon.T_Id.sName,
												ptrProfileList:=ADR(T_Profile.T_IDProfileStation));
					IF iTmp = T_ExchgParam.T_ProfileCommon.T_Id.iNumber OR iTmp = 0 THEN
						IF (T_ExchgParam.T_StationCommon.T_Param_StationWork.T_InfoProcess.iProfile = T_ExchgParam.T_ProfileCommon.T_Id.iNumber) THEN
							(* Display message 'ask for rewriting' *)
							T_ExchgParam.T_Visu.T_Message.iState:=105;	(* Aufforderung: Das Profil wird überschrieben <Enter>, abbrechen <Esc> ? *)
							(* next step *)
							iStepAction:=20;
						ELSE
							(* Display message 'confirm saving' *)
							T_ExchgParam.T_Visu.T_Message.iState:=103;	(* Aufforderung: Speichern bestätigen <Enter>, abbrechen <Esc> ? *)
							(* next step *)
							iStepAction:=20;
						END_IF
					ELSE
						T_ExchgParam.T_Visu.T_Message.iState:=219;		(* Warnung: Profil existiert schon, Daten nicht gespeichert ! *)
						iStepAction:=90;
					END_IF;
				(* Display message, 'Profile name not correct' *)
				ELSE	T_ExchgParam.T_Visu.T_Message.iState:=220;		(* Warnung: Profilname nicht korrekt ! *)
						iStepAction:=90;
				END_IF
			ELSE
				T_ExchgParam.T_Visu.T_Message.iState:=221;	(* Warnung: Default-Profilwerte können nicht geändert werden ! *)
				iStepAction:=90;
			END_IF
		(* waiting for confirmation key <Enter> or <Esc> *)
		20:	IF RisingEdgeKeyPanel_Enter.Q THEN
			(* Display message *)
				T_ExchgParam.T_Visu.T_Message.iState:=3;		(* Info: Start speichern... *)
				tTimeOutAction:=TimerAction.ET+T#10s;
				(* next step *)
				iStepAction:=30;
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN
					iStepAction:=90;
					T_ExchgParam.T_Visu.T_Message.iState:=202;	(* Warnung: Aktion abgebrochen ! *)
				END_IF
			END_IF
			(* An other message has been displayed *)
			IF (T_ExchgParam.T_Visu.T_Message.iState<>3) AND (T_ExchgParam.T_Visu.T_Message.iState<>103) AND
			     (T_ExchgParam.T_Visu.T_Message.iState<>105) AND (T_ExchgParam.T_Visu.T_Message.iState<>202) THEN iStepAction:=90; END_IF
		30:	(* activ saving profile file *)
			T_Profile.T_Ctrle.sPathAndFileName:='PROFILE\';
			T_Profile.T_Id.iNumber:=T_ExchgParam.T_ProfileCommon.T_Id.iNumber;
			T_Profile.T_Id.sName:=T_ExchgParam.T_ProfileCommon.T_Id.sName;
			T_Profile.T_Ctrle.iFunction:=5;	(* write the profile file *)
			T_Profile.T_Ctrle.xExecute:=TRUE;
			T_Profile.T_CopyProfileParameter.T_ProzessData:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess;
			T_Profile.T_CopyProfileParameter.T_ProfileOnlineChange:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange;
			(* next step *)
			iStepAction:=40;
		(* waiting signal and start saving data in NovRAM *)
		40:	T_ExchgParam.T_Visu.T_Message.iState:=3;		(* Info: Start speichern... *)
			IF NOT(T_Profile.T_Ctrle.xExecute) AND T_Profile.T_Ctrle.xDone THEN
				T_Profile.T_IDProfileStation[T_ExchgParam.T_ProfileCommon.T_Id.iNumber]:=T_ExchgParam.T_ProfileCommon.T_Id;
				(* Process profile value = file profile value *)
				IF (T_ExchgParam.T_ProfileCommon.T_Id.iNumber = T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.iProfile) THEN
					(* Beim speichern eines Profils darf dies nicht durchgeführt werden, sofern nicht das gleiche Profil gespeichert wird wo schon geladen ist,
					    weil sonst der Blaue Profilebalken überschrieben wird *)
					T_ExchgParam.T_StationCommon.T_Param_StationWork.T_InfoProcess.sProfileName:=T_ExchgParam.T_ProfileCommon.T_Id.sName;
					T_Profile.T_LoadProfileParameter:=T_Profile.T_ProcProfileParameter;
					T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_InfoProcess.sProfileName:=T_ExchgParam.T_ProfileCommon.T_Id.sName;
				END_IF
				(* page profile, update profile list *)
				xUpdateProfileList:=TRUE;
				(* next step *)
				iStepAction:=50;
			END_IF
			IF T_Profile.T_Ctrle.xErr THEN
				iStepAction:=98;
			END_IF
		(* save Image in NovRAM *)
		50:	T_NovRAM.T_Ctrle.xExecute:=TRUE;
			T_NovRAM.T_Ctrle.iFunction:=2;
			(* next Step *)
			iStepAction :=60;
			xStepActionDone:=FALSE;
		(* wait save confirmation *)
		60:	IF NOT(xStepActionDone) THEN
				T_NovRAM.T_Ctrle.xExecute:=FALSE;
				(* confirm Step *)
				xStepActionDone:=TRUE;
			ELSE
				IF T_NovRAM.T_Ctrle.xDone THEN
				(* next Step *)
					iStepAction :=90;
					xStepActionDone:=FALSE;
					T_ExchgParam.T_Visu.T_Message.iState:=55;	(* Info: Profil wurde gespeichert ! *)
				ELSE	IF T_NovRAM.T_Ctrle.xErr THEN
							iStepAction:=99;
							xStepActionDone:=FALSE;
						END_IF
				END_IF
			END_IF
		(* save done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xAction_SaveProfile:=FALSE;
		(* NovRAM not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xAction_SaveProfile:=FALSE;
		(* USB-Stick is missing or directory is missing *)
		98:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Profile.T_Ctrle.xReset:=T_Profile.T_Ctrle.xErr;
			IF T_Profile.T_Ctrle.xErr THEN
				T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=(gciStationSt1 * 1000000) + 16#F306;	(* Profil konnte nicht gespeichert werden da Verzeichnis fehlt *)
			ELSE
				T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=(gciStationSt1 * 1000000) + 16#F300;	(* USB-Stick konnte nicht gefunden werden für Profil lesen/schreiben *)
			END_IF;
			T_ExchgParam.T_SafetyCtrl.xSetForceError:=TRUE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xAction_SaveProfile:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xAction_SaveProfile:=FALSE;
			IF T_HDD.T_Ctrle.xErr THEN T_HDD.T_Ctrle.xReset:=TRUE; END_IF
			IF T_Profile.T_Ctrle.xErr THEN T_Profile.T_Ctrle.xReset:=TRUE; END_IF
			IF T_NovRAM.T_Ctrle.xErr THEN T_NovRAM.T_Ctrle.xReset:=TRUE; END_IF;
			T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=(gciStationSt1 * 1000000) + 16#F305;	(* NovRAM Speicher Fehlerhaft *)
			T_ExchgParam.T_SafetyCtrl.xSetForceError:=TRUE;
		END_CASE
	END_IF

(* Löschen eines ausgewählten Profil *)
	IF xActionDeleteProfile THEN
		(* Step delete profile *)
		CASE iStepAction OF
		(* Profile number could not be 1 *)
		1:	IF T_ExchgParam.T_ProfileCommon.T_Id.iNumber < 2 THEN
				T_ExchgParam.T_Visu.T_Message.iState:=222;	(* Warnung: Default Profil kann nicht gelöscht werden ! *)
				iStepAction:=90;
			ELSIF T_ExchgParam.T_StationCommon.T_Param_StationWork.T_InfoProcess.iProfile = T_ExchgParam.T_ProfileCommon.T_Id.iNumber THEN
				T_ExchgParam.T_Visu.T_Message.iState:=223;	(* Warnung: Geladenes Profil kann nicht gelöscht werden ! *)
				iStepAction:=90;
			ELSE
				iStepAction:=2;
			END_IF;
		(* check first if USB-Stick exist *)
		2:	T_Profile.T_Ctrle.iFunction:=3;	(* check if the USB-Stick exist *)
			T_Profile.T_Ctrle.xExecute:=TRUE;
			iStepAction:=3;
		3:	IF NOT(T_Profile.T_Ctrle.xExecute) AND T_Profile.T_Ctrle.xDone THEN
				(* USB Stick exist *)
				iStepAction:=20;
			END_IF;
			IF NOT(T_Profile.T_Ctrle.xExecute) AND T_Profile.T_Ctrle.xErr THEN
				(* USB-Stick does not exist *)
				T_ExchgParam.T_Visu.T_Message.iState:=0;	(* Meldung löschen *)
				T_Profile.T_Ctrle.xReset:=TRUE;
				iStepAction:=98;
			END_IF;
		(* no code, waiting timeout *)
		10:	IF TimerAction.Q THEN xActionDeleteProfile:=FALSE; END_IF;
		20:	T_ExchgParam.T_Visu.T_Message.iState:=106;	(* Aufforderung: Bestätigen Profil löschen <Enter>, abbrechen <Esc> ? *)
			(* next step *)
			iStepAction:=30;
		(* waiting for key <Enter> or <Esc> *)
		30:	IF RisingEdgeKeyPanel_Enter.Q THEN
				T_ExchgParam.T_Visu.T_Message.iState:=5;	(* Info: Start löschen... *)
				(* next step *)
				iStepAction:=40;
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN
					iStepAction:=90;
					T_ExchgParam.T_Visu.T_Message.iState:=202;	(* Warnung: Aktion abgebrochen ! *)
				END_IF
			END_IF
			(* An other message has been displayed *)
			IF (T_ExchgParam.T_Visu.T_Message.iState<>5) AND (T_ExchgParam.T_Visu.T_Message.iState<>106) AND (T_ExchgParam.T_Visu.T_Message.iState<>202) THEN iStepAction:=90; END_IF
		(* Init. deleting profile file *)
		40:	T_Profile.T_Ctrle.sPathAndFileName:='PROFILE\';
			T_Profile.T_Id.iNumber:=T_ExchgParam.T_ProfileCommon.T_Id.iNumber;
			T_Profile.T_Ctrle.iFunction:=8;	(* delete the profile file *)
			T_Profile.T_Ctrle.xExecute:=TRUE;
			iStepAction:=50;
		50:	IF NOT(T_Profile.T_Ctrle.xExecute) AND T_Profile.T_Ctrle.xDone OR T_Profile.T_Ctrle.xErr THEN
				T_Profile.T_Ctrle.xReset:=T_Profile.T_Ctrle.xErr;
				(* Profile will be erased from the profile list *)
				T_Profile.T_IDProfileStation[T_ExchgParam.T_ProfileCommon.T_Id.iNumber].sName:='';
				xUpdateProfileList:=TRUE;
				IF T_Profile.T_Ctrle.xErr THEN
					T_ExchgParam.T_Visu.T_Message.iState:=224;	(* Warnung: Zu löschendes Profil existiert nicht ! *)
					(* next step *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
				ELSE
					(* next step *)
					iStepAction:=70;
					xStepActionDone:=FALSE;
					T_ExchgParam.T_Visu.T_Message.iState:=56;	(* Info: Profil wurde gelöscht ! *)
				END_IF;
			END_IF
		(* active saving data NovRAM *)
		70:	(* Wenn ein Profil gelöscht wird, dann wird der Name auch in der Auswahl des Profilsnamen gelöscht *)
			T_ExchgParam.T_ProfileCommon.T_Id.sName:='';
			xAction_SaveNovRAM:=TRUE;
			xBlockSetNovRamAction_End:=TRUE;
			iStepActionNovRam:=1;
			(* next step *)
			iStepAction:=80;
		(* waiting confirm saving NovRAM action *)
		80:	IF NOT xAction_SaveNovRAM THEN iStepAction:=90; END_IF
		(* save done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xActionDeleteProfile:=FALSE;
		(* USB-Stick is missing  *)
		98:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Profile.T_Ctrle.xReset:=T_Profile.T_Ctrle.xErr;
			T_ExchgParam.T_SafetyCtrl.xSetForceError:=TRUE;
			T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=(gciStationSt1 * 1000000) + 16#F302;	(* USB-Stick konnte nicht gefunden werden für Profil löschen *)
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xActionDeleteProfile:=FALSE;
		END_CASE;
	END_IF;
END_ACTION

ACTION	VisuFunction_SafetyDoor:
(* Toggeln Maschinen- oder Lade- Tür Zuhaltung *)
	IF xMachineDoorUpGuardControlTogOnOff THEN
		(* set new page *)
		CASE iStepAction OF
		(* check ctrle visu *)
		1: 	(* activ next step *)
			iStepAction:=10;
			xStepActionDone:=FALSE;
		(* Set new page *)
		10:	IF xMachineDoorUpGuardControlTogOnOff THEN
				QxCabinDoorLock:=NOT(QxCabinDoorLock);
			END_IF;
			iStepAction:=90;
		(* override done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xMachineDoorUpGuardControlTogOnOff:=FALSE;
		END_CASE
	END_IF

(* Zustandausgabe von Maschinen und Ladetüre für die Visualisierung *)
	IF (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iAutoMode_SafetyCheck) THEN
		(* Zustand 1 für Türe oben geschlossen: Obere Türe ist geschlossen *)
		xSecurityDoorUpCloseState:=	T_TwinSafeIn.IxCabinDoorCloseCh1 AND T_TwinSafeIn.IxCabinDoorCloseCh2 AND T_TwinSafeIn.IxCabinDoorClose AND
									NOT(T_TwinSafeIn.IxCabinDoorOpen);
		(* Zustand für Türe oben geöffnet: Obere Türe ist geöffnet und untere Türe kann geöffnet oder geschlossen sein *)
		xSecurityDoorUpOpenState:=	NOT(T_TwinSafeIn.IxCabinDoorCloseCh1) AND NOT(T_TwinSafeIn.IxCabinDoorCloseCh2) AND NOT(T_TwinSafeIn.IxCabinDoorClose) AND
									T_TwinSafeIn.IxCabinDoorOpen;
		IF xSecurityDoorUpCloseState THEN
			T_ExchgParam.T_SafetyCtrl.bMachineDoorUpState:=2;	(* MaschinenTüre oben geschlossen *)
		ELSIF xSecurityDoorUpOpenState THEN
			T_ExchgParam.T_SafetyCtrl.bMachineDoorUpState:=1;	(* MaschinenTüre oben geöffnet *)
		ELSE
			T_ExchgParam.T_SafetyCtrl.bMachineDoorUpState:=3;	(* MaschinenTüre oben Fehlverhalten *)
		END_IF;
		IF T_TwinSafeIn.IxCabinDoorCloseCh1 THEN
			T_ExchgParam.T_SafetyCtrl.bMachineDoorChannel1State:=2;	(* ON *)
		ELSE
			T_ExchgParam.T_SafetyCtrl.bMachineDoorChannel1State:=1;	(* OFF *)
		END_IF;
		IF T_TwinSafeIn.IxCabinDoorCloseCh2 THEN
			T_ExchgParam.T_SafetyCtrl.bMachineDoorChannel2State:=2;	(* ON *)
		ELSE
			T_ExchgParam.T_SafetyCtrl.bMachineDoorChannel2State:=1;	(* OFF *)
		END_IF;
		IF T_TwinSafeIn.IxCabinDoorOpen THEN
			T_ExchgParam.T_SafetyCtrl.bMachineDoorUpOpenState:=2;	(* ON *)
		ELSE
			T_ExchgParam.T_SafetyCtrl.bMachineDoorUpOpenState:=1;	(* OFF *)
		END_IF;
		IF T_TwinSafeIn.IxCabinDoorClose THEN
			T_ExchgParam.T_SafetyCtrl.bMachineDoorInductiveSensorState:=2;	(* ON *)
		ELSE
			T_ExchgParam.T_SafetyCtrl.bMachineDoorInductiveSensorState:=1;	(* OFF *)
		END_IF;
		IF QxCabinDoorLock AND NOT(IxCabinDoorLocked) THEN
			T_ExchgParam.T_SafetyCtrl.bMachineDoorGuardControlState:=2;		(* ON *)
		ELSIF NOT(QxCabinDoorLock) AND IxCabinDoorLocked THEN
			T_ExchgParam.T_SafetyCtrl.bMachineDoorGuardControlState:=1;		(* OFF *)
		ELSE
			T_ExchgParam.T_SafetyCtrl.bMachineDoorGuardControlState:=3;		(* Fehlverhalten *)
		END_IF;
	END_IF;
END_ACTION

ACTION	VisuFunction_SetNewPage:
(* Set New page *)
	IF xSetNewPage THEN
		(* set new page *)
		CASE iStepAction OF
		(* check ctrle visu *)
		1: 	(* activ next step *)
			iStepAction:=10;
			xStepActionDone:=FALSE;
			xTmp:=	NOT(T_Visu.T_CtrleVisu.xDone)
					OR T_Visu.T_CtrleVisu.xExecute
					OR T_Visu.T_CtrleVisu.xErr;
			IF xTmp THEN iStepAction:=95; END_IF
		(* Set new page *)
		10:	T_Visu.T_CtrleVisu.iFunction:=1;
			T_Visu.T_CtrleVisu.xExecute:=TRUE;
			(* activ step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* wait for changing page *)
		20:	IF NOT(xStepActionDone) THEN
			(* release execution *)
				T_Visu.T_CtrleVisu.xExecute:=FALSE;
				(* confirm step done *)
				xStepActionDone:=TRUE;
			ELSE
				IF T_Visu.T_CtrleVisu.xDone THEN
				(* activ next step *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
				END_IF
				IF T_Visu.T_CtrleVisu.xErr THEN
				(* activ next error *)
					iStepAction:=99;
					xStepActionDone:=FALSE;
				END_IF
			END_IF
		(* override done *)
		90:	xBlockConfirmMessage:=TRUE;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSetNewPage:=FALSE;
		(* not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xSetNewPage:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F0000 + T_Visu.T_CtrleAction.iFunction;
			xSetNewPage:=FALSE;
		END_CASE
	END_IF
END_ACTION

ACTION	VisuFunction_SetNewPageVertical:
(* Action Set main page auto/station + next/previous page vertical*)
	IF xNextPageVertical OR  xPreviousPageVertical THEN
		(* set next or previous page vertical *)
		CASE iStepAction OF
		(* check if page exist *)
		1:	(* init. variable *)
			iStepAction:=90;
			IF T_StartUp.T_State.xBlockChangeMovementVisu THEN RETURN; END_IF;
			(* vertical page navigation *)
			IF (T_Visu.T_PlcParam.dwActualPage > 1) AND (T_Visu.T_PlcParam.dwActualPage < 999) THEN
			(* array ranch 1 to 999 *)
				(* activ next page vertical *)
				IF xNextPageVertical THEN
					(* start page vertical *)
					iStepAction:=30;
					IF (T_Visu.T_PageIndex[T_Visu.T_PlcParam.dwActualPage+1].iIndexConfigPage) <> 0 THEN iStepAction:=10; END_IF
				END_IF
				(* activ previous page vertical *)
				IF xPreviousPageVertical THEN
					IF ((T_Visu.T_PageIndex[T_Visu.T_PlcParam.dwActualPage-1].iIndexConfigPage) <> 0) THEN
						iStepAction:=20;
					ELSE
						(* Set Last Page from Task *)
						iStepAction:=40;
					END_IF;
				END_IF
			END_IF
		(* next page vertical *)
		10:	(* activ step *)
			iStepAction:=80;
			xStepActionDone:=FALSE;
			T_Visu.T_PlcParam.dwSetNewPage:=T_Visu.T_PlcParam.dwActualPage+1;
			T_Visu.T_CtrleVisu.iFunction:=1;
			T_Visu.T_CtrleVisu.xExecute:=TRUE;
		(* previous page vertical *)
		20:	T_Visu.T_PlcParam.dwSetNewPage:=T_Visu.T_PlcParam.dwActualPage-1;
			T_Visu.T_CtrleVisu.iFunction:=1;
			T_Visu.T_CtrleVisu.xExecute:=TRUE;
			(* activ step *)
			iStepAction:=80;
			xStepActionDone:=FALSE;
		(* start page vertical *)
		30:	iTmp:=DWORD_TO_INT(T_Visu.T_PlcParam.dwActualPage);
			WHILE (iTmp MOD 10) <> 0 DO
				iTmp:=iTmp-1;
			END_WHILE
			T_Visu.T_PlcParam.dwSetNewPage:=iTmp;
			T_Visu.T_CtrleVisu.iFunction:=1;
			T_Visu.T_CtrleVisu.xExecute:=TRUE;
			(* activ step *)
			iStepAction:=80;
			xStepActionDone:=FALSE;
		40:	FOR ii:=1 TO 9 DO
				IF (T_Visu.T_PageIndex[T_Visu.T_PlcParam.dwActualPage+ii].iIndexConfigPage = 0) THEN
					T_Visu.T_PlcParam.dwSetNewPage:=T_Visu.T_PlcParam.dwActualPage+ii - 1;
					T_Visu.T_CtrleVisu.iFunction:=1;
					T_Visu.T_CtrleVisu.xExecute:=TRUE;
					(* activ step *)
					iStepAction:=80;
					xStepActionDone:=FALSE;
					EXIT;
				END_IF;
			END_FOR;
		(* wait for changing page *)
		80:	IF NOT(xStepActionDone) THEN
			(* release execution *)
				T_Visu.T_CtrleVisu.xExecute:=FALSE;
				(* confirm step done *)
				xStepActionDone:=TRUE;
			ELSE
				IF T_Visu.T_CtrleVisu.xDone THEN
				(* activ next step *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
				END_IF
				IF T_Visu.T_CtrleVisu.xErr THEN
				(* activ next error *)
					iStepAction:=99;
					xStepActionDone:=FALSE;
				END_IF
			END_IF
		(* override done *)
		90:	xBlockConfirmMessage:=TRUE;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xNextPageVertical:=FALSE;
			xPreviousPageVertical:=FALSE;
		(* not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xNextPageVertical:=FALSE;
			xPreviousPageVertical:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F0000 + T_Visu.T_CtrleAction.iFunction;
			xNextPageVertical:=FALSE;
			xPreviousPageVertical:=FALSE;
		END_CASE
	END_IF
END_ACTION

ACTION	VisuFunction_SetParameterPage:
(* Set parameter page *)
	IF xSetParameterPage THEN
		(* set new page *)
		CASE iStepAction OF
		(* check ctrle visu *)
		1: 	(* activ next step *)
			iStepAction:=10;
			xStepActionDone:=FALSE;
			xTmp:=	NOT(T_Visu.T_CtrleVisu.xDone)
					OR T_Visu.T_CtrleVisu.xExecute
					OR T_Visu.T_CtrleVisu.xErr;
			IF xTmp THEN iStepAction:=95; END_IF
		(* Set new page *)
		10:	xUpdateStationParameter:=TRUE;
			T_Visu.T_CtrleVisu.iFunction:=1;
			T_Visu.T_CtrleVisu.xExecute:=TRUE;
			awSaveStateTaskBar[T_ExchgParam.T_Visu.bActiveSetupMode]:=T_ExchgParam.T_TouchScreenNavPanel.wState;
			(* activ step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* wait for changing page *)
		20:	IF NOT(xStepActionDone) THEN
			(* release execution *)
				T_Visu.T_CtrleVisu.xExecute:=FALSE;
				(* confirm step done *)
				xStepActionDone:=TRUE;
			ELSE
				IF T_Visu.T_CtrleVisu.xDone THEN
				(* activ next step *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
				END_IF
				IF T_Visu.T_CtrleVisu.xErr THEN
				(* activ next error *)
					iStepAction:=99;
					xStepActionDone:=FALSE;
				END_IF
			END_IF
		(* override done *)
		90:	xBlockConfirmMessage:=TRUE;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSetParameterPage:=FALSE;
		(* not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xSetParameterPage:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F0000 + T_Visu.T_CtrleAction.iFunction;
			xSetParameterPage:=FALSE;
		END_CASE
	END_IF
END_ACTION

ACTION	VisuFunction_SetPreviousPage:
(* Set previous page *)
	IF xSetPreviousPage THEN
		(* set previous page *)
		CASE iStepAction OF
		(* check ctrle visu *)
		1: 	(* activ next step *)
			iStepAction:=10;
			xStepActionDone:=FALSE;
			xTmp:=	NOT(T_Visu.T_CtrleVisu.xDone)
					OR T_Visu.T_CtrleVisu.xExecute
					OR T_Visu.T_CtrleVisu.xErr;
			IF xTmp THEN iStepAction:=95; END_IF
		(* Set new page *)
		10:	xUpdateStationParameter:=TRUE;
			T_Visu.T_CtrleVisu.iFunction:=1;
			T_Visu.T_PlcParam.dwSetNewPage:=dwSaveActualPageTask[T_ExchgParam.T_Visu.bActiveSetupMode,iFct_GetBitNumber(wInputButton:=awSaveStateTaskBar[T_ExchgParam.T_Visu.bActiveSetupMode])];
			T_Visu.T_CtrleVisu.xExecute:=TRUE;
			(* activ step *)
			iStepAction:=20;
			xStepActionDone:=FALSE;
		(* wait for changing page *)
		20:	IF NOT(xStepActionDone) THEN
			(* release execution *)
				T_Visu.T_CtrleVisu.xExecute:=FALSE;
				(* confirm step done *)
				xStepActionDone:=TRUE;
			ELSE
				IF T_Visu.T_CtrleVisu.xDone THEN
				(* activ next step *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
				END_IF
				IF T_Visu.T_CtrleVisu.xErr THEN
				(* activ next error *)
					iStepAction:=99;
					xStepActionDone:=FALSE;
				END_IF
			END_IF
		(* override done *)
		90:	xBlockConfirmMessage:=TRUE;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSetPreviousPage:=FALSE;
		(* not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xSetPreviousPage:=FALSE;
		(* error *)
		99:	T_Visu.T_CtrleAction.xDone:=FALSE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=TRUE;
			T_Visu.T_CtrleAction.udiErrorID:=16#F0000 + T_Visu.T_CtrleAction.iFunction;
			xSetPreviousPage:=FALSE;
		END_CASE
	END_IF
END_ACTION

ACTION	VisuFunction_Setup_Z_Axis:
(* Ausführen von Stationsfunktionen für das Einrichten der Z Achse für die Ersteinrichtung *)
	IF xStationSetupAxisZFunction THEN
		(* Step  function station  *)
		CASE iStepAction OF
		(* Überprüfe zuerst ob die Stationen bereit stehen  *)
		1:	(* For start the procedure, it need the system level *)
			IF (T_ExchgParam.T_Visu.T_Level.iActLevel <> 2) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=216;	(* Warnung: Diese Parameter können nur auf SystemLevel geändert werden ! *)
				iStepAction:=90;
				RETURN;
			END_IF;
			xTmp:=	ptrActivStation^.TControl.xDone
					AND ptrActivStation^.TControl.xRdy
					AND NOT(ptrActivStation^.TControl.xExecute)
					AND NOT(ptrActivStation^.TControl.xError)
					AND NOT(ptrActivStation^.TControl.xStop);
			(* next step *)
			IF xTmp THEN
				T_ExchgParam.T_StationCommon.iZAxisFirstSetup_StepNr:=2;				(* Untere Anweisung durchführen!! *)
				T_ExchgParam.T_StationCommon.iZAxisFirstSetupStartButton_StepNr:=2;	(* Nachträglich Bitte StartTaste drücken! *)
				T_ExchgParam.T_StationCommon.iZAxisFirstSetup_ShowObjectNr:=2;
				iStepAction:=10;
				T_ExchgParam.T_Visu.T_Message.iState:=58;	(* Info: Funktion gestartet ! *)
			ELSE iStepAction:=95; END_IF
		(* Visu Ressource muss frei gegeben werden, da in dieser Prozedur noch zusätzliche VisuFunktionen benötigt werden *)
		10:	xTmpStationSetupAxisZFunction:=TRUE;
			iStepHelpVisuFunction:=1;
			T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;	(* Blockiere die Visu Navigation *)
			iStepAction:=90;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xStationSetupAxisZFunction:=FALSE;
		(* function not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xStationSetupAxisZFunction:=FALSE;
		END_CASE
	ELSE
		IF NOT(xTmpStationSetupAxisZFunction) THEN
			T_ExchgParam.T_StationCommon.iZAxisFirstSetup_StepNr:=1;				(* Setzen der Z Nullstellung und ausmessen der Endschalter! *)
			T_ExchgParam.T_StationCommon.iZAxisFirstSetupStartButton_StepNr:=1;	(* Bitte StartTaste drücken für Prozedur zu starten! *)
			T_ExchgParam.T_StationCommon.iZAxisFirstSetup_ShowObjectNr:=1;
		END_IF;
	END_IF

	T_ExchgParam.T_StationCommon.rZAxisFirstSetup_OffsetSpinToDeskTop:=290.0;						(* 290mm muss eingerichtet werden und zwar distanz zwischen Spindel und Tischplatte *)
	rZAxisSetPosition:=T_ExchgParam.T_StationCommon.rZAxisFirstSetup_OffsetSpinToDeskTop - 190.0;	(* 190.0mm ist die Distanz zwischen Tischplatte und Spindel wo dann die Nullstellung definiert wird *)

	IF xTmpStationSetupAxisZFunction THEN
		CASE iStepHelpVisuFunction OF
		(* Erst Einrichtung der Z Axis *)
		1:	T_Visu.T_CtrleAction.xFunctionActive:=TRUE;
			T_CtrleBtStartStop.xForceSetStartButton:=TONWaitReadyStartButton.Q;
			IF xStartButton THEN
				TONWaitReadyStartButton(IN:=FALSE);
				T_ExchgParam.T_StationCommon.iZAxisFirstSetup_StepNr:=3;				(* Z Position wie unteres Bild setzen! *)
				T_ExchgParam.T_StationCommon.iZAxisFirstSetupStartButton_StepNr:=3;	(* Nachträglich Bitte StartTaste drücken um Position zu übernehmen *)
				T_ExchgParam.T_StationCommon.iZAxisFirstSetup_ShowObjectNr:=3;
				iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
				(* next step *)
				xTmpStepActionDone:=FALSE;
			END_IF;
		2:	T_CtrleBtStartStop.xForceSetStartButton:=TONWaitReadyStartButton.Q;
			IF xStartButton THEN
				TONWaitReadyStartButton(IN:=FALSE);
				T_ExchgParam.T_StationCommon.iZAxisFirstSetup_StepNr:=4;				(* Automatisches suchen des Z negativen Endschalter! *)
				T_ExchgParam.T_StationCommon.iZAxisFirstSetupStartButton_StepNr:=4;	(* Bitte StartTaste drücken um Bewegung auszulösen! *)
				T_ExchgParam.T_StationCommon.iZAxisFirstSetup_ShowObjectNr:=4;
				iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
			END_IF;
		(* Setzen der Nullposition der Z2 Achse *)
		3:	T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.rPositionReferenceZAxis_Old:=	T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.rPositionReferenceZAxis;
			IF NOT(T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.xReferencedZAxis) THEN
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.rPositionReferenceZAxis:=ptrActivStation^.THWWorkStation.TAxisZ.T_LiveValue.lrActualPosition + rZAxisSetPosition;
			ELSE
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.rPositionReferenceZAxis:=	T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.rPositionReferenceZAxis +
																																ptrActivStation^.THWWorkStation.TAxisZ.T_LiveValue.lrActualPosition +
																																rZAxisSetPosition;
			END_IF;
			T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_StProcess.rPositionEndMech:=0;
			ptrActivStation^.THWWorkStation.TAxisZ.T_CtrleSingle.iFunction:=11;	(* Position setzen *)
			ptrActivStation^.THWWorkStation.TAxisZ.T_CtrleSingle.rSetPosition:=(rZAxisSetPosition * -1.0);
			ptrActivStation^.THWWorkStation.TAxisZ.T_CtrleSingle.xExecute:=TRUE;
			iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
		4:	IF NOT(ptrActivStation^.THWWorkStation.TAxisZ.T_CtrleSingle.xExecute) AND ptrActivStation^.THWWorkStation.TAxisZ.T_CtrleSingle.xDone THEN
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.xReferencedZAxis:=TRUE;
				iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
			END_IF;
		5:	xAction_SaveNovRAM:=TRUE;
			xBlockSetNovRamAction_End:=TRUE;
			iStepActionNovRam:=1;
			iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
		6:	IF NOT(xAction_SaveNovRAM) THEN
				xUpdateStationParameter:=TRUE;
				iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
			END_IF;
		7:	T_CtrleBtStartStop.xForceSetStartButton:=TONWaitReadyStartButton.Q;
			IF xStartButton THEN
				TONWaitReadyStartButton(IN:=FALSE);
				T_ExchgParam.T_StationCommon.iZAxisFirstSetup_StepNr:=4;				(* Automatisches suchen des Z negativen Endschalter! *)
				T_ExchgParam.T_StationCommon.iZAxisFirstSetupStartButton_StepNr:=5;	(* Ausmessung der Z Achse ist am durchführen... *)
				T_ExchgParam.T_StationCommon.iZAxisFirstSetup_ShowObjectNr:=4;
				iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
				ptrActivStation^.TControl.xExecute:=TRUE;
				ptrActivStation^.TControl.iFunctNr:=9;	(* Erstinitialisierung der Z Achse *)
				(* next step *)
				xTmpStepActionDone:=FALSE;
			END_IF;
		(* wait confirmation *)
		8:	IF NOT(xTmpStepActionDone) THEN
			(* release execution *)
				ptrActivStation^.TControl.xExecute:=FALSE;
				xTmpStepActionDone:=TRUE;
			ELSE
				IF ptrActivStation^.TControl.xDone THEN
					T_ExchgParam.T_StationCommon.iZAxisFirstSetup_StepNr:=5;				(* Nullstellung der Z Achse ist gesetzt! *)
					T_ExchgParam.T_StationCommon.iZAxisFirstSetupStartButton_StepNr:=6;	(* Bitte StartTaste drücken um Prozedur abzuschliessen! *)
					T_ExchgParam.T_StationCommon.iZAxisFirstSetup_ShowObjectNr:=5;
					(* action done *)
					iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
					xTmpStepActionDone:=FALSE;
				END_IF
			END_IF
		(* Anzeigen der Position für die Erstinitialisierung der Z Achse und dann Prozedur beenden *)
		9:	T_CtrleBtStartStop.xForceSetStartButton:=TONWaitReadyStartButton.Q;
			IF xStartButton THEN
				TONWaitReadyStartButton(IN:=FALSE);
				T_ExchgParam.T_StationCommon.iZAxisFirstSetup_StepNr:=1;				(* Setzen der Z Nullstellung und ausmessen der Endschalter! *)
				T_ExchgParam.T_StationCommon.iZAxisFirstSetupStartButton_StepNr:=1;	(* Bitte StartTaste drücken für Prozedur zu starten! *)
				T_ExchgParam.T_StationCommon.iZAxisFirstSetup_ShowObjectNr:=1;
				iStepHelpVisuFunction:=1;
				(* next step *)
				xTmpStepActionDone:=FALSE;
				xTmpStationSetupAxisZFunction:=FALSE;
				T_Visu.T_CtrleAction.xFunctionActive:=FALSE;
				T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
				T_ExchgParam.T_Visu.T_Message.iState:=59;	(* Info: Funktion beendet ! *)
			END_IF;
		END_CASE;
	END_IF;

	IF (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iWorkStation_Setup3) THEN
		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_AxisState.rPositionNegLimitSwitchZAxis:=
												T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.rPositionNegLimitSwitchZAxis;
		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_AxisState.rPositionNegLimitSwitchZAxis_Old:=
												T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.rPositionNegLimitSwitchZAxis_Old;
		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_AxisState.rPositionReferenceZAxis:=
												T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.rPositionReferenceZAxis;
		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_AxisState.rPositionReferenceZAxis_Old:=
												T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.rPositionReferenceZAxis_Old;
		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_AxisState.xReferencedZAxis:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.xReferencedZAxis;
		T_ExchgParam.T_StationCommon.xInitial_FirstSetupZ:=	T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.xReferencedZAxis;
	END_IF;
END_ACTION

ACTION	VisuFunction_Setup_Z_Axis_ToolGuide:
(* Ausführen von Stationsfunktionen für das Einrichten der Z Achse für das bestimmen der Z Achsen Position in Abhängigkeit der Position des oberen Führungsrohr *)
	IF xStationSetupAxisZFunctionToolGuide THEN
		(* Step  function station  *)
		CASE iStepAction OF
		(* Überprüfe zuerst ob die Stationen bereit stehen  *)
		1:	(* For start the procedure, it need the system level *)
			IF (T_ExchgParam.T_Visu.T_Level.iActLevel <> 2) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=216;	(* Warnung: Diese Parameter können nur auf SystemLevel geändert werden ! *)
				iStepAction:=90;
				RETURN;
			END_IF;
			IF NOT(T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.xReferencedZAxis) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=294;	(* Warnung: Z Achse Ersteinrichtung zuerst durchführen ! *)
				iStepAction:=90;
				RETURN;
			END_IF;
			xTmp:=	ptrActivStation^.TControl.xDone
					AND ptrActivStation^.TControl.xRdy
					AND NOT(ptrActivStation^.TControl.xExecute)
					AND NOT(ptrActivStation^.TControl.xError)
					AND NOT(ptrActivStation^.TControl.xStop);
			(* next step *)
			IF xTmp THEN
				T_ExchgParam.T_StationCommon.iZAxisGuideTube_StepNr:=2;				(* Untere Anweisung durchführen! *)
				T_ExchgParam.T_StationCommon.iZAxisGuideTubeStartButton_StepNr:=2;		(* Nachträglich Bitte StartTaste drücken! *)
				T_ExchgParam.T_StationCommon.iZAxisGuideTube_ShowObjectNr:=2;
				iStepAction:=10;
				T_ExchgParam.T_Visu.T_Message.iState:=58;	(* Info: Funktion gestartet ! *)
			ELSE iStepAction:=95; END_IF
		(* Visu Ressource muss frei gegeben werden, da in dieser Prozedur noch zusätzliche VisuFunktionen benötigt werden *)
		10:	xTmpStationSetupAxisZFunctionToolGuide:=TRUE;
			iStepHelpVisuFunction:=1;
			T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;	(* Blockiere die Visu Navigation *)
			iStepAction:=90;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xStationSetupAxisZFunctionToolGuide:=FALSE;
		(* function not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xStationSetupAxisZFunctionToolGuide:=FALSE;
		END_CASE
	ELSE
		IF NOT(xTmpStationSetupAxisZFunctionToolGuide) THEN
			T_ExchgParam.T_StationCommon.iZAxisGuideTube_StepNr:=1;				(* Setzen der abhängigkeit Z Achse und oberes Führungsrohr! *)
			T_ExchgParam.T_StationCommon.iZAxisGuideTubeStartButton_StepNr:=1;		(* Bitte StartTaste drücken für Prozedur zu starten! *)
			T_ExchgParam.T_StationCommon.iZAxisGuideTube_ShowObjectNr:=1;
		END_IF;
	END_IF

	T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_Z_TGuide.rDistanceTGuideToTableBoard:=250.0;	(* Distanz zwischen dem Schlitten des oberen Führungsrohr zur Tischplatte muss 250mm eingestellt werden *)
	T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_Z_TGuide.rScaleDefinedPos:=160.0;	(* Wenn der Schlitten des oberen Führungsrohr auf diese 250mm gesetzt ist, dann muss der Massstab so eingerichtet werden, dass es auf 160mm steht *)

	IF xTmpStationSetupAxisZFunctionToolGuide THEN
		CASE iStepHelpVisuFunction OF
		(* Erst Einrichtung der Z Axis *)
		1:	T_Visu.T_CtrleAction.xFunctionActive:=TRUE;
			T_CtrleBtStartStop.xForceSetStartButton:=TONWaitReadyStartButton.Q;
			IF xStartButton THEN
				TONWaitReadyStartButton(IN:=FALSE);
				T_ExchgParam.T_StationCommon.iZAxisGuideTube_StepNr:=3;				(* Untere Anweisung durchführen! *)
				T_ExchgParam.T_StationCommon.iZAxisGuideTubeStartButton_StepNr:=3;		(* Nachträglich Bitte StartTaste drücken! *)
				T_ExchgParam.T_StationCommon.iZAxisGuideTube_ShowObjectNr:=3;
				iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
				(* next step *)
				xTmpStepActionDone:=FALSE;
			END_IF;
		2:	T_CtrleBtStartStop.xForceSetStartButton:=TONWaitReadyStartButton.Q;
			IF xStartButton THEN
				TONWaitReadyStartButton(IN:=FALSE);
				T_ExchgParam.T_StationCommon.iZAxisGuideTube_StepNr:=4;				(* Untere Anweisung durchführen! *)
				T_ExchgParam.T_StationCommon.iZAxisGuideTubeStartButton_StepNr:=4;		(* Nachträglich Bitte StartTaste drücken! *)
				T_ExchgParam.T_StationCommon.iZAxisGuideTube_ShowObjectNr:=4;
				iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
			END_IF;
		3:	T_CtrleBtStartStop.xForceSetStartButton:=TONWaitReadyStartButton.Q;
			IF xStartButton THEN
				TONWaitReadyStartButton(IN:=FALSE);
				T_ExchgParam.T_StationCommon.iZAxisGuideTube_StepNr:=5;				(* Untere Anweisung durchführen! *)
				T_ExchgParam.T_StationCommon.iZAxisGuideTubeStartButton_StepNr:=5;		(* Nachträglich Bitte StartTaste drücken! *)
				T_ExchgParam.T_StationCommon.iZAxisGuideTube_ShowObjectNr:=5;
				iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_Z_TGuide.rToolLengthSetup:=
					T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Z_TGuide.rToolLengthSetup;
			END_IF;
		4:	xAction_SaveNovRAM:=TRUE;
			xBlockSetNovRamAction_End:=TRUE;
			iStepActionNovRam:=1;
			iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
		5:	IF NOT(xAction_SaveNovRAM) THEN
				xUpdateStationParameter:=TRUE;
				iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
			END_IF;
		6:	T_CtrleBtStartStop.xForceSetStartButton:=TONWaitReadyStartButton.Q;
			IF xStartButton THEN
				TONWaitReadyStartButton(IN:=FALSE);
				T_ExchgParam.T_StationCommon.iZAxisGuideTube_StepNr:=6;				(* Untere Anweisung durchführen! *)
				T_ExchgParam.T_StationCommon.iZAxisGuideTubeStartButton_StepNr:=6;		(* Nachträglich Bitte StartTaste drücken! *)
				T_ExchgParam.T_StationCommon.iZAxisGuideTube_ShowObjectNr:=6;
				iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_Z_TGuide.rDistanceTGuideToTableBoardLess:=
					T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Z_TGuide.rDistanceTGuideToTableBoardLess;
			END_IF;
		7:	xAction_SaveNovRAM:=TRUE;
			xBlockSetNovRamAction_End:=TRUE;
			iStepActionNovRam:=1;
			iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
		8:	IF NOT(xAction_SaveNovRAM) THEN
				xUpdateStationParameter:=TRUE;
				iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
			END_IF;
		9:	T_CtrleBtStartStop.xForceSetStartButton:=TONWaitReadyStartButton.Q;
			IF xStartButton THEN
				TONWaitReadyStartButton(IN:=FALSE);
				T_ExchgParam.T_StationCommon.iZAxisGuideTube_StepNr:=7;				(* Abhängigkeit ist gesetzt! *)
				T_ExchgParam.T_StationCommon.iZAxisGuideTubeStartButton_StepNr:=7;		(* Bitte StartTaste drücken um Prozedur abzuschliessen! *)
				T_ExchgParam.T_StationCommon.iZAxisGuideTube_ShowObjectNr:=7;
				iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_Z_TGuide.rOffset_Z_ToolGuide_Old:=
					T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_Z_TGuide.rOffset_Z_ToolGuide;
				T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_Z_TGuide.rOffset_Z_ToolGuide:=
					ptrTCommonAxis^.T_LiveValue.lrActualPosition;
			END_IF;
		10:	xAction_SaveNovRAM:=TRUE;
			xBlockSetNovRamAction_End:=TRUE;
			iStepActionNovRam:=1;
			iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
		11:	IF NOT(xAction_SaveNovRAM) THEN
				xUpdateStationParameter:=TRUE;
				iStepHelpVisuFunction:=iStepHelpVisuFunction + 1;
			END_IF;
		(* Anzeigen der Position für die Erstinitialisierung der Z Achse und dann Prozedur beenden *)
		12:	T_CtrleBtStartStop.xForceSetStartButton:=TONWaitReadyStartButton.Q;
			IF xStartButton THEN
				TONWaitReadyStartButton(IN:=FALSE);
				T_ExchgParam.T_StationCommon.iZAxisGuideTube_StepNr:=1;				(* Setzen der abhängigkeit Z Achse und oberes Führungsrohr! *)
				T_ExchgParam.T_StationCommon.iZAxisGuideTubeStartButton_StepNr:=1;		(* Bitte StartTaste drücken für Prozedur zu starten! *)
				T_ExchgParam.T_StationCommon.iZAxisGuideTube_ShowObjectNr:=1;
				iStepHelpVisuFunction:=1;
				(* next step *)
				xTmpStepActionDone:=FALSE;
				xTmpStationSetupAxisZFunctionToolGuide:=FALSE;
				T_Visu.T_CtrleAction.xFunctionActive:=FALSE;
				T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
				T_ExchgParam.T_Visu.T_Message.iState:=59;	(* Info: Funktion beendet ! *)
			END_IF;
		END_CASE;
	END_IF;

	IF (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iWorkStation_Setup3) THEN
		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Z_TGuide.rDistanceTGuideToTableBoard:=
												T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_Z_TGuide.rDistanceTGuideToTableBoard;
		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Z_TGuide.rOffset_Z_ToolGuide:=
												T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_Z_TGuide.rOffset_Z_ToolGuide;
		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Z_TGuide.rOffset_Z_ToolGuide_Old:=
												T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_Z_TGuide.rOffset_Z_ToolGuide_Old;
		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Z_TGuide.rScaleDefinedPos:=
												T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_Z_TGuide.rScaleDefinedPos;
		IF (T_ExchgParam.T_StationCommon.iZAxisGuideTube_ShowObjectNr <> 4) THEN
			T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Z_TGuide.rToolLengthSetup:=
													T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_Z_TGuide.rToolLengthSetup;
		END_IF;
		IF (T_ExchgParam.T_StationCommon.iZAxisGuideTube_ShowObjectNr <> 5) THEN
			T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Z_TGuide.rDistanceTGuideToTableBoardLess:=
													T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_Z_TGuide.rDistanceTGuideToTableBoardLess;
		END_IF;
	END_IF;
END_ACTION

ACTION	VisuFunction_SetupPotentiometer:
(* Setup Potentiometer starten *)
	IF xSetupPotentiometer THEN
		CASE iStepAction OF
		(* check state *)
		1:	xTmp:=	TRUE;
			iStepPotentiometer:=0;
			(* next step *)
			IF xTmp THEN iStepAction:=10; ELSE iStepAction:=95; END_IF
		(* Set Value *)
		10:	(* For set the value, it need the system level *)
			IF (T_ExchgParam.T_Visu.T_Level.iActLevel <> 2) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=216;	(* Warnung: Diese Parameter können nur auf SystemLevel geändert werden ! *)
				iStepAction:=90;
				RETURN;
			END_IF;
			CASE iStepPotentiometer OF
			0:	T_ExchgParam.T_Visu.T_Message.iState:=112;	(* Aufforderung: Position 0 am Poti einstellen und dann speichern *)
			1:	T_ExchgParam.T_Visu.T_Message.iState:=113;	(* Aufforderung: Position 1 am Poti einstellen und dann speichern *)
			2:	T_ExchgParam.T_Visu.T_Message.iState:=114;	(* Aufforderung: Position 2 am Poti einstellen und dann speichern *)
			3:	T_ExchgParam.T_Visu.T_Message.iState:=115;	(* Aufforderung: Position 3 am Poti einstellen und dann speichern *)
			4:	T_ExchgParam.T_Visu.T_Message.iState:=116;	(* Aufforderung: Position 4 am Poti einstellen und dann speichern *)
			5:	T_ExchgParam.T_Visu.T_Message.iState:=117;	(* Aufforderung: Position 5 am Poti einstellen und dann speichern *)
			6:	T_ExchgParam.T_Visu.T_Message.iState:=118;	(* Aufforderung: Position 6 am Poti einstellen und dann speichern *)
			7:	T_ExchgParam.T_Visu.T_Message.iState:=119;	(* Aufforderung: Position 7 am Poti einstellen und dann speichern *)
			8:	T_ExchgParam.T_Visu.T_Message.iState:=120;	(* Aufforderung: Position 8 am Poti einstellen und dann speichern *)
			9:	T_ExchgParam.T_Visu.T_Message.iState:=121;	(* Aufforderung: Position 9 am Poti einstellen und dann speichern *)
			10:	T_ExchgParam.T_Visu.T_Message.iState:=122;	(* Aufforderung: Position 10 am Poti einstellen und dann speichern *)
			END_CASE;
			iStepAction:=20;
		(* Display message to ask for confirmation *)
		20:	IF (T_ExchgParam.T_BtFunctionPanel.wActivBt = 32) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=103;	(* Aufforderung: Speichern bestätigen <Enter>, abbrechen <Esc> ? *)
				iStepAction:=30;
			END_IF;
		(* waiting for key <Enter> or <Esc> *)
		30:	IF RisingEdgeKeyPanel_Enter.Q THEN
				iStepAction:=40;
				(* Display message *)
				T_ExchgParam.T_Visu.T_Message.iState:=3;	(* Info: Start speichern... *)
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN
					iStepAction:=90;
					T_ExchgParam.T_Visu.T_Message.iState:=202;	(* Warnung: Aktion abgebrochen ! *)
				END_IF
			END_IF
			(* An other message has been displayed *)
			IF (T_ExchgParam.T_Visu.T_Message.iState<>3) AND (T_ExchgParam.T_Visu.T_Message.iState<>103) AND (T_ExchgParam.T_Visu.T_Message.iState<>202) THEN iStepAction:=90; END_IF
		40:	T_NovRam.T_Parameter.T_Machine.adiPotentiometerValue[iStepPotentiometer]:=IiASpeedServoDrive;
			iStepAction:=50;
		50:	xAction_SaveNovRAM:=TRUE;
			xBlockSetNovRamAction_End:=TRUE;
			iStepActionNovRam:=1;
			iStepAction:=60;
		60:	IF NOT xAction_SaveNovRAM THEN
				T_ExchgParam.T_Visu.T_Message.iState:=25;	(* gewählte Pos ist nun gespeichert *)
				iStepPotentiometer:=iStepPotentiometer + 1;
				IF (iStepPotentiometer <= 10) THEN
					iStepAction:=10;
				ELSE
					iStepAction:=90;
					T_ExchgParam.T_Visu.T_Message.iState:=59;	(* Info: Funktion beendet ! *)
				END_IF;
			END_IF;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSetupPotentiometer:=FALSE;
		(* cylinder not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xSetupPotentiometer:=FALSE;
		END_CASE
	END_IF;

	FBLinearization_Potentiometer(	adi_X_MeasurePoint_Voltage:= T_NovRam.T_Parameter.T_Machine.adiPotentiometerValue,
								lr_X_Voltage:= IiASpeedServoDrive);

	T_ExchgParam.byOverride:=	REAL_TO_BYTE(FBLinearization_Potentiometer.lrScaledValuePercent);
	IF (T_ExchgParam.byOverride < 0) THEN
		T_ExchgParam.byOverride:=0;
	ELSIF (T_ExchgParam.byOverride > 100) THEN
		T_ExchgParam.byOverride:=100;
	END_IF;
	IF NOT(TProcess.T_Ctrle.xExecute) AND TProcess.T_Ctrle.xDone AND
	    NOT(TStation_Work_St1.TControl.xExecute) AND TStation_Work_St1.TControl.xDone AND
	    NOT(gxSetupFunctionActive) AND NOT(gxAxisAbsolutMovementActive) THEN
		T_ExchgParam.byOverride:=100;	(* Override nur wenn ein Prozess oder Station aktiv ist *)
	END_IF;
	TStation_Work_St1.THWWorkStation.TAxisZ.T_CtrleSingle.dwOverride:=T_ExchgParam.byOverride;

	(* Z Axis *)
	T_ExchgParam.T_TeachIn.arTeachSelStep[gciAxisZ_St1]:=	(1.0/100.0) * FBLinearization_Potentiometer.lrScaledValuePercent;
	IF (T_ExchgParam.T_TeachIn.arTeachSelStep[gciAxisZ_St1] < 0.01) THEN
		T_ExchgParam.T_TeachIn.arTeachSelStep[gciAxisZ_St1]:=0.01;
	END_IF;
	T_ExchgParam.T_TeachIn.arTeachSelVel[gciAxisZ_St1]:=	(20.0/100.0) * FBLinearization_Potentiometer.lrScaledValuePercent;
	IF (T_ExchgParam.T_TeachIn.arTeachSelVel[gciAxisZ_St1] < 0.1) THEN
		T_ExchgParam.T_TeachIn.arTeachSelVel[gciAxisZ_St1]:=0.1;
	END_IF;

	(* S Axis *)
	T_ExchgParam.T_TeachIn.arTeachSelStep[gciAxisS_St1]:=	(1.0/100.0) * FBLinearization_Potentiometer.lrScaledValuePercent;
	IF (T_ExchgParam.T_TeachIn.arTeachSelStep[gciAxisS_St1] < 0.01) THEN
		T_ExchgParam.T_TeachIn.arTeachSelStep[gciAxisS_St1]:=0.01;
	END_IF;
	T_ExchgParam.T_TeachIn.arTeachSelVel[gciAxisS_St1]:=	(20.0/100.0) * FBLinearization_Potentiometer.lrScaledValuePercent;
	IF (T_ExchgParam.T_TeachIn.arTeachSelVel[gciAxisS_St1] < 0.1) THEN
		T_ExchgParam.T_TeachIn.arTeachSelVel[gciAxisS_St1]:=0.1;
	END_IF;
END_ACTION

ACTION	VisuFunction_SetupTorque:
(* Torque Offset -/+ *)
	IF xTorqueOffsetMinus OR xTorqueOffsetPlus THEN
		CASE iStepAction OF
		(* check state *)
		1:	xTmp:=	TRUE;
			(* next step *)
			IF xTmp THEN iStepAction:=10; ELSE iStepAction:=95; END_IF
		(* Set Value *)
		10:	IF xTorqueOffsetMinus THEN
				T_ExchgParam.T_AnalogSensTorque.rActual_Offset:=T_ExchgParam.T_AnalogSensTorque.rActual_Offset - 0.01;
			ELSE
				T_ExchgParam.T_AnalogSensTorque.rActual_Offset:=T_ExchgParam.T_AnalogSensTorque.rActual_Offset + 0.01;
			END_IF;
			iStepAction:=90;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xTorqueOffsetMinus:=xTorqueOffsetPlus:=FALSE;
		(* cylinder not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xTorqueOffsetMinus:=xTorqueOffsetPlus:=FALSE;
		END_CASE
	END_IF;

(* Save Torque Scale *)
	IF xSaveTorqueScale THEN
		CASE iStepAction OF
		(* check state *)
		1:	xTmp:=	TRUE;
			(* next step *)
			IF xTmp THEN iStepAction:=10; ELSE iStepAction:=95; END_IF
		(* Set Value *)
		10:	(* For set the value, it need the system level *)
			IF (T_ExchgParam.T_Visu.T_Level.iActLevel <> 2) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=216;	(* Warnung: Diese Parameter können nur auf SystemLevel geändert werden ! *)
				iStepAction:=90;
				RETURN;
			END_IF;
			iStepAction:=20;
		(* Display message to ask for confirmation *)
		20:	T_ExchgParam.T_Visu.T_Message.iState:=103;	(* Aufforderung: Speichern bestätigen <Enter>, abbrechen <Esc> ? *)
			iStepAction:=30;
		(* waiting for key <Enter> or <Esc> *)
		30:	IF RisingEdgeKeyPanel_Enter.Q THEN iStepAction:=40;
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN
					iStepAction:=90;
					T_ExchgParam.T_Visu.T_Message.iState:=202;	(* Warnung: Aktion abgebrochen ! *)
				END_IF
			END_IF
			(* An other message has been displayed *)
			IF (T_ExchgParam.T_Visu.T_Message.iState<>103) AND (T_ExchgParam.T_Visu.T_Message.iState<>202) THEN iStepAction:=90; END_IF
		40:	CASE T_ExchgParam.bToolSpindleActive OF
			1:	(* Maxon Spindel *)
				IF (T_ExchgParam.T_AnalogSensTorque.rMeasureDistance <> 0.0) THEN
					T_ExchgParam.T_AnalogSensTorque.rScaleFactor:=	IiAToolTorque_St1;
					T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_TorqueSystem.rTorqueScaleFactor:=	T_ExchgParam.T_AnalogSensTorque.rScaleFactor;
				ELSE
					T_ExchgParam.T_AnalogSensTorque.rScaleFactor:=	0.0;
					T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_TorqueSystem.rTorqueScaleFactor:=	T_ExchgParam.T_AnalogSensTorque.rScaleFactor;
				END_IF;
				T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_TorqueSystem.rMeasureDistance:=T_ExchgParam.T_AnalogSensTorque.rMeasureDistance;
			END_CASE;
			iStepAction:=50;
		50:	xAction_SaveNovRAM:=TRUE;
			xBlockSetNovRamAction_End:=TRUE;
			iStepActionNovRam:=1;
			iStepAction:=60;
		60:	IF NOT xAction_SaveNovRAM THEN
				iStepAction:=90;
				T_ExchgParam.T_Visu.T_Message.iState:=59;	(* Info: Funktion beendet ! *)
			END_IF;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSaveTorqueScale:=FALSE;
		(* cylinder not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xSaveTorqueScale:=FALSE;
		END_CASE
	END_IF;

(* Save Torque Position *)
	IF xSaveTorquePosition THEN
		CASE iStepAction OF
		(* check state *)
		1:	xTmp:=	TRUE;
			(* next step *)
			IF xTmp THEN iStepAction:=10; ELSE iStepAction:=95; END_IF
		(* Set Value *)
		10:	iStepAction:=20;
		(* Display message to ask for confirmation *)
		20:	T_ExchgParam.T_Visu.T_Message.iState:=103;	(* Aufforderung: Speichern bestätigen <Enter>, abbrechen <Esc> ? *)
			iStepAction:=30;
		(* waiting for key <Enter> or <Esc> *)
		30:	IF RisingEdgeKeyPanel_Enter.Q THEN iStepAction:=40;
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN
					iStepAction:=90;
					T_ExchgParam.T_Visu.T_Message.iState:=202;	(* Warnung: Aktion abgebrochen ! *)
				END_IF
			END_IF
			(* An other message has been displayed *)
			IF (T_ExchgParam.T_Visu.T_Message.iState<>103) AND (T_ExchgParam.T_Visu.T_Message.iState<>202) THEN iStepAction:=90; END_IF
		40:	CASE T_ExchgParam.bToolSpindleActive OF
			1:	(* Maxon Spindel *)
				CASE T_ExchgParam.T_AnalogSensTorque.iSelectHC_Position OF
				0:	T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_TorqueSystem.rTorquePosition_HC:=	T_ExchgParam.T_AnalogSensTorque.rActual_Position +
																							T_ExchgParam.T_AnalogSensTorque.rActual_Offset;
				1:	T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_TorqueSystem.rTorquePosition_HCOverload:=	T_ExchgParam.T_AnalogSensTorque.rActual_Position +
																									T_ExchgParam.T_AnalogSensTorque.rActual_Offset;
				END_CASE;
			END_CASE;
			iStepAction:=50;
		50:	xAction_SaveNovRAM:=TRUE;
			xBlockSetNovRamAction_End:=TRUE;
			iStepActionNovRam:=1;
			iStepAction:=60;
		60:	IF NOT xAction_SaveNovRAM THEN
				iStepAction:=90;
				T_ExchgParam.T_Visu.T_Message.iState:=59;	(* Info: Funktion beendet ! *)
			END_IF;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSaveTorquePosition:=FALSE;
		(* cylinder not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xSaveTorquePosition:=FALSE;
		END_CASE
	END_IF;

	T_ExchgParam.T_AnalogSensTorque.rActual_Position:=	ptrTSensorTorque_St1^.T_CtrleCyl.T_Analog.rPosIn;
	IF (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iWorkStation_Setup4) THEN
		CASE T_ExchgParam.bToolSpindleActive OF
		1:	(* Maxon Spindel *)
			CASE T_ExchgParam.T_AnalogSensTorque.iSelectHC_Position OF
			0:	T_ExchgParam.T_AnalogSensTorque.rSaved_Position:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_TorqueSystem.rTorquePosition_HC;
			1:	T_ExchgParam.T_AnalogSensTorque.rSaved_Position:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_TorqueSystem.rTorquePosition_HCOverload;
			END_CASE;
		END_CASE;
	ELSE
		T_ExchgParam.T_AnalogSensTorque.rActual_Offset:=0.0;
	END_IF;
END_ACTION

ACTION	VisuFunction_SpecialFunction:
CASE T_ExchgParam.bToolSpindleActive OF
1:	(* Maxon Spindel *)
	IF (T_ExchgParam.T_StationCommon.bSelectCylinderConfig <= 1) THEN
			T_ExchgParam.T_StationCommon.bShowCylinderConfig:=1;	(* Ansicht Auslenkung SM Kopf *)
	ELSE
		IF T_ExchgParam.T_StationCommon.xToolSpindle_L_Connect THEN
			T_ExchgParam.T_StationCommon.bShowCylinderConfig:=4;	(* Ansicht Drehmoment L Kopf *)
		ELSE
			T_ExchgParam.T_StationCommon.bShowCylinderConfig:=3;	(* Ansicht Drehmoment SM Kopf *)
		END_IF;
	END_IF;
2:	(* Beckhoff Spindel L *)
	T_ExchgParam.T_StationCommon.bShowCylinderConfig:=2;	(* Ansicht Auslenkung L Kopf *)
3:	(* Beckhoff Spindel M *)
	T_ExchgParam.T_StationCommon.bShowCylinderConfig:=5;	(* Ansicht Auslenkung M Kopf *)
END_CASE;

IF xStationSetupAxisZFunctionToolGuide OR xTmpStationSetupAxisZFunctionToolGuide THEN
	T_ExchgParam.T_StationCommon.xBlockSelectZAxisProcedure:=TRUE;
	T_ExchgParam.T_StationCommon.iZAxisFirstSetup_ShowObjectNr:=0;
ELSIF xStationSetupAxisZFunction OR xTmpStationSetupAxisZFunction THEN
	T_ExchgParam.T_StationCommon.xBlockSelectZAxisProcedure:=TRUE;
	T_ExchgParam.T_StationCommon.iZAxisGuideTube_ShowObjectNr:=0;
ELSE
	T_ExchgParam.T_StationCommon.xBlockSelectZAxisProcedure:=FALSE;
	IF (T_ExchgParam.T_StationCommon.bSelectZAxisProcedure <= 1) THEN
		T_ExchgParam.T_StationCommon.iZAxisGuideTube_ShowObjectNr:=1;
		T_ExchgParam.T_StationCommon.iZAxisFirstSetup_ShowObjectNr:=0;
	ELSE
		T_ExchgParam.T_StationCommon.iZAxisGuideTube_ShowObjectNr:=0;
		T_ExchgParam.T_StationCommon.iZAxisFirstSetup_ShowObjectNr:=1;
	END_IF;
END_IF;

(* Auswahl Position Führungsrohr, Auswahl Abstand Führungsrohr, Auswahl Werkzeug oder Auswahl Führungsrohreinsatz *)
	IF xSelectConfigPosition_1 OR xSelectConfigPosition_2 OR xSelectConfigPosition_3 OR xSelectConfigPosition_4 THEN
		CASE iStepAction OF
		(* check state *)
		1:	xTmp:=	TRUE;
			(* next step *)
			IF xTmp THEN iStepAction:=10; ELSE iStepAction:=95; END_IF
		(* Set Value *)
		10:	IF xSelectConfigPosition_1 THEN
				T_ExchgParam.T_StationCommon.iSelectConfigPosition:=1;
			ELSIF xSelectConfigPosition_2 THEN
				T_ExchgParam.T_StationCommon.iSelectConfigPosition:=2;
			ELSIF xSelectConfigPosition_3 THEN
				T_ExchgParam.T_StationCommon.iSelectConfigPosition:=3;
			ELSE
				T_ExchgParam.T_StationCommon.iSelectConfigPosition:=4;
			END_IF;
			iStepAction:=90;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSelectConfigPosition_1:=xSelectConfigPosition_2:=xSelectConfigPosition_3:=xSelectConfigPosition_4:=FALSE;
		(* cylinder not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xSelectConfigPosition_1:=xSelectConfigPosition_2:=xSelectConfigPosition_3:=xSelectConfigPosition_4:=FALSE;
		END_CASE
	END_IF;

	IF (T_ExchgParam.T_StationCommon.iSelectConfigPosition <> iSelectConfigPosition) THEN
		iSelectConfigPosition:=T_ExchgParam.T_StationCommon.iSelectConfigPosition;
		xUpdateStationParameter:=TRUE;
	END_IF;

(* Speichern der Positionskonfiguration oder KonfigPos EIN/AUS *)
	IF xSaveConfigPosition OR xConfigPosOnOff THEN
		CASE iStepAction OF
		(* check state *)
		1:	xTmp:=	TRUE;
			(* next step *)
			IF xTmp THEN iStepAction:=10; ELSE iStepAction:=95; END_IF
		(* Display message to ask for confirmation *)
		10:	T_ExchgParam.T_Visu.T_Message.iState:=103;	(* Aufforderung: Speichern bestätigen <Enter>, abbrechen <Esc> ? *)
			iStepAction:=20;
		(* waiting for key <Enter> or <Esc> *)
		20:	IF RisingEdgeKeyPanel_Enter.Q THEN iStepAction:=30;
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN
					iStepAction:=90;
					T_ExchgParam.T_Visu.T_Message.iState:=202;	(* Warnung: Aktion abgebrochen ! *)
				END_IF
			END_IF
			(* An other message has been displayed *)
			IF (T_ExchgParam.T_Visu.T_Message.iState<>103) AND (T_ExchgParam.T_Visu.T_Message.iState<>202) THEN iStepAction:=90; END_IF
		30:	IF xSaveConfigPosition THEN
				IF (T_ExchgParam.T_StationCommon.iSelectConfigPosition = 1) THEN
					T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rPosToolGuid_Up:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rPosToolGuid_Up;
					T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rPosToolGuid_Down:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rPosToolGuid_Down;
				ELSIF (T_ExchgParam.T_StationCommon.iSelectConfigPosition = 2) THEN
					T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rDistanceToolGuide:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rDistanceToolGuide;
					T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rDistanceToolEndPos:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rDistanceToolEndPos;
				ELSIF (T_ExchgParam.T_StationCommon.iSelectConfigPosition = 3) THEN
					T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rLengthTool_Fixed:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rLengthTool_Fixed;
					T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rLengthTool_Work:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rLengthTool_Work;
				ELSIF (T_ExchgParam.T_StationCommon.iSelectConfigPosition = 4) THEN
					T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rLengthToolGuide:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rLengthToolGuide;
					T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rLengthAirTableBoard:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rLengthAirTableBoard;
				END_IF;
			ELSE
				T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.xConfigActive:=NOT(T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.xConfigActive);
			END_IF;
			iStepAction:=40;
		40:	xAction_SaveNovRAM:=TRUE;
			xBlockSetNovRamAction_End:=TRUE;
			iStepActionNovRam:=1;
			iStepAction:=50;
		50:	IF NOT xAction_SaveNovRAM THEN
				iStepAction:=90;
				T_ExchgParam.T_Visu.T_Message.iState:=59;	(* Info: Funktion beendet ! *)
			END_IF;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSaveConfigPosition:=xConfigPosOnOff:=FALSE;
		(* cylinder not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xSaveConfigPosition:=xConfigPosOnOff:=FALSE;
		END_CASE
	END_IF;

	gxProcessCylindricalAreaActive:=(T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rZPositionCylindricalArea <> 0.0);
	T_ExchgParam.T_StationCommon.xProcessCylindricalAreaActive:=gxProcessCylindricalAreaActive;
	IF NOT(gxProcessCylindricalAreaActive) THEN
		T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rZPositionCylindricalAreaStop:=0.0;
		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rZPositionCylindricalAreaStop:=0.0;
	END_IF;

	T_ExchgParam.T_StationCommon.xSControllerActive:=(T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rWorkingSpindleSpeedMinMax <> 0.0);	(* Spindelregeler im Prozess Aktiv wenn dieser Wert nicht Null ist *)
	T_ExchgParam.T_StationCommon.xOControllerActive:=(T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rO_Ctrl_HystereseOffset <> 0.0);		(* Schnellhubregler im Prozess Aktiv wenn der Hysterese Offset nicht Null ist *)

	IF NOT(T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.xConfigActive) THEN
		grZ_LoadPos:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rPositionLoad;
		grZ_WorkStartPos:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rPositionStartProc;
(*
		grZ_WorkEndPos:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rPositionEndProc;
*)
		IF NOT(gxProcessCylindricalAreaActive) THEN
			IF NOT(T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.xPositionEndProcIncOnOff) THEN
				garPositionEndProcCalc[1]:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rPositionEndProc;
			ELSE
				IF (garPositionEndProcCalc[1] < T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rPositionEndProc) THEN
					garPositionEndProcCalc[1]:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rPositionEndProc;
				END_IF;
				IF (garPositionEndProcCalc[1] = 0.0) THEN
					garPositionEndProcCalc[1]:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rPositionEndProc;
				END_IF;
			END_IF;
			T_ExchgParam.T_StationCommon.rZPositionEndProc:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rPositionEndProc;
		ELSE
			(* Neuer Ablauf mit der Bestimmung des Zylindrischen Bereich ist aktiviert und deshalb gilt als End Position die Max Inkrement Position unabhängig ob mit oder ohne Inkrementierung *)
			IF NOT(T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.xPositionEndProcIncOnOff) THEN
				garPositionEndProcCalc[1]:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rZPositionCylindricalArea;
			ELSE
				IF (garPositionEndProcCalc[1] < T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rZPositionCylindricalArea) THEN
					garPositionEndProcCalc[1]:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rZPositionCylindricalArea;
				END_IF;
				IF (garPositionEndProcCalc[1] = 0.0) THEN
					garPositionEndProcCalc[1]:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rZPositionCylindricalArea;
				END_IF;
			END_IF;
			T_ExchgParam.T_StationCommon.rZPositionEndProc:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rZPositionCylindricalArea;
		END_IF;
	ELSE
		grZ_LoadPos:=		T_NovRam.T_Parameter.T_StationWork[1].T_Z_TGuide.rOffset_Z_ToolGuide -
							(T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rLengthTool_Fixed - T_NovRam.T_Parameter.T_StationWork[1].T_Z_TGuide.rToolLengthSetup) -
							(T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rPosToolGuid_Up - T_NovRam.T_Parameter.T_StationWork[1].T_Z_TGuide.rScaleDefinedPos) +
							T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rLengthToolGuide -
							1.0;	(* Minus 1mm, damit das Wz nicht durch die ungenauigkeit aus dem Führungsrohr herausschaut *)
		grZ_WorkStartPos:=	T_NovRam.T_Parameter.T_StationWork[1].T_Z_TGuide.rOffset_Z_ToolGuide -
							(T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rLengthTool_Fixed - T_NovRam.T_Parameter.T_StationWork[1].T_Z_TGuide.rToolLengthSetup) +
							52.0 -
							T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rDistanceToolGuide -
							T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rLengthAirTableBoard +
							5.0;	(* Damit das Wz im unteren Führungsrohr ungefähr um 5mm drin ist *)
		grZ_WorkEndPos:=	T_NovRam.T_Parameter.T_StationWork[1].T_Z_TGuide.rOffset_Z_ToolGuide -
							(T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rLengthTool_Fixed - T_NovRam.T_Parameter.T_StationWork[1].T_Z_TGuide.rToolLengthSetup) +
							T_NovRam.T_Parameter.T_StationWork[1].T_Z_TGuide.rDistanceTGuideToTableBoardLess -
							T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rDistanceToolEndPos -
							T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rLengthAirTableBoard +
							T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rLengthTool_Work;
		IF NOT(T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.xPositionEndProcIncOnOff) THEN
			garPositionEndProcCalc[1]:=grZ_WorkEndPos;
		ELSE
			IF (garPositionEndProcCalc[1] < grZ_WorkEndPos) THEN
				garPositionEndProcCalc[1]:=grZ_WorkEndPos;
			END_IF;
			IF (garPositionEndProcCalc[1] = 0.0) THEN
				garPositionEndProcCalc[1]:=grZ_WorkEndPos;
			END_IF;
		END_IF;
	END_IF;

	IF NOT(T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.xCentringEndProcIncOnOff) THEN
		garCentringEndProcCalc[1]:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rCentringPosZ1Axis;
	ELSE
		IF (garCentringEndProcCalc[1] < T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rCentringPosZ1Axis) THEN
			garCentringEndProcCalc[1]:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rCentringPosZ1Axis;
		END_IF;
		IF (garCentringEndProcCalc[1] = 0.0) THEN
			garCentringEndProcCalc[1]:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rCentringPosZ1Axis;
		END_IF;
	END_IF;

	IF (T_Visu.T_PlcParam.dwActualPage <> gT_PageNumber.iAutoMode_ToolChange) AND (T_Visu.T_PlcParam.dwActualPage <> gT_PageNumber.iHandMode_Parameter) THEN
		T_ExchgParam.T_StationCommon.rPositionEndProcCalc:=	garPositionEndProcCalc[1];
		T_ExchgParam.T_StationCommon.rCentringEndProcCalc:=garCentringEndProcCalc[1];
	END_IF;

	IF T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.xPositionEndProcIncOnOff THEN
		T_ExchgParam.T_StationCommon.xDisableChangeEndPos:=FALSE;
	ELSE
		T_ExchgParam.T_StationCommon.xDisableChangeEndPos:=TRUE;
	END_IF;

	IF T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.xCentringEndProcIncOnOff THEN
		T_ExchgParam.T_StationCommon.xDisableCentringChangeEndPos:=FALSE;
	ELSE
		T_ExchgParam.T_StationCommon.xDisableCentringChangeEndPos:=TRUE;
	END_IF;

	xTmp:=	TProcess.T_Ctrle.xEnable AND
			NOT(TProcess.T_Ctrle.xExecute) AND
			(NOT(TProcess.T_Ctrle.xDone) OR
			TProcess.T_Ctrle.xError);
	T_ExchgParam.T_StationCommon.xDisableConfigPosition:=xTmp;




(* Regler Parameter speichern *)		(* IGS *)
IF xRegulatorOverlaySave THEN
	CASE iStepAction OF
	(* check state *)
	1:	(*iTmpSelectedStationAutomat:=giSelectedStationAutomat;*)
		xTmp:=	TRUE;
		(* next step *)
		IF xTmp THEN iStepAction:=20; ELSE iStepAction:=95; END_IF
	(* Display message to ask for confirmation *)
	20:	T_ExchgParam.T_Visu.T_Message.iState:=103;	(* Aufforderung: Speichern bestätigen <Enter>, abbrechen <Esc> ? *)
		iStepAction:=30;
	(* waiting for key <Enter> or <Esc> *)
	30:	IF RisingEdgeKeyPanel_Enter.Q THEN
			iStepAction:=40;
		ELSE
			IF RisingEdgeKeyPanel_Esc.Q THEN
				iStepAction:=90;
				T_ExchgParam.T_Visu.T_Message.iState:=202;	(* Warnung: Aktion abgebrochen ! *)
			END_IF
		END_IF
		(* An other message has been displayed *)
		IF ((T_ExchgParam.T_Visu.T_Message.iState<>103) AND (T_ExchgParam.T_Visu.T_Message.iState<>202)) (*OR (iTmpSelectedStationAutomat <> giSelectedStationAutomat)*) THEN iStepAction:=90; END_IF
	40:	IF (T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.iWorkControlType <= 1) THEN
			T_NovRAM.T_Parameter.T_StationWork[1].T_OnlineChange.rWorkingSpeedForward:=		T_ExchgParam.T_StationCommon.rSpeedZ_V1;
			T_NovRAM.T_Parameter.T_StationWork[1].T_OnlineChange.rTorqueLevelHC:=			T_ExchgParam.T_StationCommon.rTorqueZ_S4;
		ELSIF (T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.iWorkControlType = 2) THEN
			T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.rZ_PID_Torque:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rZ_PID_Torque;
			T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.rZ_PID_Kp:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rZ_PID_Kp;
			T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.rZ_PID_Ki:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rZ_PID_Ki;
			T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.rZ_PID_Kd:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rZ_PID_Kd;
			T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.rZ_PID_MinSpeed:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rZ_PID_MinSpeed;
			T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.rZ_PID_MaxSpeed:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rZ_PID_MaxSpeed;
			T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.iZ_PID_FilterM:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.iZ_PID_FilterM;
		ELSE
			T_NovRAM.T_Parameter.T_StationWork[1].T_OnlineChange.rWorkingSpeedForward:=		T_ExchgParam.T_StationCommon.rSpeedZ_V1;
			T_NovRAM.T_Parameter.T_StationWork[1].T_OnlineChange.rTorqueLevelHC:=			T_ExchgParam.T_StationCommon.rTorqueZ_S4;
			T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.rZ_D_Kd:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.rZ_D_Kd;
			T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.iZ_D_FilterM:=T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.iZ_D_FilterM;
		END_IF;
		iStepAction:=50;
	50:	xAction_SaveNovRAM:=TRUE;
		xBlockSetNovRamAction_End:=TRUE;
		iStepActionNovRam:=1;
		iStepAction:=60;
	60:	IF NOT xAction_SaveNovRAM THEN
			iStepAction:=90;
			T_ExchgParam.T_Visu.T_Message.iState:=59;	(* Info: Funktion beendet ! *)
		END_IF;
	(* action done *)
	90:	T_Visu.T_CtrleAction.xDone:=TRUE;
		T_Visu.T_CtrleAction.xNotReady:=FALSE;
		T_Visu.T_CtrleAction.xErr:=FALSE;
		T_Visu.T_CtrleAction.udiErrorID:=0;
		xRegulatorOverlaySave:=FALSE;
		(*IF (iTmpSelectedStationAutomat <> giSelectedStationAutomat) THEN
			T_ExchgParam.T_Visu.T_Message.iState:=202;	(* Aktion abgebrochen *)
		END_IF;*)
	(* cylinder not ready *)
	95:	TimerNotReady(IN:=TRUE);
		xRegulatorOverlaySave:=FALSE;
	END_CASE
END_IF;

(* Auswahl Konventioneller Regler, Adaptive Voschub Regler oder Konventioneller PD Regler *)
IF xRegulatorType1 OR xRegulatorType2 OR xRegulatorType3 THEN
	CASE iStepAction OF
	(* check state *)
	1:	(*iTmpSelectedStationAutomat:=giSelectedStationAutomat;*)
		xTmp:=	TRUE;
		(* next step *)
		IF xTmp THEN iStepAction:=20; ELSE iStepAction:=95; END_IF
	(* Display message to ask for confirmation *)
	20:	T_ExchgParam.T_Visu.T_Message.iState:=103;	(* Aufforderung: Speichern bestätigen <Enter>, abbrechen <Esc> ? *)
		iStepAction:=30;
	(* waiting for key <Enter> or <Esc> *)
	30:	IF RisingEdgeKeyPanel_Enter.Q THEN
			iStepAction:=40;
		ELSE
			IF RisingEdgeKeyPanel_Esc.Q THEN
				iStepAction:=90;
				T_ExchgParam.T_Visu.T_Message.iState:=202;	(* Warnung: Aktion abgebrochen ! *)
			END_IF
		END_IF
		(* An other message has been displayed *)
		IF ((T_ExchgParam.T_Visu.T_Message.iState<>103) AND (T_ExchgParam.T_Visu.T_Message.iState<>202)) (*OR (iTmpSelectedStationAutomat <> giSelectedStationAutomat)*) THEN iStepAction:=90; END_IF
	40:	IF xRegulatorType1 THEN
			T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.iWorkControlType:=1;
		ELSIF xRegulatorType2 THEN
			T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.iWorkControlType:=2;
		ELSE
			T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.iWorkControlType:=3;
		END_IF;
		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_StProcess.iWorkControlType:=T_NovRAM.T_Parameter.T_StationWork[1].T_StProcess.iWorkControlType;
		iStepAction:=50;
	50:	xAction_SaveNovRAM:=TRUE;
		xBlockSetNovRamAction_End:=TRUE;
		iStepActionNovRam:=1;
		iStepAction:=60;
	60:	IF NOT xAction_SaveNovRAM THEN
			iStepAction:=90;
			T_ExchgParam.T_Visu.T_Message.iState:=59;	(* Info: Funktion beendet ! *)
		END_IF;
	(* action done *)
	90:	T_Visu.T_CtrleAction.xDone:=TRUE;
		T_Visu.T_CtrleAction.xNotReady:=FALSE;
		T_Visu.T_CtrleAction.xErr:=FALSE;
		T_Visu.T_CtrleAction.udiErrorID:=0;
		xRegulatorType1:=xRegulatorType2:=xRegulatorType3:=FALSE;
	(* cylinder not ready *)
	95:	TimerNotReady(IN:=TRUE);
		xRegulatorType1:=xRegulatorType2:=xRegulatorType3:=FALSE;
	END_CASE
END_IF;

T_ExchgParam.T_StationCommon.rController2_MinSpeed:=	T_Profile.T_Profile_MinMax.T_Max.rWorkingSpeedForward * -1.0;

IF (T_Visu.T_PlcParam.dwActualPage <> gT_PageNumber.iHandMode_RegulatorPara) (*OR RisingEdgeStationNr.Q*) THEN
	T_ExchgParam.T_StationCommon.rSpeedZ_V1:=TStation_Work_St1.THWWorkStation.TCtrlWork.rSpeedZ_V1;
	T_ExchgParam.T_StationCommon.rSpeedZ_V3:=TStation_Work_St1.THWWorkStation.TCtrlWork.rSpeedZ_V3;
	T_ExchgParam.T_StationCommon.rTorqueZ_S1:=TStation_Work_St1.THWWorkStation.TCtrlWork.rTorqueZ_S1;
	T_ExchgParam.T_StationCommon.rTorqueZ_S4:=TStation_Work_St1.THWWorkStation.TCtrlWork.rTorqueZ_S4;
	T_ExchgParam.T_StationCommon.iProgressBar_Torque:=TStation_Work_St1.THWWorkStation.TCtrlWork.iProgressBar_Torque;
	T_ExchgParam.T_StationCommon.iProgressBar_ZPos:=TStation_Work_St1.THWWorkStation.TCtrlWork.iProgressBar_ZPos;
	T_ExchgParam.T_StationCommon.iProgressBar_ZVel:=TStation_Work_St1.THWWorkStation.TCtrlWork.iProgressBar_ZVel;
	T_ExchgParam.T_StationCommon.xTorqueAfterHC_Min_Overlimit:=TStation_Work_St1.THWWorkStation.TCtrlWork.xTorqueAfterHC_Min_Overlimit;
	T_ExchgParam.T_StationCommon.xTorqueAfterHC_Max_Overlimit:=TStation_Work_St1.THWWorkStation.TCtrlWork.xTorqueAfterHC_Max_Overlimit;
END_IF;

END_ACTION

ACTION	VisuFunction_SpindleBurnIn:
(* Ausführen der Stationsfunktion für den BurnIn der Spindeln über ausgewählte Stationen *)
	IF xStationSpindleBurnInFunction THEN
		TONElapsedBurnInTime(IN:=TRUE,PT:=T#99999s);
		T_ExchgParam.T_SpindleBurnIn.tTimeElapsed:=TONElapsedBurnInTime.ET;
		(* Step  function station  *)
		CASE iStepAction OF
		(* Überprüfe zuerst ob die ausgewählten Stationen bereit stehen  *)
		1:	xTmp:=	(ptrActivStation^.TControl.xDone
					AND ptrActivStation^.TControl.xRdy
					AND NOT(ptrActivStation^.TControl.xExecute)
					AND NOT(ptrActivStation^.TControl.xError)
					AND NOT(ptrActivStation^.TControl.xStop)
					AND T_ExchgParam.T_SafetyCtrl.xSetupOperateB_EnergyON);
			(* next step *)
			IF xTmp THEN iStepAction:=10; ELSE iStepAction:=95; END_IF
		(* determin function number *)
		10:	ptrActivStation^.TControl.iFunctNr:=8;	(* Spindle Burn-In *)
			ptrActivStation^.TControl.xExecute:=TRUE;
			(* next step *)
			iStepAction:=20;
			(* next step *)
			xStepActionDone:=FALSE;
			T_ExchgParam.T_Visu.T_Message.iState:=63;	(* Info: BurnIn Funktion gestartet ! *)
		(* wait confirmation *)
		20:	IF NOT(xStepActionDone) THEN
			(* release execution *)
				ptrActivStation^.TControl.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				xTmp:=	NOT(ptrActivStation^.TControl.xExecute) AND ptrActivStation^.TControl.xDone;
				IF xTmp THEN
					(* action done *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
					T_ExchgParam.T_Visu.T_Message.iState:=64;	(* Info: BurnIn Funktion beendet ! *)
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xStationSpindleBurnInFunction:=FALSE;
		(* function not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xStationSpindleBurnInFunction:=FALSE;
		END_CASE
	ELSE
		TONElapsedBurnInTime(IN:=FALSE);
	END_IF
END_ACTION

ACTION	VisuFunction_StationFunction:
(* Ausführen von Stationsfunktionen der Bearbeitungsstation oder des Handling *)
	IF xStationWorkFunction THEN
		(* Step  function station  *)
		CASE iStepAction OF
		1:	ptrActivStation_Function1:=ADR(TStation_Work_St1);
			IF NOT(T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.xReferencedZAxis) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=294;	(* Warnung: Z Achse Ersteinrichtung zuerst durchführen ! *)
				iStepAction:=90;
			ELSE
				FBGetStationFunctionNr(	iVisuFunctionNr:= T_ExchgParam.T_FunctionCommon.iFunctionNrMicrohead);
				iStationFunctionNr:=FBGetStationFunctionNr.iWorkStation_FunctionNr;
				iStepAction:=10;
				T_Visu.T_CtrleAction.xFunctionActive:=TRUE;
				ptrActivStation_Function1:=ADR(TStation_Work_St1);
			END_IF;
		(* check station state *)
		10:	xTmp:=	ptrActivStation_Function1^.TControl.xDone
					AND ptrActivStation_Function1^.TControl.xRdy
					AND NOT(ptrActivStation_Function1^.TControl.xExecute)
					AND NOT(ptrActivStation_Function1^.TControl.xError)
					AND NOT(ptrActivStation_Function1^.TControl.xStop);
			(* next step *)
			IF xTmp THEN
				iStepAction:=11;
			ELSE iStepAction:=95; END_IF
		(* determin function number *)
		11:	ptrActivStation_Function1^.TControl.iFunctNr:=iStationFunctionNr;
			T_ExchgParam.T_Visu.T_Message.iState:=58;	(* Info: Funktion gestartet ! *)
			(* Auffangen der Funktion ToolRotation *)
			ptrActivStation_Function1^.TControl.xExecute:=TRUE;
			iStepAction:=12;
			(* next step *)
			xStepActionDone:=FALSE;
		(* wait confirmation *)
		12:	IF NOT(xStepActionDone) THEN
			(* release execution *)
				ptrActivStation_Function1^.TControl.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				IF ptrActivStation_Function1^.TControl.xDone THEN
					(* action done *)
					iStepAction:=90;
					xStepActionDone:=FALSE;
					T_ExchgParam.T_Visu.T_Message.iState:=59;	(* Info: Funktion beendet ! *)
				END_IF
			END_IF
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xStationWorkFunction:=FALSE;
			T_Visu.T_CtrleAction.xFunctionActive:=FALSE;
		(* function not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xStationWorkFunction:=FALSE;
			T_Visu.T_CtrleAction.xFunctionActive:=FALSE;
		END_CASE
	END_IF
END_ACTION

ACTION	VisuFunction_StationStop:
(* Stoppen von Stationsfunktionen von rechter und linker Arbeitsstation *)
	IF xStationStop THEN
		(* Step  function station stop  *)
		CASE iStepAction OF
		(* Überprüfe zuerst welche Stationen gestoppt werden müssen  *)
		1:	iCheckStationNr:=1;
			ptrActivStation_FunctionStop:=ADR(TStation_Work_St1);
			iStepAction:=10;
		10:	IF (iCheckStationNr = 1) THEN ptrActivStation_FunctionStop:=ADR(TStation_Work_St1);
			ELSE
				iStepAction:=30;
				iCheckStationNr:=1;
				iStationNrReady:=0;
				RETURN;
			END_IF;
			xTmp:=	NOT(ptrActivStation_FunctionStop^.TControl.xDone)
					AND ptrActivStation_FunctionStop^.TControl.xRdy
					AND NOT(ptrActivStation_FunctionStop^.TControl.xExecute)
					AND NOT(ptrActivStation_FunctionStop^.TControl.xError)
					AND NOT(ptrActivStation_FunctionStop^.TControl.xStop);
			IF xTmp THEN
				(* Mindestens eine Station kann gestoppt werden *)
				iStepAction:=20;
			ELSE
				iCheckStationNr:=iCheckStationNr + 1;
			END_IF
		20:	ptrActivStation_FunctionStop^.TControl.xStop:=TRUE;
			iCheckStationNr:=iCheckStationNr + 1;
			(* next step *)
			iStepAction:=10;
		30:	IF (iCheckStationNr = 1) THEN ptrActivStation_FunctionStop:=ADR(TStation_Work_St1);END_IF;
			xTmp:=	(ptrActivStation_FunctionStop^.TControl.xDone OR ptrActivStation_FunctionStop^.TControl.xError)
					AND ptrActivStation_FunctionStop^.TControl.xRdy
					AND NOT(ptrActivStation_FunctionStop^.TControl.xExecute);
			IF xTmp THEN
				iStationNrReady:=iStationNrReady + 1;
			END_IF;
			iCheckStationNr:=iCheckStationNr + 1;
			IF (iCheckStationNr > 14) THEN
				IF (iStationNrReady = 14) THEN
					(* Alle Stationen sind gestoppt *)
					(* next step *)
					iStepAction:=40;
				ELSE
					(* Mindestens eine Station ist noch nicht gestoppt *)
					iCheckStationNr:=1;
					iStationNrReady:=0;
				END_IF;
			END_IF;
		(* Alle Stationen sind gestoppt. Nun müssen noch alle Achsen überprüft werden ob sie gestoppt sind *)
		40:	IF NOT(ptrTAxisZ_St1^.T_CtrleSingle.xNotMoving) AND NOT(ptrTAxisZ_St1^.T_CtrleSingle.xErr) THEN
				ptrTAxisZ_St1^.T_CtrleSingle.iFunction:=5;
				ptrTAxisZ_St1^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxisS_St1^.T_CtrleSingle.xNotMoving) AND NOT(ptrTAxisS_St1^.T_CtrleSingle.xErr) THEN
				ptrTAxisS_St1^.T_CtrleSingle.iFunction:=5;
				ptrTAxisS_St1^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			iStepAction:=50;
		(* Warte bis alle Achsen stehen *)
		50:	xTmp:=	(NOT(ptrTAxisZ_St1^.T_CtrleSingle.xExecute) AND (ptrTAxisZ_St1^.T_CtrleSingle.xDone OR ptrTAxisZ_St1^.T_CtrleSingle.xErr)) AND
					(NOT(ptrTAxisS_St1^.T_CtrleSingle.xExecute) AND (ptrTAxisS_St1^.T_CtrleSingle.xDone OR ptrTAxisS_St1^.T_CtrleSingle.xErr));
			IF xTmp THEN
				(* action done *)
				iStepAction:=90;
				T_ExchgParam.T_Visu.T_Message.iState:=274;	(* Warnung: Funktion wurde gestoppt ! *)
			END_IF;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xFunctionActive:=FALSE;
			T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xStationStop:=FALSE;
		(* function not ready *)
		95:	T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
			TimerNotReady(IN:=TRUE);
			xStationStop:=FALSE;

		END_CASE;
	END_IF;

(* Stoppen von Stationsfunktionen von rechter Arbeitsstation *)
	IF xStationStopWorkRight THEN
		(* Step  function station stop  *)
		CASE iStepAction OF
		(* Überprüfe zuerst welche Stationen gestoppt werden müssen  *)
		1:	iCheckStationNr:=1;
			ptrActivStation_FunctionStop:=ADR(TStation_Work_St1);
			iStepAction:=10;
		10:	IF (iCheckStationNr = 1) THEN ptrActivStation_FunctionStop:=ADR(TStation_Work_St1);
			ELSE
				iStepAction:=30;
				iCheckStationNr:=1;
				iStationNrReady:=0;
				RETURN;
			END_IF;
			xTmp:=	NOT(ptrActivStation_FunctionStop^.TControl.xDone)
					AND ptrActivStation_FunctionStop^.TControl.xRdy
					AND NOT(ptrActivStation_FunctionStop^.TControl.xExecute)
					AND NOT(ptrActivStation_FunctionStop^.TControl.xError)
					AND NOT(ptrActivStation_FunctionStop^.TControl.xStop);
			IF xTmp THEN
				(* Mindestens eine Station kann gestoppt werden *)
				iStepAction:=20;
			ELSE
				iCheckStationNr:=iCheckStationNr + 1;
			END_IF
		20:	ptrActivStation_FunctionStop^.TControl.xStop:=TRUE;
			iCheckStationNr:=iCheckStationNr + 1;
			(* next step *)
			iStepAction:=10;
		30:	IF (iCheckStationNr = 1) THEN ptrActivStation_FunctionStop:=ADR(TStation_Work_St1);END_IF;
			xTmp:=	(ptrActivStation_FunctionStop^.TControl.xDone OR ptrActivStation_FunctionStop^.TControl.xError)
					AND ptrActivStation_FunctionStop^.TControl.xRdy
					AND NOT(ptrActivStation_FunctionStop^.TControl.xExecute);
			IF xTmp THEN
				iStationNrReady:=iStationNrReady + 1;
			END_IF;
			iCheckStationNr:=iCheckStationNr + 1;
			IF (iCheckStationNr > 7) THEN
				IF (iStationNrReady = 7) THEN
					(* Alle Stationen sind gestoppt *)
					(* next step *)
					iStepAction:=40;
				ELSE
					(* Mindestens eine Station ist noch nicht gestoppt *)
					iCheckStationNr:=1;
					iStationNrReady:=0;
				END_IF;
			END_IF;
		(* Alle Stationen sind gestoppt. Nun müssen noch alle Achsen überprüft werden ob sie gestoppt sind *)
		40:	IF NOT(ptrTAxisZ_St1^.T_CtrleSingle.xNotMoving) AND NOT(ptrTAxisZ_St1^.T_CtrleSingle.xErr) THEN
				ptrTAxisZ_St1^.T_CtrleSingle.iFunction:=5;
				ptrTAxisZ_St1^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			IF NOT(ptrTAxisS_St1^.T_CtrleSingle.xNotMoving) AND NOT(ptrTAxisS_St1^.T_CtrleSingle.xErr) THEN
				ptrTAxisS_St1^.T_CtrleSingle.iFunction:=5;
				ptrTAxisS_St1^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
			iStepAction:=50;
		(* Warte bis alle Achsen stehen *)
		50:	xTmp:=	(NOT(ptrTAxisZ_St1^.T_CtrleSingle.xExecute) AND (ptrTAxisZ_St1^.T_CtrleSingle.xDone OR ptrTAxisZ_St1^.T_CtrleSingle.xErr)) AND
					(NOT(ptrTAxisS_St1^.T_CtrleSingle.xExecute) AND (ptrTAxisS_St1^.T_CtrleSingle.xDone OR ptrTAxisS_St1^.T_CtrleSingle.xErr));
			IF xTmp THEN
				(* action done *)
				iStepAction:=90;
				T_ExchgParam.T_Visu.T_Message.iState:=274;	(* Warnung: Funktion wurde gestoppt ! *)
			END_IF;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xFunctionActive:=FALSE;
			T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
			T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xStationStopWorkRight:=FALSE;
		(* function not ready *)
		95:	T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
			TimerNotReady(IN:=TRUE);
			xStationStopWorkRight:=FALSE;
		END_CASE;
	END_IF;
END_ACTION

ACTION	VisuFunction_ToolCalibration:
(* Ausführen der Stationsfunktion für das Kalibrieren des ToolDefelction und ToolTorque *)
	IF xStationToolCalibrateFunction THEN
		(* Step  function station  *)
		CASE iStepAction OF
		(* Überprüfe zuerst ob es sich um die Station MicroHead oder Entgratstation handelt  *)
		1:	IF (T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration.iSelectCalibrationCylinder = 1) THEN
				ptrActivStation^.THWWorkStation.TCtrlWork.xActiveCalibrateToolDeflection:=TRUE;
				ptrActivStation^.THWWorkStation.TCtrlWork.xActiveCalibrateToolTorque:=FALSE;
			END_IF;
			IF (T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration.iSelectCalibrationCylinder = 2) THEN
				ptrActivStation^.THWWorkStation.TCtrlWork.xActiveCalibrateToolDeflection:=FALSE;
				ptrActivStation^.THWWorkStation.TCtrlWork.xActiveCalibrateToolTorque:=TRUE;
			END_IF;
			iStepAction:=10;
		(* check station state *)
		10:	xTmp:=	ptrActivStation^.TControl.xDone
					AND ptrActivStation^.TControl.xRdy
					AND NOT(ptrActivStation^.TControl.xExecute)
					AND NOT(ptrActivStation^.TControl.xError)
					AND NOT(ptrActivStation^.TControl.xStop);
			(* next step *)
			IF xTmp THEN iStepAction:=20; ELSE iStepAction:=95; END_IF
		(* determin function number *)
		20:	T_ExchgParam.T_Visu.T_Message.iState:=66;	(* Info: Kalibrierungsfunktion gestartet ! *)
			ptrActivStation^.TControl.iFunctNr:=7;
			ptrActivStation^.TControl.xExecute:=TRUE;
			ptrActivStation^.THWWorkStation.TCtrlWork.xStopToolRotation:=TRUE;
			iStepAction:=30;
			(* next step *)
			xStepActionDone:=FALSE;
		(* wait confirmation *)
		30:	IF NOT(xStepActionDone) THEN
			(* release execution *)
				ptrActivStation^.TControl.xExecute:=FALSE;
				xStepActionDone:=TRUE;
			ELSE
				T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_Fct_SpindleCalibration;
				IF (T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration.iSelectCalibrationCylinder = 1) THEN
					T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration.arOffsetToolDeflection[1]:=ptrActivStation^.THWWorkStation.TCtrlWork.rOffsetToolDeflection;
				END_IF;
				IF (T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration.iSelectCalibrationCylinder = 2) THEN
					T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration.arOffseTToolTorque[1]:=ptrActivStation^.THWWorkStation.TCtrlWork.rOffseTToolTorque;
				END_IF;
				IF ptrActivStation^.TControl.xDone THEN
					(* action done *)
					iStepAction:=40;
					xStepActionDone:=FALSE;
				END_IF
			END_IF
		40:	T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_Fct_SpindleCalibration;
			iStepAction:=50;
		50:	xAction_SaveNovRAM:=TRUE;
			xBlockSetNovRamAction_End:=TRUE;
			iStepActionNovRam:=1;
			iStepAction:=60;
		60:	IF NOT(xAction_SaveNovRAM) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=67;	(* Info: Kalibrierungsfunktion beendet ! *)
				xUpdateStationParameter:=TRUE;
				iStepAction:=90;
			END_IF;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xStationToolCalibrateFunction:=FALSE;
		(* function not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xStationToolCalibrateFunction:=FALSE;
		END_CASE
	END_IF

(* Spindelkalibrierung EIN/AUS *)
	IF xSpindelCalibrationONOFF THEN
		CASE iStepAction OF
		(* check state *)
		1:	xTmp:=	TRUE;
			(* next step *)
			IF xTmp THEN iStepAction:=10; ELSE iStepAction:=95; END_IF
		(* Set Value *)
		10:	gxSpindelCalibrationONOFF_St1:=NOT(gxSpindelCalibrationONOFF_St1);
			iStepAction:=90;
		(* action done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSpindelCalibrationONOFF:=FALSE;
		(* cylinder not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xSpindelCalibrationONOFF:=FALSE;
		END_CASE
	END_IF;

	IF (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iWorkStation_Setup1) THEN
		IF (T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_Fct_SpindleCalibration.iSelectCalibrationCylinder <> 1) AND
			(T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_Fct_SpindleCalibration.iSelectCalibrationCylinder <> 2) THEN
			T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_Fct_SpindleCalibration.iSelectCalibrationCylinder:=1;
		END_IF;
		IF (T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration.iSelectCalibrationCylinder <> 1) AND
			(T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration.iSelectCalibrationCylinder <> 2) THEN
			T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration.iSelectCalibrationCylinder:=1;
		END_IF;
		IF (T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration.iSelectCalibrationCylinder <>
		     T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_Fct_SpindleCalibration.iSelectCalibrationCylinder) THEN
			T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_Fct_SpindleCalibration.iSelectCalibrationCylinder:=
											T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration.iSelectCalibrationCylinder;
		END_IF;

		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration.rEffectiveForceToolDeflection:=
					T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rForceDeflection +
					T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_Fct_SpindleCalibration.arOffsetToolDeflection[1];
		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration.rNullValueToolDeflection:=
					T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rForceDeflection;

		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration.rEffectiveForceToolTorque:=
					T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rTorqueLevelHC +
					T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_Fct_SpindleCalibration.arOffseTToolTorque[1];
		T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration.rNullValueToolTorque:=
					T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange.rTorqueLevelHC;

		IF NOT(xStationToolCalibrateFunction) THEN
			T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration.arOffsetToolDeflection:=
					T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_Fct_SpindleCalibration.arOffsetToolDeflection;
			T_ExchgParam.T_StationCommon.T_Param_StationWork.T_Fct_SpindleCalibration.arOffseTToolTorque:=
					T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].T_Fct_SpindleCalibration.arOffseTToolTorque;
		END_IF;
	END_IF;

END_ACTION

ACTION	VisuFunction_ToolChange:
(* Resetten des Werkzeugwechsel für den Automatik für Station 1,2,3 und 4-->braucht mindestens den OperatorLevel oder für das setzen der berechneten Z EndPosition *)
	IF xProcessStation1ResetToolChange OR xZSaveEndPosCalc THEN
		CASE iStepAction OF
		(* Überprüfe zuerst ob mindestens der OperatorLevel gesetzt ist *)
		1:	IF (T_ExchgParam.T_Visu.T_Level.iActLevel < 1) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=217;	(* Warnung: Mindestens OperatorLevel wird benötigt ! *)
				iStepAction:=90;
			ELSE
				iStepAction:=10;
			END_IF;
		10:	T_ExchgParam.T_Visu.T_Message.iState:=103;	(* Aufforderung: Speichern bestätigen <Enter>, abbrechen <Esc> ? *)
			iStepAction:=20;
		(* waiting for key <Enter> or <Esc> *)
		20:	IF RisingEdgeKeyPanel_Enter.Q THEN
				iStepAction:=30;
			ELSE
				IF RisingEdgeKeyPanel_Esc.Q THEN
					iStepAction:=90;
					T_ExchgParam.T_Visu.T_Message.iState:=202;	(* Warnung: Aktion abgebrochen ! *)
				END_IF
			END_IF
			(* An other message has been displayed *)
			IF (T_ExchgParam.T_Visu.T_Message.iState<>103) AND (T_ExchgParam.T_Visu.T_Message.iState<>202) THEN iStepAction:=90; END_IF
		30:	IF xProcessStation1ResetToolChange THEN
				T_NovRam.T_Parameter.T_StationWork[1].T_ToolCounter.diToolCycleCounter:=0;
				T_ExchgParam.T_StationCommon.T_ToolCounter_St1.diToolCycleCounter:=0;
				IF NOT(gxProcessCylindricalAreaActive) THEN
					garPositionEndProcCalc[1]:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rPositionEndProc;
					T_ExchgParam.T_StationCommon.rPositionEndProcCalc:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rPositionEndProc;
				ELSE
					garPositionEndProcCalc[1]:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rZPositionCylindricalArea;
					T_ExchgParam.T_StationCommon.rPositionEndProcCalc:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rZPositionCylindricalArea;
				END_IF;
				garCentringEndProcCalc[1]:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rCentringPosZ1Axis;
				T_ExchgParam.T_StationCommon.rCentringEndProcCalc:=T_NovRam.T_Parameter.T_StationWork[1].T_StProcess.rCentringPosZ1Axis;
			ELSE
				IF (T_ExchgParam.T_StationCommon.bSelectShowIncValue = 0) THEN
					garPositionEndProcCalc[1]:=T_ExchgParam.T_StationCommon.rPositionEndProcCalc;
				ELSE
					garCentringEndProcCalc[1]:=T_ExchgParam.T_StationCommon.rCentringEndProcCalc;
				END_IF;
			END_IF;
			iStepAction:=40;
		40:	IF xZSaveEndPosCalc THEN
				IF (T_ExchgParam.T_StationCommon.bSelectShowIncValue = 0) THEN
					IF (garPositionEndProcCalc[1] <> T_ExchgParam.T_StationCommon.rPositionEndProcCalc) THEN
						T_ExchgParam.T_StationCommon.rPositionEndProcCalc:=garPositionEndProcCalc[1];
					END_IF;
				ELSE
					IF (garCentringEndProcCalc[1] <> T_ExchgParam.T_StationCommon.rCentringEndProcCalc) THEN
						T_ExchgParam.T_StationCommon.rCentringEndProcCalc:=garCentringEndProcCalc[1];
					END_IF;
				END_IF;
			END_IF;
			xAction_SaveNovRAM:=TRUE;
			xBlockSetNovRamAction_End:=TRUE;
			iStepActionNovRam:=1;
			iStepAction:=50;
		50:	IF NOT(xAction_SaveNovRAM) THEN
				iStepAction:=90;
				IF xProcessStation1ResetToolChange THEN
					T_ExchgParam.T_Visu.T_Message.iState:=68;	(* Info: WzZähler für Station 1 wurde zurückgesetzt ! *)
				ELSE
					T_ExchgParam.T_Visu.T_Message.iState:=69;	(* Info: Position gespeichert ! *)
				END_IF;
			END_IF;
		(* axis not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xProcessStation1ResetToolChange:=xZSaveEndPosCalc:=FALSE;
		(* slow/fast configuration done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xProcessStation1ResetToolChange:=xZSaveEndPosCalc:=FALSE;
		END_CASE
	END_IF;


(* Umschalten Z Ink Wert für Bearbeitung oder Zentrierung *)
	IF xSelectZInkWorkInfo OR xSelectZInkCentringInfo THEN
		CASE iStepAction OF
		(* Überprüfe zuerst ob mindestens der OperatorLevel gesetzt ist *)
		1:	iStepAction:=10;
		10:	IF xSelectZInkWorkInfo THEN
				T_ExchgParam.T_StationCommon.bSelectShowIncValue:=0;
			ELSE
				T_ExchgParam.T_StationCommon.bSelectShowIncValue:=1;
			END_IF;
			iStepAction:=90;
		(* axis not ready *)
		95:	TimerNotReady(IN:=TRUE);
			xSelectZInkWorkInfo:=xSelectZInkCentringInfo:=FALSE;
		(* slow/fast configuration done *)
		90:	T_Visu.T_CtrleAction.xDone:=TRUE;
			T_Visu.T_CtrleAction.xNotReady:=FALSE;
			T_Visu.T_CtrleAction.xErr:=FALSE;
			T_Visu.T_CtrleAction.udiErrorID:=0;
			xSelectZInkWorkInfo:=xSelectZInkCentringInfo:=FALSE;
		END_CASE
	END_IF;
END_ACTION

ACTION	VisuUpdateParameter:
IF (T_Visu.T_PlcParam.dwActualPage = gT_PageNumber.iHandMode_OnlineChange) THEN
	xFctUpdateOnlineChangeValue(	ptrProfileOnlineChange:=ADR(T_Profile.T_Profile_MinMax),
									ptrProfileOnlineChangeLoad:=ADR(T_Profile.T_LoadProfileParameter.T_ProfileOnlineChange),
									ptrExchgParamStationCommon:=ADR(T_ExchgParam.T_ProfileCommon.T_OnlineChange),
									TOnlineChangeParameter:=T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_OnlineChange);
END_IF;

END_ACTION





























































(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU\/FB_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FBQVIS_INITPAGE
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR_IN_OUT
	T_Visu:ST_QVIS;
END_VAR
VAR
(* pointer *)
	ptrConfigPage: POINTER TO ST_CONFIGPAGE;
(* variable *)
	iIndexPage:INT;
	iPageNumber:INT;
(* variable Tmp *)
	i:INT;
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(***********                    This Functionblock init all the defined page in QVis for the hole page management                            ************)
(****************************************************************************************************************************************************)
(* init. index array *)
FOR i:=0 TO 999 DO
	T_Visu.T_PageIndex[i].iIndexConfigPage:=0;
END_FOR

(* init. Number Page *)
iPageNumber:=0;
Page_000_Start;
Page_001_BIOS;
Page_002_BIOS;
Page_010_AutoMode_Process;
Page_011_AutoMode_ProcessValue1;
Page_012_AutoMode_ProcessValue2;	(* IGS *)
Page_013_AutoMode_PartQuality;
Page_020_AutoMode_Referencing;
Page_030_AutoMode_Profile;
Page_040_AutoMode_ToolChange;
Page_041_AutoMode_UserLevel;
Page_042_AutoMode_Language;
Page_050_AutoMode_WPCounter;
Page_051_AutoMode_LampTest;
Page_052_AutoMode_SafetyCheck;
Page_053_AutoMode_SysInfo;
Page_060_AutoMode_ErrorList;
Page_070_AutoMode_Parameter;
Page_110_HandMode_Process;
Page_111_HandMode_WorkParameter;		(* IGS *)
Page_112_HandMode_RegulatorPara;		(* IGS *)
Page_113_HandMode_OnlineChange;
Page_114_HandMode_ConfigPosition;
Page_120_HandMode_ProfileMngmt1;
Page_150_HandMode_Setup1;
Page_160_HandMode_ErrorList;
Page_170_HandMode_Parameter;
Page_210_WorkStation_Axis1;
Page_220_WorkStation_Cylinder1;
Page_230_WorkStation_Valve1;
Page_240_WorkStation_Function1;
Page_250_WorkStation_Setup1;
Page_251_WorkStation_Setup2;
Page_252_WorkStation_Setup3;
Page_253_WorkStation_Setup4;
Page_254_WorkStation_Setup5;
Page_260_WorkStation_ErrorList;
Page_270_WorkStation_Parameter;
END_FUNCTION_BLOCK
ACTION	Page_000_Start:
(* QVis page 0, start page *)
iIndexPage:=gT_PageNumber.iStart_Page1;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='Start page';
ptrConfigPage^.wMaskBtPanelLeft:=16#0;
ptrConfigPage^.wMaskBtPanelRight:=16#0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#0;
ptrConfigPage^.wMaskProcBtPanelRight:=16#0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,1]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,1]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,1]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,1]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,1]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,1]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,9]:=0;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=FALSE;
END_ACTION

ACTION	Page_001_BIOS:
(* QVis page 1, BIOS input Password *)
iIndexPage:=gT_PageNumber.iBIOS_Page1;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='BIOS input Password';
ptrConfigPage^.wMaskBtPanelLeft:=16#0;
ptrConfigPage^.wMaskBtPanelRight:=16#0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#0;
ptrConfigPage^.wMaskProcBtPanelRight:=16#0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_BIOS;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=FALSE;
END_ACTION

ACTION	Page_002_BIOS:
(* QVis page 2, BIOS Parameter *)
iIndexPage:=gT_PageNumber.iBIOS_Page2;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='BIOS Parameter';
ptrConfigPage^.wMaskBtPanelLeft:=16#0;
ptrConfigPage^.wMaskBtPanelRight:=16#0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#0;
ptrConfigPage^.wMaskProcBtPanelRight:=16#0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_BIOS;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=FALSE;
END_ACTION

ACTION	Page_010_AutoMode_Process:
(* QVis page 10, AutoMode Process all holes *)
iIndexPage:=gT_PageNumber.iAutoMode_Process;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='AutoMode Process all holes';
ptrConfigPage^.wMaskBtPanelLeft:=16#18;		(*              1 1000	Lampe & Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#3E0;		(* 11 1110 0000	Auto Process, Work Info1, Work Info 2, WP Analysis, Meldung Anzeigen *)	(* alt: 1E0; *)
ptrConfigPage^.wMaskFunctionPanel:=16#1F;		(* F1, F2, F3, F4, F5 *)
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#F;		(*              1 1111 *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#3E0;	(* 11 1110 0000 Auto Process, Work Info1, Work Info 2, WP Analysis, Meldung Anzeigen *)	(* alt: 1E0; *)
ptrConfigPage^.wMaskProcFunctionPanel:=16#1;		(* F1 *)
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iAutoMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iAutoMode_Process;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iAutoMode_ProcessValue1;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iAutoMode_ProcessValue2;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iAutoMode_PartQuality;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=104;		(* Meldungsfenster Öffnen *)
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=151;	(* Endlos Prozess für Messe *)
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=152;	(* Zentrieren EIN/AUS *)
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=153;	(* NurZentrieren EIN/AUS *)
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=154;	(* Suspension EIN/AUS *)
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=155;	(* WPUnfix EIN/AUS *)
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_NormalMode;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_011_AutoMode_ProcessValue1:
(* QVis page 11, AutoMode PartQuality *)
iIndexPage:=gT_PageNumber.iAutoMode_ProcessValue1;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='AutoMode ProcessValue';
ptrConfigPage^.wMaskBtPanelLeft:=16#18;		(*              1 1000	Lampe & Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#3E0;		(* 11 1110 0000	Auto Process, Work Info1, Work Info 2, WP Analysis, Meldung Anzeigen *)	(* alt: 1E0; *)
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#F;		(*              1 1111 *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#3E0;	(* 11 1110 0000 Auto Process, Work Info1, Work Info 2, WP Analysis, Meldung Anzeigen *)	(* alt: 1E0; *)
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iAutoMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iAutoMode_Process;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iAutoMode_ProcessValue1;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iAutoMode_ProcessValue2;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iAutoMode_PartQuality;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=104;		(* Meldungsfenster Öffnen *)
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_NormalMode;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_012_AutoMode_ProcessValue2:
(* QVis page 12, AutoMode ProzessValue2 *)
iIndexPage:=gT_PageNumber.iAutoMode_ProcessValue2;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='AutoMode ProcessValue2';
ptrConfigPage^.wMaskBtPanelLeft:=16#18;		(*              1 1000	Lampe & Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#3E0;		(* 11 1110 0000	Auto Process, Work Info1, Work Info 2, WP Analysis, Meldung Anzeigen *)	(* alt: 1E0; *)
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#F;		(*              1 1111 *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#3E0;	(* 11 1110 0000 Auto Process, Work Info1, Work Info 2, WP Analysis, Meldung Anzeigen *)	(* alt: 1E0; *)
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iAutoMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iAutoMode_Process;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iAutoMode_ProcessValue1;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iAutoMode_ProcessValue2;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iAutoMode_PartQuality;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=104;		(* Meldungsfenster Öffnen *)
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_NormalMode;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_013_AutoMode_PartQuality:
(* QVis page 12, AutoMode PartQuality *)
iIndexPage:=gT_PageNumber.iAutoMode_PartQuality;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='AutoMode PartQuality';
ptrConfigPage^.wMaskBtPanelLeft:=16#18;		(*              1 1000	Lampe & Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#3E0;		(* 11 1110 0000	Auto Process, Work Info1, Work Info 2, WP Analysis, Meldung Anzeigen *)	(* alt: 1E0; *)
ptrConfigPage^.wMaskFunctionPanel:=16#1;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#F;		(*              1 1111 *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#3E0;	(* 11 1110 0000 Auto Process, Work Info1, Work Info 2, WP Analysis, Meldung Anzeigen *)	(* alt: 1E0; *)
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iAutoMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iAutoMode_Process;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iAutoMode_ProcessValue1;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iAutoMode_ProcessValue2;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iAutoMode_PartQuality;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=104;		(* Meldungsfenster Öffnen *)
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=150;	(* Löschen des Prozesszustandspeicher *)
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_NormalMode;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_020_AutoMode_Referencing:
(* QVis page 20, AutoMode Referencing *)
iIndexPage:=gT_PageNumber.iAutoMode_Referencing;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='AutoMode Referencing';
ptrConfigPage^.wMaskBtPanelLeft:=16#18;	(* Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#0;
ptrConfigPage^.wMaskFunctionPanel:=16#1;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#F;
ptrConfigPage^.wMaskProcBtPanelRight:=16#0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iAutoMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=198;	(* Spindelkalibrierung EIN/AUS St1/St3 *)
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_NormalMode;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_030_AutoMode_Profile:
(* QVis page 30, AutoMode Profile *)
iIndexPage:=gT_PageNumber.iAutoMode_Profile;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='AutoMode Profile';
ptrConfigPage^.wMaskBtPanelLeft:=16#18;	(* Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#20;	(* Profil laden *)
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#F;
ptrConfigPage^.wMaskProcBtPanelRight:=16#0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iAutoMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=1003;		(* Profil laden *)
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_NormalMode;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_040_AutoMode_ToolChange:
(* QVis page 40, AutoMode ToolChange *)
iIndexPage:=gT_PageNumber.iAutoMode_ToolChange;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='AutoMode ToolChange';
ptrConfigPage^.wMaskBtPanelLeft:=16#18;	(* Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#E0;
ptrConfigPage^.wMaskFunctionPanel:=16#7F;	(* F1,F2,F3,F4,F5F6 *)
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#F;
ptrConfigPage^.wMaskProcBtPanelRight:=16#E0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#18;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iAutoMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iAutoMode_ToolChange;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iAutoMode_UserLevel;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iAutoMode_Language;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=115;		(* Reset St1 WzWechsel-->With Operator Level *)
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=116;		(* Z Achse auf WzWechsel Pos setzen *)
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=117;		(* Z Achse auf LadePos setzen *)
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=113;		(* Umschalten Z Ink Wert für Bearbeitung *)
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=114;		(* Umschalten Z Ink Wert für Zentrierung *)
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=118;		(* Speichern Z EndPos Berechnet *)
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_NormalMode;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_041_AutoMode_UserLevel:
(* QVis page 41, AutoMode UserLevel *)
iIndexPage:=gT_PageNumber.iAutoMode_UserLevel;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='AutoMode UserLevel';
ptrConfigPage^.wMaskBtPanelLeft:=16#18;	(* Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#3E0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#F;
ptrConfigPage^.wMaskProcBtPanelRight:=16#3E0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iAutoMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iAutoMode_ToolChange;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iAutoMode_UserLevel;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iAutoMode_Language;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=110;	(* Wenn OperatorLevel aktiv ist, dann wird diese Funktion freigeschaltet für das Passwort ändern zu können *)
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_NormalMode;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_042_AutoMode_Language:
(* QVis page 42, AutoMode Language *)
iIndexPage:=gT_PageNumber.iAutoMode_Language;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='AutoMode Language';
ptrConfigPage^.wMaskBtPanelLeft:=16#18;	(* Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#3E0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#F;
ptrConfigPage^.wMaskProcBtPanelRight:=16#3E0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iAutoMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iAutoMode_ToolChange;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iAutoMode_UserLevel;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iAutoMode_Language;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_NormalMode;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_050_AutoMode_WPCounter:
(* QVis page 50, AutoMode WPCounter *)
iIndexPage:=gT_PageNumber.iAutoMode_WPCounter;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='AutoMode WPCounter';
ptrConfigPage^.wMaskBtPanelLeft:=16#18;	(* Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#1E0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#F;
ptrConfigPage^.wMaskProcBtPanelRight:=16#1E0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iAutoMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iAutoMode_WPCounter;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iAutoMode_LampTest;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iAutoMode_SafetyCheck;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iAutoMode_SysInfo;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_NormalMode;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_051_AutoMode_LampTest:
(* QVis page 51, AutoMode LampTest *)
iIndexPage:=gT_PageNumber.iAutoMode_LampTest;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='AutoMode LampTest';
ptrConfigPage^.wMaskBtPanelLeft:=16#10;	(* Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#1E0;
ptrConfigPage^.wMaskFunctionPanel:=16#7;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#F;
ptrConfigPage^.wMaskProcBtPanelRight:=16#1E0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iAutoMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iAutoMode_WPCounter;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iAutoMode_LampTest;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iAutoMode_SafetyCheck;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iAutoMode_SysInfo;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=100;		(* Lampen EIN/AUS *)
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=101;		(* Lampen Blinken *)
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=102;		(* Lampen Test *)
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_NormalMode;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_052_AutoMode_SafetyCheck:
(* QVis page 52, AutoMode SafetyCheck *)
iIndexPage:=gT_PageNumber.iAutoMode_SafetyCheck;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='AutoMode SafetyCheck';
ptrConfigPage^.wMaskBtPanelLeft:=16#18;	(* Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#1E0;
ptrConfigPage^.wMaskFunctionPanel:=16#1;	(* F1 *)
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#F;
ptrConfigPage^.wMaskProcBtPanelRight:=16#1E0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iAutoMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iAutoMode_WPCounter;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iAutoMode_LampTest;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iAutoMode_SafetyCheck;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iAutoMode_SysInfo;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=105;		(* Maschinen Tür Zuhaltung EIN/AUS *)
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_NormalMode;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_053_AutoMode_SysInfo:
(* QVis page 53, AutoMode SysInfo *)
iIndexPage:=gT_PageNumber.iAutoMode_SysInfo;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='AutoMode SysInfo';
ptrConfigPage^.wMaskBtPanelLeft:=16#18;	(* Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#1E0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#F;
ptrConfigPage^.wMaskProcBtPanelRight:=16#1E0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iAutoMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iAutoMode_WPCounter;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iAutoMode_LampTest;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iAutoMode_SafetyCheck;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iAutoMode_SysInfo;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_NormalMode;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_060_AutoMode_ErrorList:
(* QVis page 60, AutoMode ErrorList *)
iIndexPage:=gT_PageNumber.iAutoMode_ErrorList;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='AutoMode ErrorList';
ptrConfigPage^.wMaskBtPanelLeft:=16#18;	(* Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#60;	(* Reset Fehler, Löschen Fehlerliste *)
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#F;
ptrConfigPage^.wMaskProcBtPanelRight:=16#0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iAutoMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=99;		(* Reset Fehler *)
ptrConfigPage^.aiRTrigActionPanelRight[2]:=97;		(* Löschen Fehlerliste *)
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_NormalMode;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_070_AutoMode_Parameter:
(* QVis page 70, AutoMode Parameter *)
iIndexPage:=gT_PageNumber.iAutoMode_Parameter;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='AutoMode Parameter';
ptrConfigPage^.wMaskBtPanelLeft:=16#18;	(* Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#200;	(* Speichern *)
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#F;
ptrConfigPage^.wMaskProcBtPanelRight:=16#200;	(* Speichern *)
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=5;		(* Parameter OFF-->Previous Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=1001;		(* Speichern *)
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_NormalMode;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_110_HandMode_Process:
(* QVis page 110, HandMode Process *)
iIndexPage:=gT_PageNumber.iHandMode_Process;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='HandMode Process';
ptrConfigPage^.wMaskBtPanelLeft:=16#19;		(*              1 1001 	SetupModeA, Lampe, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#3E0;		(* 11 1110 0000	Process, WorkParameter, RegulatorPara, OnlineChange, ConfigPosition *)
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#9;		(*              1 1001 	SetupModeA, Lampe *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#3E0;	(* 11 1110 0000	Process, WorkParameter, RegulatorPara, OnlineChange, ConfigPosition *)
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iHandMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iHandMode_Process;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iHandMode_WorkParameter;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iHandMode_RegulatorPara;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iHandMode_OnlineChange;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=10000 + gT_PageNumber.iHandMode_ConfigPosition;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeA;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_111_HandMode_WorkParameter:
(* QVis page 111, HandMode WorkParameter *)
iIndexPage:=gT_PageNumber.iHandMode_WorkParameter;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='HandMode Work Parameter';
ptrConfigPage^.wMaskBtPanelLeft:=16#19;		(*              1 1001 	SetupModeA, Lampe, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#3E0;		(* 11 1110 0000	Process, WorkParameter, RegulatorPara, OnlineChange, ConfigPosition *)
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#9;		(*              1 1001 	SetupModeA, Lampe *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#3E0;	(* 11 1110 0000	Process, WorkParameter, RegulatorPara, OnlineChange, ConfigPosition *)
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iHandMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iHandMode_Process;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iHandMode_WorkParameter;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iHandMode_RegulatorPara;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iHandMode_OnlineChange;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=10000 + gT_PageNumber.iHandMode_ConfigPosition;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeA;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_112_HandMode_RegulatorPara:
(* QVis page 112, HandMode RegulatorPara *)
iIndexPage:=gT_PageNumber.iHandMode_RegulatorPara;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='HandMode Regulator Parameter';
ptrConfigPage^.wMaskBtPanelLeft:=16#19;		(*              1 1001 	SetupModeA, Lampe, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#3E0;		(* 11 1110 0000	Process, WorkParameter, RegulatorPara, OnlineChange, ConfigPosition *)
ptrConfigPage^.wMaskFunctionPanel:=16#27;		(* 10 0000 *)
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#9;		(*              1 1001 	SetupModeA, Lampe *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#3E0;	(* 11 1110 0000	Process, WorkParameter, RegulatorPara, OnlineChange, ConfigPosition *)
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iHandMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iHandMode_Process;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iHandMode_WorkParameter;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iHandMode_RegulatorPara;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iHandMode_OnlineChange;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=10000 + gT_PageNumber.iHandMode_ConfigPosition;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=190;	(* Konventioneller Regler *)
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=191;	(* Adaptive Voschub Regler *)
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=192;	(* Konventioneller PD Regler *)
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=195;	(* Regler Parameter speichern *)
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeA;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_113_HandMode_OnlineChange:
(* QVis page 111, HandMode OnlineChange *)
iIndexPage:=gT_PageNumber.iHandMode_OnlineChange;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='HandMode OnlineChange';
ptrConfigPage^.wMaskBtPanelLeft:=16#19;		(*              1 1001 	SetupModeA, Lampe, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#3E0;		(* 11 1110 0000	Process, WorkParameter, RegulatorPara, OnlineChange, ConfigPosition *)		(* IGS alt: E0;*)
ptrConfigPage^.wMaskFunctionPanel:=16#FFF;	(*configuration by FBQVIS, because page has more than 1 List*)
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#9;	(* SetupModeA, Parameter *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#3E0;	(* 11 1110 0000	Process, WorkParameter, RegulatorPara, OnlineChange, ConfigPosition *)		(* IGS alt: E0;*)
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;	(*configuration by FBQVIS, because page has more than 1 List*)
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iHandMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iHandMode_Process;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iHandMode_WorkParameter;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iHandMode_RegulatorPara;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iHandMode_OnlineChange;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=10000 + gT_PageNumber.iHandMode_ConfigPosition;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=120;	(*configuration by FBQVIS, because page has more than 1 List*)
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=126;	(*configuration by FBQVIS, because page has more than 1 List*)
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=128;	(*configuration by FBQVIS, because page has more than 1 List*)
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=132;	(*configuration by FBQVIS, because page has more than 1 List*)
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=130;	(*configuration by FBQVIS, because page has more than 1 List*)
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=134;	(*configuration by FBQVIS, because page has more than 1 List*)
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=121;	(*configuration by FBQVIS, because page has more than 1 List*)
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=127;	(*configuration by FBQVIS, because page has more than 1 List*)
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=129;	(*configuration by FBQVIS, because page has more than 1 List*)
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=133;	(*configuration by FBQVIS, because page has more than 1 List*)
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=131;	(*configuration by FBQVIS, because page has more than 1 List*)
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=135;	(*configuration by FBQVIS, because page has more than 1 List*)
TaskBar_SetupModeA;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_114_HandMode_ConfigPosition:
(* QVis page 112, HandMode Config Position *)
iIndexPage:=gT_PageNumber.iHandMode_ConfigPosition;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='HandMode Config Position';
ptrConfigPage^.wMaskBtPanelLeft:=16#19;		(*              1 1001 	SetupModeA, Lampe, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#3E0;		(* 11 1110 0000	Process, WorkParameter, RegulatorPara, OnlineChange, ConfigPosition *)		(* IGS alt: E0;*)
ptrConfigPage^.wMaskFunctionPanel:=16#3F;		(* 11 1111 *)
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#9;		(*              1 1001 	SetupModeA, Lampe *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#3E0;	(* 11 1110 0000	Process, WorkParameter, RegulatorPara, OnlineChange, ConfigPosition *)		(* IGS alt: E0;*)
ptrConfigPage^.wMaskProcFunctionPanel:=16#F;	(* 00 1111 *)
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iHandMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iHandMode_Process;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iHandMode_WorkParameter;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iHandMode_RegulatorPara;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iHandMode_OnlineChange;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=10000 + gT_PageNumber.iHandMode_ConfigPosition;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=181;	(* Auswahl Position Führungsrohr *)
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=182;	(* Auswahl Abstand Führungsrohr *)
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=183;	(* Auswahl Werkzeug *)
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=184;	(* Auswahl Führungsrohr Einsatz *)
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=185;	(* KonfigPos EIN/AUS *)
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=186;	(* Speichern der Positionskonfiguration *)
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeA;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_120_HandMode_ProfileMngmt1:
(* QVis page 130, HandMode ProfileMngmt1 *)
iIndexPage:=gT_PageNumber.iHandMode_ProfileMngmt1;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='HandMode ProfileMngmt1';
ptrConfigPage^.wMaskBtPanelLeft:=16#19;	(* SetupModeA, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#E0;	(* Profil laden, Profil speichern, Profil löschen, Page Up, Page Down *)
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#9;	(* SetupModeA, Parameter *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#0;	(* Page Up, Page Down *)
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iHandMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=1003;		(* Profil laden *)
ptrConfigPage^.aiRTrigActionPanelRight[2]:=1004;		(* Profil speichern *)
ptrConfigPage^.aiRTrigActionPanelRight[3]:=1005;		(* Profil löschen *)
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeA;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_150_HandMode_Setup1:
(* QVis page 150, HandMode Setup1 *)
iIndexPage:=gT_PageNumber.iHandMode_Setup1;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='HandMode Setup1';
ptrConfigPage^.wMaskBtPanelLeft:=16#19;	(* SetupModeA, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;	(* Einrichtung starten, Werte speichern *)
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#9;	(* SetupModeA, Parameter *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iHandMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=170;(* Einrichtung Potentiometer starten *)
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeA;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_160_HandMode_ErrorList:
(* QVis page 160, HandMode ErrorList *)
iIndexPage:=gT_PageNumber.iHandMode_ErrorList;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='HandMode ErrorList';
ptrConfigPage^.wMaskBtPanelLeft:=16#19;	(* SetupModeA, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#60;	(* Reset Fehler, Löschen Fehlerliste *)
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#9;	(* SetupModeA, Parameter *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iHandMode_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=99;		(* Reset Fehler *)
ptrConfigPage^.aiRTrigActionPanelRight[2]:=97;		(* Löschen Fehlerliste *)
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeA;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_170_HandMode_Parameter:
(* QVis page 170, HandMode Parameter *)
iIndexPage:=gT_PageNumber.iHandMode_Parameter;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='HandMode Parameter';
ptrConfigPage^.wMaskBtPanelLeft:=16#19;	(* SetupModeA, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#200;	(* Speichern *)
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#9;	(* SetupModeA, Parameter *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#200;	(* Speichern *)
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=5;		(* Parameter OFF-->Previous Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=1001;		(* Speichern *)
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeA;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_210_WorkStation_Axis1:
(* QVis page 210, WorkStation Axis1 *)
iIndexPage:=gT_PageNumber.iWorkStation_Axis1;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='WorkStation Axis1';
ptrConfigPage^.wMaskBtPanelLeft:=16#1A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#0;	(* NegIncJogSlow, PosIncJogSlow, Page Up, Page Down *)
ptrConfigPage^.wMaskFunctionPanel:=16#3F;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iWorkStation_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=217;		(* Achse Jog/Ink Bewegung -/- - *)
ptrConfigPage^.aiRTrigActionPanelRight[2]:=216;		(* Achse Jog/Ink Bewegung +/++ *)
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=203;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=204;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=185;	(* KonfigPos EIN/AUS *)
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=214;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeB;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_220_WorkStation_Cylinder1:
(* QVis page 220, WorkStation Cylinder1 *)
iIndexPage:=gT_PageNumber.iWorkStation_Cylinder1;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='WorkStation Cylinder1';
ptrConfigPage^.wMaskBtPanelLeft:=16#1A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#60;	(* EIN,AUS, Drucklos *)
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iWorkStation_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=301;		(* EIN/AUS *)
ptrConfigPage^.aiRTrigActionPanelRight[2]:=302;		(* Zylinder Drucklos schalten *)
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeB;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_230_WorkStation_Valve1:
(* QVis page 230, WorkStation Valve1 *)
iIndexPage:=gT_PageNumber.iWorkStation_Valve1;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='WorkStation Valve1';
ptrConfigPage^.wMaskBtPanelLeft:=16#1A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#0;	(* wird dynamisch zugewiesen für EIN/AUS, wegen der Entgratstation *)
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iWorkStation_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeB;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_240_WorkStation_Function1:
(* QVis page 240, WorkStation Function1 *)
iIndexPage:=gT_PageNumber.iWorkStation_Function1;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='WorkStation Function1';
ptrConfigPage^.wMaskBtPanelLeft:=16#1A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iWorkStation_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeB;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_250_WorkStation_Setup1:
(* QVis page 250, WorkStation Setup1 *)
iIndexPage:=gT_PageNumber.iWorkStation_Setup1;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='WorkStation Setup1';
ptrConfigPage^.wMaskBtPanelLeft:=16#1A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#3E0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#3E0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iWorkStation_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iWorkStation_Setup1;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iWorkStation_Setup2;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iWorkStation_Setup3;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iWorkStation_Setup4;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=10000 + gT_PageNumber.iWorkStation_Setup5;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeB;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_251_WorkStation_Setup2:
(* QVis page 251, WorkStation Setup2 *)
iIndexPage:=gT_PageNumber.iWorkStation_Setup2;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='WorkStation Setup2';
ptrConfigPage^.wMaskBtPanelLeft:=16#1A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#3E0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#3E0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iWorkStation_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iWorkStation_Setup1;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iWorkStation_Setup2;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iWorkStation_Setup3;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iWorkStation_Setup4;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=10000 + gT_PageNumber.iWorkStation_Setup5;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeB;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_252_WorkStation_Setup3:
(* QVis page 252, WorkStation Setup3 *)
iIndexPage:=gT_PageNumber.iWorkStation_Setup3;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='WorkStation Setup3';
ptrConfigPage^.wMaskBtPanelLeft:=16#1A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#3E0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#3E0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iWorkStation_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iWorkStation_Setup1;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iWorkStation_Setup2;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iWorkStation_Setup3;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iWorkStation_Setup4;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=10000 + gT_PageNumber.iWorkStation_Setup5;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeB;
ptrConfigPage^.xMaskBtStart:=TRUE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_253_WorkStation_Setup4:
(* QVis page 253, WorkStation Setup4 *)
iIndexPage:=gT_PageNumber.iWorkStation_Setup4;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='WorkStation Setup4';
ptrConfigPage^.wMaskBtPanelLeft:=16#1A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#3E0;
ptrConfigPage^.wMaskFunctionPanel:=16#3F;	(* Offset -, Offset +, Skalierungswert speichern, Position speichern *)
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#3E0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iWorkStation_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iWorkStation_Setup1;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iWorkStation_Setup2;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iWorkStation_Setup3;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iWorkStation_Setup4;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=10000 + gT_PageNumber.iWorkStation_Setup5;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=171;	(* Torque Offset - *)
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=172;	(* Torque Offset - *)
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=303;	(* Zyl WzDrehmoment EIN/AUS *)
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=304;	(* Zyl WzDrehmomentÜberlast EIN/AUS *)
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=173;	(* Save Torque Scale *)
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=174;	(* Save Torque Position *)
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeB;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_254_WorkStation_Setup5:
(* QVis page 254, WorkStation Setup5 *)
iIndexPage:=gT_PageNumber.iWorkStation_Setup5;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='WorkStation Setup5';
ptrConfigPage^.wMaskBtPanelLeft:=16#1A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#3E0;
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#3E0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iWorkStation_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=10000 + gT_PageNumber.iWorkStation_Setup1;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=10000 + gT_PageNumber.iWorkStation_Setup2;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=10000 + gT_PageNumber.iWorkStation_Setup3;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=10000 + gT_PageNumber.iWorkStation_Setup4;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=10000 + gT_PageNumber.iWorkStation_Setup5;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeB;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_260_WorkStation_ErrorList:
(* QVis page 260, WorkStation ErrorList *)
iIndexPage:=gT_PageNumber.iWorkStation_ErrorList;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='WorkStation ErrorList';
ptrConfigPage^.wMaskBtPanelLeft:=16#1A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#60;	(* Reset Fehler, Löschen Fehlerliste *)
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#0;
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=11000 + gT_PageNumber.iWorkStation_Parameter;		(* Parameter Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=99;		(* Reset Fehler *)
ptrConfigPage^.aiRTrigActionPanelRight[2]:=97;		(* Löschen Fehlerliste *)
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeB;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	Page_270_WorkStation_Parameter:
(* QVis page 270, WorkStation Parameter *)
iIndexPage:=gT_PageNumber.iWorkStation_Parameter;
iPageNumber:=iPageNumber+1;
T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage:=iPageNumber;
ptrConfigPage:=ADR(T_Visu.T_ConfigPage[T_Visu.T_PageIndex[iIndexPage].iIndexConfigPage]);
ptrConfigPage^.sName:='WorkStation Parameter';
ptrConfigPage^.wMaskBtPanelLeft:=16#1A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskBtPanelRight:=16#200;	(* Speichern *)
ptrConfigPage^.wMaskFunctionPanel:=16#0;
(* Process mask *)
ptrConfigPage^.wMaskProcBtPanelLeft:=16#A;	(* SetupModeB, Parameter *)
ptrConfigPage^.wMaskProcBtPanelRight:=16#200;	(* Speichern *)
ptrConfigPage^.wMaskProcFunctionPanel:=16#0;
(* Button edge action *)
ptrConfigPage^.aiRTrigActionPanelLeft[1]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[2]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[3]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[4]:=0;
ptrConfigPage^.aiRTrigActionPanelLeft[5]:=5;		(* Parameter OFF-->Previous Page *)
ptrConfigPage^.aiRTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiRTrigActionPanelRight[5]:=1001;		(* Speichern *)
ptrConfigPage^.aiFTrigActionPanelRight[1]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[2]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[3]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[4]:=0;
ptrConfigPage^.aiFTrigActionPanelRight[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[1]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[2]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[3]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[4]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[5]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[6]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[7]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[8]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[9]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[10]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[11]:=0;
ptrConfigPage^.aiRTrigActionFunctionPanel[12]:=0;
TaskBar_SetupModeB;
ptrConfigPage^.xMaskBtStart:=FALSE;
ptrConfigPage^.xMaskBtStop:=TRUE;
END_ACTION

ACTION	TaskBar_BIOS:
(* Navigation panel restriction *)
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,1]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,1]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,1]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,1]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,1]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,1]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,9]:=0;
END_ACTION

ACTION	TaskBar_NormalMode:
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,1]:=10000 + gT_PageNumber.iAutoMode_Process;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,2]:=10000 + gT_PageNumber.iAutoMode_ProcessValue1;	(* IGS *)
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,3]:=10000 + gT_PageNumber.iAutoMode_ProcessValue2;	(* IGS *)
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,4]:=10000 + gT_PageNumber.iAutoMode_PartQuality;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,1]:=10000 + gT_PageNumber.iAutoMode_Referencing;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,1]:=10000 + gT_PageNumber.iAutoMode_Profile;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,1]:=10000 + gT_PageNumber.iAutoMode_ToolChange;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,2]:=10000 + gT_PageNumber.iAutoMode_UserLevel;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,3]:=10000 + gT_PageNumber.iAutoMode_Language;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,1]:=10000 + gT_PageNumber.iAutoMode_WPCounter;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,2]:=10000 + gT_PageNumber.iAutoMode_LampTest;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,3]:=10000 + gT_PageNumber.iAutoMode_WPCounter;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,4]:=10000 + gT_PageNumber.iAutoMode_SysInfo;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,1]:=10000 + gT_PageNumber.iAutoMode_ErrorList;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,9]:=0;
END_ACTION

ACTION	TaskBar_SetupModeA:
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#33;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,1]:=10000 + gT_PageNumber.iHandMode_Process;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,2]:=10000 + gT_PageNumber.iHandMode_WorkParameter;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,3]:=10000 + gT_PageNumber.iHandMode_RegulatorPara;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,4]:=10000 + gT_PageNumber.iHandMode_OnlineChange;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,5]:=10000 + gT_PageNumber.iHandMode_ConfigPosition;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,1]:=10000 + gT_PageNumber.iHandMode_ProfileMngmt1;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,1]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,1]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,1]:=10000 + gT_PageNumber.iHandMode_Setup1;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,1]:=10000 + gT_PageNumber.iHandMode_ErrorList;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,9]:=0;
END_ACTION

ACTION	TaskBar_SetupModeB:
(* Navigation panel restriction *)
ptrConfigPage^.wMaskTouchScreenNavPanel:=16#3F;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,1]:=10000 + gT_PageNumber.iWorkStation_Axis1;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,2]:=0;;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[1,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,1]:=10000 + gT_PageNumber.iWorkStation_Cylinder1;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[2,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,1]:=10000 + gT_PageNumber.iWorkStation_Valve1;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[3,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,1]:=10000 + gT_PageNumber.iWorkStation_Function1;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[4,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,1]:=10000 + gT_PageNumber.iWorkStation_Setup1;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,2]:=10000 + gT_PageNumber.iWorkStation_Setup2;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,3]:=10000 + gT_PageNumber.iWorkStation_Setup3;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,4]:=10000 + gT_PageNumber.iWorkStation_Setup4;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,5]:=10000 + gT_PageNumber.iWorkStation_Setup5;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[5,9]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,1]:=10000 + gT_PageNumber.iWorkStation_ErrorList;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,2]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,3]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,4]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,5]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,6]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,7]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,8]:=0;
ptrConfigPage^.aiRTrigActionTouchScreenNavPanel[6,9]:=0;
END_ACTION













































(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PRG_LAYER5_VISU' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_VISU
VAR
	FBQVIS: FBQVIS;
	FBCtrlButton: FB_CTRLEBUTTON;
	xNormalMode_EnergyON:BOOL;
	xSetupOperateA_EnergyON:BOOL;
	xSetupOperateB_EnergyON:BOOL;
	xSetupOperateC_EnergyON:BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
_FBD_BODY
_NETWORKS : 9
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
gT_SafetyStatus.xEnergyONNormalMode
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
xNormalMode_EnergyON
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
gT_SafetyStatus.xEnergyONSetupModeASt1
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
xSetupOperateA_EnergyON
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
gT_SafetyStatus.xEnergyONSetupModeBSt1
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
xSetupOperateB_EnergyON
_NETWORK

_COMMENT
''
_END_COMMENT
_FUNCTIONBLOCK
FBCtrlButton
_BOX_EXPR : 14
_OPERAND
_EXPRESSION
_POSITIV
T_StartUp.T_State.xCompleted
_OPERAND
_EXPRESSION
_POSITIV
IxStartButton
_OPERAND
_EXPRESSION
_POSITIV
IxStopButton
_OPERAND
_EXPRESSION
_POSITIV
T_VisuQVis.T_PlcParam.dwActualPage
_OPERAND
_EXPRESSION
_POSITIV
T_VisuQVis
_OPERAND
_EXPRESSION
_POSITIV
T_ExchgParam
_OPERAND
_EXPRESSION
_POSITIV
gT_SafetyStatus.xSetupOperateModeActive
_OPERAND
_EXPRESSION
_POSITIV
gT_SafetyStatus.iSetupMode
_OPERAND
_EXPRESSION
_POSITIV
xNormalMode_EnergyON
_OPERAND
_EXPRESSION
_POSITIV
xSetupOperateA_EnergyON
_OPERAND
_EXPRESSION
_POSITIV
xSetupOperateB_EnergyON
_OPERAND
_EXPRESSION
_POSITIV
xSetupOperateC_EnergyON
_OPERAND
_EXPRESSION
_POSITIV
T_CtrleBtStartStop.T_Start
_OPERAND
_EXPRESSION
_POSITIV
T_CtrleBtStartStop.T_Stop
_EXPRESSION
_POSITIV
FB_CTRLEBUTTON
_OUTPUTS : 0
_NETWORK

_COMMENT
''
_END_COMMENT
_JUMP
_EXPRESSION
_POSITIV
StepVisu
_OPERATOR
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_NEGATIV
T_StartUp.T_State.xCompleted
_OPERAND
_EXPRESSION
_POSITIV
T_ExchgParam.T_SafetyCtrl.xDeactivateLamp
_EXPRESSION
_POSITIV
OR
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
T_CtrleBtStartStop.T_Start.xLedState
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
QxCtrlLampStartButton
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
T_CtrleBtStartStop.T_Stop.xLedState
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
QxCtrlLampStopButton
_NETWORK
StepVisu
_COMMENT
''
_END_COMMENT
_FUNCTIONBLOCK
FBQVIS
_BOX_EXPR : 8
_OPERAND
_EXPRESSION
_POSITIV
T_CtrleBtStartStop.T_Start.xInputState
_OPERAND
_EXPRESSION
_POSITIV
T_CtrleBtStartStop.T_Stop.xInputState
_OPERAND
_EXPRESSION
_POSITIV
UDINT_TO_WORD(T_CtrlePanel.udiButton)
_OPERAND
_EXPRESSION
_POSITIV
gT_SafetyStatus.xSetupOperateModeActive
_OPERAND
_EXPRESSION
_POSITIV
gT_SafetyStatus.iSetupMode
_OPERAND
_EXPRESSION
_POSITIV
T_VisuQVis
_OPERAND
_EXPRESSION
_POSITIV
QVisCtrl
_OPERAND
_EXPRESSION
_POSITIV
T_ExchgParam
_EXPRESSION
_POSITIV
FBQVIS
_OUTPUTS : 0
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_OPERAND
_EXPRESSION
_POSITIV
FALSE
_EXPRESSION
_POSITIV
_OUTPUTS : 2
_OUTPUT
_POSITIV
_NO_SET
T_VisuQVis.T_CtrleVisu.xReset
_OUTPUT
_POSITIV
_NO_SET
T_VisuQVis.T_CtrleVisu.xExecute

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_COLLISION_DETECTION
VAR
	ptrTCommonStation:POINTER TO ST_STATION;
	ptrTCommonStation0:POINTER TO ST_STATION;
	ptrTCommonAxis : POINTER TO ST_AXIS;
	ptrTCommonAxis0 : POINTER TO ST_AXIS;
	xTmp: BOOL;
	xTmp0: BOOL;
	xActiveMessageWork: BOOL;
	xActiveMessageWork1: BOOL;
	xCheckHCSensor: BOOL;
	xCheckZAxisVelModePosDirection: BOOL;
	xCheckMovement: BOOL;
	xCheckZAxisRelPosDirection: BOOL;
	xCheckZAxisAbsPosDirection: BOOL;
	iSaveAxisNr:INT;
	diSaveAxisZErrNr: DINT;
	diSaveAxisZErr1Nr: DINT;
	ii: INT;
	xZAxisBrakeReleased: BOOL;
	xCheckHCOverloadSensor: BOOL;
	jj: INT;
	iSaveStateMessage: INT;
	TONCheckRelease: TON;
END_VAR
(* @END_DECLARATION := '0' *)
(* Kollisionsüberprüfung für den HandBetrieb und Prozess *)
	Check_Station_Working_AxisBrake;
	Check_Station_Working;
END_PROGRAM
ACTION	Check_Station_Working:
IF NOT(T_StartUp.T_State.xCompleted) OR gxHardwareOFF OR gxAxisOFF THEN
	RETURN;
END_IF;
(* Überprüfe den Zustand der Zylinder *)
(* Überwachung im AutoBetrieb und HandBetrieb *)
IF NOT(TProcess.T_Ctrle.xExecute) AND TProcess.T_Ctrle.xDone AND NOT(TProcess.T_Ctrle.xError) OR TRUE THEN
(* Zylinder Überwachung der Bearbeitungsstation MicroHead und Entgrat *)
(* Achsen Überwachung der Bearbeitungsstation MicroHead und Entgrat *)
	FOR ii:=1 TO 1 DO
		IF (ii = 1) THEN ptrTCommonStation:=ADR(TStation_Work_St1); jj:=1; END_IF;
		ptrTCommonAxis:=ADR(ptrTCommonStation^.THWWorkStation.TAxisZ);
		xCheckHCSensor:=			ptrTCommonStation^.THWWorkStation.TCylToolDeflection.T_CtrleCyl.xStatePosOn AND NOT(ptrTCommonStation^.TControl.xExecute) AND ptrTCommonStation^.TControl.xDone AND
									NOT(ptrTCommonStation^.TControl.xError) AND ptrTCommonStation^.TControl.xRdy;
		xCheckHCOverloadSensor:=	FALSE;
		(* Für Z Achse muss die Positive Richtung für HC überprüft werden *)
		xCheckZAxisVelModePosDirection:=(ptrTCommonAxis^.T_CtrleSingle.iFunction = 6) AND (ptrTCommonAxis^.T_CtrleSingle.lrVelocity >= 0);
		xCheckZAxisRelPosDirection:=(ptrTCommonAxis^.T_CtrleSingle.iFunction = 8) AND (ptrTCommonAxis^.T_CtrleSingle.lrDistance >= 0);
		xCheckZAxisAbsPosDirection:=(ptrTCommonAxis^.T_CtrleSingle.iFunction = 7) AND (ptrTCommonAxis^.T_CtrleSingle.lrPosition > ptrTCommonAxis^.T_LiveValue.lrActualPosition);
		xCheckMovement:=	(xCheckHCSensor OR xCheckHCOverloadSensor) AND
							(xCheckZAxisVelModePosDirection OR xCheckZAxisRelPosDirection OR xCheckZAxisAbsPosDirection);
		IF ptrTCommonAxis^.T_CtrleSingle.xExecute AND ptrTCommonAxis^.T_CtrleSingle.xDone THEN
			(* Überprüfung für Achse wenn Start Befehl erfolgt *)
			xTmp:=	xCheckMovement;
			IF xTmp THEN
				(* Überprüfe nun ob die Achse sich bewegen darf *)
				IF (ptrTCommonAxis^.T_CtrleSingle.iFunction <> 1) AND (ptrTCommonAxis^.T_CtrleSingle.iFunction <> 3) AND (ptrTCommonAxis^.T_CtrleSingle.iFunction <> 4) THEN
					ptrTCommonAxis^.T_CtrleSingle.xExecute:=FALSE;		(* Aufruf des Aktuators wird zurückgesetzt *)
					T_VisuQVis.T_CtrleAction.xDeleteVisuFunction:=TRUE;
					T_VisuQVis.T_CtrleAction.xFunctionActive:=FALSE;
					xActiveMessageWork1:=TRUE;
					IF xCheckHCSensor THEN
						iSaveStateMessage:=241;		(* Warnung: Kollisionsgefahr: WzAuslenkung Sensor ST1 Aktiv ! *)
					ELSIF xCheckHCOverloadSensor THEN
						iSaveStateMessage:=245;		(* Warnung: Kollisionsgefahr: WzDrehmoment Überlast Sensor ST1 Aktiv ! *)
					END_IF;
				END_IF;
			END_IF;
		END_IF;
		IF NOT(ptrTCommonAxis^.T_CtrleSingle.xNotMoving) AND NOT(ptrTCommonAxis^.T_CtrleSingle.xExecute) AND (ptrTCommonAxis^.T_CtrleSingle.iFunction <> 5) THEN
			(* Überprüfung für Achse wenn sich in Positiver Richtung bewegt *)
			IF ptrTCommonAxis^.T_CtrleSingle.xMovingForward THEN
				(* Überprüfe nun ob die Achse gestoppt werden muss *)
				IF xCheckMovement THEN
					(* Teller liegt nicht im Raster, daher muss die Achse gestoppt werden *)
					ptrTCommonAxis^.T_CtrleSingle.iFunction:=5;
					ptrTCommonAxis^.T_CtrleSingle.xExecute:=TRUE;
					T_VisuQVis.T_CtrleAction.xDeleteVisuFunction:=TRUE;
					T_VisuQVis.T_CtrleAction.xFunctionActive:=FALSE;
					xActiveMessageWork1:=TRUE;
					IF xCheckHCSensor THEN
						iSaveStateMessage:=241;		(* Warnung: Kollisionsgefahr: WzAuslenkung Sensor ST1 Aktiv ! *)
					ELSIF xCheckHCOverloadSensor THEN
						iSaveStateMessage:=245;		(* Warnung: Kollisionsgefahr: WzDrehmoment Überlast Sensor ST1 Aktiv ! *)
					END_IF;
				END_IF;
			END_IF;
		END_IF;
	END_FOR;

	IF xActiveMessageWork1 THEN
		xActiveMessageWork1:=FALSE;
		T_ExchgParam.T_Visu.T_Message.iState:=iSaveStateMessage;
	ELSE
		diSaveAxisZErr1Nr:=0;
	END_IF;
END_IF;
END_ACTION

ACTION	Check_Station_Working_AxisBrake:
IF NOT(T_StartUp.T_State.xCompleted) OR gxHardwareOFF THEN
	RETURN;
END_IF;
(* Überprüfe den Zustand der Zylinder *)
TONCheckRelease(IN:=NOT(TStation_Work_St1.THWWorkStation.TCylBrakeReleaseZAxis.T_CtrleCyl.xStatePosOn), PT:=T#1S);
IF TStation_Work_St1.THWWorkStation.TCylBrakeReleaseZAxis.T_CtrleCyl.xStatePosOn THEN
	TCollisionDetection.xZAxisBrakeReleased:=TRUE;	(* Bremse gelöst *)
END_IF;
IF TONCheckRelease.Q THEN
	TCollisionDetection.xZAxisBrakeReleased:=FALSE;	(* Bremse nicht gelöst *)
END_IF;

(* Überwachung im AutoBetrieb und HandBetrieb *)
IF NOT(TProcess.T_Ctrle.xExecute) AND TProcess.T_Ctrle.xDone AND NOT(TProcess.T_Ctrle.xError) OR TRUE THEN
(* Achsen Überwachung der Bearbeitungsstation MicroHead *)
	FOR ii:=1 TO 1 DO
		IF (ii = 1) THEN ptrTCommonStation0:=ADR(TStation_Work_St1); xZAxisBrakeReleased:=TCollisionDetection.xZAxisBrakeReleased;END_IF;
		ptrTCommonAxis0:=ADR(ptrTCommonStation0^.THWWorkStation.TAxisZ);
		IF ptrTCommonAxis0^.T_CtrleSingle.xExecute AND ptrTCommonAxis0^.T_CtrleSingle.xDone THEN
			(* Überprüfung für Achse wenn Start Befehl erfolgt *)
			xTmp0:=	(ptrTCommonAxis0^.T_CtrleSingle.iFunction = 6) OR (ptrTCommonAxis0^.T_CtrleSingle.iFunction = 7) OR (ptrTCommonAxis0^.T_CtrleSingle.iFunction = 8) OR (ptrTCommonAxis0^.T_CtrleSingle.iFunction = 9);
			IF xTmp0 THEN
				(* Überprüfe nun ob die Achse sich bewegen darf *)
				IF NOT(xZAxisBrakeReleased) AND NOT(ptrTCommonAxis0^.T_CtrleSingle.xStateHWLimitPos) AND NOT(ptrTCommonAxis0^.T_CtrleSingle.xStateHWLimitNeg) THEN
					(* Bremse ist Aktiv und deshalb darf die Achse nicht verfahren werden *)
					ptrTCommonAxis0^.T_CtrleSingle.xExecute:=FALSE;		(* Aufruf des Aktuators wird zurückgesetzt *)
					T_VisuQVis.T_CtrleAction.xDeleteVisuFunction:=TRUE;
					T_VisuQVis.T_CtrleAction.xFunctionActive:=FALSE;
					xActiveMessageWork:=TRUE;
					iSaveAxisNr:=ii;
				END_IF;
			END_IF;
		END_IF;
		IF NOT(ptrTCommonAxis0^.T_CtrleSingle.xNotMoving) AND NOT(ptrTCommonAxis0^.T_CtrleSingle.xExecute) AND (ptrTCommonAxis0^.T_CtrleSingle.iFunction <> 5) THEN
			(* Überprüfe nun ob die Achse gestoppt werden muss *)
			IF NOT(xZAxisBrakeReleased) AND NOT(ptrTCommonAxis0^.T_CtrleSingle.xStateHWLimitPos) AND NOT(ptrTCommonAxis0^.T_CtrleSingle.xStateHWLimitNeg) THEN
				(* Teller liegt nicht im Raster, daher muss die Achse gestoppt werden *)
				ptrTCommonAxis0^.T_CtrleSingle.iFunction:=5;
				ptrTCommonAxis0^.T_CtrleSingle.xExecute:=TRUE;
				T_VisuQVis.T_CtrleAction.xDeleteVisuFunction:=TRUE;
				T_VisuQVis.T_CtrleAction.xFunctionActive:=FALSE;
				xActiveMessageWork:=TRUE;
				iSaveAxisNr:=ii;
			END_IF;
		END_IF;
	END_FOR;
	IF xActiveMessageWork THEN
		xActiveMessageWork:=FALSE;
		IF (iSaveAxisNr = 1) THEN
			T_ExchgParam.T_Visu.T_Message.iState:=239;		(* Warnung: Kollisionsgefahr: Z Achse ST1 Bremse Aktiv ! *)
			ptrTCommonStation0:=ADR(TStation_Work_St1);
		END_IF;
		ptrTCommonAxis0:=ADR(ptrTCommonStation0^.THWWorkStation.TAxisZ);
		IF NOT(ptrTCommonStation0^.TControl.xExecute) AND NOT(ptrTCommonStation0^.TControl.xDone) AND NOT(ptrTCommonStation0^.TControl.xError) THEN
			IF (diSaveAxisZErrNr = 0) THEN
				IF (T_ExchgParam.T_Visu.T_Message.iState = 239) THEN
					diSaveAxisZErrNr:=16#F501;		(* Bremse Aktiv von ST1 *)
				ELSIF (T_ExchgParam.T_Visu.T_Message.iState = 240) THEN
					diSaveAxisZErrNr:=16#F502;		(* Bremse Aktiv von ST2 *)
				ELSIF (T_ExchgParam.T_Visu.T_Message.iState = 255) THEN
					diSaveAxisZErrNr:=16#F503;		(* Bremse Aktiv von ST3 *)
				ELSIF (T_ExchgParam.T_Visu.T_Message.iState = 256) THEN
					diSaveAxisZErrNr:=16#F504;		(* Bremse Aktiv von ST4 *)
				END_IF;
			END_IF;
			IF NOT(ptrTCommonAxis0^.T_CtrleSingle.xExecute) AND ptrTCommonAxis0^.T_CtrleSingle.xDone AND
			     NOT(ptrTCommonAxis0^.T_CtrleSingle.xErr) AND ptrTCommonAxis0^.T_CtrleSingle.xNotMoving THEN
				ptrTCommonAxis0^.T_CtrleSingle.xErr:=TRUE;
				ptrTCommonAxis0^.T_CtrleSingle.xDone:=FALSE;
				ptrTCommonAxis0^.T_CtrleSingle.udiErrorID:=diSaveAxisZErrNr;
			ELSE
				xActiveMessageWork:=TRUE;
			END_IF;
		END_IF;
	ELSE
		diSaveAxisZErrNr:=0;
	END_IF;
END_IF;
END_ACTION





(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_ERROR_WARNING_CTRLE
VAR
	RisingEdge_ProcessError_St1St2: R_TRIG;
	RisingEdge_Station1Error: R_TRIG;
	RisingEdge_Station1_Axis1Error: R_TRIG;
	RisingEdge_Station1_Axis2Error: R_TRIG;
	RisingEdge_Station1_Axis3Error: R_TRIG;
	RisingEdge_Station2_Axis1Error: R_TRIG;
	RisingEdge_Station2_Axis2Error: R_TRIG;
	RisingEdge_Station2_Axis3Error: R_TRIG;
	RisingEdge_Station5_Axis1Error: R_TRIG;
	ii: INT;
	FBErrorMessage:FB_ErrorMessage;
	FBErrorMessageVisu:FB_ErrorMessage;
	diErrorNr: DINT;
	sErrorTimeStamp: STRING(12);
	RisingEdgeUpdateErrorList: R_TRIG;
	xNoProcessStationActive_St1St2: BOOL;
	iStepSetForceError: INT;
	adiTmpErrorList: ARRAY [1..20] OF DINT;
	asTmpErrorList: ARRAY [1..20] OF STRING(12);
	FBNT_GetTime:NT_GetTime;
	FBResetError: FB_ResetError;
	iStepResetError: INT;
	xSetError: BOOL;
	udi_TmpErrorNr: UDINT;
	TONWaitCheckError_Z_St1: TON;
	TONWaitCheckError_Z_St2: TON;
	TONWaitCheckError_S_St1: TON;
	TONWaitCheckError_S_St2: TON;
	TONWaitCheckError_O_St1: TON;
	TONWaitCheckError_O_St2: TON;
	TONWaitCheckError_C_St1: TON;
	xCheckAxisError_Z_St1: BOOL;
	xCheckAxisError_Z_St2: BOOL;
	xCheckAxisError_S_St1: BOOL;
	xCheckAxisError_S_St2: BOOL;
	xCheckAxisError_O_St1: BOOL;
	xCheckAxisError_O_St2: BOOL;
	xCheckAxisError_C_St1: BOOL;
	xExecuteResetError:BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
IF (TStatusUPS.ePowerStatus = PowerOnBattery) THEN
	RETURN;
END_IF;
RisingEdge_ProcessError_St1St2(CLK:=NOT(TProcess.T_Ctrle.xDone) AND TProcess.T_Ctrle.xError);
RisingEdge_Station1Error(CLK:=NOT(TStation_Work_St1.TControl.xDone) AND TStation_Work_St1.TControl.xError);

RisingEdge_Station1_Axis1Error(CLK:=	NOT(TStation_Work_St1.THWWorkStation.TAxisZ.T_CtrleSingle.xDone) AND TStation_Work_St1.THWWorkStation.TAxisZ.T_CtrleSingle.xErr);
RisingEdge_Station1_Axis2Error(CLK:=	NOT(TStation_Work_St1.THWWorkStation.TAxisS.T_CtrleSingle.xDone) AND TStation_Work_St1.THWWorkStation.TAxisS.T_CtrleSingle.xErr);
IF RisingEdge_ProcessError_St1St2.Q AND T_StartUp.T_State.xCompleted THEN
	T_ExchgParam.T_SafetyCtrl.xSetForceError:=TRUE;
	T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=TProcess.T_Ctrle.diErrorNr;
END_IF;
IF (TProcess.T_Ctrle.xDone AND NOT(TProcess.T_Ctrle.xError)) OR NOT(T_StartUp.T_State.xCompleted) THEN
	(* Stationsfehler nur auffangen falls der Prozess nicht aktiv ist oder die Maschine am Aufstarten ist *)
	IF RisingEdge_Station1Error.Q THEN
		T_ExchgParam.T_SafetyCtrl.xSetForceError:=TRUE;
		T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=TStation_Work_St1.TControl.diErrorNr;
	END_IF;
END_IF;

AxisError;

IF (T_ExchgParam.T_SafetyCtrl.xSetForceError AND NOT(T_ExchgParam.T_SafetyCtrl.xResetErrorWarning)) OR xSetError THEN
	CASE iStepSetForceError OF
		1:	xSetError:=TRUE;
			T_VisuQVis.T_CtrleAction.xReset:=FALSE;
			T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
			FBErrorMessage(	diErrorNr:=T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr,
								T_ErrorList:=T_ErrorList);
			adiTmpErrorList:=T_NovRAM.T_Parameter.T_ErrorNrList.adiErrorListMachine;
			T_NovRAM.T_Parameter.T_ErrorNrList.adiErrorListMachine[1]:=T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr;
			FOR ii:=2 TO 20 DO
				T_NovRAM.T_Parameter.T_ErrorNrList.adiErrorListMachine[ii]:=adiTmpErrorList[ii-1];
			END_FOR;
			iStepSetForceError:=iStepSetForceError + 1;
		2:	FBNT_GetTime(	NETID:= '',
							START:=FALSE );
			iStepSetForceError:=iStepSetForceError + 1;
		3:	FBNT_GetTime(	NETID:= '',
							START:= TRUE,
							TMOUT:= T#2s);
			IF NOT(FBNT_GetTime.BUSY) OR FBNT_GetTime.ERR THEN
				asTmpErrorList:=T_NovRAM.T_Parameter.T_ErrorNrList.asErrorTimeStampMachine;
				IF NOT(FBNT_GetTime.ERR) THEN
					T_NovRAM.T_Parameter.T_ErrorNrList.asErrorTimeStampMachine[1]:=Fct_ConvertDateToString(2,FBNT_GetTime.TIMESTR);
				ELSE
					T_NovRAM.T_Parameter.T_ErrorNrList.asErrorTimeStampMachine[1]:='00.00 00:00';	(* Fehler beim lesen der Systemzeit, daher wird ein default-Wert gesetzt *)
				END_IF;
				FOR ii:=2 TO 20 DO
					T_NovRAM.T_Parameter.T_ErrorNrList.asErrorTimeStampMachine[ii]:=asTmpErrorList[ii-1];
				END_FOR;
				iStepSetForceError:=iStepSetForceError + 1;
			END_IF;
		4:	IF NOT(T_VisuQVis.T_CtrleAction.xDone) AND NOT(T_VisuQVis.T_CtrleAction.xExecute) THEN
				T_VisuQVis.T_CtrleAction.xReset:=TRUE;
				iStepSetForceError:=iStepSetForceError + 1;
			END_IF;
			IF T_VisuQVis.T_CtrleAction.xDone AND NOT(T_VisuQVis.T_CtrleAction.xExecute) THEN
				iStepSetForceError:=iStepSetForceError + 1;
			END_IF;
		5:	IF T_VisuQVis.T_CtrleAction.xDone AND NOT(T_VisuQVis.T_CtrleAction.xReset) AND NOT(T_NovRAM.T_Ctrle.xExecute) AND T_NovRAM.T_Ctrle.xDone AND NOT(gxHardwareOFF) THEN
				T_NovRAM.T_Ctrle.xExecute:=TRUE;
				T_NovRAM.T_Ctrle.iFunction:=2;
				iStepSetForceError:=iStepSetForceError + 1;
			ELSE
				iStepSetForceError:=iStepSetForceError + 1;
			END_IF;
		6:	IF (NOT(T_NovRAM.T_Ctrle.xExecute) AND T_NovRAM.T_Ctrle.xDone) OR gxHardwareOFF THEN
				T_ExchgParam.T_SafetyCtrl.xUpdateErrorList:=TRUE;
				T_ExchgParam.T_Visu.T_Message.sDynamicTextEnglish:=FBErrorMessage.sErrorTextEnglish;
				T_ExchgParam.T_Visu.T_Message.sDynamicTextDeutsch:=FBErrorMessage.sErrorTextDeutsch;
				T_ExchgParam.T_Visu.T_Message.sDynamicTextFrancais:=FBErrorMessage.sErrorTextFrancais;
				iStepSetForceError:=iStepSetForceError + 1;
			END_IF;
		7:	IF (NOT(T_NovRAM.T_Ctrle.xExecute) AND T_NovRAM.T_Ctrle.xDone) OR gxHardwareOFF THEN
				iStepSetForceError:=1;
				T_ExchgParam.T_SafetyCtrl.xSetForceError:=FALSE;
				xSetError:=FALSE;
			END_IF;
	END_CASE;
ELSE
	iStepSetForceError:=1;
END_IF;

(* Monitor dynamic text *)
	IF (T_ExchgParam.T_Visu.T_Message.sDynamicTextEnglish <> '')
			AND (T_ExchgParam.T_Visu.T_Message.iState <> 401) THEN
		T_ExchgParam.T_Visu.T_Message.iState:=401;
	END_IF

(* Quittieren der Fehler/Warnung *)
FBResetError(	xExecute:=xExecuteResetError);
IF T_ExchgParam.T_SafetyCtrl.xResetErrorWarning THEN
	T_ExchgParam.T_SafetyCtrl.xSetForceError:=FALSE;
	CASE iStepResetError OF
		1:	xExecuteResetError:=TRUE;
			iStepResetError:=iStepResetError + 1;
		2:	IF NOT(xExecuteResetError) AND FBResetError.xDone THEN
				T_ExchgParam.T_Visu.T_Message.iState:=0;	(* Meldung löschen *)
				T_ExchgParam.T_Visu.T_Message.sDynamicTextEnglish:='';
				T_ExchgParam.T_Visu.T_Message.sDynamicTextDeutsch:='';
				T_ExchgParam.T_Visu.T_Message.sDynamicTextFrancais:='';
				T_ExchgParam.T_SafetyCtrl.xResetErrorWarning:=FALSE;
				iStepResetError:=1;
			END_IF;
	END_CASE;
ELSE
	iStepResetError:=1;
END_IF;

(* Visualisieren der Fehlermeldungen *)
RisingEdgeUpdateErrorList(CLK:=		(T_VisuQVis.T_PlcParam.dwActualPage = gT_PageNumber.iAutoMode_ErrorList) OR
								  	(T_VisuQVis.T_PlcParam.dwActualPage = gT_PageNumber.iHandMode_ErrorList) OR
								     	(T_VisuQVis.T_PlcParam.dwActualPage = gT_PageNumber.iWorkStation_ErrorList));
IF RisingEdgeUpdateErrorList.Q OR T_ExchgParam.T_SafetyCtrl.xUpdateErrorList THEN
	T_ExchgParam.T_SafetyCtrl.xUpdateErrorList:=FALSE;
	FOR ii:=1 TO 20 DO
		diErrorNr:=T_NovRAM.T_Parameter.T_ErrorNrList.adiErrorListMachine[ii];
		sErrorTimeStamp:=T_NovRAM.T_Parameter.T_ErrorNrList.asErrorTimeStampMachine[ii];
		sErrorTimeStamp:=CONCAT(sErrorTimeStamp,'--');
		IF (T_NovRAM.T_Parameter.T_ErrorNrList.asErrorTimeStampMachine[ii] <> '') THEN
			FBErrorMessageVisu(	diErrorNr:=diErrorNr ,
									T_ErrorList:=T_ErrorList);
			T_ExchgParam.T_Visu.T_MsgErrorEnglish.asMsgErrorList[ii]:=CONCAT(sErrorTimeStamp,FBErrorMessageVisu.sErrorTextEnglish);
			T_ExchgParam.T_Visu.T_MsgErrorDeutsch.asMsgErrorList[ii]:=CONCAT(sErrorTimeStamp,FBErrorMessageVisu.sErrorTextDeutsch);
		ELSE
			T_ExchgParam.T_Visu.T_MsgErrorEnglish.asMsgErrorList[ii]:='';
			T_ExchgParam.T_Visu.T_MsgErrorDeutsch.asMsgErrorList[ii]:='';
		END_IF;
	END_FOR;
END_IF;
END_PROGRAM
ACTION	AxisError:
xNoProcessStationActive_St1St2:=	TProcess.T_Ctrle.xDone AND
									TStation_Work_St1.TControl.xDone AND
									(T_ExchgParam.T_Visu.T_Message.iState <> 228) AND (T_ExchgParam.T_Visu.T_Message.iState <> 229) AND (T_ExchgParam.T_Visu.T_Message.iState <> 279);
IF xNoProcessStationActive_St1St2 AND T_StartUp.T_State.xCompleted THEN
	IF RisingEdge_Station1_Axis1Error.Q THEN
		xCheckAxisError_Z_St1:=TRUE;
	END_IF;
	IF RisingEdge_Station1_Axis2Error.Q THEN
		xCheckAxisError_S_St1:=TRUE;
	END_IF;
	IF RisingEdge_Station1_Axis3Error.Q THEN
		xCheckAxisError_O_St1:=TRUE;
	END_IF;
	IF RisingEdge_Station2_Axis1Error.Q THEN
		xCheckAxisError_Z_St2:=TRUE;
	END_IF;
	IF RisingEdge_Station2_Axis2Error.Q THEN
		xCheckAxisError_S_St2:=TRUE;
	END_IF;
	IF RisingEdge_Station2_Axis3Error.Q THEN
		xCheckAxisError_O_St2:=TRUE;
	END_IF;
	IF RisingEdge_Station5_Axis1Error.Q THEN
		xCheckAxisError_C_St1:=TRUE;
	END_IF;
	TONWaitCheckError_Z_St1(IN:=xCheckAxisError_Z_St1,PT:=T#100ms);
	TONWaitCheckError_Z_St2(IN:=xCheckAxisError_Z_St2,PT:=T#100ms);
	TONWaitCheckError_S_St1(IN:=xCheckAxisError_S_St1,PT:=T#100ms);
	TONWaitCheckError_S_St2(IN:=xCheckAxisError_S_St2,PT:=T#100ms);
	TONWaitCheckError_O_St1(IN:=xCheckAxisError_O_St1,PT:=T#100ms);
	TONWaitCheckError_O_St2(IN:=xCheckAxisError_O_St2,PT:=T#100ms);
	TONWaitCheckError_C_St1(IN:=xCheckAxisError_C_St1,PT:=T#100ms);
	(* Kein Prozess und keine Station ist Aktiv, daher Eigenüberwachung der Achsen-->Überwachung nur wenn Maschine aufgestartet ist *)
	IF NOT(T_TwinSafe_Status_Z_Axis_St1.xError) AND TONWaitCheckError_Z_St1.Q AND (TStation_Work_St1.THWWorkStation.TAxisZ.T_CtrleSingle.udiErrorID <> 0) THEN
		T_ExchgParam.T_SafetyCtrl.xSetForceError:=TRUE;
		T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=20000000 + TStation_Work_St1.THWWorkStation.TAxisZ.T_CtrleSingle.udiErrorID;
	END_IF;
	IF RisingEdge_Station1_Axis2Error.Q THEN
		T_ExchgParam.T_SafetyCtrl.xSetForceError:=TRUE;
		udi_TmpErrorNr:=	udiFct_FormatNumber(	udiNumber:=	TStation_Work_St1.THWWorkStation.TAxisS.T_CtrleSingle.udiErrorID,
													iNumberLength:=6);
		T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=24000000 + udi_TmpErrorNr;
	END_IF;
	IF TONWaitCheckError_Z_St1.Q THEN
		xCheckAxisError_Z_St1:=FALSE;
	END_IF;
	IF TONWaitCheckError_S_St1.Q THEN
		xCheckAxisError_S_St1:=FALSE;
	END_IF;
END_IF;
END_ACTION




(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_STARTUP
VAR
	xPLCWait: BOOL := TRUE;
	TONPLCWait: TON;
	FBInitErrorList:FB_InitErrorList;
	RisingEdgeExecute:R_TRIG;
	iStepFunction: INT;
	xInitVisu: BOOL;
	tTimeOutFunction: TIME;
	xLoading: BOOL;
	TONStartUp: TON;
	xEmergency: BOOL;
	xStartBooting: BOOL;
	xNoAirPressure: BOOL;
	xReadHardware: BOOL;
	xActiveErrorMsg: BOOL;
	iMsgNumber: INT;
	xActiveInfoMsg: BOOL;
	TimerFunction: TON;
	xNovRamParameterReaded: BOOL;
	xTmp: BOOL;
	TONWaitResetOutput: TON;
	RisingEdgeStartButton: R_TRIG;
	RisingEdgeQuitButton: R_TRIG;
	xDeleteErrorMessage: BOOL;
	TONWaitCircuitOn: TON;
	xMsgActiveDeactivatedSupply: BOOL;
	xStationErrorActive: BOOL;
	tTimeStartUp: TIME := T#40ms;
	xActiveBootingError: BOOL;
	xForceCloseMessage: BOOL;
	xActiveWarningMsg: BOOL;
	xSetOutputDisable: BOOL;
	iStepFunctionMsg: INT;
	xActiveInfoMsgIntern: BOOL;
	xActiveErrorMsgIntern: BOOL;
	xActiveWarningMsgIntern: BOOL;
	TONWaitMessage: TON;
	iStepFunctionON: INT;
	TONWaitSetSecStateON: TON;
	xSwitchOffStartUpFunction: BOOL;
	xMachineActivated: BOOL;
	iStepUPS: INT;
	xFallingEdgeEnergyOff:BOOL;
	xRisingEdgeEnergyOn:BOOL;
	TONWaitEndMessage: TON;
	RisingEdgePower_SetupA_St1: R_TRIG;
	FallingEdgePower_SetupA_St1: F_TRIG;
	RisingEdgePower_SetupB_St1: R_TRIG;
	FallingEdgePower_SetupB_St1: F_TRIG;
	FBSafetyLogic: FB_SAFETYLOGIC;
	ptrTCommonAxis : POINTER TO ST_AXIS;
	xInitPointer: BOOL;
	FBCheckMachineState: FB_CHECKMACHINESTATE;
	iStepCheckSafetyError: INT;
	xTwinSAFEError: BOOL;
	xCheckConfirm: BOOL;
	xTerminalError: BOOL;
	RisingEdgePower_NormalOperate_St1St2: R_TRIG;
	FallingEdgePower_NormalOperate_St1St2: F_TRIG;
	FBGetAdaptersInfo: FB_GetAdaptersInfo;
	ii: INT;
	xReadyToCheckSafety: BOOL;
	xFirstBooting: BOOL;
	fbNT_Shutdown: NT_Shutdown;
	FBBIOSPARAMETER: FB_BIOSPARAMETER;
	xNovRamError: BOOL;
	RisingEdgeOpenSecDoorMachine: R_TRIG;
	RisingEdgeCloseSecDoorMachine: R_TRIG;
	xOpenSecurityDoor: BOOL;
	xCloseSecurityDoor: BOOL;
	iStepOpenSecurityDoor: INT;
	TONWaitSecurityDoorLocked: TON;
	iStepCloseSecurityDoor: INT;
	xReadySetMessageDeactivate: BOOL;
	xReadySetMessageActivate: BOOL;
	TONWaitCheckAirPressure: TON;
	RisingEdgeUPS: R_TRIG;
	TONPrellen_ON: TON;
	TONPrellen_OFF: TON;
	xCabinDoorLocked: BOOL;
	xInitMachineLamp: BOOL;
	RisingEdgeFirstTime: R_TRIG;
	RisingEdgeSetupOperateMode: R_TRIG;
	xInit: BOOL;
	TPEnablingSwitch: TP;
	RisingEdgeCheckSwitchVibration: R_TRIG;
	TONWaitStopVibration: TON;
	wWCEPOS_State: WORD;
	wEtherCAT_2_State: WORD;
	xActivateEPOSPreOPMode: BOOL;
	FBGetHostName: FB_GetHostName;
	FBGetLocalAmsNetId: FB_GetLocalAmsNetId;
	sCopyString: STRING;
	iPoint: INT;
	sCopyStringIP: STRING;

	T_TwinSafeInWithoutHW:POINTER TO	ST_TWINSAFE_IN;
	T_TwinSafeOutWithoutHW:	POINTER TO ST_TWINSAFE_OUT;

	(* .StartUpFunction_Booting *)
	TONWaitMessage1: TON;		(* IGS *)
END_VAR
(* @END_DECLARATION := '0' *)
(****************************************************************************************************************************************************)
(**********      This Functionblock manage the booting of the machine and the security mangament of the machine during   ********)
(**********       the machine operating                           														    ************)
(****************************************************************************************************************************************************)
(* waiting 5 sec before starting *)
	IF xPLCWait THEN
		TONPLCWait(IN:=TRUE,PT:=T#5s);
		IF TONPLCWait.Q THEN
			TONPLCWait(IN:=FALSE);
			xPLCWait:=FALSE;
			T_StartUp.T_Ctrle.xExecute:=FALSE;
			T_StartUp.T_Ctrle.xDone:=FALSE;
			T_StartUp.T_Ctrle.xErr:=FALSE;
			T_StartUp.T_Ctrle.xReset:=FALSE;
			T_StartUp.T_State.xPLCReady:=FALSE;
			T_StartUp.T_Ctrle.iFunction:=0;
			T_StartUp.T_Ctrle.udiErrorID:=16#0;
			T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;
			T_StartUp.T_Ctrle.iMsgNumber:=0;
			(* activ function "Start PLC" *)
			T_StartUp.T_Ctrle.xExecute:=TRUE;
			T_StartUp.T_Ctrle.iFunction:=1;
			FBInitErrorList(T_ErrorList:= T_ErrorList);	(* Init Static Text for Error List *)
		END_IF;
		RETURN;
	END_IF;
	(* Start and Quit Button *)
	RisingEdgeStartButton(CLK:=IxStartButton);
	RisingEdgeQuitButton(CLK:=IxReleaseButton);
	(* IN<-->OUT --> für TwinSAFE Verbindung mit Standard IO zu Sicherheit IO *)
	TPEnablingSwitch(IN:=	T_TwinSafeIn.IxEnablingSwitchActiveCh1 AND T_TwinSafeIn.IxEnablingSwitchActiveCh2 AND
							(NOT(FBSafetyLogic.xMachineDoorClose)) AND T_StartUp.T_State.xCompleted, PT:=T#0.1s);
	QxTwinSafeReleaseButton:=(IxReleaseButton OR TPEnablingSwitch.Q) ;	(* Übergabe des IxReleaseButton an TwinSafe Logik *)
	CtrlPowerSupply;
	CtrlEmergency;
	CtrlSecurityDoor;
	CtrlSecurityState;
	CtrlBIOSParameter;
	CtrlMachineLamp;
	CtrlStartUpFunction;

	IF NOT(xEmergency) AND NOT(xNoAirPressure) AND NOT(xTerminalError) THEN
		StartUpFunction_Initialisation;
		StartUpFunction_ReadHW;
		StartUpFunction_Booting;
		StartUpFunction_Loading;
	END_IF;

	StartUpFunction_MessageActivate;
	StartUpFunction_Emergency;

(* Delete of the line error message *)
	IF xDeleteErrorMessage THEN
		xDeleteErrorMessage:=FALSE;
		T_ExchgParam.T_Visu.T_Message.sDynamicTextEnglish:='';
		T_ExchgParam.T_Visu.T_Message.sDynamicTextDeutsch:='';
		T_ExchgParam.T_Visu.T_Message.sDynamicTextFrancais:='';
		T_ExchgParam.T_Visu.T_Message.iState:=0;	(* Meldung löschen *)
	END_IF;

(* Set Output disabled *)
	IF xSetOutputDisable THEN
		T_TwinSafeCtrleOUT.xTwinSAFE_Run_1:=FALSE;	(* Stop TwinSafe Groupe *)
		TProcess.T_Ctrle.xEnable:=FALSE;
		QxCtrlLampStartButton:=FALSE;
		QxCtrlLampStopButton:=FALSE;
		QxCtrlLampReleaseButton:=FALSE;
		QxCtrlLampAxesCurrentOff:=FALSE;
		QxReadyToOperateMasterModul1:=FALSE;
		QxReadyToOperateMasterModul2:=FALSE;
		TStation_Work_St1.TControl.xEnable:=FALSE;
		T_ExchgParam.T_Visu.iLoadingStartPage:=1;
		(* confirm *)
		xSetOutputDisable:=FALSE;
	END_IF;

	IF NOT(gxBlockChangeMovementVisuActiveMessage) AND NOT(xEmergency) AND NOT(xNoAirPressure) AND NOT(xTerminalError) AND NOT(xActiveInfoMsg) AND NOT(xActiveInfoMsgIntern)
	AND NOT(xActiveErrorMsg) AND NOT(xActiveErrorMsgIntern) AND NOT(xActiveWarningMsg) AND NOT(xActiveWarningMsgIntern) AND NOT(xPLCWait) AND T_StartUp.T_State.xCompleted THEN
		T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
	END_IF;

	IF gxHardwareOFF AND NOT(xInit) THEN
		xInit:=TRUE;

		T_TwinSafeInWithoutHW:=ADR(T_TwinSafeIn);
		T_TwinSafeOutWithoutHW:=ADR(T_TwinSafeOut);
		T_TwinSafeInWithoutHW^.IxAxesCurrentOffCh1:=TRUE;
		T_TwinSafeInWithoutHW^.IxAxesCurrentOffCh2:=TRUE;
		T_TwinSafeInWithoutHW^.IxCabinDoorClose:=TRUE;
		T_TwinSafeInWithoutHW^.IxCabinDoorCloseCh1:=TRUE;
		T_TwinSafeInWithoutHW^.IxCabinDoorCloseCh2:=TRUE;
		T_TwinSafeInWithoutHW^.IxEmergencyStopButtonCh1:=TRUE;
		T_TwinSafeInWithoutHW^.IxEmergencyStopButtonCh2:=TRUE;
		T_TwinSafeInWithoutHW^.IxReadyToOperateMasterModul1:=TRUE;
		T_TwinSafeInWithoutHW^.IxReadyToOperateMasterModul2:=TRUE;
		T_TwinSafeOutWithoutHW^.QxContactor24VCh1:=TRUE;
		T_TwinSafeOutWithoutHW^.QxContactor24VCh2:=TRUE;
		T_TwinSafeOutWithoutHW^.QxContactorMasterModul400VCh1:=TRUE;
		T_TwinSafeOutWithoutHW^.QxContactorMasterModul400VCh2:=TRUE;
		T_TwinSafeOutWithoutHW^.QxEnablingAxisSpindle_St1:=TRUE;
		T_TwinSafeOutWithoutHW^.QxEnablingSwitchLed:=TRUE;

		T_NovRam.T_Parameter.T_StationWork[gciStationSt1].T_AxisState.xReferencedZAxis:=TRUE;

	END_IF;
END_PROGRAM
ACTION	CtrlBIOSParameter:
	IF T_StartUp.T_State.xPLCReady THEN
		xTmp:=	T_TwinSafeOut.QxContactorMasterModul400VCh1 AND T_TwinSafeOut.QxContactorMasterModul400VCh2 AND
				T_TwinSafeOut.QxContactor24VCh1;
		FBBIOSPARAMETER(	dwBIOSPasswordPage:= gT_PageNumber.iBIOS_Page1,
							dwBIOSParameterPage:= gT_PageNumber.iBIOS_Page2,
							xActiveCurrentAxes:=xTmp,
							xReadyToSwitchPasswordPage:=xStartBooting AND (iStepFunction <= 40) AND T_TwinSafeIn.IxEmergencyStopButtonCh1 AND T_TwinSafeIn.IxEmergencyStopButtonCh2,
							T_Visu:= T_VisuQVis,
							T_ExchgParam:=T_ExchgParam,
							T_HDD:= T_HDD,
							T_NovRam:= T_NovRam,
							T_CtrlePanel:= T_CtrlePanel);
	END_IF;
END_ACTION

ACTION	CtrlEmergency:
(* check the emergency stop, the air pressure, Lightbus of the MasterAxis after booting the machine *)

	IF T_StartUp.T_State.xPLCReady AND NOT(gxHardwareOFF) THEN
	(* check emergency stop, only if it is not already in this state *)
		IF NOT(T_TwinSafeIn.IxEmergencyStopButtonCh1) OR NOT(T_TwinSafeIn.IxEmergencyStopButtonCh2) THEN
			RisingEdgeExecute(CLK:=FALSE);
			(* Set emergency function *)
			T_StartUp.T_Ctrle.xExecute:=TRUE;
			T_StartUp.T_Ctrle.iFunction:=4;
			xSwitchOffStartUpFunction:=TRUE;
		END_IF;

	(* check air pressure, only if it is not already in this state *)
		IF NOT(IxAirSupply) AND T_TwinSafeOut.QxContactor24VCh1 AND T_TwinSafeOut.QxContactor24VCh2 THEN
			TONWaitCheckAirPressure(IN:=T_TwinSafeOut.QxContactor24VCh1 AND T_TwinSafeOut.QxContactor24VCh2,PT:=T#2s);
			IF TONWaitCheckAirPressure.Q THEN
				TONWaitCheckAirPressure(IN:=FALSE);
				(* Set No Air pressure function *)
				T_StartUp.T_Ctrle.xExecute:=TRUE;
				T_StartUp.T_Ctrle.iFunction:=6;
				xSwitchOffStartUpFunction:=TRUE;
			END_IF;
		ELSE
			TONWaitCheckAirPressure(IN:=FALSE);
		END_IF;

		IF xActivateEPOSPreOPMode THEN
			wWCEPOS_State:=8;
			wEtherCAT_2_State:=0;
		ELSE
			wWCEPOS_State:=T_TerminalState.wWCEPOS_State;
			wEtherCAT_2_State:=T_TerminalState.wEtherCAT_2_State;
		END_IF;
	(* Beckhoff Klemmen oder Koppler Überprüfung oder Power Supply 24V *)
		IF NOT(gxHardwareOFF) THEN
			xTmp:=	(T_TerminalState.wEtherCAT_1_State <> 0) OR (wEtherCAT_2_State <> 0) OR (T_TerminalState.wWCMasterAxisModul1_State <> 8) OR (T_TerminalState.wWCMasterAxisModul2_State <> 8)
					OR (wWCEPOS_State <> 8) OR (T_TerminalState.wWCSMCValve <> 8) OR NOT(IxFuse24VDC_OK);
		ELSE
			xTmp:=	FALSE;
		END_IF;
		IF xTmp THEN
			(* Set Terminal Error *)
			T_StartUp.T_Ctrle.xExecute:=TRUE;
			T_StartUp.T_Ctrle.iFunction:=3;
			xSwitchOffStartUpFunction:=TRUE;
		END_IF;

	(* Disable the active StartUp Function *)
		IF xSwitchOffStartUpFunction THEN
			xSwitchOffStartUpFunction:=FALSE;
			xInitVisu:=FALSE;
			xLoading:=FALSE;
			xStartBooting:=FALSE;
			xActiveErrorMsg:=FALSE;
			xActiveInfoMsg:=FALSE;
			xActiveWarningMsg:=FALSE;
			xNoAirPressure:=FALSE;
			xReadHardware:=FALSE;
			xTerminalError:=FALSE;
			T_StartUp.T_State.xCompleted:=FALSE;
		END_IF;
	END_IF;
END_ACTION

ACTION	CtrlMachineLamp:
IF NOT(xInitMachineLamp) THEN
	xInitMachineLamp:=TRUE;
	TMachineLamp.T_CtrleCyl.xFBActiv:=TRUE;
	TMachineLamp.T_Config.xActivState:=TRUE;
	TMachineLamp.T_CtrleCyl.xReset:=TRUE;
END_IF;
RisingEdgeFirstTime(CLK:=T_StartUp.T_State.xPLCReady);
IF RisingEdgeFirstTime.Q OR RisingEdgeSetupOperateMode.Q THEN
	(* Einschalten der Einrichtlampe, nachdem die Maschine eingeschaltet wurde *)
	TMachineLamp.T_CtrleCyl.iFunction:=2;
	TMachineLamp.T_CtrleCyl.xExecute:=TRUE;
END_IF;
IF NOT(T_StartUp.T_State.xCompleted) AND T_StartUp.T_State.xPLCReady THEN
	(* Sollte z.B. wegen dem Not Aus die StartSeite wieder erreicht werden, dann muss die Lampe falls sie ausgeschaltet ist wieder eingeschaltet werden *)
	IF NOT(TMachineLamp.T_CtrleCyl.T_Standard.xActivOn) AND NOT(TMachineLamp.T_CtrleCyl.xExecute) AND TMachineLamp.T_CtrleCyl.xDone THEN
		TMachineLamp.T_CtrleCyl.iFunction:=2;
		TMachineLamp.T_CtrleCyl.xExecute:=TRUE;
	END_IF;
END_IF;
END_ACTION

ACTION	CtrlPowerSupply:
RisingEdgeUPS(CLK:=TStatusUPS.ePowerStatus = PowerOnBattery);
IF RisingEdgeUPS.Q OR T_ExchgParam.xShutdownSystem THEN
	CASE iStepUPS OF
	1:	T_CtrleUPS.xBlockSystem_PowerFail:=TRUE;	(* Schicht 5 wird gesperrt *)
		T_TwinSafeCtrleOUT.xTwinSAFE_Run_1:=FALSE;	(* Stop TwinSafe Groupe 1 *)
		TProcess.T_Ctrle.xEnable:=FALSE;
		TStation_Work_St1.TControl.xEnable:=FALSE;
		xSwitchOffStartUpFunction:=FALSE;
		xInitVisu:=FALSE;
		xLoading:=FALSE;
		xStartBooting:=FALSE;
		xActiveErrorMsg:=FALSE;
		xActiveInfoMsg:=FALSE;
		xActiveWarningMsg:=FALSE;
		xNoAirPressure:=FALSE;
		xTerminalError:=FALSE;
		xReadHardware:=FALSE;
		T_StartUp.T_State.xCompleted:=FALSE;
		xActiveErrorMsgIntern:=TRUE;
		iStepFunctionMsg:=1;
		IF RisingEdgeUPS.Q THEN
			iMsgNumber:=51;		(* Stromausfall Detektiert! Daten werden im NovRAM gespeichert!! Steuerung ist blockiert! *)
		ELSIF T_ExchgParam.xShutdownSystem THEN
			iMsgNumber:=47;		(* System wird heruntergefahren! Daten werden im NovRAM gespeichert!! Steuerung ist blockiert! *)
		END_IF;
		IF xMachineActivated THEN
			iStepUPS:=iStepUPS + 1;
		ELSE
			fbNT_Shutdown(	NETID:= '127.0.0.1.1.1',
							DELAY:= 1,
							START:= FALSE,
							TMOUT:= T#10s);
			iStepUPS:=4;
		END_IF;
	(* NovRAM speichern *)
	2:	IF NOT(T_NovRAM.T_Ctrle.xExecute) AND (T_NovRAM.T_Ctrle.xDone OR T_NovRAM.T_Ctrle.xErr) THEN
			T_NovRAM.T_Ctrle.xExecute:=TRUE;
			T_NovRAM.T_Ctrle.iFunction:=2;
			iStepUPS:=iStepUPS + 1;
		END_IF;
	3:	IF NOT(T_NovRAM.T_Ctrle.xExecute) AND (T_NovRAM.T_Ctrle.xDone OR T_NovRAM.T_Ctrle.xErr) THEN
			iStepUPS:=iStepUPS + 1;
			fbNT_Shutdown(	NETID:= '127.0.0.1.1.1',
							DELAY:= 1,
							START:= FALSE,
							TMOUT:= T#10s);
		END_IF;
	4:	IF NOT(T_NovRAM.T_Ctrle.xExecute) AND (T_NovRAM.T_Ctrle.xDone OR T_NovRAM.T_Ctrle.xErr) THEN
			fbNT_Shutdown(	NETID:='127.0.0.1.1.1',
							DELAY:= 1,
							START:= TRUE,
							TMOUT:= T#10s);
			IF NOT(fbNT_Shutdown.BUSY) OR fbNT_Shutdown.ERR OR T_ExchgParam.xShutdownSystem THEN
				iStepUPS:=99;	(* CPU kann nun heruntergefahren werden *)
			END_IF;
		END_IF;
	END_CASE;
ELSE
	iStepUPS:=1;
END_IF;

END_ACTION

ACTION	CtrlSecurityDoor:
RisingEdgeOpenSecDoorMachine(CLK:=T_ExchgParam.T_SafetyCtrl.xOpenSecurityDoorMachine);
RisingEdgeCloseSecDoorMachine(CLK:=T_ExchgParam.T_SafetyCtrl.xCloseSecurityDoorMachine);
IF RisingEdgeOpenSecDoorMachine.Q THEN
	xOpenSecurityDoor:=TRUE;
	xCloseSecurityDoor:=FALSE;
	T_ExchgParam.T_SafetyCtrl.xCloseSecurityDoorMachine:=FALSE;
END_IF;
IF RisingEdgeCloseSecDoorMachine.Q THEN
	xOpenSecurityDoor:=FALSE;
	xCloseSecurityDoor:=TRUE;
	T_ExchgParam.T_SafetyCtrl.xOpenSecurityDoorMachine:=FALSE;
END_IF;
TONPrellen_ON(IN:=IxCabinDoorLocked,PT:=T#50ms);
TONPrellen_OFF(IN:=NOT(IxCabinDoorLocked),PT:=T#50ms);
IF TONPrellen_ON.Q THEN
	xCabinDoorLocked:=TRUE;
END_IF;
IF TONPrellen_OFF.Q THEN
	xCabinDoorLocked:=FALSE;
END_IF;
IF xOpenSecurityDoor THEN
	CASE iStepOpenSecurityDoor OF
		1:	IF QxCabinDoorLock THEN
				xReadySetMessageDeactivate:=TRUE;
			END_IF;
			QxCabinDoorLock:=FALSE;
			TONWaitSecurityDoorLocked(IN:=FALSE);
			(* next step *)
			iStepOpenSecurityDoor:=iStepOpenSecurityDoor + 1;
		2:	TONWaitSecurityDoorLocked(IN:=TRUE,PT:=T#2000ms);
			IF TONWaitSecurityDoorLocked.Q OR (xCabinDoorLocked) THEN
				TONWaitSecurityDoorLocked(IN:=FALSE);
				(* next step *)
				iStepOpenSecurityDoor:=iStepOpenSecurityDoor + 1;
			END_IF;
		3:	xOpenSecurityDoor:=FALSE;
			T_ExchgParam.T_SafetyCtrl.xOpenSecurityDoorMachine:=FALSE;
			IF NOT(xCabinDoorLocked) THEN	(* IxCabinDoorUpLocked, Check if CabinDoor of the Machine is no more blocked *)
				T_ExchgParam.T_Visu.T_Message.iState:=287;	(* Kabinen-Türe Zuhaltung fehlerhaft beim öffnen ! *)
				xReadySetMessageDeactivate:=FALSE;
			END_IF;
			IF xReadySetMessageDeactivate THEN
				T_ExchgParam.T_Visu.T_Message.iState:=281;	(* Die Zuhaltung der Sicherheitstüren wurde deaktiviert! *)
			END_IF;
	END_CASE;
ELSE
	xReadySetMessageDeactivate:=FALSE;
	iStepOpenSecurityDoor:=1;
END_IF;
IF xCloseSecurityDoor THEN
	CASE iStepCloseSecurityDoor OF
		1:	IF NOT(QxCabinDoorLock) THEN
				xReadySetMessageActivate:=TRUE;
			END_IF;
			QxCabinDoorLock:=TRUE;
			TONWaitSecurityDoorLocked(IN:=FALSE);
			(* next step *)
			iStepCloseSecurityDoor:=iStepCloseSecurityDoor + 1;
		2:	TONWaitSecurityDoorLocked(IN:=TRUE,PT:=T#2000ms);
			IF TONWaitSecurityDoorLocked.Q OR NOT(xCabinDoorLocked) THEN
				TONWaitSecurityDoorLocked(IN:=FALSE);
				(* next step *)
				iStepCloseSecurityDoor:=iStepCloseSecurityDoor + 1;
			END_IF;
		3:	xCloseSecurityDoor:=FALSE;
			T_ExchgParam.T_SafetyCtrl.xCloseSecurityDoorMachine:=FALSE;
			IF xCabinDoorLocked THEN	(* IxCabinDoorUpLocked, Check if CabinDoor of the Machine is blocked *)
				T_ExchgParam.T_Visu.T_Message.iState:=286;	(* Kabinen-Türe Zuhaltung fehlerhaft beim schliessen ! *)
				xReadySetMessageActivate:=FALSE;
			END_IF;
			IF xReadySetMessageActivate THEN
				T_ExchgParam.T_Visu.T_Message.iState:=280;	(* Die Zuhaltung der Sicherheitstüren wurde aktiviert! *)
			END_IF;
	END_CASE;
ELSE
	xReadySetMessageActivate:=FALSE;
	iStepCloseSecurityDoor:=1;
END_IF;
END_ACTION

ACTION	CtrlSecurityState:
	IF NOT(xInitPointer) THEN
		xInitPointer:=TRUE;
		ptrTCommonAxis:=ADR(TStation_Work_St1.THWWorkStation.TAxisZ);
	END_IF;
(* Function for Switch on the Security State *)
	IF T_StartUp.T_Ctrle.xSetSecurityStateON THEN
		CASE iStepFunctionON OF
		1:	QxCtrlLampStartButton:=FALSE;
			QxCtrlLampStopButton:=FALSE;
			QxCtrlLampReleaseButton:=FALSE;
			QxCtrlLampAxesCurrentOff:=FALSE;
			TONWaitSetSecStateON(IN:=FALSE);
			iStepFunctionON:=2;
		2:	TONWaitSetSecStateON(IN:=TRUE,PT:=T#500ms);
			IF TONWaitSetSecStateON.Q THEN
				TONWaitSetSecStateON(IN:=FALSE);
				T_TwinSafeCtrleOUT.xTwinSAFE_Run_1:=FALSE;	(* Stop TwinSafe Groupe 1 *)
				iStepFunctionON:=3;
			END_IF;
		3:	TONWaitSetSecStateON(IN:=TRUE,PT:=T#500ms);
			IF TONWaitSetSecStateON.Q THEN
				TONWaitSetSecStateON(IN:=FALSE);
				iStepFunctionON:=4;
			END_IF;
		4:	T_TwinSafeCtrleOUT.xTwinSAFE_Run_1:=TRUE;	(* Start TwinSafe Groupe 1 *)
			T_StartUp.T_Ctrle.xSetSecurityStateON:=FALSE;
			TONWaitSetSecStateON(IN:=FALSE);
			iStepFunctionON:=1;
		END_CASE;
	ELSE
		iStepFunctionON:=1;
		TONWaitSetSecStateON(IN:=FALSE);
	END_IF;

(* Zustandsüberwachung und Zuordnung der Sicherheitssignale *)
FBSafetyLogic(	T_TwinSafeIn:=T_TwinSafeIn,
				T_TwinSafeOut:=T_TwinSafeOut,
				xActiveBooting:=xLoading,
				xActiveBootingError:=xActiveBootingError,
				xVisuFunctionActive:=(NOT(T_VisuQVis.T_CtrleAction.xDone) OR T_VisuQVis.T_CtrleAction.xFunctionActive),
				dwActualPage:= T_VisuQVis.T_PlcParam.dwActualPage,
				xOverlayMessageAcitve:=(T_ExchgParam.T_SafetyCtrl.bStateMessageError<>0) OR (T_ExchgParam.T_SafetyCtrl.bStateMessageInfo<>0) OR (T_ExchgParam.T_SafetyCtrl.bStateMessageWarning<>0),
				iStateMessage:=T_ExchgParam.T_Visu.T_Message.iState,
				TCommonAxis:=ptrTCommonAxis^);

IF gT_SafetyStatus.xSetupOperateModeActive THEN
	CASE T_ExchgParam.T_TeachIn.iSetup_AxisSel OF
	1:	ptrTCommonAxis:=ADR(TStation_Work_St1.THWWorkStation.TAxisZ);
	2,3:	ptrTCommonAxis:=ADR(TStation_Work_St1.THWWorkStation.TAxisS);
	ELSE
		ptrTCommonAxis:=ADR(TStation_Work_St1.THWWorkStation.TAxisZ);
	END_CASE
END_IF;

IF (T_ExchgParam.T_SafetyCtrl.bStateSafetyCtrl = 99) OR T_ExchgParam.T_Visu.T_Message.xShowMessageInfo OR
    T_ExchgParam.T_Visu.T_Message.xShowMessageInput OR T_ExchgParam.T_Visu.T_Message.xShowMessageWarning OR
    (T_ExchgParam.T_Visu.T_Message.iState = 401) THEN
	T_ExchgParam.T_SafetyCtrl.xHideSafetyCtrlMessage:=TRUE;	(* Sicherheitsstatusmeldung auf der Visualisierung unterdrücken *)
ELSE
	T_ExchgParam.T_SafetyCtrl.xHideSafetyCtrlMessage:=FALSE;
END_IF;

T_ExchgParam.T_SafetyCtrl.bStateSafetyCtrl:=FBSafetyLogic.bStateSafetyCtrl;		(* Ausgabe direkt an der Visualisierung um den Operator Mitteilen zu können, was er unternehmen muss damit er Prozess,Funktion usw. auslösen kann *)

(* Kontrollampe für Freigabe QxCtrlLampReleaseButton der Energieversorgung *)
IF NOT(T_ExchgParam.T_SafetyCtrl.xDeactivateLamp) THEN	(* Wenn Lampen Test Aktiv ist, dann muss dies gesperrt werden *)
	QxCtrlLampReleaseButton:=	NOT(gT_SafetyStatus.xEnergyONNormalMode OR gT_SafetyStatus.xEnergyONSetupModeASt1 OR
								gT_SafetyStatus.xEnergyONSetupModeBSt1) AND
								FBSafetyLogic.xSafetyNotActive AND T_TwinSafeCtrleOUT.xTwinSAFE_Run_1 AND T_StartUp.T_State.xPLCReady AND
								(gT_SafetyStatus.xSecurityDoorClose);
END_IF;

(* Check Power switch on/off from the security circuit for control the Station *)
	RisingEdgePower_NormalOperate_St1St2(CLK:=gT_SafetyStatus.xEnergyONNormalMode);
	FallingEdgePower_NormalOperate_St1St2(CLK:=gT_SafetyStatus.xEnergyONNormalMode);
	RisingEdgePower_SetupA_St1(CLK:=	gT_SafetyStatus.xEnergyONSetupModeASt1);
	FallingEdgePower_SetupA_St1(CLK:=gT_SafetyStatus.xEnergyONSetupModeASt1);
	RisingEdgePower_SetupB_St1(CLK:=gT_SafetyStatus.xEnergyONSetupModeBSt1);
	FallingEdgePower_SetupB_St1(CLK:=gT_SafetyStatus.xEnergyONSetupModeBSt1);

	IF T_StartUp.T_State.xCompleted THEN
		xTmp:=	RisingEdgePower_NormalOperate_St1St2.Q OR FallingEdgePower_NormalOperate_St1St2.Q OR
				RisingEdgePower_SetupA_St1.Q OR FallingEdgePower_SetupA_St1.Q OR
				RisingEdgePower_SetupB_St1.Q OR FallingEdgePower_SetupB_St1.Q;
		IF xTmp THEN
			TStation_Work_St1.TControl.xSecurityCircuitOn:=			RisingEdgePower_NormalOperate_St1St2.Q OR RisingEdgePower_SetupA_St1.Q OR RisingEdgePower_SetupB_St1.Q;
			TStation_Work_St1.TControl.xSecurityCircuitOff:=			FallingEdgePower_NormalOperate_St1St2.Q OR FallingEdgePower_SetupA_St1.Q OR FallingEdgePower_SetupB_St1.Q;
		END_IF;
	(* Message Energy on/off *)
		xRisingEdgeEnergyOn:=	RisingEdgePower_NormalOperate_St1St2.Q OR
								RisingEdgePower_SetupA_St1.Q OR RisingEdgePower_SetupB_St1.Q;

		xFallingEdgeEnergyOff:=	FallingEdgePower_NormalOperate_St1St2.Q OR
								FallingEdgePower_SetupA_St1.Q OR FallingEdgePower_SetupB_St1.Q;

		IF T_StartUp.T_State.xCompleted AND xFallingEdgeEnergyOff THEN
			IF (T_ExchgParam.T_Visu.T_Message.iState = 0) OR (T_ExchgParam.T_Visu.T_Message.iState = 228) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=229;	(* Warnung: Die Energieversorgung ist AUS ! *)
				TONWaitEndMessage(IN:=FALSE);
				T_ExchgParam.T_StationCommon.xBlockSelectAutoMode:=FALSE;
			END_IF;
		END_IF;
		IF T_StartUp.T_State.xCompleted AND xRisingEdgeEnergyOn THEN
			IF (T_ExchgParam.T_Visu.T_Message.iState = 0) OR (T_ExchgParam.T_Visu.T_Message.iState = 229) OR (T_ExchgParam.T_Visu.T_Message.iState = 279) THEN
				T_ExchgParam.T_Visu.T_Message.iState:=228;	(* Warnung: Die Energieversorgung ist EIN ! *)
				TONWaitEndMessage(IN:=FALSE);
			END_IF;
		END_IF;

	END_IF;

(* Überprüfe Maschinenstatus damit die entsprechende LED auf der Visu ausgegeben werden kann *)
FBCheckMachineState(	xSecurityKey:= gT_SafetyStatus.xSetupOperateModeActive,
						iSetupMode:= gT_SafetyStatus.iSetupMode,
						xNormalOperate_EnergyON:= gT_SafetyStatus.xEnergyONNormalMode,
						xSetupOperateA_EnergyON:= gT_SafetyStatus.xEnergyONSetupModeASt1,
						xSetupOperateB_EnergyON:= gT_SafetyStatus.xEnergyONSetupModeBSt1);
T_ExchgParam.T_SafetyCtrl.xNormalOperate_EnergyON:=	gT_SafetyStatus.xEnergyONNormalMode;
T_ExchgParam.T_SafetyCtrl.xSetupOperateA_EnergyON:=	gT_SafetyStatus.xEnergyONSetupModeASt1;
T_ExchgParam.T_SafetyCtrl.xSetupOperateB_EnergyON:=	gT_SafetyStatus.xEnergyONSetupModeBSt1;

(* Überwachung der Not Bremse für alle Achsen die am AX5206 angeschlossen sind beim ausschalten der Energieversorgung *)
	IF IxTwinSafeQuickStopMaster1_1 THEN	(* QuickStop Achsen von TwinSAFE *)
		QxEnableQuickStopMasterModul1:=TRUE;
	ELSE
		QxEnableQuickStopMasterModul1:=FALSE;	(* QxEnableQuickStopMasterModul1-->NotBremse aktivieren *)
	END_IF;
	IF IxTwinSafeQuickStopMaster2_1 OR IxTwinSafeQuickStopMaster2_2 THEN	(* QuickStop Achsen von TwinSAFE *)
		QxEnableQuickStopMasterModul2:=TRUE;
	ELSE
		QxEnableQuickStopMasterModul2:=FALSE;	(* QxEnableQuickStopMasterModul2-->NotBremse aktivieren *)
	END_IF;

(* Anzeigelampe für den EinrichtBetrieb *)
IF NOT(T_ExchgParam.T_SafetyCtrl.xDeactivateLamp) THEN	(* Wenn Lampen Test Aktiv ist, dann muss dies gesperrt werden *)
	IF gT_SafetyStatus.xSetupOperateModeActive AND T_StartUp.T_State.xCompleted THEN
		QxSetupModeLamp:=TRUE;
	ELSE
		QxSetupModeLamp:=FALSE;
	END_IF;
END_IF;

(* Anzeigelampe für AntriebSperrTaste *)
IF NOT(T_ExchgParam.T_SafetyCtrl.xDeactivateLamp) THEN	(* Wenn Lampen Test Aktiv ist, dann muss dies gesperrt werden *)
	IF T_TwinSafeIn.IxAxesCurrentOffCh1 AND T_TwinSafeIn.IxAxesCurrentOffCh2 THEN
		QxCtrlLampAxesCurrentOff:=FALSE;
	ELSE
		QxCtrlLampAxesCurrentOff:=TRUE;
	END_IF;
END_IF;

(* Überwachung ein TwinSAFE Fehler besteht *)
xTmp:=	(T_TwinSafeFBError.xMON_EmergencyButtonMachine OR				(* Diskrepanzfehler  Not Aus Taster Maschine *)
		T_TwinSafeFBError.xMON_Error_MachineDoor OR					(* Diskrepanzfehler Sicherheitstüre der Maschine *)
		T_TwinSafeFBError.xMON_KeySwitchProcObservation OR			(* Diskrepanzfehler Schlüsselschalter für Einrichtbetrieb Prozessbeobachtung Stellung I *)
		T_TwinSafeFBError.xMON_KeySwitchWorkStation OR				(* Diskrepanzfehler Schlüsselschalter für Einrichtbetrieb Bearbeitungsstation Stellung II *)
		T_TwinSafeFBError.xMON_EnablingSwitchActive OR					(* Diskrepanzfehler  Zustimmschalter *)
		T_TwinSafeFBError.xMON_AxesCurrentOff OR						(* Diskrepanzfehler Antriebsperrtaste *)
		T_TwinSafeFBError.xEDM_PowSup_MasterModul OR					(* Fehler im Rückführkreis der Leistungsschütze der  Z1 Achse (400V) *)
		T_TwinSafeFBError.xEDM_PowSup_24V OR							(* Fehler im Rückführkreis des Sicherheitsrelais für 24V Speisung *)
		((T_TwinSafeCtrleIN.xTwinSAFE_Group_OUT_Error_1 OR
		T_TwinSafeCtrleIN.xTwinSAFE_Group_FB_Error_1 OR
		T_TwinSafeCtrleIN.xTwinSAFE_Group_COM_Error_1) AND NOT(xStartBooting) AND NOT(xInitVisu) AND NOT(xReadHardware))) AND
		T_TwinSafeCtrleOUT.xTwinSAFE_Run_1 AND xReadyToCheckSafety;


IF (xTmp OR xTwinSAFEError) AND xNovRamParameterReaded THEN
	CASE iStepCheckSafetyError OF
	1:	xTwinSAFEError:=TRUE;
		T_VisuQVis.T_CtrleVisu.xReset:=TRUE;
		iStepCheckSafetyError:=iStepCheckSafetyError + 1;
		xSetOutputDisable:=TRUE;
	2:	IF NOT(T_VisuQVis.T_CtrleVisu.xReset) AND T_VisuQVis.T_CtrleVisu.xDone THEN
			IF T_TwinSafeFBError.xMON_EmergencyButtonMachine THEN
				iMsgNumber:=3;		(* Diskrepanzfehler zwischen den zweikanal. Schalter des Not Aus Taster der Maschine! Bitte Kontakt aufnehmen mit Microcut Ltd! *)
			ELSIF T_TwinSafeFBError.xMON_Error_MachineDoor THEN
				iMsgNumber:=4;		(* Diskrepanzfehler zwischen den zweikanal. Schalter der Sicherheitstüre der Maschine! Bitte Kontakt aufnehmen mit Microcut Ltd! *)
			ELSIF T_TwinSafeFBError.xMON_KeySwitchProcObservation THEN
				iMsgNumber:=5;		(* Diskrepanzfehler zwischen den zweikanal. Schalter des Schlüsselschalter Stellung I ! Bitte Kontakt aufnehmen mit Microcut Ltd! *)
			ELSIF T_TwinSafeFBError.xMON_KeySwitchWorkStation THEN
				iMsgNumber:=6;		(* Diskrepanzfehler zwischen den zweikanal. Schalter des Schlüsselschalter Stellung II ! Bitte Kontakt aufnehmen mit Microcut Ltd! *)
			ELSIF T_TwinSafeFBError.xMON_EnablingSwitchActive THEN
				iMsgNumber:=17;	(* Diskrepanzfehler zwischen den zweikanal. Schalter des Zustimmschalters! Bitte Kontakt aufnehmen mit Microcut Ltd! *)
			ELSIF T_TwinSafeFBError.xMON_AxesCurrentOff THEN
				iMsgNumber:=18;	(* Diskrepanzfehler zwischen den zweikanal. Schalter der AntriebSperrTaste! Bitte Kontakt aufnehmen mit Microcut Ltd! *)
			ELSIF T_TwinSafeFBError.xEDM_PowSup_MasterModul THEN
				iMsgNumber:=26;	(* Fehler im Rückführkreis des Schützes für Z1 Achse! Bitte Kontakt aufnehmen mit Microcut Ltd! *)
			ELSIF T_TwinSafeFBError.xEDM_PowSup_24V THEN
				iMsgNumber:=29;	(* Fehler im Rückführkreis des Sicherheitsrelais für Luftdruck und 24V Ausgänge Bitte Kontakt aufnehmen mit Microcut Ltd! *)
			ELSIF T_TwinSafeCtrleIN.xTwinSAFE_Group_OUT_Error_1 THEN
				iMsgNumber:=35;	(* TwinSAFE Sichere Ausgänge Fehlerhaft! Mindestens einen Sicheren Ausgang hat einen Fehler festgestellt! Bitte Kontakt aufnehmen mit Microcut Ltd! *)
			ELSIF T_TwinSafeCtrleIN.xTwinSAFE_Group_FB_Error_1 THEN
				iMsgNumber:=36;	(* TwinSAFE Funktionsbaustein Fehlerhaft! Mindestens ein Funktionsbaustein hat einen Fehler festgestellt! Bitte Kontakt aufnehmen mit Microcut Ltd! *)
			ELSIF T_TwinSafeCtrleIN.xTwinSAFE_Group_COM_Error_1 THEN
				iMsgNumber:=37;	(* TwinSAFE Sichere Verbindung Fehlerhaft! Mindestens eine Verbindung hat einen Fehler festgestellt! Bitte Kontakt aufnehmen mit Microcut Ltd! *)
			END_IF;
			(* Overlay Message Error *)
			xActiveErrorMsgIntern:=TRUE;
			iStepFunctionMsg:=1;
			iStepCheckSafetyError:=iStepCheckSafetyError + 1;
			TONWaitResetOutput(IN:=FALSE);
			xSwitchOffStartUpFunction:=FALSE;
			xLoading:=FALSE;
			xStartBooting:=FALSE;
			xActiveErrorMsg:=FALSE;
			xActiveInfoMsg:=FALSE;
			xActiveWarningMsg:=FALSE;
			xNoAirPressure:=FALSE;
			xTerminalError:=FALSE;
			T_StartUp.T_State.xCompleted:=FALSE;
			T_TwinSafeCtrleOUT.xTwinSAFE_Run_1:=TRUE;
		END_IF;
	3:	IF NOT(xActiveErrorMsgIntern) THEN
			iStepCheckSafetyError:=iStepCheckSafetyError + 1;
		END_IF;
	4:	TONWaitResetOutput(IN:=TRUE,PT:=T#0.2s);
		IF TONWaitResetOutput.Q THEN
			TONWaitResetOutput(IN:=FALSE);
			T_TwinSafeCtrleOUT.xTwinSAFE_Reset_1:=TRUE;
			iStepCheckSafetyError:=iStepCheckSafetyError + 1;
		END_IF;
	5:	TONWaitResetOutput(IN:=TRUE,PT:=T#0.2s);
		IF TONWaitResetOutput.Q THEN
			TONWaitResetOutput(IN:=FALSE);
			T_TwinSafeCtrleOUT.xTwinSAFE_Reset_1:=FALSE;
			iStepCheckSafetyError:=iStepCheckSafetyError + 1;
		END_IF;
	6:	IF NOT(xActiveErrorMsgIntern) THEN
			T_TwinSafeCtrleOUT.xTwinSAFE_Run_1:=FALSE;
			IF T_TwinSafeCtrleIN.xTwinSAFE_Group_OUT_Error_1 OR T_TwinSafeCtrleIN.xTwinSAFE_Group_FB_Error_1 OR T_TwinSafeCtrleIN.xTwinSAFE_Group_COM_Error_1 THEN
				iStepCheckSafetyError:=1;
				RETURN;
			END_IF;
			T_StartUp.T_Ctrle.xDone:=TRUE;
			T_StartUp.T_Ctrle.xErr:=FALSE;
			T_StartUp.T_Ctrle.udiErrorID:=0;
			(* Start Boot *)
			T_StartUp.T_Ctrle.xExecute:=TRUE;
			T_StartUp.T_Ctrle.iFunction:=5;
			xTwinSAFEError:=FALSE;
			iStepCheckSafetyError:=1;
		END_IF;
	END_CASE;
ELSE
	iStepCheckSafetyError:=1;
END_IF;

(* Vibrationssteuerung des Zustimmschalter *)
RisingEdgeCheckSwitchVibration(CLK:=T_TwinSafeOut.QxEnablingSwitchLed);
IF RisingEdgeCheckSwitchVibration.Q THEN
	QxEnablingSwitchVibration:=TRUE;
END_IF;
TONWaitStopVibration(IN:=QxEnablingSwitchVibration,PT:=T#0.5s);
IF TONWaitStopVibration.Q THEN
	QxEnablingSwitchVibration:=FALSE;
END_IF;
END_ACTION

ACTION	CtrlStartUpFunction:
(****************************************************************************************************************************************************)
(***********                                               start of the management for calling of the start up function                                                   ************)
(****************************************************************************************************************************************************)
(* execute *)
	RisingEdgeExecute(CLK:=T_StartUp.T_Ctrle.xExecute);
	T_StartUp.T_Ctrle.xExecute:=FALSE;
	IF RisingEdgeExecute.Q THEN
		T_StartUp.T_Ctrle.xExecute:=FALSE;
		CASE T_StartUp.T_Ctrle.iFunction OF
		(* Start PLC *)
		1:	xInitVisu:=TRUE;
			tTimeOutFunction:=T#2s;
		(* Start loading *)
		2:	xLoading:=TRUE;
			T_ExchgParam.T_Visu.iLoadingStartPage:=1;
			tTimeOutFunction:=T#60s;
			TONStartUp(IN:=FALSE);
		(* Terminal Error *)
		3:	xTerminalError:=TRUE;
			tTimeOutFunction:=T#0s;	(* No Time out *)
			T_StartUp.T_State.xPLCReady:=FALSE;
		(* Emergency *)
		4:	xEmergency:=TRUE;
			tTimeOutFunction:=T#0s;	(* No Time out *)
			T_StartUp.T_State.xPLCReady:=FALSE;
		(* Start Booting *)
		5:	xStartBooting:=TRUE;
			tTimeOutFunction:=T#0s;	(* No Time out *)
		(* No Air pressure *)
		6:	xNoAirPressure:=TRUE;
			tTimeOutFunction:=T#0s;	(* No Time out *)
			T_StartUp.T_State.xPLCReady:=FALSE;
		(* Read NovRAM Parameter *)
		8:	xReadHardware:=TRUE;
			tTimeOutFunction:=T#5s;
		(* Activate Error Message Overlay *)
		10:	xActiveErrorMsg:=TRUE;
			iMsgNumber:=T_StartUp.T_Ctrle.iMsgNumber;
			tTimeOutFunction:=T#0s;	(* No Time out *)
			T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;	(* Lock the navigation of the visu *)
		(* Acitvate Info Message Overlay *)
		11:	xActiveInfoMsg:=TRUE;
			iMsgNumber:=T_StartUp.T_Ctrle.iMsgNumber;
			tTimeOutFunction:=T#0s;	(* No Time out *)
			T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;	(* Lock the navigation of the visu *)
		(* Activate Warning Message Overlay *)
		12:	xActiveWarningMsg:=TRUE;
			iMsgNumber:=T_StartUp.T_Ctrle.iMsgNumber;
			tTimeOutFunction:=T#0s;	(* No Time out *)
			T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;	(* Lock the navigation of the visu *)
		ELSE
		(* function not implemented *)
			T_StartUp.T_Ctrle.xDone:=FALSE;
			T_StartUp.T_Ctrle.xErr:=TRUE;
			T_StartUp.T_Ctrle.udiErrorID:=16#F000;
			(* Exit FB *)
			RETURN;
		END_CASE
		(* Init. variable *)
		iStepFunction:=1;
		iStepFunctionMsg:=1;
		T_StartUp.T_Ctrle.xDone:=FALSE;
		T_StartUp.T_Ctrle.xErr:=FALSE;
		T_StartUp.T_Ctrle.udiErrorID:=0;
		TimerFunction(IN:=FALSE);
		xCheckConfirm:=FALSE;
	(* Exit FB *)
		RETURN;
	END_IF
(****************************************************************************************************************************************************)
(***********                                               end of the management for calling of the start up function                                                   ************)
(****************************************************************************************************************************************************)
(* Time out function *)
	IF tTimeOutFunction <> T#0s THEN TimerFunction(IN:=TRUE,PT:=tTimeOutFunction); ELSE TimerFunction(IN:=FALSE); END_IF
	IF TimerFunction.Q AND NOT T_StartUp.T_Ctrle.xDone AND NOT T_StartUp.T_Ctrle.xErr THEN
	(* Error, timeout action activ *)
		T_StartUp.T_Ctrle.xErr:=TRUE;
		(* Display error message *)
		IF xInitVisu THEN
			iMsgNumber:=64;		(* TIMEOUT! Beim Aufstarten des Moduls konnte die Visualisierung nicht Initialisiert werden! Bitte Kontakt aufnehmen mit Microcut Ltd! *)
		ELSIF xReadHardware AND NOT(xNovRamError) THEN
			iMsgNumber:=65;		(* TIMEOUT! Beim Aufstarten des Moduls konnte die Hardware nicht Initialisiert werden! Bitte Kontakt aufnehmen mit Microcut Ltd! *)
		ELSIF xReadHardware AND xNovRamError THEN
			xNovRamError:=FALSE;
			iMsgNumber:=75;		(* TIMEOUT! Falsche Konfiguration des NovRAM Speicher! Hauptschalter  Aus! Bitte Kontakt aufnehmen mit Microcut Ltd! *)
		ELSIF xLoading THEN
			iMsgNumber:=66;		(* TIMEOUT! Beim Aufstarten des Moduls konnten die Stationen nicht Initialisiert werden! Bitte Kontakt aufnehmen mit Microcut Ltd! *)
		END_IF;
		xActiveErrorMsgIntern:=TRUE;
		iStepFunctionMsg:=1;
		iStepFunction:=1;
		(* Init. variable *)
		xInitVisu:=FALSE;
		xLoading:=FALSE;
		xReadHardware:=FALSE;
		(* Set output disable *)
		xSetOutputDisable:=TRUE;
		xCheckConfirm:=TRUE;
	END_IF
	IF xCheckConfirm AND NOT(xActiveErrorMsgIntern) THEN
		IF (iMsgNumber = 64) THEN
			(* Start InitVisu *)
			T_StartUp.T_Ctrle.xExecute:=TRUE;
			T_StartUp.T_Ctrle.iFunction:=1;
		ELSIF (iMsgNumber = 65) THEN
			(* Start ReadHardware *)
			T_StartUp.T_Ctrle.xExecute:=TRUE;
			T_StartUp.T_Ctrle.iFunction:=8;
		ELSIF (iMsgNumber = 66) THEN
			(* Start Booting *)
			T_StartUp.T_Ctrle.xExecute:=TRUE;
			T_StartUp.T_Ctrle.iFunction:=5;
		ELSIF (iMsgNumber = 75) THEN
			(* Start ReadHardware *)
			T_StartUp.T_Ctrle.xExecute:=TRUE;
			T_StartUp.T_Ctrle.iFunction:=8;
		END_IF;
	END_IF;
END_ACTION

ACTION	StartUpFunction_Booting:
(* Function Start Booting *)
	IF xStartBooting THEN
		T_ExchgParam.T_Visu.iLoadingStartPage:=1;
		T_ExchgParam.xBIOSButtonHide:=FALSE;
		CASE iStepFunction OF
		1:	xDeleteErrorMessage:=TRUE;
			T_TwinSafeCtrleOUT.xTwinSAFE_Run_1:=FALSE;	(* Stop TwinSafe Groupe *)
			T_StartUp.T_State.xPLCReady:=FALSE;
			T_StartUp.T_State.xCompleted:=FALSE;
			QxCtrlLampStartButton:=FALSE;
			QxCtrlLampStopButton:=FALSE;
			QxReadyToOperateMasterModul1:=TRUE;
			QxReadyToOperateMasterModul2:=TRUE;
			T_HDD.T_Ctrle.xReset:=TRUE;
			IF T_VisuQVis.T_CtrleVisu.xQvis THEN	(* Visualisierung muss bereit stehen *)
				(* next step *)
				IF NOT(gxHardwareOFF) THEN
					(*iStepFunction:=10;*)
					iStepFunction:=iStepFunction+1;		(* IGS *)
				ELSE
					T_ExchgParam.xInputSelectAxisSuccesful:=TRUE;
					T_ExchgParam.bToolSpindleActive:=3;	(* Beckhoff Spindel M ausgewählt *)
					iStepFunction:=60;
					T_StartUp.T_State.xPLCReady:=TRUE;
				END_IF;
			END_IF;



		(* Auswahl treffen welche Spindel eingesetzt ist *)		(* IGS *)
		2:	(* next step *)
			IF NOT(T_ExchgParam.xInputSelectAxisSuccesful) THEN
				(* Der Operator muss zuerst eine Auswahl treffen ob Spindelkopf S1 oder Spindekopf S2 eingestetzt ist *)
				T_ExchgParam.xButtonSelect_S1:=FALSE;
				T_ExchgParam.xButtonSelect_S2:=FALSE;
				T_ExchgParam.xButtonSelect_S3:=FALSE;
				T_ExchgParam.xButtonDisable:=FALSE;
				iStepFunction:=iStepFunction+1;
			ELSE
				iStepFunction:=10;
			END_IF;
		3:	IF T_ExchgParam.xButtonSelect_S1 THEN	(* Maxon Spindel ausgewählt *)
				T_ExchgParam.xButtonSelect_S1:=FALSE;
				T_ExchgParam.xButtonDisable:=TRUE;
				T_ExchgParam.xWriteSoEParameter:=FALSE;
				T_ExchgParam.bToolSpindleActive:=1;
				TONWaitMessage1(IN:=FALSE);
				iStepFunction:=iStepFunction+1;
			END_IF;
			IF T_ExchgParam.xButtonSelect_S2 THEN	(* Beckhoff Spindel L ausgewählt *)
				T_ExchgParam.xButtonSelect_S2:=FALSE;
				T_ExchgParam.xButtonDisable:=TRUE;
				T_ExchgParam.xWriteSoEParameter:=TRUE;	(* -> LAYER2 -> FBHW_STATION_WORK.A01_AX5000_Parametrization -> Parameter schreiben durchführen *)
				T_ExchgParam.bToolSpindleActive:=2;
				TONWaitMessage1(IN:=FALSE);
				iStepFunction:=iStepFunction+1;
			END_IF;
			IF T_ExchgParam.xButtonSelect_S3 THEN	(* Beckhoff Spindel M ausgewählt *)
				T_ExchgParam.xButtonSelect_S3:=FALSE;
				T_ExchgParam.xButtonDisable:=TRUE;
				T_ExchgParam.xWriteSoEParameter:=TRUE;	(* -> LAYER2 -> FBHW_STATION_WORK.A01_AX5000_Parametrization -> Parameter schreiben durchführen *)
				T_ExchgParam.bToolSpindleActive:=3;
				TONWaitMessage1(IN:=FALSE);
				iStepFunction:=iStepFunction+1;
			END_IF;
		4:	CASE T_ExchgParam.bToolSpindleActive OF
			1:	(* Maxon Spindel *)
				TONWaitMessage1(IN:=TRUE,PT:=T#3s);
				T_ExchgParam.T_Visu.T_Message.iState:=79;	(* Info: Maxon Spindelkopf ausgewählt ! *)
				T_ExchgParam.T_Visu.T_Message.xShowMessageInfo:=TRUE;
				IF TONWaitMessage1.Q THEN
					TONWaitMessage1(IN:=FALSE);
					T_ExchgParam.xInputSelectAxisSuccesful:=TRUE;
					T_ExchgParam.T_Visu.T_Message.iState:=0;
					T_ExchgParam.T_Visu.T_Message.xShowMessageInfo:=FALSE;
					iStepFunction:=10;
				END_IF
			2:	(* Beckhoff Spindel L *)
				T_ExchgParam.T_Visu.T_Message.iState:=80;	(* Info: Beckhoff Spindelkopf L ausgewählt ! *)
				T_ExchgParam.T_Visu.T_Message.xShowMessageInfo:=TRUE;
				IF NOT(T_ExchgParam.xWriteSoEParameter) THEN
					T_ExchgParam.xInputSelectAxisSuccesful:=TRUE;
					T_ExchgParam.T_Visu.T_Message.iState:=0;
					T_ExchgParam.T_Visu.T_Message.xShowMessageInfo:=FALSE;
					iStepFunction:=10;
				END_IF
			3:	(* Beckhoff Spindel M *)
				T_ExchgParam.T_Visu.T_Message.iState:=81;	(* Info: Beckhoff Spindelkopf M ausgewählt ! *)
				T_ExchgParam.T_Visu.T_Message.xShowMessageInfo:=TRUE;
				IF NOT(T_ExchgParam.xWriteSoEParameter) THEN
					T_ExchgParam.xInputSelectAxisSuccesful:=TRUE;
					T_ExchgParam.T_Visu.T_Message.iState:=0;
					T_ExchgParam.T_Visu.T_Message.xShowMessageInfo:=FALSE;
					iStepFunction:=10;
				END_IF
			END_CASE;



		10:	T_TwinSafeCtrleOUT.xTwinSAFE_Run_1:=TRUE;	(* Start TwinSafe Groupe 1 *)
			TONWaitResetOutput(IN:=FALSE);
			(* next step *)
			iStepFunction:=11;
		11:	TONWaitResetOutput(IN:=TRUE,PT:=T#0.5s);
			IF TONWaitResetOutput.Q THEN
				IF T_TwinSafeCtrleIN.xTwinSAFE_Group_OUT_Error_1 OR T_TwinSafeCtrleIN.xTwinSAFE_Group_FB_Error_1 OR T_TwinSafeCtrleIN.xTwinSAFE_Group_COM_Error_1 THEN
					IF T_TwinSafeCtrleIN.xTwinSAFE_Group_OUT_Error_1 OR T_TwinSafeCtrleIN.xTwinSAFE_Group_FB_Error_1 OR T_TwinSafeCtrleIN.xTwinSAFE_Group_COM_Error_1 THEN
						T_TwinSafeCtrleOUT.xTwinSAFE_Reset_1:=TRUE;
					END_IF;
					TONWaitResetOutput(IN:=FALSE);
					iStepFunction:=12;
					RETURN;
				END_IF;
				TONWaitResetOutput(IN:=FALSE);
				iStepFunction:=14;
			END_IF;
		12:	TONWaitResetOutput(IN:=TRUE,PT:=T#0.2s);
			IF TONWaitResetOutput.Q THEN
				T_TwinSafeCtrleOUT.xTwinSAFE_Reset_1:=FALSE;
				TONWaitResetOutput(IN:=FALSE);
				iStepFunction:=13;
			END_IF;
		13:	TONWaitResetOutput(IN:=TRUE,PT:=T#0.2s);
			IF TONWaitResetOutput.Q THEN
				TONWaitResetOutput(IN:=FALSE);
				IF NOT(xFirstBooting) THEN
					iStepFunction:=10;
				ELSE
					iStepFunction:=14;
				END_IF;
			END_IF;
		14:	xReadyToCheckSafety:=TRUE;
			TStation_Work_St1.THWWorkStation.xActiveStation:=TRUE;
			TStation_Work_St1.TControl.xResetHardware:=TRUE;
			T_VisuQVis.T_CtrleVisu.xReset:=TRUE;
			T_VisuQVis.T_CtrleAction.xExecute:=FALSE;
			IF T_TwinSafeIn.IxReadyToOperateMasterModul1 AND T_TwinSafeIn.IxReadyToOperateMasterModul2 THEN
				iStepFunction:=17;
			ELSE
				iStepFunction:=15;	(* Mindestens eine Achse steht nicht Bereit-->Hardware wird zurückgesetzt *)
			END_IF;
		15:	IF NOT(TStation_Work_St1.TControl.xResetHardware) THEN
				iStepFunction:=16;
			END_IF;
		16:	IF T_TwinSafeIn.IxReadyToOperateMasterModul1 AND T_TwinSafeIn.IxReadyToOperateMasterModul2 THEN
				iStepFunction:=17;
			ELSE
				iStepFunction:=40;	(* Mindestens eine Achse steht immer noch nicht Bereit-->Fehlerausgabe *)
			END_IF;
		(* Überprüfe zuerst ob die USV bereit steht *)
		17:	IF T_CtrleUPS.xUPSReady THEN
				(* next step *)
				iStepFunction:=20;
			ELSE
				(* next step *)
				iStepFunction:=40;
			END_IF;
		20:	T_StartUp.T_State.xPLCReady:=TRUE;
			xFirstBooting:=TRUE;
			IF RisingEdgeQuitButton.Q OR gT_SafetyStatus.xEnergyONNormalMode THEN		(* Wait until the Operator press the external quit button *)
				xDeleteErrorMessage:=TRUE;	(* Reset the line message error *)
				TONWaitCircuitOn(IN:=FALSE);
				(* next step *)
				iStepFunction:=30;
			END_IF;
		30:	TONWaitCircuitOn(IN:=TRUE,PT:=T#1000ms);
			IF TONWaitCircuitOn.Q THEN
				TONWaitCircuitOn(IN:=FALSE);
				(* next step *)
				iStepFunction:=31;
			END_IF;
		31:	TStation_Work_St1.TControl.xResetHardware:=TRUE;
			iStepFunction:=iStepFunction + 1;
		32:	IF NOT(TStation_Work_St1.TControl.xResetHardware) THEN
				iStepFunction:=40;
			END_IF;
		40:	(* Overlay Message Error *)
			xActiveErrorMsgIntern:=TRUE;	(* Falls Kein Fehlverhalten festgestellt wird, dann wird es wieder zurückgesetzt *)
			iStepFunctionMsg:=1;
			iStepFunction:=50;
			iMsgNumber:=0;
			IF T_TwinSafeCtrleIN.xTwinSAFE_Group_OUT_Error_1 THEN
				iMsgNumber:=35;	(* TwinSAFE Sichere Ausgänge Fehlerhaft! Mindestens einen Sicheren Ausgang hat einen Fehler festgestellt! Bitte Kontakt aufnehmen mit Microcut Ltd!  *)
			ELSIF T_TwinSafeCtrleIN.xTwinSAFE_Group_FB_Error_1 THEN
				iMsgNumber:=36;	(* TwinSAFE Funktionsbaustein Fehlerhaft! Mindestens ein Funktionsbaustein hat einen Fehler festgestellt! Bitte Kontakt aufnehmen mit Microcut Ltd!  *)
			ELSIF T_TwinSafeCtrleIN.xTwinSAFE_Group_COM_Error_1 THEN
				iMsgNumber:=37;	(* TwinSAFE Sichere Verbindung Fehlerhaft! Mindestens eine Verbindung hat einen Fehler festgestellt! Bitte Kontakt aufnehmen mit Microcut Ltd! *)
			ELSIF NOT(T_CtrleUPS.xUPSReady) THEN
				iMsgNumber:=50;		(* Unterbrechungsfreie Stromversorgung USV steht nicht Bereit! Überprüfen Sie Bitte die USV und bestätigen Sie die Meldung *)
			ELSIF NOT(T_TwinSafeIn.IxReadyToOperateMasterModul1) THEN
				iMsgNumber:=39;		(* Achsen des MasterModul 1 stehen nicht Bereit! Überprüfen Sie Bitte den Servo des MasterModul 1 und bestätigen Sie die Meldung *)
			ELSIF NOT(T_TwinSafeIn.IxReadyToOperateMasterModul2) THEN
				iMsgNumber:=40;		(* Achsen des MasterModul 2 stehen nicht Bereit! Überprüfen Sie Bitte den Servo des MasterModul 2 und bestätigen Sie die Meldung *)
			ELSIF T_TwinSafeIn.IxKeySwitchProcObservationCh1 OR T_TwinSafeIn.IxKeySwitchProcObservationCh2 OR T_TwinSafeIn.IxKeySwitchWorkStationCh1 OR T_TwinSafeIn.IxKeySwitchWorkStationCh2 THEN
				iMsgNumber:=53;		(* Um die Maschine zu starten schalten Sie den Schlüsselschalter aus, bestätigen Sie die Meldung und drücken Sie erneut die StartTaste *)
			ELSIF NOT(T_TwinSafeIn.IxCabinDoorCloseCh1 AND T_TwinSafeIn.IxCabinDoorCloseCh2 AND NOT(T_TwinSafeIn.IxCabinDoorOpen) AND
			    T_TwinSafeIn.IxCabinDoorClose) THEN
				iMsgNumber:=54;		(* Um die Maschine zu starten schliessen Sie die MaschinenTüre, bestätigen Sie die Meldung und drücken Sie erneut die StartTaste *)
			ELSIF NOT(T_TwinSafeIn.IxAxesCurrentOffCh1) AND NOT(T_TwinSafeIn.IxAxesCurrentOffCh2) THEN
				iMsgNumber:=44;		(* Um die Maschine zu starten lösen Sie die AntriebSperrTaste, bestätigen Sie die Meldung und drücken Sie erneut die StartTaste *)
			ELSIF (NOT(T_TwinSafeOut.QxContactorMasterModul400VCh1) OR NOT(T_TwinSafeOut.QxContactorMasterModul400VCh2)) AND NOT(xMsgActiveDeactivatedSupply) AND NOT(xStationErrorActive) THEN
				iMsgNumber:=67;		(* Die Leistungsschütze der AX5106 Servos funktionieren nicht Einwandfrei! Bestätigen Sie die Meldung und versuchen Sie es erneut Kontrollieren Sie die Einrichtung *)
			ELSIF (NOT(T_TwinSafeOut.QxContactor24VCh1) OR NOT(T_TwinSafeOut.QxContactor24VCh2)) AND NOT(xMsgActiveDeactivatedSupply) AND NOT(xStationErrorActive) THEN
				iMsgNumber:=68;		(* Die Leistungsschütze der Luftversorgung und 24V funktionieren nicht Einwandfrei! Bestätigen Sie die Meldung und versuchen Sie es erneut Kontrollieren Sie die Einrichtung *)
			ELSIF (xMsgActiveDeactivatedSupply AND NOT(xStationErrorActive)) THEN
				iMsgNumber:=56;		(* Die Energieversorgung wurde ausgeschaltet! Bestätigen Sie die Meldung und versuchen Sie es erneut!  *)
			ELSIF xStationErrorActive THEN
				iMsgNumber:=49;		(* Während des Aufstarten der Maschine ist ein Fehler/Error aufgetreten! Bestätigen Sie die Meldung und Überprüfen Sie den entsprechenden Fehler/Error *)
			ELSE
				T_TwinSafeCtrleOUT.xTwinSAFE_Run_1:=TRUE;	(* Kein Fehlverhalten festgestellt, daher wird es wieder gesetzt *)
				xActiveErrorMsgIntern:=FALSE;						(* Kein Fehlverhalten festgestellt, daher wird es wieder zurückgesetzt *)
				TONWaitCircuitOn(IN:=FALSE);
				(* next step *)
				iStepFunction:=60;
			END_IF;
			IF (iMsgNumber <> 0) THEN
				T_TwinSafeCtrleOUT.xTwinSAFE_Run_1:=FALSE;	(* Stop TwinSafe Groupe-->Falls Kein Fehlverhalten festgestellt wird, dann wird es wieder gesetzt *)
			END_IF;
			xMsgActiveDeactivatedSupply:=xStationErrorActive:=FALSE;
			T_HDD.T_Ctrle.xReset:=TRUE;
		50:	IF NOT(xActiveErrorMsgIntern) THEN
				TONWaitCircuitOn(IN:=FALSE);
				IF QxCabinDoorLock THEN
					T_ExchgParam.T_SafetyCtrl.xOpenSecurityDoorMachine:=TRUE;
				ELSE
					T_ExchgParam.T_SafetyCtrl.xOpenSecurityDoorMachine:=FALSE;
				END_IF;
				(* next step *)
				iStepFunction:=51;
			END_IF;
		51:	IF NOT(T_ExchgParam.T_SafetyCtrl.xOpenSecurityDoorMachine) THEN
				(* next step *)
				iStepFunction:=1;
			END_IF;
		60:	QxCtrlLampStartButton:=TRUE;
			IF RisingEdgeStartButton.Q THEN		(* Wait until the Operator press the external start button *)
				QxCtrlLampStartButton:=FALSE;
				xDeleteErrorMessage:=TRUE;	(* Reset the line message error *)
				(* next step *)
				iStepFunction:=70;
			END_IF;
			IF (NOT(gT_SafetyStatus.xEnergyONNormalMode) OR NOT(gT_SafetyStatus.xSecuritySwitch)) AND NOT(gxHardwareOFF) THEN
				(* next step *)
				iStepFunction:=40;
				xMsgActiveDeactivatedSupply:=TRUE;
				QxCtrlLampStartButton:=FALSE;
				RETURN;
			END_IF;
		(* Aktivieren der Zuhaltung der Maschinen- Sicherheitstüre *)
		70:	T_ExchgParam.T_SafetyCtrl.xCloseSecurityDoorMachine:=TRUE;
			(* next step *)
			iStepFunction:=80;
		80:	IF NOT(T_ExchgParam.T_SafetyCtrl.xCloseSecurityDoorMachine) THEN
				iStepFunction:=90;
			END_IF;
		90:	(* Start Booting is ended, the machine has now the right state to boot the machine *)
			IF NOT(gT_SafetyStatus.xEnergyONNormalMode) AND NOT(gxHardwareOFF) THEN
				(* next step *)
				iStepFunction:=40;
				xMsgActiveDeactivatedSupply:=TRUE;
				RETURN;
			END_IF;
			xStartBooting:=FALSE;
			(* Start Loading *)
			T_StartUp.T_Ctrle.xExecute:=TRUE;
			T_StartUp.T_Ctrle.iFunction:=2;
		END_CASE;
	END_IF;
END_ACTION

ACTION	StartUpFunction_Emergency:
(* Emergency or air supply *)
	IF (xEmergency OR xNoAirPressure OR xTerminalError) AND NOT(T_CtrleUPS.xBlockSystem_PowerFail) AND (TStatusUPS.ePowerStatus <> PowerOnBattery) THEN
		CASE iStepFunction OF
		1:	xSetOutputDisable:=TRUE;
			T_StartUp.T_State.xCompleted:=FALSE;
			T_NovRAM.T_Ctrle.xReset:=TRUE;
			T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;
			T_StartUp.T_Ctrle.xDeleteAllMessageOverlay:=TRUE;
			T_VisuQVis.T_CtrleAction.xDeleteVisuFunction:=TRUE;
			T_VisuQVis.T_CtrleVisu.xActive:=FALSE;
			T_StartUp.T_Ctrle.iMsgNumber:=0;
			TProcess.T_Ctrle.xError:=FALSE;
			iStepFunction:=iStepFunction + 1;
		2:	IF NOT(T_NovRAM.T_Ctrle.xReset) AND T_NovRAM.T_Ctrle.xDone THEN
				T_VisuQVis.T_CtrleVisu.xActive:=TRUE;
				iStepFunction:=iStepFunction + 1;
			END_IF;
		3:	IF T_VisuQVis.T_CtrleVisu.xActive AND T_VisuQVis.T_CtrleVisu.xDone THEN
				T_VisuQVis.T_CtrleVisu.xReset:=TRUE;
				iStepFunction:=iStepFunction + 1;
			END_IF;
		4:	IF NOT(T_VisuQVis.T_CtrleVisu.xReset) AND T_VisuQVis.T_CtrleVisu.xDone THEN
				T_VisuQVis.T_CtrleVisu.xReset:=TRUE;
				iStepFunction:=iStepFunction + 1;
			END_IF;
		(* waiting confirm *)
		5:	IF NOT(xSetOutputDisable) AND NOT(T_VisuQVis.T_CtrleVisu.xReset) THEN
				xActiveErrorMsgIntern:=TRUE;
				iStepFunctionMsg:=1;
				IF (T_TerminalState.wEtherCAT_1_State <> 0) THEN
					T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=16#F100;	(* EtherCAT 1 Klemme Fehlerhaft *)
					iMsgNumber:=69;		(* Beckhoff Klemme oder Buskoppler Fehlerhaft! Herunterfahren der Steuerung, Modul ausschalten und schalten Sie dann das Modul wieder ein! *)
				ELSIF (wEtherCAT_2_State <> 0) THEN
					T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=16#F101;	(* EtherCAT 2 Klemme Fehlerhaft *)
					iMsgNumber:=69;		(* Beckhoff Klemme oder Buskoppler Fehlerhaft! Herunterfahren der Steuerung, Modul ausschalten und schalten Sie dann das Modul wieder ein! *)
				ELSIF (wWCEPOS_State <> 8) THEN
					T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=16#F102;	(* Maxon EPOS nicht im Operational Mode OP *)
					iMsgNumber:=69;		(* Beckhoff Klemme oder Buskoppler Fehlerhaft! Herunterfahren der Steuerung, Modul ausschalten und schalten Sie dann das Modul wieder ein! *)
				ELSIF (T_TerminalState.wWCSMCValve <> 8) THEN
					T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=16#F103;	(* SMC Ventilinsel nicht im Operational Mode OP *)
					iMsgNumber:=69;		(* Beckhoff Klemme oder Buskoppler Fehlerhaft! Herunterfahren der Steuerung, Modul ausschalten und schalten Sie dann das Modul wieder ein! *)
				ELSIF (T_TerminalState.wWCMasterAxisModul1_State <> 8) THEN
					T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=16#F104;	(* Achsen MasterModul 1 nicht im Operational Mode OP *)
					iMsgNumber:=69;		(* Beckhoff Klemme oder Buskoppler Fehlerhaft! Herunterfahren der Steuerung, Modul ausschalten und schalten Sie dann das Modul wieder ein! *)
				ELSIF (T_TerminalState.wWCMasterAxisModul2_State <> 8) THEN
					T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=16#F105;	(* Achsen MasterModul 2 nicht im Operational Mode OP *)
					iMsgNumber:=69;		(* Beckhoff Klemme oder Buskoppler Fehlerhaft! Herunterfahren der Steuerung, Modul ausschalten und schalten Sie dann das Modul wieder ein! *)
				ELSIF NOT(IxFuse24VDC_OK) THEN
					T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=16#F106;	(* Spannungsversorgung 24VDC fehlerhaft *)
					iMsgNumber:=59;		(* Spannungsversorgung 24VDC fehlerhaft! Herunterfahren der Steuerung, Maschine ausschalten und schalten Sie dann die Maschine wieder ein!  *)
				ELSIF (NOT(T_TwinSafeIn.IxEmergencyStopButtonCh1) OR NOT(T_TwinSafeIn.IxEmergencyStopButtonCh2)) THEN
					iMsgNumber:=1;		(* Not-Aus Taste Maschine ist betätigt! Lösen Sie die Not-Aus Taste und bestätigen Sie die Meldung *)
					T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=1;	(* Not Aus Taste Maschine wurde gedrückt *)
				ELSIF xNoAirPressure THEN
					iMsgNumber:=2;		(* Keine Druckluft! Stellen Sie die Zufuhr sicher und bestätigen Sie die Meldung *)
					T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=8;	(* Keine Druckluft *)
				END_IF;
				T_ExchgParam.T_SafetyCtrl.xSetForceError:=TRUE;
				iStepFunction:=iStepFunction + 1;
			END_IF
		6:	IF NOT(xActiveErrorMsgIntern) THEN
					wWCEPOS_State:=8;
					wEtherCAT_2_State:=0;
					IF (T_TerminalState.wEtherCAT_1_State <> 0) OR (wEtherCAT_2_State <> 0) OR (T_TerminalState.wWCMasterAxisModul1_State <> 8) OR (T_TerminalState.wWCMasterAxisModul2_State <> 8)
					OR (wWCEPOS_State <> 8) OR (T_TerminalState.wWCSMCValve <> 8) OR NOT(IxFuse24VDC_OK)THEN
					(* next step *)
					iStepFunction:=iStepFunction + 1;
					TONWaitMessage(IN:=FALSE);
				ELSIF NOT(T_TwinSafeIn.IxEmergencyStopButtonCh1) OR NOT(T_TwinSafeIn.IxEmergencyStopButtonCh2) THEN
					(* next step *)
					iStepFunction:=iStepFunction + 1;
					TONWaitMessage(IN:=FALSE);
				ELSE
					(* next step *)
					iStepFunction:=90;
				END_IF;
			END_IF;
		7:	TONWaitMessage(IN:=TRUE,PT:=T#1s);
			IF TONWaitMessage.Q THEN
				(* next step *)
				iStepFunction:=5;	(* NotAus immer noch gedrückt-->Wiederhole die Meldung *)
			END_IF;
		(* Check if the SecurityDoor is locked *)
		90:	IF NOT(IxCabinDoorLocked) THEN
				xActiveErrorMsgIntern:=TRUE;
				iStepFunctionMsg:=1;
				iMsgNumber:=48;		(* Die MaschinenTüre ist zugehalten Bestätigen Sie und die Zuhaltung Der MaschinenTüre wird deaktiviert *)
				(* next step *)
				iStepFunction:=iStepFunction + 1;
			ELSE
				(* next step *)
				iStepFunction:=99;
			END_IF;
		91:	IF NOT(xActiveErrorMsgIntern) THEN
				T_ExchgParam.T_SafetyCtrl.xOpenSecurityDoorMachine:=TRUE;
				(* next step *)
				iStepFunction:=iStepFunction + 1;
			END_IF;
		92:	IF NOT(T_ExchgParam.T_SafetyCtrl.xOpenSecurityDoorMachine) THEN
				iStepFunction:=99;
			END_IF;
		(* end function or time out *)
		99:	xActiveErrorMsg:=FALSE;
			xActiveInfoMsg:=FALSE;
			xActiveWarningMsg:=FALSE;
			T_StartUp.T_Ctrle.xDone:=TRUE;
			T_StartUp.T_Ctrle.xErr:=FALSE;
			T_StartUp.T_Ctrle.udiErrorID:=0;
			xEmergency:=FALSE;
			xNoAirPressure:=FALSE;
			xTerminalError:=FALSE;
			(* Start Boot *)
			T_StartUp.T_Ctrle.xExecute:=TRUE;
			T_StartUp.T_Ctrle.iFunction:=5;
		END_CASE
	END_IF;
END_ACTION

ACTION	StartUpFunction_Initialisation:
(* Function Init PLC *)
	IF xInitVisu THEN
		CASE iStepFunction OF
		1:	T_VisuQVis.T_CtrleVisu.xActive:=TRUE;
			T_VisuQVis.T_CtrleVisu.xReset:=TRUE;
			(* next step *)
			iStepFunction:=10;
		(* Confirm Reset *)
		10:	IF T_VisuQVis.T_CtrleVisu.xDone THEN
				(* next step *)
				iStepFunction:=90;
			END_IF
		(* end function or time out *)
		90:	T_StartUp.T_Ctrle.xDone:=TRUE;
			T_StartUp.T_Ctrle.xErr:=FALSE;
			T_StartUp.T_Ctrle.udiErrorID:=0;
			xInitVisu:=FALSE;
			tTimeOutFunction:=T#0s;
			(* Start Read Hardware *)
			T_StartUp.T_Ctrle.xExecute:=TRUE;
			T_StartUp.T_Ctrle.iFunction:=8;
		END_CASE
	END_IF

END_ACTION

ACTION	StartUpFunction_Loading:
(* Function start loading *)
	IF xLoading THEN
		(* Timer bargraph *)
		IF (iStepFunction < 999) THEN
			TONStartUp(IN:=TRUE,PT:=tTimeStartUp);
			IF TONStartUp.Q THEN
				TONStartUp(IN:=FALSE);
				IF (T_ExchgParam.T_Visu.iLoadingStartPage <=100) THEN
					T_ExchgParam.T_Visu.iLoadingStartPage:=T_ExchgParam.T_Visu.iLoadingStartPage +1; END_IF
			END_IF;
		END_IF;
		IF NOT(gT_SafetyStatus.xEnergyONNormalMode) AND (iStepFunction < 985) AND NOT(gxHardwareOFF) THEN
			T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=9;		(* Spannungsversorgung wurde ausgeschaltet *)
			T_ExchgParam.T_SafetyCtrl.xSetForceError:=TRUE;
			iStepFunction:=999;
		END_IF;
		CASE iStepFunction OF
		(* Check *)
		1:	IF T_StartUp.T_State.xPLCReady THEN iStepFunction:=10; END_IF
			tTimeStartUp:=T#40ms;
		(* Init. Visu and Set Power *)
		10:	gxInitialStateActivated:=FALSE;
			xActiveBootingError:=FALSE;
			xDeleteErrorMessage:=TRUE;	(* Reset the line message error *)
			T_VisuQVis.T_PlcParam.dwSetNewPage:=16#0;
			T_VisuQVis.T_CtrleVisu.xReset:=TRUE;
			T_VisuQVis.T_CtrleVisu.xExecute:=TRUE;
			T_VisuQVis.T_CtrleVisu.iFunction:=1;
			(* next Step *)
			iStepFunction:=20;
		(* wait until the reset procedure is ready *)
		20:	IF NOT(T_VisuQVis.T_CtrleVisu.xReset) AND T_VisuQVis.T_CtrleVisu.xQvis THEN
				(* next Step *)
				IF NOT(gxHardwareOFF) THEN
					iStepFunction:=30;
				ELSE
					iStepFunction:=70;		(* IGS alt: 30; *)
				END_IF;
			END_IF;
		(* Adapter Informationen lesen *)
		30:	FBGetAdaptersInfo(	sNetID:= '',
								bExecute:=FALSE);
			iStepFunction:=40;
		40:	FBGetAdaptersInfo(	sNetID:= '',
								bExecute:= TRUE,
								tTimeout:= T#2s);
			IF NOT(FBGetAdaptersInfo.bBusy) THEN
				FOR ii:=0 TO UDINT_TO_INT(FBGetAdaptersInfo.nGet - 1) DO
					IF (FIND(FBGetAdaptersInfo.arrAdapters[ii].sDescription,'#2') <> 0) AND (FBGetAdaptersInfo.arrAdapters[ii].eType = MIB_IF_TYPE_ETHERNET) THEN
						T_ExchgParam.T_Visu.sIPAddress:=FBGetAdaptersInfo.arrAdapters[ii].sIpAddr;
						T_ExchgParam.T_Visu.sSubNetMask:=FBGetAdaptersInfo.arrAdapters[ii].sSubNet;
						T_ExchgParam.T_Visu.xDHCPActive:=FBGetAdaptersInfo.arrAdapters[ii].bDhcpEnabled;
						T_ExchgParam.T_Visu.sGatewayAddress:=FBGetAdaptersInfo.arrAdapters[ii].sDefGateway;
						EXIT;
					END_IF;
				END_FOR;
				FBGetHostName(	bExecute:=FALSE);
				iStepFunction:=41;
			END_IF;
		41:	FBGetHostName(	sNetID:= '',
								bExecute:= TRUE,
								tTimeout:= T#2s);
			IF NOT(FBGetHostName.bBusy) THEN
				T_ExchgParam.T_Visu.sHostName:=FBGetHostName.sHostName;
				FBGetLocalAmsNetId(	bExecute:=FALSE);
				iStepFunction:=42;
			END_IF;
		42:	FBGetLocalAmsNetId(	bExecute:= TRUE,
									tTimeout:= T#2s);
			IF NOT(FBGetLocalAmsNetId.bBusy) THEN
				T_ExchgParam.T_Visu.xNoRemoteControlActive:=FALSE;
				IF (FBGetLocalAmsNetId.AddrString <> '') AND NOT(FBGetLocalAmsNetId.bError) THEN
					T_ExchgParam.T_Visu.sAmsNetID:=FBGetLocalAmsNetId.AddrString;
					IF (FIND(STR1:=T_ExchgParam.T_Visu.sIPAddress, STR2:='0.0.0.0') <> 0) AND NOT(T_ExchgParam.T_Visu.xDHCPActive) THEN
						(* An der CX2020 ist am Netzwerkadapter kein Rechner angeschlossen und deshalb wird die konfigurierte IP Adresse nicht ausgegeben. Man geht davon aus dass die AmsNetID der IP Adresse entspricht und übergibt diesen ausser nicht den Byte 5 und 6 Wert nicht *)
						sCopyString:=FBGetLocalAmsNetId.AddrString;
						sCopyStringIP:='';
						FOR ii:=1 TO 4 DO
							iPoint:=FIND(STR1:=sCopyString, STR2:='.');
							sCopyStringIP:=CONCAT(sCopyStringIP,MID(STR:=sCopyString, LEN:=iPoint, POS:=1));
							sCopyString:=DELETE(STR:=sCopyString, LEN:=iPoint, POS:=1);
						END_FOR;
						sCopyStringIP:=DELETE(STR:=sCopyStringIP, LEN:=1, POS:=LEN(sCopyStringIP));	(* Den letzten Punkt muss gelöscht werden *)
						T_ExchgParam.T_Visu.sIPAddress:=sCopyStringIP;
						T_ExchgParam.T_Visu.sSubNetMask:='255.255.255.0';
						T_ExchgParam.T_Visu.xNoRemoteControlActive:=TRUE;	(* In diesem Fall werde die IP Adresse und Subnetmaske Orange dargestellt, dass es Möglich sein könnte dass es nicht dem eingestellten Wert entspricht *)
					END_IF;
				END_IF;
				iStepFunction:=50;
			END_IF;
		(* Überprüfe ob USB-Stick eingesteckt ist *)
		50:	T_Profile.T_Ctrle.iFunction:=3;		(* check if USB Stick exist *)
			T_Profile.T_Ctrle.xExecute:=TRUE;
			iStepFunction:=60;
		60:	IF NOT(T_Profile.T_Ctrle.xExecute) AND T_Profile.T_Ctrle.xDone THEN
				iStepFunction:=70;
			END_IF;
			IF NOT(T_Profile.T_Ctrle.xExecute) AND T_Profile.T_Ctrle.xErr THEN
				T_ExchgParam.T_SafetyCtrl.diSetForceErrorNr:=16#F305;	(* USB-Stick konnte nicht gefunden werden *)
				T_ExchgParam.T_SafetyCtrl.xSetForceError:=TRUE;
				T_Profile.T_Ctrle.xReset:=TRUE;
				iStepFunction:=999;
			END_IF;
		(* Lesen des Operator Passwortes *)
		70:	T_Password.T_Ctrle.xExecute:=TRUE;
			T_Password.T_Ctrle.iFunction:=1;
			iStepFunction:=80;
		80:	IF NOT(T_Password.T_Ctrle.xExecute) AND T_Password.T_Ctrle.xDone THEN
				T_ExchgParam.T_Visu.T_Level.diPwOperatorSaved:=T_Password.T_Ctrle.udiGetOperatorPassword;
				iStepFunction:=90;
			END_IF;
			IF NOT(T_Password.T_Ctrle.xExecute) AND T_Password.T_Ctrle.xErr THEN
				T_ExchgParam.T_Visu.T_Level.diPwOperatorSaved:=123456;	(* Bei Fehler Standardmässig Passwort 123456 definieren *)
				T_Password.T_Ctrle.xReset:=TRUE;
				iStepFunction:=90;
			END_IF;
		(* Überprüfe ob die Maschinenkonfiguration bezüglich der ausgewählten Stationen korrekt ist *)
		90:	iStepFunction:=100;
		100:	(* Aktivierung der Stationen *)
			TStation_Work_St1.TControl.xActiveStation:=TRUE;
			TStation_Work_St1.THWWorkStation.xActiveStation:=TRUE;
			TStation_Work_St1.THWWorkStation.TCtrlWork.iSpindelActiveRotationDay:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].iSpindelActiveRotationDay;
			TStation_Work_St1.THWWorkStation.TCtrlWork.tSpindelActiveRotationTime:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].tSpindelActiveRotationTime;
			TStation_Work_St1.THWWorkStation.TCtrlWork.iSpindel2ActiveRotationDay:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].iSpindel2ActiveRotationDay;
			TStation_Work_St1.THWWorkStation.TCtrlWork.tSpindel2ActiveRotationTime:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].tSpindel2ActiveRotationTime;
			TStation_Work_St1.THWWorkStation.TCtrlWork.iSpindel3ActiveRotationDay:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].iSpindel3ActiveRotationDay;
			TStation_Work_St1.THWWorkStation.TCtrlWork.tSpindel3ActiveRotationTime:=T_NovRAM.T_Parameter.T_StationWork[gciStationSt1].tSpindel3ActiveRotationTime;
			TStation_Work_St1.TControl.xEnable:=TRUE;
			iStepFunction:=200;
		(* Warten bis alle Stationen bereit stehen *)
		200:	xTmp:=	(TStation_Work_St1.TControl.xDone OR TStation_Work_St1.TControl.xError);
			IF xTmp THEN
				xTmp:=	NOT(TStation_Work_St1.TControl.xError);
				IF xTmp THEN
					iStepFunction:=300;
				ELSE
					xStationErrorActive:=TRUE;
					iStepFunction:=999;
				END_IF;
			END_IF;
		(* Aktivieren der Prozessschicht *)
		300:	TProcess.T_Ctrle.xEnable:=TRUE;
			iStepFunction:=400;
		400:	IF TProcess.T_Ctrle.xRdy AND TProcess.T_Ctrle.xDone THEN
					iStepFunction:=600;
				END_IF;
		(* Lesen aller Profile *)
		600:	T_VisuQVis.T_CtrleAction.xExecute:=TRUE;
			T_VisuQVis.T_CtrleAction.iFunction:=1002;
			(* next step *)
			iStepFunction:=700;
		700:	IF NOT(T_VisuQVis.T_CtrleAction.xExecute) AND T_VisuQVis.T_CtrleAction.xDone THEN iStepFunction:=984; END_IF;
			IF NOT(T_VisuQVis.T_CtrleAction.xExecute) AND T_VisuQVis.T_CtrleAction.xErr THEN iStepFunction:=999; END_IF
			IF NOT(T_VisuQVis.T_CtrleAction.xExecute) AND (T_VisuQVis.T_CtrleAction.xDone OR T_VisuQVis.T_CtrleAction.xErr) THEN
				T_VisuQVis.T_PlcParam.dwSetNewPage:=16#A;	(* Main Page wird aufgerufen *)
				T_VisuQVis.T_CtrleVisu.iFunction:=1;
				T_VisuQVis.T_CtrleVisu.xExecute:=TRUE;
				gxAxisPositionSettled:=TRUE;	(* Achsen ref State der BIOS Parameter kann nun nicht mehr verstellt werden. Die Maschine muss zuerst ausgeschaltet werden
											    und muss wieder eingeschaltet werden. Vor dem erstmaligen Booten muss die Änderung der BIOS Parameter vorgenommen werden *)
			END_IF;
		984:	tTimeOutFunction:=T#0s;	(* deactivate the time out *)
			(* Overlay Message Info *)
			xMachineActivated:=TRUE;
			xActiveInfoMsgIntern:=TRUE;
			iStepFunctionMsg:=1;
			iMsgNumber:=1;		(* Modul wurde aufgestartet! Bestätigen Sie die Meldung und das Modul steht dann Bereit! *)
			(* next step *)
			iStepFunction:=985;
		985:	IF NOT(xActiveInfoMsgIntern) OR (T_TwinSafeIn.IxKeySwitchProcObservationCh1 AND T_TwinSafeIn.IxKeySwitchProcObservationCh2) OR (T_TwinSafeIn.IxKeySwitchWorkStationCh1 AND T_TwinSafeIn.IxKeySwitchWorkStationCh2) THEN
				T_ExchgParam.T_SafetyCtrl.bStateMessageInfo:=0;
				T_ExchgParam.T_SafetyCtrl.xConfirmMsgInfo:=FALSE;
				(* next step *)
				iStepFunction:=986;
			END_IF;
			T_StartUp.T_State.xCompleted:=TRUE;
		986:	T_ExchgParam.T_SafetyCtrl.xOpenSecurityDoorMachine:=TRUE;
			iStepFunction:=987;
		987:	IF NOT(T_ExchgParam.T_SafetyCtrl.xOpenSecurityDoorMachine) THEN
				iStepFunction:=990;
			END_IF;
		(* End function *)
		990:	T_StartUp.T_State.xCompleted:=TRUE;
			T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
			T_StartUp.T_Ctrle.xDone:=TRUE;
			T_StartUp.T_Ctrle.xErr:=FALSE;
			T_StartUp.T_Ctrle.udiErrorID:=16#0;
			xLoading:=FALSE;
			tTimeOutFunction:=T#0s;	(* deactivate the time out *)
		(* Error function, set output disable *)
		999:	xActiveBootingError:=TRUE;
			tTimeOutFunction:=T#0s;	(* deactivate the time out *)
			TStation_Work_St1.TControl.xEnable:=FALSE;
			T_ExchgParam.T_Visu.iLoadingStartPage:=1;
			(* next step *)
			iStepFunction:=9994;
		9994:(* Overlay Message Error *)
			xActiveErrorMsgIntern:=TRUE;
			iStepFunctionMsg:=1;
			iMsgNumber:=49;		(* Während des Aufstarten der Maschine ist ein Fehler/Error aufgetreten! Bestätigen Sie die Meldung und Überprüfen Sie den entsprechenden Fehler/Error *)
			(* next step *)
			iStepFunction:=9995;
			T_TwinSafeCtrleOUT.xTwinSAFE_Run_1:=FALSE;	(* Stop TwinSafe Groupe 1 *)
		9995:IF NOT(xActiveErrorMsgIntern) THEN
				xStationErrorActive:=FALSE;
				(* next step *)
				iStepFunction:=9996;
			END_IF;
		9996:T_ExchgParam.T_SafetyCtrl.xOpenSecurityDoorMachine:=TRUE;
			iStepFunction:=9997;
		9997:IF NOT(T_ExchgParam.T_SafetyCtrl.xOpenSecurityDoorMachine) THEN
				iStepFunction:=9998;
			END_IF;
		9998:xLoading:=FALSE;
			xStartBooting:=TRUE;
			tTimeOutFunction:=T#0s;	(* deactivate the time out *)
			(* next step *)
			iStepFunction:=1;
		END_CASE
	END_IF
END_ACTION

ACTION	StartUpFunction_MessageActivate:
xForceCloseMessage:=((T_TwinSafeIn.IxKeySwitchProcObservationCh1 AND T_TwinSafeIn.IxKeySwitchProcObservationCh2) OR (T_TwinSafeIn.IxKeySwitchWorkStationCh1 AND T_TwinSafeIn.IxKeySwitchWorkStationCh2)) AND T_StartUp.T_State.xCompleted;
(* Automode Process Page muss aufgerufen werden, falls der Automat Aktiv ist und man nicht auf dieser Seite steht *)
IF xActiveInfoMsg OR xActiveErrorMsg OR xActiveWarningMsg THEN
	xTmp:=	T_VisuQVis.T_CtrleVisu.xDone
			AND NOT(T_VisuQVis.T_CtrleVisu.xExecute)
			AND NOT(T_VisuQVis.T_CtrleVisu.xErr)
			AND (gT_PageNumber.iAutoMode_Process <> T_VisuQVis.T_PlcParam.dwActualPage)
			AND (gT_PageNumber.iAutoMode_ProcessValue1 <> T_VisuQVis.T_PlcParam.dwActualPage)
			AND (gT_PageNumber.iAutoMode_ProcessValue2 <> T_VisuQVis.T_PlcParam.dwActualPage)
			AND (gT_PageNumber.iAutoMode_PartQuality <> T_VisuQVis.T_PlcParam.dwActualPage)
			AND (TProcess.T_Ctrle.iFunctNr = 2)
			AND NOT(xForceCloseMessage) AND
			T_StartUp.T_State.xCompleted;
	IF xTmp THEN
		T_VisuQVis.T_CtrleVisu.iFunction:=1;
		T_VisuQVis.T_PlcParam.dwSetNewPage:=gT_PageNumber.iAutoMode_Process;
		T_VisuQVis.T_CtrleVisu.xExecute:=TRUE;
	END_IF;
END_IF;
(* Maschine Referenzierung Page muss aufgerufen werden, falls der Maschinen Referenzierung Aktiv ist und man nicht auf dieser Seite steht *)
IF xActiveInfoMsg OR xActiveErrorMsg OR xActiveWarningMsg THEN
	xTmp:=	T_VisuQVis.T_CtrleVisu.xDone
			AND NOT(T_VisuQVis.T_CtrleVisu.xExecute)
			AND NOT(T_VisuQVis.T_CtrleVisu.xErr)
			AND (gT_PageNumber.iAutoMode_Referencing <> T_VisuQVis.T_PlcParam.dwActualPage)
			AND (TProcess.T_Ctrle.iFunctNr = 1)
			AND NOT(xForceCloseMessage) AND
			T_StartUp.T_State.xCompleted;
	IF xTmp THEN
		T_VisuQVis.T_CtrleVisu.iFunction:=1;
		T_VisuQVis.T_PlcParam.dwSetNewPage:=gT_PageNumber.iAutoMode_Referencing;
		T_VisuQVis.T_CtrleVisu.xExecute:=TRUE;
	END_IF;
END_IF;

(* Acitvate Info Message Overlay *)
	IF xActiveInfoMsg OR xActiveInfoMsgIntern THEN
		CASE iStepFunctionMsg OF
		(* Check *)
		1:	T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;	(* Lock the navigation of the visu *)
			(* Overlay Message Error *)
			T_ExchgParam.T_SafetyCtrl.bStateMessageError:=0;
			T_ExchgParam.T_SafetyCtrl.bStateMessageInfo:=1;
			T_ExchgParam.T_SafetyCtrl.bStateMessageWarning:=0;
			T_ExchgParam.T_SafetyCtrl.iMsgInfoLine1:=iMsgNumber;
			T_ExchgParam.T_SafetyCtrl.iMsgInfoLine2:=iMsgNumber;
			T_ExchgParam.T_SafetyCtrl.iMsgInfoLine3:=iMsgNumber;
			T_ExchgParam.T_SafetyCtrl.iMsgInfoLine4:=iMsgNumber;
			T_ExchgParam.T_SafetyCtrl.xConfirmMsgInfo:=FALSE;
			(* next step *)
			iStepFunctionMsg:=iStepFunctionMsg + 1;
		2:	IF T_ExchgParam.T_SafetyCtrl.xConfirmMsgInfo OR xForceCloseMessage THEN
				xForceCloseMessage:=FALSE;
				T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;	(* Unlock the navigation of the visu *)
				T_ExchgParam.T_SafetyCtrl.bStateMessageInfo:=0;
				T_ExchgParam.T_SafetyCtrl.xConfirmMsgInfo:=FALSE;
				IF xActiveInfoMsg THEN
					T_StartUp.T_Ctrle.xDone:=TRUE;
					T_StartUp.T_Ctrle.xErr:=FALSE;
					T_StartUp.T_Ctrle.udiErrorID:=16#0;
				END_IF;
				xActiveInfoMsg:=FALSE;
				xActiveInfoMsgIntern:=FALSE;
				(* next step *)
				iStepFunctionMsg:=1;
				IF T_StartUp.T_Ctrle.xUnlockSecurityDoor THEN
					T_StartUp.T_Ctrle.xUnlockSecurityDoor:=FALSE;
					T_ExchgParam.T_SafetyCtrl.xOpenSecurityDoorMachine:=TRUE;
				END_IF;
			END_IF;
		END_CASE;
	END_IF;
	T_ExchgParam.T_SafetyCtrl.iMsgInfo_ColourState:=0;	(* Info Meldung mit grünem Hintergrund *)

(* Activate Error Message Overlay *)
	IF xActiveErrorMsg OR xActiveErrorMsgIntern THEN
		CASE iStepFunctionMsg OF
		(* Check *)
		1:	T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;	(* Lock the navigation of the visu *)
			(* Overlay Message Error *)
			T_ExchgParam.T_SafetyCtrl.bStateMessageError:=1;
			T_ExchgParam.T_SafetyCtrl.bStateMessageInfo:=0;
			T_ExchgParam.T_SafetyCtrl.bStateMessageWarning:=0;
			T_ExchgParam.T_SafetyCtrl.iMsgErrorLine1:=iMsgNumber;
			T_ExchgParam.T_SafetyCtrl.iMsgErrorLine2:=iMsgNumber;
			T_ExchgParam.T_SafetyCtrl.iMsgErrorLine3:=iMsgNumber;
			T_ExchgParam.T_SafetyCtrl.iMsgErrorLine4:=iMsgNumber;
			T_ExchgParam.T_SafetyCtrl.xConfirmMsgError:=FALSE;
			(* next step *)
			iStepFunctionMsg:=iStepFunctionMsg + 1;
		2:	IF T_ExchgParam.T_SafetyCtrl.xConfirmMsgError OR xForceCloseMessage THEN
				xForceCloseMessage:=FALSE;
				T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;	(* Unlock the navigation of the visu *)
				T_ExchgParam.T_SafetyCtrl.bStateMessageError:=0;
				T_ExchgParam.T_SafetyCtrl.xConfirmMsgError:=FALSE;
				IF xActiveErrorMsg THEN
					T_StartUp.T_Ctrle.xDone:=TRUE;
					T_StartUp.T_Ctrle.xErr:=FALSE;
					T_StartUp.T_Ctrle.udiErrorID:=16#0;
				END_IF;
				xActiveErrorMsg:=FALSE;
				xActiveErrorMsgIntern:=FALSE;
				(* next step *)
				iStepFunctionMsg:=1;
				IF T_StartUp.T_Ctrle.xUnlockSecurityDoor THEN
					T_StartUp.T_Ctrle.xUnlockSecurityDoor:=FALSE;
					T_ExchgParam.T_SafetyCtrl.xOpenSecurityDoorMachine:=TRUE;
				END_IF;
			END_IF;
		END_CASE;
	END_IF;

(* Activate Warning Message Overlay *)
	IF xActiveWarningMsg OR xActiveWarningMsgIntern THEN
		CASE iStepFunctionMsg OF
		(* Check *)
		1:	T_StartUp.T_State.xBlockChangeMovementVisu:=TRUE;	(* Lock the navigation of the visu *)
			(* Overlay Message Error *)
			T_ExchgParam.T_SafetyCtrl.bStateMessageError:=0;
			T_ExchgParam.T_SafetyCtrl.bStateMessageInfo:=0;
			T_ExchgParam.T_SafetyCtrl.bStateMessageWarning:=1;
			T_ExchgParam.T_SafetyCtrl.iMsgWarningLine1:=iMsgNumber;
			T_ExchgParam.T_SafetyCtrl.iMsgWarningLine2:=iMsgNumber;
			T_ExchgParam.T_SafetyCtrl.iMsgWarningLine3:=iMsgNumber;
			T_ExchgParam.T_SafetyCtrl.iMsgWarningLine4:=iMsgNumber;
			T_ExchgParam.T_SafetyCtrl.xConfirmMsgWarning:=FALSE;
			(* next step *)
			iStepFunctionMsg:=iStepFunctionMsg + 1;
		2:	IF T_ExchgParam.T_SafetyCtrl.xConfirmMsgWarning OR xForceCloseMessage THEN
				xForceCloseMessage:=FALSE;
				T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;	(* Unlock the navigation of the visu *)
				T_ExchgParam.T_SafetyCtrl.bStateMessageWarning:=0;
				T_ExchgParam.T_SafetyCtrl.xConfirmMsgWarning:=FALSE;
				IF xActiveWarningMsg THEN
					T_StartUp.T_Ctrle.xDone:=TRUE;
					T_StartUp.T_Ctrle.xErr:=FALSE;
					T_StartUp.T_Ctrle.udiErrorID:=16#0;
				END_IF;
				xActiveWarningMsg:=FALSE;
				xActiveWarningMsgIntern:=FALSE;
				(* next step *)
				iStepFunctionMsg:=1;
				IF T_StartUp.T_Ctrle.xUnlockSecurityDoor THEN
					T_StartUp.T_Ctrle.xUnlockSecurityDoor:=FALSE;
					T_ExchgParam.T_SafetyCtrl.xOpenSecurityDoorMachine:=TRUE;
				END_IF;
			END_IF;
		END_CASE;
	END_IF;

(* Löschen Aller Meldungen *)
	IF T_StartUp.T_Ctrle.xDeleteAllMessageOverlay AND (T_StartUp.T_State.xCompleted OR NOT(T_VisuQVis.T_CtrleVisu.xActive)) THEN
		T_StartUp.T_Ctrle.xDeleteAllMessageOverlay:=FALSE;
		xActiveInfoMsg:=xActiveInfoMsgIntern:=FALSE;
		xActiveErrorMsg:=xActiveErrorMsgIntern:=FALSE;
		xActiveWarningMsg:=xActiveWarningMsgIntern:=FALSE;
		T_ExchgParam.T_SafetyCtrl.bStateMessageError:=0;
		T_ExchgParam.T_SafetyCtrl.bStateMessageInfo:=0;
		T_ExchgParam.T_SafetyCtrl.bStateMessageWarning:=0;
		T_ExchgParam.T_SafetyCtrl.bStateMessageRequest:=0;
		T_ExchgParam.T_SafetyCtrl.bStateMessagePreWarning:=0;
		T_ExchgParam.T_SafetyCtrl.xConfirmMsgInfo:=FALSE;
		T_ExchgParam.T_SafetyCtrl.xConfirmMsgError:=FALSE;
		T_ExchgParam.T_SafetyCtrl.xConfirmMsgWarning:=FALSE;
		T_ExchgParam.T_SafetyCtrl.xConfirmMsgPreWarning:=FALSE;
		T_ExchgParam.T_SafetyCtrl.xConfirmMsgRequest:=FALSE;
		T_ExchgParam.T_SafetyCtrl.xConfirmMsgPartNumber:=FALSE;
		T_StartUp.T_State.xBlockChangeMovementVisu:=FALSE;
	ELSE
		T_StartUp.T_Ctrle.xDeleteAllMessageOverlay:=FALSE;
	END_IF;
END_ACTION

ACTION	StartUpFunction_ReadHW:
(* Function ReadHardware with NovRAM Parameter *)
	IF xReadHardware THEN
		CASE iStepFunction OF
		(* Start station, reset FB *)
		1:	T_HDD.T_Ctrle.xReset:=TRUE;
			T_NovRAM.T_Ctrle.xReset:=TRUE;
			T_Profile.T_Ctrle.xReset:=TRUE;
			T_Password.T_Ctrle.xReset:=TRUE;
			T_ProcessData_St1.T_Ctrle.xReset:=TRUE;
			xNovRamParameterReaded:=FALSE;
			(* next step *)
			iStepFunction:=10;
			xNovRamError:=FALSE;
		(* waiting reset confirmation *)
		10:	xTmp:=	T_HDD.T_Ctrle.xDone
					AND T_NovRAM.T_Ctrle.xDone;
			IF xTmp THEN  iStepFunction:=20; END_IF
		(* Keine DeviceId mehr *)
		20:	(* next step *)
			iStepFunction:=30;
		(* waiting ID confirmation, Start BoxID *)
		30:	iStepFunction:=40;
		(* Keine BoxId mehr *)
		40:	iStepFunction:=50;
		50:	IF NOT(gxHardwareOFF) THEN
				T_NovRAM.T_Ctrle.iFunction:=1;
				T_NovRam.T_Ctrle.xBlockReadFirstTime:=FALSE;
				T_NovRAM.T_Ctrle.xExecute:=TRUE;
				T_NovRAM.T_Ctrle.tTimeOut:=T#5s;		(* IGS *) (* ansonsten erscheint Timeout NovRAM beim Booten *)
			END_IF;
			iStepFunction:=60;
		60:	IF NOT(T_NovRAM.T_Ctrle.xExecute) AND T_NovRAM.T_Ctrle.xDone THEN
				T_VisuQVis.T_CtrleVisu.xReset:=TRUE;
				iStepFunction:=70;
			END_IF;
			IF NOT(T_NovRAM.T_Ctrle.xExecute) AND T_NovRAM.T_Ctrle.xErr THEN
				xNovRamError:=TRUE;
				T_VisuQVis.T_CtrleVisu.xReset:=TRUE;
				T_NovRAM.T_Ctrle.xReset:=TRUE;
				iStepFunction:=99;
			END_IF;
		(* end function or time out *)
		70:	IF T_VisuQVis.T_CtrleVisu.xDone THEN
				T_StartUp.T_Ctrle.xDone:=TRUE;
				T_StartUp.T_Ctrle.xErr:=FALSE;
				T_StartUp.T_Ctrle.udiErrorID:=0;
				xReadHardware:=FALSE;
				tTimeOutFunction:=T#0s;
				(* Start Boot *)
				T_StartUp.T_Ctrle.xExecute:=TRUE;
				T_StartUp.T_Ctrle.iFunction:=5;
				xNovRamParameterReaded:=TRUE;
			END_IF;
		END_CASE;
	END_IF;
	T_ExchgParam.T_Config.xNoTouchScreenBtPanel:=NOT(gxHardwareOFF);;
END_ACTION
















(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_USB_IO_PANEL
VAR
(* Panel tastatur *)
	(* function bloc *)
	fbCtrlePanel_IO:FBHW_PANEL_IO;
	(* IO connection *)

	IarxCtrlePanelButton AT %I* : ARRAY[1..10] OF BOOL;
	QarxCtrlePanelLed AT %Q* : ARRAY[1..10] OF BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(* Call FB *)
	fbCtrlePanel_IO(	arxButton:=IarxCtrlePanelButton,
					T_CtrlePanel:=T_CtrlePanel,
					arxLed=>QarxCtrlePanelLed);
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_VELOCITY_DETECTION
VAR
	ptrTCommonAxis : POINTER TO ST_AXIS;
	xTmp: BOOL;
	lrSaveZAxisVelocity: LREAL;
	lrMaxVelocity_Z_Axis: LREAL;
	xSLS_Z_Axis: BOOL;
	lrMaxVelocity_SetupA_Z_Axis:LREAL:=79.0;
	lrMaxVelocity_SetupB_Z_Axis:LREAL:=29.9;
END_VAR
(* @END_DECLARATION := '0' *)
Check_Station_Working;
gxSetSpeedInMovement:=FALSE;
END_PROGRAM
ACTION	Check_Station_Working:
IF gT_SafetyStatus.xSetupOperateModeActive THEN
	ptrTCommonAxis:=ADR(TStation_Work_St1.THWWorkStation.TAxisZ);
	IF (gT_SafetyStatus.iSetupMode = 1) THEN
		lrMaxVelocity_Z_Axis:=lrMaxVelocity_SetupA_Z_Axis;
		xSLS_Z_Axis:=T_TwinSafe_Status_Z_Axis_St1.xSLS1;
	ELSIF (gT_SafetyStatus.iSetupMode = 2) THEN
		lrMaxVelocity_Z_Axis:=lrMaxVelocity_SetupB_Z_Axis;
		xSLS_Z_Axis:=T_TwinSafe_Status_Z_Axis_St1.xSLS2;
	ELSE
		lrMaxVelocity_Z_Axis:=lrMaxVelocity_SetupA_Z_Axis;
		xSLS_Z_Axis:=T_TwinSafe_Status_Z_Axis_St1.xSLS1;
	END_IF;
	IF gT_SafetyStatus.xSecurityDoorOpen THEN
		xTmp:=	ptrTCommonAxis^.T_CtrleSingle.xExecute AND ptrTCommonAxis^.T_CtrleSingle.xDone AND ptrTCommonAxis^.T_CtrleSingle.xNotMoving AND
				((ptrTCommonAxis^.T_CtrleSingle.iFunction = 6) OR (ptrTCommonAxis^.T_CtrleSingle.iFunction = 7) OR (ptrTCommonAxis^.T_CtrleSingle.iFunction = 8));
		IF xTmp THEN
			IF (ABS(ptrTCommonAxis^.T_CtrleSingle.lrVelocity) >= lrMaxVelocity_Z_Axis) THEN
				lrSaveZAxisVelocity:=ptrTCommonAxis^.T_CtrleSingle.lrVelocity;
				IF (lrSaveZAxisVelocity >= 0) THEN
					ptrTCommonAxis^.T_CtrleSingle.lrVelocity:=lrMaxVelocity_Z_Axis - 0.1;
				ELSE
					ptrTCommonAxis^.T_CtrleSingle.lrVelocity:=(lrMaxVelocity_Z_Axis - 0.1) * -1.0;
				END_IF;
			END_IF;
		END_IF;
		xTmp:=	NOT(ptrTCommonAxis^.T_CtrleSingle.xExecute) AND ptrTCommonAxis^.T_CtrleSingle.xDone AND NOT(ptrTCommonAxis^.T_CtrleSingle.xNotMoving) AND (ptrTCommonAxis^.T_CtrleSingle.iFunction = 6);
		xTmp:=	xTmp OR (NOT(ptrTCommonAxis^.T_CtrleSingle.xExecute) AND NOT(ptrTCommonAxis^.T_CtrleSingle.xDone) AND NOT(ptrTCommonAxis^.T_CtrleSingle.xNotMoving) AND
				((ptrTCommonAxis^.T_CtrleSingle.iFunction = 7) OR (ptrTCommonAxis^.T_CtrleSingle.iFunction = 8))) OR gxSetSpeedInMovement;
		IF xTmp THEN
			IF (ABS(ptrTCommonAxis^.T_CtrleSingle.lrVelocity) >= lrMaxVelocity_Z_Axis) THEN
				lrSaveZAxisVelocity:=ptrTCommonAxis^.T_CtrleSingle.lrVelocity;
				ptrTCommonAxis^.T_CtrleSingle.lrVelocity:=lrMaxVelocity_Z_Axis - 0.1;
				ptrTCommonAxis^.T_CtrleSingle.iFunction:=12;
				ptrTCommonAxis^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
	ELSE
		xTmp:=	NOT(ptrTCommonAxis^.T_CtrleSingle.xExecute) AND ptrTCommonAxis^.T_CtrleSingle.xDone AND NOT(ptrTCommonAxis^.T_CtrleSingle.xNotMoving) AND (ptrTCommonAxis^.T_CtrleSingle.iFunction = 6);
		xTmp:=	xTmp OR (NOT(ptrTCommonAxis^.T_CtrleSingle.xExecute) AND NOT(ptrTCommonAxis^.T_CtrleSingle.xDone) AND NOT(ptrTCommonAxis^.T_CtrleSingle.xNotMoving) AND
				((ptrTCommonAxis^.T_CtrleSingle.iFunction = 7) OR (ptrTCommonAxis^.T_CtrleSingle.iFunction = 8)));
		IF xTmp THEN
			IF (ptrTCommonAxis^.T_CtrleSingle.lrVelocity <> lrSaveZAxisVelocity) AND (lrSaveZAxisVelocity <> 0) AND NOT(xSLS_Z_Axis) THEN
				ptrTCommonAxis^.T_CtrleSingle.lrVelocity:=lrSaveZAxisVelocity;
				ptrTCommonAxis^.T_CtrleSingle.iFunction:=12;
				ptrTCommonAxis^.T_CtrleSingle.xExecute:=TRUE;
			END_IF;
		END_IF;
	END_IF;
	IF (NOT(ptrTCommonAxis^.T_CtrleSingle.xExecute) AND ptrTCommonAxis^.T_CtrleSingle.xDone AND ptrTCommonAxis^.T_CtrleSingle.xNotMoving) OR ptrTCommonAxis^.T_CtrleSingle.xErr THEN
		lrSaveZAxisVelocity:=0.0;
	END_IF;
END_IF;
END_ACTION



(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis\/Axis_DC_KL2552' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_AXIS_FILE_OBJ_DCAXIS :
STRUCT
	sData: ARRAY[1..csiMaxAxisFileObj] OF STRING(80);
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis\/Axis_DC_KL2552' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_COMM_IN_DCAXIS :
STRUCT
	usiStatusWord :USINT;
	iDataIn :INT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis\/Axis_DC_KL2552' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_COMM_OUT_DCAXIS :
STRUCT
	usiControlWord :USINT;
	iDataOut :INT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis\/Axis_DC_KL2552' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CONFIG_GENERAL_DCAXIS :
STRUCT
	sDeviceName:STRING(32);
	sDeviceFileName:STRING(32);
	sServoNetId:STRING(23);		(* Beckhoff *)
	udiNodeId:UDINT;				(* Maxon *)
	iTyp:INT;
	lrScaleFactor:LREAL:=0.0;
	lrInitFactor:LREAL:=0.0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis\/Axis_DC_KL2552' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CONFIG_OBJECT_DCAXIS :
STRUCT
	diMaxMotorCurrent:DINT:=0;
	diNominalMotorCurrent:DINT:=0;
	diMotorResistor:DINT:=0;
	diKpSpeedControl:DINT:=0;
	diTnCurrentControl:DINT:=0;
	diMaxTorqueMotor:DINT:=0;
	xSpeedControlAcitv:BOOL:=FALSE;
	xCurrentControlAcitv:BOOL:=FALSE;
	xWinCurrentControlActiv:BOOL:=FALSE;
	xTorqueControlAcitv:BOOL:=FALSE;
	xOverVoltageActiv:BOOL:=FALSE;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis\/Axis_DC_KL2552' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLE_DCAXIS :
STRUCT
(* Input *)
	xExecute:BOOL:=FALSE;
	iFunction:INT:=0;
	xReset:BOOL:=FALSE;
	lrVelocity:LREAL:=0;
	tAcceleration:TIME:=T#0s;
	tDecceleration:TIME:=T#0s;
	iRegisterNr:INT:=0;
	iValueRegister:INT:=0;

(* Output *)
	xDone:BOOL:=FALSE;
	xErr:BOOL:=FALSE;
	udiErrorID:UDINT:=0;
	xPower:BOOL:=FALSE;
	xReady:BOOL:=FALSE;
	xNotMoving:BOOL:=FALSE;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis\/Axis_DC_KL2552' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_DC_AXIS :
STRUCT
	T_CtrleDCAxis : ST_CTRLE_DCAXIS;
	T_ParamFileObj:ARRAY[1..20] OF ST_PARAM_FILE_OBJ_DCAXIS;
	T_Config_Gen:ST_CONFIG_GENERAL_DCAXIS;
	T_Config_ObjFileValue:ST_CONFIG_OBJECT_DCAXIS;
	T_FileObj:ST_AXIS_FILE_OBJ_DCAXIS;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis\/Axis_DC_KL2552' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PARAM_FILE_OBJ_DCAXIS :
STRUCT
	iRegisterNr:INT:=0;
	iBitValue:INT:=0;
	lrReal:LREAL:=0;
	sName:STRING(20);
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_AXIS :
STRUCT
	T_CtrleSingle:ST_CTRLESINGLE;
	T_CtrleMulti:ST_CTRLEMULTI;
	T_ParamFileObj:ARRAY[1..40] OF ST_PARAM_FILE_OBJ;
	T_Config_Gen:ST_CONFIG_GENERAL;
	T_Config_ObjFileValue:ST_CONFIG_OBJECT;
	T_Config_Setting:ST_CONFIG_SETTING;
	T_LiveValue:ST_LIVEVALUE;
	T_Oscillation:ST_OSCILLATION;
	T_FileObj:ST_AXIS_FILE_OBJ;
	T_DriveState:ST_AXIS_DRIVESTATE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_AXIS_CTRLE :
STRUCT
	diVelocityCommandValue AT %QD1000	:DINT;	(* Verknüpfung mit E/A Ebene des Servos der Z Achse *)
	nOutData2 AT %ID1003 :ARRAY [0..1] OF UINT;	(* Verknüpfung mit NC Ebene des Servos der Z Achse *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_AXIS_DRIVESTATE :
STRUCT
	usiDriveState0:USINT;
	usiDriveState1:USINT;
	usiDriveState2:USINT;
	usiDriveState3:USINT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_AXIS_FILE_OBJ :
STRUCT
	sData: ARRAY[1..csiMaxAxisFileObj] OF STRING(80);
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_AXIS_LIVESTATE : (*Axis State struct  for HMI-Interface*)
STRUCT
	rActPos				:REAL;	(*PLC To HMI:actual position*)
	rActSpeed			:REAL;	(*PLC To HMI:actual speed*)
	bActState			:BYTE;	(*PLC To HMI:actual state*)
	rTeachPosStored		:REAL;	(*PLC To HMI:stored position according 'iTeachSelPos' *)
	rSWLimPos			:REAL;	(*SW-Limit positive value, Grenzwerte für HMI-Eingabe *)
	rSWLimNeg			:REAL;	(*SW-Limit negative value,Grenzwerte für HMI-Eingabe*)

	rSetSpeed			:REAL;	(*HMI To PLC:new speed setpoint*)
	rSetPos				:REAL;	(*HMI To PLC:new position setpoint*)
	iTeachSelPos		:INT;	(*HMI To PLC:actual  selection 'teach-list' *)

	xAxisSelect			:BOOL;	(* Anzeigen welche Achse ausgewählt ist *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CONFIG_GENERAL :
STRUCT
	sDeviceName:STRING(32);
	sDeviceFileName:STRING(32);
	sServoNetId:STRING(23);		(* Beckhoff *)
	sAmsNetId:T_AmsNetId;		(* Maxon *)
	udiNC_TaskIdxGrp:UDINT;		(* Beckhoff *)
	udiNodeId:UDINT;				(* Maxon *)
	iTyp:INT;
	wPosLimitSwitchBit:WORD;		(* Gilt nur für AX5xxx Antriebe und nur falls Endschalter belegt ist
								    Bei Single oder Dualservoantrieb gilt für Achse 1
									PosLimitSwitch:8
								    Bei Dualservoantrieb gilt für Achse 2
									PosLimitSwitch:32
								*)
	wNegLimitSwitchBit:WORD;		(* Gilt nur für AX5xxx Antriebe und nur falls Endschalter belegt ist
								    Bei Single oder Dualservoantrieb gilt für Achse 1
									NegLimitSwitch:16
								    Bei Dualservoantrieb gilt für Achse 2
									NegLimitSwitch:64
								*)
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CONFIG_OBJECT :
STRUCT
(* Object value *)
	lrMaxVelocity:LREAL;
	lrCalVelocityForward:LREAL;
	lrCalVelocityBackward:LREAL;
	lrAcceleration:LREAL;
	lrDecceleration:LREAL;
	lrJerk:LREAL;
	xSWLimitPos:BOOL;
	lrSWLimitPos:LREAL;
	xSWLimitNeg:BOOL;
	lrSWLimitNeg:LREAL;
	lrScaleFactor:LREAL;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CONFIG_SETTING :
STRUCT
	lrJogFast:LREAL;
	lrJogSlow:LREAL;
	lrJogStepFast:LREAL;
	lrJogStepSlow:LREAL;
	lrVelocityAbs:LREAL;
	lrVelocityRel:LREAL;
	lrVelocityProcess:LREAL;
	lrSpindleCurrentLimit:LREAL;
	xHardwareLimitPos:BOOL;
	xHardwareLimitNeg:BOOL;
	xSoftwareLimitPos:BOOL;
	xSoftwareLimitNeg:BOOL;
	lrHWLimitDecceleration:LREAL;
	rHCRampDeceleration:REAL;
	rHCRampJerk:REAL;
	xAbsoluteEncoder:BOOL;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLEMULTI :
STRUCT
(* Input *)
	xExecute:BOOL:=FALSE;
	xReset:BOOL:=FALSE;
	iNumerator:INT:=1;
	uiDenominator:UINT:=1;
	iFunction:INT:=0;

(* Ouput *)
	xDone:BOOL:=FALSE;
	xErr:BOOL:=FALSE;
	udiErrorID:UDINT:=0;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLESINGLE :
STRUCT
(* Input *)
	xExecute:BOOL:=FALSE;		(* Ausführen einer Achsen Funktion *)
	iFunction:INT:=0;				(*
								1=Achse Resetten
								2=Achsen Datei lesen
								3=Achsenstrom Einschalten-->Drehmoment ON
								4=Achsenstrom Ausschalten-->Drehmoment OFF
								5=Achsenbewegung stoppen
									-->lrDecceleration und lrJerk übergeben
								6=Geschwindigkeitsbewegung-->Sobald Drehzahl erreicht wird, dann wird das Endflag xDone gesetzt
									-->lrVelocity, lrAcceleration, lrDecceleration und lrJerk übergeben
								7=Absolute Bewegung-->Erst wenn Position erreicht wird, dann wird das Endflag xDone gesetzt
									-->lrPosition, lrVelocity, lrAcceleration, lrDecceleration und lrJerk übergeben
								8=Relative Bewegung-->Erst wenn der Weg abgefahren ist, dann wird das Endflag xDone gesetzt
									-->lrDistance, lrVelocity, lrAcceleration, lrDecceleration und lrJerk übergeben
								9=Achse Referenzieren-->Erst wenn Achse Referenziert ist, dann wird das Endflag xDone gesetzt
									-->rSetPosition für den Referenzoffset übergeben (restliche Parameter erfolgt über NC Parameter)
								10=Overrider der Geschwindigkeit in %
									-->dwOverride übergeben (...0.9=90%, 1.0=100%, 1.1=110%...)
								11=Überschreiben der Aktuellen Position
									-->rSetPosition übergeben
								12=Während Achse in Bewegung ist (Geschwindigkeit, Absolut, Relativ oder Modulo) kann eine neue Geschwindigkeit vorgegeben werden
									-->lrVelocity übergeben
								13=Referenzflag Manuell setzten
								14=Referenzflag Manuell zurück setzen
								15=Einschalten des Externen Sollwertgenerator. Die Achse übernimmt anschliessend die Sollwertvorgaben aus ihrem zyklischen Achsinterface
								       (fExtSetPos, fExtSetVelo, fExtSetAcc, nExtSetDirection)
								16=Ausschalten des Externen Sollwertgenerator
								17=Einschalten einer Oszillationsbewegung
									folgende Parameter müssen übergeben werden:
									-->T_Oscillation.rFrequence: Oszillationsfrequenz
									-->T_Oscillation.rOffset: Oszillationshub (positiver Wert: erste Bewegung in positiver Richtung! negativer Wert: erste Bewegung in negativer Richtung 
									-->T_Oscillation.iCycle: Anzahl Oszillationsperioden
								18=Während einer Absoluten Positionierung kann eine neue Position vorgegeben werden
									-->lrPosition muss übergeben werden
								19=Berechnung, mittels Achsbewegung, des Winkels zwischen Ref.Sensor und EncoderIndex
								20=Setzen der Default Achsen Parameter an der Achsenstruktur
								21=Senden der Achsenparameter (eingelsen über die Datei oder Default Achsen Parameter) an die NC Parameter
								22=Senden eines String über den ADS um Zugriff direkt auf die Servo Parameter
									-->sSend übergeben
								23=Achsdatei erstellen mit den Achse Parameter (ist nicht implementiert)
								24=Modulo Bewegung für z.B. Tellerpositionen anzufahren
									-->lrPosition, lrVelocity, lrAcceleration, lrDecceleration und lrJerk übergeben
								25=Einschalten des Positiven Software Endschalter (Position muss im System Manager manuell eingetragen werden)
								26=Ausschalten des Positiven Software Endschalter
								*)
	xReset:BOOL:=FALSE;			(* Zurücksetzen des Achsen Treiberbausteins *)
	lrPosition:LREAL:=0;			(* Positionsübergabe für Absolut oder Modulo Bewegung *)
	lrDistance:LREAL:=0;			(* Streckenübergabe für Relative Bewegung *)
	lrVelocity:LREAL:=0;			(* Geschwindigkeit in Technische Einheit für jegliche Bewegungen *)
	lrAcceleration:LREAL:=0;		(* Positive Beschleunigung für jegliche Bewegungen *)
	lrDecceleration:LREAL:=0;		(* Negative Beschleunigung für jegliche Bewegungen und Stopp Rampe *)
	lrJerk:REAL:=0;				(* Ruck für jegliche Bewegungen und Stopp Rampe *)
	dwOverride:DWORD:=100;		(* Overrider der Geschwindigkeit in % --> ...0.9=90%, 1.0=100%, 1.1=110%... *)
	rSetPosition:REAL:=0;			(* Setzen der Position für Referenzoffset oder überschreiben der Aktuellen Position *)
	rSetTorque:REAL:=0;			(* Festlegen des Drehmomentes für Maxon Motoren *)
	sSend:STRING(20):='';			(* Senden eines String über das ADS für Servoparameter *)
	lrScaleFactor:LREAL:=0;		(* Skalierungsfaktor für Technische Einheit *)
	rNominalSpeed:REAL:=0;		(* Nenndrehzahl für Maxon Motoren *)
	iModuloDirection:INT;			(*	Enum Werte:
									MC_Positive_Direction := 1,
    									MC_Shortest_Way :=2,
    									MC_Negative_Direction :=3,
    									MC_Current_Direction :=4
								*)
	lrHardwarePosition:LREAL;		(* Gilt für Absolut Encoder *)
	xMoveAwayFromHWLimitSwitchActive:BOOL;	(* Gilt für AX5000 Servo: Mittels diesem Signal = TRUE--> ermöglicht es die Achse auf den Endschalter zu fahren und dass man es über die Steuerung
												wieder vom Endschalter wegfahren kann. Ist es FALSE, dann muss die Achse von Hand vom Endschalter weggezogen werden *)
	xAX5000Active:BOOL;			(* FALSE = AX25xx, TRUE = AX5xxx *)
	xKL2541Active:BOOL;			(* TRUE = Schrittmotor KL2541 *)
(* Output *)
	xDone:BOOL:=FALSE;			(* Nach dem starten der Funktion wird es zu FALSE und sobald die Funktion beendet wird dann wird es auf TRUE gesetzt!
					    	    		    sollte ein Fehler entstehen, dann bleibt es auf FALSE bis der Baustein zurückgesetzt wird *)
	xErr:BOOL:=FALSE;			(* Sollte bei einer Funktion ein Fehler entstehen, dann wird dieser Flag gesetzt-->In diesem Fall wird das xDone Flag nicht gesetzt *)
	udiErrorID:UDINT:=0;			(* Fehlernummer, falls des xErr Flag gesetzt wird
									Fehler aus der NC Ebene:
									0x40nn=Allgemeine NC-Fehler
									0x41nn=Kanalfehler
									0x42nn=Gruppenfehler
									0x43nn=Achsfehler
									0x44nn=Geberfehler
									0x45nn=Reglerfehler
									0x46nn=Antriebfehler
									0x4Ann=Tabellenfehler	
									0x4Bnn=NC-SPS-Fehler
									-->Genaueres entnehme man aus den TwinCAT NC Fehlercodes!
									Fehlernummer des Treibers:
									16#F000=Aufgerufene Funktionsnummer gibt es nicht
									16#F100=Während der Aktiven StoppFunktion wurde eine andere (Ausnahme Reset) Funktion aufgerufen
									16#F101=Beim senden der Achsenparameter Funktion ist ein Timeout entstanden beim ein- oder ausschalten des Achsenstromes
									16#F102=Beim einschalten des Positiven Software Endschalter darf die Achse sich nicht bewegen
									16#F103=Beim einschalten des Positiven Software Endschalter darf die Achse nicht im Slave Mode betrieben sein
									16#F104=Timeout für das lesen der Achsen Parameter Datei->T_HDD ist gesperrt
									16#F105=Timeout für das schreiben der Achsen Parameter Datei->T_HDD ist gesperrt
									16#F106=Beim senden eines Achsenstring Funktion ist der empfangene String nicht gleichwertig wie der gesendete String-->Bestätigung des Servos Misslungen
									16#F201=Achsen Parameter Datei nicht gefunden
									16#F202=Falscher Syntax für eingelesener Achsen Parameter Datei
								*)
	xPower:BOOL:=FALSE;			(* Zeigt den Status des Motorstromes an-->TRUE=Strom ON, FALSE=Strom OFF *)
	xReady:BOOL:=FALSE;		(* Zeigt den Status ob der Servo bereit steht oder nicht-->TRUE=Servo Bereit, FALSE=Servo nicht Bereit *)
	xNotMoving:BOOL:=FALSE;		(* Zeigt den Status ob die Achse sich bewegt-->TRUE=Achse steht still, FALSE=Achse bewegt sich *)
	xMovingForward:BOOL:=FALSE;		(* Zeigt den Status ob die Achse sich in Positiver Richtung bewegt-->TRUE=Achse bewegt sich in Positiver Richtung *)
	xMovingBackwards:BOOL:=FALSE;	(* Zeigt den Status ob die Achse sich in Negativer Richtung bewegt-->TRUE=Achse bewegt sich in Negativer Richtung *)
	xRef:BOOL:=FALSE;			(* Zeigt den Status ob die Achse referenziert ist oder nicht-->TRUE=Achse Referenziert, FALSE=Achse nicht Referenziert *)
	xSlave:BOOL:=FALSE;			(* Zeigt den Status ob die Achse als Slave bei Master/Slave Verbindung aktiv ist-->TRUE=mit einer anderen Achse gekoppelt als Slave, FALSE=Standalone Betrieb oder Master *)
	xConstantVel:BOOL:=FALSE;	(* Zeigt den Status ob bei Achsbewegung die vorgegebene Drehzahl erreicht wurde-->TRUE=Drehzahl erreicht, FALSE=Drehzahl nicht erreicht *)
	xBusyNewPosAndVel:BOOL:=FALSE;	(* Zeigt den Status ob neue Geschwindigkeit oder Position Aktiv ist-->TRUE=Neue Geschw./Pos ist in Bearbeitung, FALSE=Keine neue Geschw./Pos in Bearbeitung *)
	xDriveTorque:BOOL:=FALSE;	(* Zeigt ob die Achse in Drehmomentbetrieb ist-->gilt für Maxon Motoren *)
	xSWLimitPos:BOOL:=FALSE;	(* Definiert ob die Achse einen Positiven Software Endschalter hat *)
	xSWLimitNeg:BOOL:=FALSE;	(* Definiert ob die Achse einen Negativen Software Endschalter hat *)
	xHWLimitPos:BOOL:=FALSE;	(* Definiert ob die Achse einen Positiven Hardware Endschalter hat *)
	xHWLimitNeg:BOOL:=FALSE;	(* Definiert ob die Achse einen Negativen Hardware Endschalter hat *)
	xStateHWLimitPos:BOOL:=FALSE;	(* Zeigt den Status des Positiven Software Endschalter-->TRUE=SW_PLS ON, FALSE=SW_PLS OFF *)
	xStateHWLimitNeg:BOOL:=FALSE;	(* Zeigt den Status des Negativen Software Endschalter-->TRUE=SW_NLS ON, FALSE=SW_NLS OFF *)
	xStateSWLimitPos:BOOL:=FALSE;	(* Zeigt den Status des Positiven Hardware Endschalter-->TRUE=HW_PLS ON, FALSE=HW_PLS OFF *)
	xStateSWLimitNeg:BOOL:=FALSE;	(* Zeigt den Status des Negativen Hardware Endschalter-->TRUE=HW_NLS ON, FALSE=HW_NLS OFF *)
	xSpindleBlocked:BOOL:=FALSE;	(* Zeigt an ob die Spindel blockiert ist-->gilt für Maxon Motoren *)
	iZAngleRefIndex:INT;		(* Gilt für die Prozedur für das einstellen des Referenzindex der Achse-->Für die Visu damit der Winkel angezeigt werden kann zwischen RefSensor und EncoderIndex *)
	xSWLimitSwitchPosActivated:BOOL:=FALSE;	(* Zeigt den Status ob der Positive Software Endschalter gesetzt wurde oder nicht *)
	xSlowFast:BOOL:=TRUE;		(* Zeigt an ob die langsame/schnelle geschwindigkeit oder kurzes/langes Inkrement für INK/JOG Bewegung ausgewählt ist-->gilt nur für ausserhalb des Treiberbausteins
									FALSE=langsame Geschwindigkeit(JOG) oder kurzes Inkrement(INK) 
									TRUE=schnelle Geschwindigkeit(JOG) oder langes Inkrement(INK)
								*)
	xJogInc:BOOL;	(* Umschaltung zwischen Jog und Ink *)
	sDeviceName:STRING(255);	(* Beckhoff oder Maxon für das konvertieren der eingelesenen Achsendatei *)
	xAxisCollisionError:BOOL;
	xHomingSensor:BOOL;			(* TRUE= Referenzsensor ON *)

(* Für Maxon ESCON Servocontroller *)
	iMaxVelocty	:UINT;(*Maximum rpm*)
	xAmplReady		:BOOL;
	xAmplPower		:BOOL;
	xStandstill		:BOOL;
	xSpindleOverloadError:BOOL;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_LIVEVALUE :
STRUCT
	dwState:DWORD;
	uiActualTorque:UINT;
	diActualTorqueCalc:DINT;	(* entsricht dem uiActualTorque, nur dass positiver und negativer Torque berücksichtigt wird *)
	lrActualVelocity:LREAL;
	lrActualPosition:LREAL;
	bDigitalInput:BYTE;
	lrSollPosition:LREAL;
	lrActualPositionNotModulo:LREAL;
	uiDigitalInput:UINT;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_OSCILLATION :
STRUCT
	rFrequence:REAL;
	rOffset:REAL;
	rPosTorqueLimitOffset:REAL;
	iCycle:INT;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Axis' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PARAM_FILE_OBJ :
STRUCT
	udiIdxGroup:UDINT:=0;
	udiIndexOffset:UDINT:=0;
	udiLength:UDINT:=0;
	lrReal:LREAL:=0;
	sName:STRING(20);
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/CollisionDetection' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_COLLISION_DETECTION :
STRUCT
(* Bearbeitungsstation *)
	xZAxisBrakeReleased:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Controller' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRL_PID_PARAM :
STRUCT
 	rCtrlCycleTime         : REAL;		(* Zykluszeit, mit der der Regelkreis bearbeitet wird. Der Funktionsbaustein berechnet mit dieser Eingangsgröße intern,
																	ob die Zustands- und Ausgangsgrößen im aktuellen Zyklus aktualisiert werden müssen. *)
 	rKp                    : REAL;					(* Reglerverstärkung / Reglerbeiwert *)
 	rKi                    : REAL; 			(* Nachstellzeit, wenn diese zu T#0s parametriert ist, wird der I-Anteil deaktiviert.*)
	rKd                    : REAL; 			(* Vorhaltzeit, wenn diese zu T#0s parametriert ist, wird der D-Anteil deaktiviert. *)
	rOutMaxLimit       : REAL;
 	rOutMinLimit         : REAL;
	xReset_I_Anteil:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Cylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_ANALOG :
STRUCT
(* input *)
	tDelayActiv:TIME;			(* Für die FunktionNr 2 lässt sich mittels dieser Zeit(falls <> 0s) die Impulsdauer festlegen, d.h. der Ausgang bleibt für diese Zeit gesetzt *)
	tDelayAfterSensor:TIME;	(* Für die FunktionNr 1 und 2 lässt sich mit Sensorüberwachung eine Zeit definieren welches nachdem der Sensor eintrifft bis das Flag xDone gesetzt wird *)
	iAnalogIN:INT;			(* Analog Wert 0 - 32767 (0 - 10V) welcher für den Ausgang übergeben wird *)
	rForceIn:REAL;			(* Technische Einheit-->wird intern im Zylinder Treiber nicht verwendet-->Ausserhalb muss die Umrechnung für den iAnalogIN erfolgen *)
	lrVoltageIN:LREAL;		(* Spannungswert in Volt (V) *)
	iRampFctOn:INT;			(* Rampe für FunktionNr 2 für das setzen des Analogen Ausganges
								1=Parabelfunktion
								2=e-Funktion
								3=Linearfunktion
							*)
	iRampFctOff:INT;			(* Rampe für FunktionNr 1 für das setzen des Analogen Ausganges
								1=Parabelfunktion
								2=e-Funktion
								3=Linearfunktion
							*)
	rStepValue:REAL;			(* Schrittgrösse für Rampe FunktionNr 1 und 2
							    	Wert 0 = Rampenfunktion ausgeschaltet
							*)
(* Output *)
	xActiv:BOOL;				(* Analogausgang = 0 --> FALSE
							    Analogausgang > 0 --> TRUE
							*)
	iAnalogOut:INT;			(* Analog Wert 0 - 32767 (0 - 10V) für Effektiven Wert welcher am Ausgang steht-->muss ausserhalb des Zylinder Treiber zugewiesen werden *)
	rForceOut:REAL;			(* Technische Einheit für Effektiven Wert welcher am Ausgang steht-->muss ausserhalb des Zylinder Treiber berechnet und zugewiesen werden *)
	rTorqueOut:REAL;			(* Technische Einheit für Effektiven Wert welcher am Ausgang steht-->muss ausserhalb des Zylinder Treiber berechnet und zugewiesen werden *)
	rPosOut:REAL;
	lrTorqueOut:LREAL;		(* Drehmoment in mNm *)
	tTimeActivOn:TIME;		(* Rampenfunktion Aktiv für FunktionNr 2 --> Zeigt abgelaufene Zeit für die Rampe *)
	tTimeActivOff:TIME;		(* Rampenfunktion Aktiv für FunktionNr 1 --> Zeigt abgelaufene Zeit für die Rampe *)
	rForceCalibrated:REAL;	(* Berechnete Kraft mit Abzug des Kalibrierungswertes *)
	rPosIn:REAL;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Cylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CONFIG :
STRUCT
	tDelayOn:TIME;		(* Zeitverzögerung beim einschalten des Zylinders mit der FunktionNr 2-->Timer startet zum Zeitpunkt wenn Ausgang gesetzt wird!
						    Braucht es nur falls die Überwachung des Sensors ausgeschaltet ist-->Nach Ablauf der Zeit wird dann das "xDone-Flag" gesetzt!
						    t=0-->Zeitverzögerung ausgeschaltet *)
	tDelayOff:TIME;		(* Zeitverzögerung beim ausschalten des Zylinders mit der FunktionNr 1-->Timer startet zum Zeitpunkt wenn Ausgang zurück gesetzt wird!
						    Braucht es nur falls die Überwachung des Sensors ausgeschaltet ist-->Nach Ablauf der Zeit wird dann das "xDone-Flag" gesetzt!
						    t=0-->Zeitverzögerung ausgeschaltet *)
	tDelayPreOn:TIME;	(* Zeitverzögerung vor dem einschalten des Zylinders mit der FunktionNr 2-->Nach Ablauf der Zeit wird dann der Ausgang gesetzt,
						    falls nicht auch noch die Zeit "tDelayOn" gesetzt ist!
						    t=0-->Zeitverzögerung ausgeschaltet *)
	tDelayPreOff:TIME;	(* Zeitverzögerung vor dem ausschalten des Zylinders mit der FunktionNr 1-->Nach Ablauf der Zeit wird dann der Ausgang zurück gesetzt,
						    falls nicht auch noch die Zeit "tDelayOff" gesetzt ist!
						    t=0-->Zeitverzögerung ausgeschaltet *)
	xCtrlePosOn:BOOL;	(* FALSE=Sensorüberwachung für FunktionNr 2 ausgeschaltet
						    TRUE=Sensorüberwachung für FunktionNr 2 eingeschaltet-->Mittels der Zeit "tTimeOut" wird festgelegt wie lange auf den Sensor gewartet wird
						     bis ein Fehler generiert wird *)
	xCtrlePosOff:BOOL;	(* FALSE=Sensorüberwachung für FunktionNr 1 ausgeschaltet
						    TRUE=Sensorüberwachung für FunktionNr 1 eingeschaltet-->Mittels der Zeit "tTimeOut" wird festgelegt wie lange auf den Sensor gewartet wird
						     bis ein Fehler generiert wird *)
	tTimeOut:TIME;		(* Gilt für Sensorüberwachung wie lange auf den Sensor gewartet werden muss bis ein Fehler generiert wird *)
	xActivState:BOOL;		(* FALSE=FunktionNr 1 setzt den Ausgang auf TRUE
								  FunktionNr 2 setzt den Ausgang auf FALSE
						    TRUE=FunktionNr 1 setzt den Ausgang auf FALSE
								  FunktionNr 2 setzt den Ausgang auf TRUE *)
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Cylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLECYL :
STRUCT
(* input *)
	xFBActiv:BOOL;	(* Aktivieren des Zylinder Treiberbausteins *)
	xExecute:BOOL;	(* Ausführen einer Zylinder Funktion *)
	xReset:BOOL;	(* Zurücksetzen des Zylinder Treiberbausteins-->Ausgänge werden auch zurückgesetzt *)
	iFunction:INT;		(*
						1=Zylinder ausschalten-->Grundstellung
						2=Zylinder einschalten
						4=Analogausgang setzen-->Gilt nur für die analogen Zylinderbausteine
						51=Invertieren des Zylinderausganges-->gilt für den Toggle Betrieb
					*)
(* output *)
	xDone:BOOL;			(* Nach dem starten der Funktion wird es zu FALSE und sobald die Funktion beendet wird dann wird es auf TRUE gesetzt!
					    	    sollte ein Fehler entstehen, dann bleibt es auf FALSE bis der Baustein zurückgesetzt wird *)
	xErr:BOOL;			(* Sollte bei einer Funktion ein Fehler entstehen, dann wird dieser Flag gesetzt-->In diesem Fall wird das xDone Flag nicht gesetzt *)
	udiErrorID:UDINT;		(* Fehlernummer, falls des xErr Flag gesetzt wird
							16#F000=Aufgerufene Funktionsnummer gibt es nicht
							16#F201=Bei FunktionNr 2 mit eingeschalteter Sensorüberwachung ist der Sensor nicht eingetroffen-->TimeOut
							16#F202=Bei FunktionNr 1 mit eingeschalteter Sensorüberwachung ist der Sensor nicht eingetroffen-->TimeOut
						*)
	xStatePosOn:BOOL;	(* Sensorzustand für FunktionNr 2 *)
	xStatePosOn1:BOOL;	(* Sensorzustand für FunktionNr 2 -->Falls zweiten Sensor vorhanden ist *)
	xStatePosOff:BOOL;	(* Sensorzustand für FunktionNr 1 *)
	T_Standard:ST_STANDARD;			(* Datenstruktur für Zylinder mit 1 oder 2 Digitalen Ausgänge *)
	T_Analog:ST_ANALOG;				(* Datenstruktur für Zylinder mit nur einem Servoventil *)
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Cylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CYLINDER :
STRUCT
	iCylinderTpye:INT:=0;		(* 1=CylToolDeflection, 2=CylToolTorque
							     Kann Applikationsbedingt spezifiziert werden *)
	T_Config:ST_CONFIG;		(* Datenstruktur für Grundfunktion aller Zylinder Treiber *)
	T_CtrleCyl:ST_CTRLECYL;	(* Datenstruktur für das Controlling der Zylinder *)
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Cylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CYLSTAT :  (*Cylinder Status structure to HMI*)
STRUCT
	xOn				:BOOL;
	xOff				:BOOL;
	bStat			:BYTE;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Cylinder' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_STANDARD :
STRUCT
(* Input *)
	tDelayActiv:TIME;			(* Für die FunktionNr 2 lässt sich mittels dieser Zeit(falls <> 0s) die Impulsdauer festlegen, d.h. der Ausgang bleibt für diese Zeit gesetzt *)
	tDelayAfterSensorOn:TIME;	(* Für die FunktionNr 2 lässt sich mit Sensorüberwachung eine Zeit definieren welches nachdem der Sensor eintrifft bis das Flag xDone gesetzt wird *)
	tDelayAfterSensorOff:TIME;	(* Für die FunktionNr 1 lässt sich mit Sensorüberwachung eine Zeit definieren welches nachdem der Sensor eintrifft bis das Flag xDone gesetzt wird *)
(* Output *)
	xActivOn:BOOL;			(* TRUE falls Ausgang gesetzt ist, anderenfalls FALSE *)
	xActivOff:BOOL;			(* TRUE falls Ausgang für Grundstellung gesetzt ist, anderenfalls FALSE
							     --> Gilt nur für Zylinder mit zwei Ausgänge *)
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/HDD' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLE_HDD :
STRUCT
(* input *)
	xExecute:BOOL:=FALSE;
	xReset:BOOL:=FALSE;
	iFunction:INT:=0;
	tTimeOut:TIME;
	xLocked:BOOL:=FALSE;

(* output *)
	xDone:BOOL:=FALSE;
	xErr:BOOL:=FALSE;
	udiErrorID:UDINT:=0;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/HDD' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_HDD :
STRUCT
	T_Ctrle:ST_CTRLE_HDD;
	T_Config:ST_HDD_CONFIG;
	T_File:ST_HDD_FILE;
	T_Data:ST_HDD_DATA;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/HDD' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_HDD_CONFIG :
STRUCT
	sNetId:T_AmsNetId;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/HDD' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_HDD_DATA :
STRUCT
	sData: ARRAY[1..csiMaxFileLine] OF STRING(csiMaxCharPerLine);
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/HDD' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_HDD_FILE :
STRUCT
	sPathAndFileName:STRING(255):='';
	sOldPathAndFileName:STRING(255):='';
	dwPtrWriteBuffer:DWORD:=0;
	udiLenBuffer:UDINT:=0;
	sDirectoryPath:STRING(255):='';
	cssRootPLC:STRING(255):='';
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Panel' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLEPANEL :
STRUCT
(* Input *)
	xExecute:BOOL:=FALSE;
	iFunction:INT:=0;
	xReset:BOOL:=FALSE;
(* output *)
	xDone:BOOL;
	xErr:BOOL;
	udiErrorID:UDINT;
	udiButton:UDINT:=0;
	udiLED:UDINT:=0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PASSWORD' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PASSWORD :
STRUCT
	T_Ctrle:ST_PASSWORD_CTRLE;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PASSWORD' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PASSWORD_CTRLE :
STRUCT
(* input *)
	xExecute:BOOL:=FALSE;
	xReset:BOOL:=FALSE;
	iFunction:INT:=0;
	sGetOperatorPassword : STRING;
	udiGetOperatorPassword : UDINT;
	udiSetOperatorPassword : UDINT;

(* Output *)
	xDone:BOOL:=FALSE;
	xErr:BOOL:=FALSE;
	udiErrorID:UDINT:=0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLE_PROCESS :
STRUCT
	iFunctNr : INT :=0;
	xEnable : BOOL := FALSE;
	xExecute : BOOL := FALSE;
	xDone : BOOL := FALSE;
	xStop : BOOL := FALSE;
	xRdy : BOOL := FALSE;
	xError : BOOL := FALSE;
	diErrorNr : DINT :=0;
	xErrorReady:BOOL;
	xQuitError : BOOL := FALSE;
	wStatus : WORD := 0;
	xAbordProcess : BOOL := FALSE;
	xReferenced : BOOL := FALSE;
	xActiveProcessState:BOOL:=FALSE;	(* Prozesszustand *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_FCT_PROCESS :
STRUCT
	iFunctNr : INT :=0;
	xExecute: BOOL := FALSE;
	xStop: BOOL := FALSE;
	xQuitError : BOOL := FALSE;
	xAbordProcess : BOOL := FALSE;
	xDone : BOOL := FALSE;
	xError : BOOL := FALSE;
	diErrorNr : DINT := 0;
	xErrorReady:BOOL;
	xSetEndFunction:BOOL;
	xReset:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PREWARNING :
STRUCT
	xToolNearChangeSt1:BOOL;			(* Dieses Signal besagt dass bald ein Werkzeug Wechsel vorgenommen werden muss *)
	xZAxisBrakeBlockedSt1:BOOL;		(* Dieses Signal besagt dass die Bremse der Z Achse blockiert ist *)

	asMessageBufferEngl:ARRAY [1..10,1..5] OF STRING(55);	(* Maximal 10 Meldungen können aufgenommen werden *)
	asMessageBufferGer:ARRAY [1..10,1..5] OF STRING(55);	(* Maximal 10 Meldungen können aufgenommen werden *)

	aiMessageNrBuffer:ARRAY [1..10] OF INT;			(* Maximal 10 Meldungen-->Nummer der Meldung *)
	xPreWarningActive:BOOL;							(* Dieses Signal besagt ob mindestens eine Vorwarnung besteht *)
	iNumberOfMessage:INT;								(* Anzahl eingetragenen Meldungen *)
	asEmptyMessageEngl:ARRAY [1..5] OF STRING(55);		(* Diese Meldung wird angezeigt wenn keine Warnungen vorhanden sind *)
	asEmptyMessageGer:ARRAY [1..5] OF STRING(55);		(* Diese Meldung wird angezeigt wenn keine Warnungen vorhanden sind *)
	aiDeleteMessage:ARRAY [1..10] OF INT;				(* Nummer zu löschende Meldung *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/PROCESS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PROCESS :
STRUCT
	T_Ctrle:ST_CTRLE_PROCESS;
	T_Fct:ST_FCT_PROCESS;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/ProcessData' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PROCESSDATA :
STRUCT
	T_Ctrle:ST_PROCESSDATA_CTRLE;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/ProcessData' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PROCESSDATA_CTRLE :
STRUCT
(* input *)
	xExecute:BOOL:=FALSE;
	xReset:BOOL:=FALSE;
	iFunction:INT:=0;
(* Output *)
	xDone:BOOL:=FALSE;
	xErr:BOOL:=FALSE;
	udiErrorID:UDINT:=0;
	tTimeElapsed:TIME;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Profile' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PROFILE :
STRUCT
	T_Ctrle:ST_PROFILE_CTRLE;
	T_Id:ST_PROFILE_ID;
	T_LoadProfileParameter:ST_RETAIN_DATA_PROFILEPARAMETER;	(* Profil Parameter für Profil(LoadData) *)
	T_ProcProfileParameter:ST_RETAIN_DATA_PROFILEPARAMETER;	(* Prozessabblid Parameter für Profil(Data) *)
	T_DefaultProfileParameter:ST_RETAIN_DATA_PROFILEPARAMETER;	(* Default Werte für OnlineChange und Prozess Parameter *)
	T_CopyProfileParameter:ST_RETAIN_DATA_PROFILEPARAMETER;					(* Braucht es nur damit die eingelesenen Werte eines Profils kopiert werden können *)
	T_Profile_MinMax:ST_PROFILEONLINECHANGE;
	T_IDProfileStation:ARRAY[1..csiMaxProfile] OF ST_PROFILE_ID;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Profile' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PROFILE_CTRLE :
STRUCT
(* input *)
	xExecute:BOOL:=FALSE;
	xReset:BOOL:=FALSE;
	iFunction:INT:=0;
	sPathAndFileName:STRING(255):='';
	sProfileName:STRING(30);
	xActiveReadProfileForCopy:BOOL;

(* Output *)
	xDone:BOOL:=FALSE;
	xErr:BOOL:=FALSE;
	udiErrorID:UDINT:=0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Profile' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PROFILE_ID :
STRUCT
	iNumber:INT;
	sName:STRING(30);
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Profile' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PROFILE_LIST :
STRUCT
	iNumber:INT;
	sName:STRING(30);
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Profile' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PROFILE_LIST_MANAGE :
STRUCT
	xListProfileUp:BOOL;
	xListProfileDown:BOOL;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Profile' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PROFILEONLINECHANGE :
STRUCT
	T_Max:ST_PROFILEONLINECHANGE_DATA;
	T_Min:ST_PROFILEONLINECHANGE_DATA;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Profile' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PROFILEONLINECHANGE_DATA :
STRUCT
	rTorqueLevelHC:REAL;								(* Schwellwert Drehmoment HC-->Gleichwertig wie konventionell ein HC ausgelöst wurde *)
	rForceDeflection:REAL;
	rWorkingSpeedForward:REAL;						(* Normalgeschwindigkeit ohne dass Schwellwert Drehoment Aktiv ist *)
	rWorkingOffsetBackward:REAL;
	rWorkingSpeedBackward:REAL;
	rWorkingSpindleSpeed:REAL;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Retain' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLE_DATA_RETAIN :
STRUCT
(* input *)
	xExecute:BOOL:=FALSE;
	xReset:BOOL:=FALSE;
	iFunction:INT:=0;
	udiSrcLen:UDINT;
	udiDestLen:UDINT;
	udipSrcAddr:UDINT;
	udipDestAddr:UDINT;
	tTimeOut:TIME;
	xBlockReadFirstTime:BOOL;

(* Output *)
	xFirstRead:BOOL:=FALSE;
	xDone:BOOL:=FALSE;
	xErr:BOOL:=FALSE;
	udiErrorID:UDINT:=0;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Retain' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_NOVRAM :
STRUCT
	T_Ctrle:ST_CTRLE_DATA_RETAIN;
	T_Parameter:ST_RETAIN_DATA;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Retain' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_RETAIN_DATA :
STRUCT
	T_Machine:ST_RETAIN_DATA_MACHINE;
	T_StationWork: ARRAY [1..1] OF ST_RETAIN_DATA_STATIONWORK;
	T_ErrorNrList:ST_RETAIN_ERROR_DATA;
	T_PartAnalysis:ARRAY [1..1] OF ST_PARTANALYSIS;

	arZ1AxisCalcEndPosSaveProfile:ARRAY [1..1,1..100] OF REAL;	(* Zu jedem Profil wird die Endposition für das Inkrementieren der Z EndPos gespeichert. So hat man die Möglichkeit wenn man das Profil ändert und dann wieder ein bestehendes Profil wieder laded und immer noch mit dem
															   gleichen Wz arbeitet, dass dieser Wert immer noch vorhanden ist. Wenn man aber für dieses Profil ein neues Wz einspannt, dann muss der Bediener den Zählerstand nullen, anderenfalls fährt es dann tiefer *)

	arZ1CentringCalcEndPosSaveProfile:ARRAY [1..1,1..100] OF REAL;	(* Zu jedem Profil wird die Endposition für das Inkrementieren der Z Zentrierpos gespeichert. So hat man die Möglichkeit wenn man das Profil ändert und dann wieder ein bestehendes Profil wieder laded und immer noch mit dem
															   gleichen Wz arbeitet, dass dieser Wert immer noch vorhanden ist. Wenn man aber für dieses Profil ein neues Wz einspannt, dann muss der Bediener den Zählerstand nullen, anderenfalls fährt es dann tiefer *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Retain' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_RETAIN_DATA_AX5000_PARAM :
STRUCT
	uiP61					: UINT;								(* Parameter P-0-0061 *)
	bP150					: ARRAY [0..227] OF BYTE;				(* Parameter P-0-0150 *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Retain' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_RETAIN_DATA_MACHINE :
STRUCT
	T_ParamSystem:ST_EXCHG_PARAM_SYSTEM;
	T_ParamAutomat:ST_EXCHG_PARAM_AUTOMAT;
	adiPotentiometerValue		:ARRAY [0..11] OF DINT;	(* Wert für Potentiometerstellung *)
	xEndlessProcessActive:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Retain' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_RETAIN_DATA_PROFILEPARAMETER :
STRUCT
	T_ProzessData:ST_EXCHG_PARAM_STANDARDPROCESS;
	T_ProfileOnlineChange:ST_PROFILEONLINECHANGE_DATA;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Retain' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_RETAIN_DATA_STATIONWORK :
STRUCT
	T_StProcess:ST_EXCHG_PARAM_STANDARDPROCESS;	(* Standard Parameter Prozessabbild ohne dass das Profile geändert wird-->Prozess arbeitet mit diesen Parameter *)
	T_OnlineChange:ST_PROFILEONLINECHANGE_DATA;	(* OnlineChange Parameter Prozessabbild ohne dass das Profile geändert wird-->Prozess arbeitet mit diesen Parameter *)
	T_OnlineChangeINC:ST_PROFILEONLINECHANGE_DATA;
	T_InfoProcess:ST_EXCHG_INFO_PROCESS;
	T_AxisState:ST_EXCHG_PARAM_AXIS_STATE;
	T_TorqueSystem:ST_EXCHG_PARAM_TORQUESYSTEM;					(* Maxon Spindel *)
	T_TorqueSystem_L:ST_EXCHG_PARAM_TORQUESYSTEM_L;				(* Beckhoff Spindel L *)
	T_TorqueSystem_M:ST_EXCHG_PARAM_TORQUESYSTEM_L;				(* Beckhoff Spindel M *)		(* IGS *)
	T_SpindleSystem:ST_EXCHG_PARAM_SPINDLESYSTEM;					(* Maxon Spindel *)
	T_SpindleSystem_L:ST_EXCHG_PARAM_SPINDLESYSTEM_L;				(* Beckhoff Spindel L *)
	T_SpindleSystem_M:ST_EXCHG_PARAM_SPINDLESYSTEM_L;				(* Beckhoff Spindel M *)		(* IGS *)
	T_Fct_SpindleBurnIn:ST_EXCHG_PARAM_SPINDLEBURNIN;
	T_Fct_SpindleCalibration:ST_EXCHG_PARAM_SPINDLECALIBRATION;
	T_ToolCounter:ST_EXCHG_PARAM_TOOLCOUNTER;
	T_WPCounter:ST_EXCHG_PARAM_WPCOUNTER;
	(* Zylinder Parameter für WorkStation MicroHead *)
	TCylBrakeReleaseZAxis:ST_EXCHG_PARAM_CYLINDER;
(* Gilt für das Aufzeichnen der Rotationsdauer der Spindel *)
	tSpindelActiveRotationTime:TIME;
	iSpindelActiveRotationDay:INT;
	tSpindel2ActiveRotationTime:TIME;										(* IGS *)
	iSpindel2ActiveRotationDay:INT;										(* IGS *)
	tSpindel3ActiveRotationTime:TIME;										(* IGS *)
	iSpindel3ActiveRotationDay:INT;										(* IGS *)
	T_RegulatorSpindle_SM:ST_EXCHG_PARAM_CONTRMOT;
	T_Z_TGuide:ST_EXCHG_PARAM_Z_TGUIDE;

	T_AxisS2:ST_RETAIN_DATA_AX5000_PARAM;	(* AX5000 Parameter *)		(* Beckhoff Spindel L *)		(* IGS *)
	T_AxisS3:ST_RETAIN_DATA_AX5000_PARAM;	(* AX5000 Parameter *)		(* Beckhoff Spindel M *)		(* IGS *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Retain' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_RETAIN_ERROR_DATA :
STRUCT
	adiErrorListMachine:ARRAY [1..20] OF DINT;
	asErrorTimeStampMachine:ARRAY [1..20] OF STRING(12);
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/StartUp' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLESTARTUP :
STRUCT
(* Input *)
	xExecute:BOOL;
	xReset:BOOL;
	iFunction:INT;
	iMsgNumber:INT;
	xUnlockSecurityDoor:BOOL;
	xSetSecurityStateON:BOOL;
	xDeleteAllMessageOverlay:BOOL;
(* Output *)
	xDone:BOOL;
	xErr:BOOL;
	udiErrorID:UDINT;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/StartUp' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_STARTUP :
STRUCT
	T_Ctrle:ST_CTRLESTARTUP;
	T_State:ST_STARTUPSTATE;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/StartUp' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_STARTUPSTATE :
STRUCT
	xPLCReady:BOOL;
	xCompleted:BOOL;
	xBlockChangeMovementVisu:BOOL;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/STATIC_ERROR_LIST' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_ERROR_LIST :
STRUCT
	asErrorListEnglish: ST_LANGUAGE_LIST;
	asErrorListDeutsch: ST_LANGUAGE_LIST;
	asErrorListFrancais: ST_LANGUAGE_LIST;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/STATIC_ERROR_LIST' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_LANGUAGE_LIST :
STRUCT
	T_LanguagList:ARRAY [1..300] OF STRING(100);
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/StationsControlling\/PART_ANALYSIS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PARTANALYSIS :
STRUCT
	sFileName:STRING;
	sStartOfProcess:STRING;
	sEndOfProcess:STRING;
	diActual_NumberHoleToWork:DINT;					(* Aktuell zu bearbeitende Bohrungsnummer *)

	abWorkPartQuality:ARRAY [1..ciMaxWP] OF BYTE;		(* 0=Hole not worked, 1=Go HC, 2=Go No HC, 3=NoGo minTime, 4=NoGo maxTime, 5=NoGo insert fail, 6=NoGo NoWP detect, 7=Working, 8=Cycle aborted *)
	arFirstHC:ARRAY [1..ciMaxWP] OF REAL;				(* Absolute Position der Z-Achse in mm beim ersten HC *)
	aiHCCounter:ARRAY [1..ciMaxWP] OF INT;			(* Anzahl HC *)
	aiHCCounterCentering:ARRAY [1..ciMaxWP] OF INT;			(* Anzahl HC während der Zentrierung *)
	aiHCCounterTorque:ARRAY [1..ciMaxWP] OF INT;		(* Anzahl HC *)
	aiHCCounterSpeed:ARRAY [1..ciMaxWP] OF INT;		(* Anzahl HC Geschwindigkeit *)		(* IGS *)
	adiCycleTime:ARRAY [1..ciMaxWP] OF DINT;			(* Zykluszeit in ms --> Beinhaltet Wstk Spannung, Spindeldrehung, Bearbeitung, Spindel stoppen und Wstk entspannen *)
	adiWorkTime:ARRAY [1..ciMaxWP] OF DINT;			(* Bearbeitungszeit --> Beinhaltet nur die effektive Bearbeitungszeit *)
	abInfeedCounterZ:ARRAY [1..ciMaxWP] OF BYTE;		(* Anzahl Einfädelversuche mit der Z Achse. Wenn erste mal durchgeht dann steht eine 1, wenn erst beim zweiten Versuch dann eine 2 usw. *)
	adiNumberHole:ARRAY [1..ciMaxWP] OF DINT;		(* WstkNummer *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/StationsControlling\/PART_ANALYSIS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PARTANALYSIS_OUTPUT :
STRUCT
	bHole_WorkPartQuality:BYTE;		(* 0=Hole not worked, 1=Go HC, 2=Go No HC, 3=NoGo minTime, 4=NoGo maxTime, 5=NoGo insert fail, 6=NoGo NoHole, 7=Working, 8=Cycle aborted *)
	rHole_FirstHC:REAL;				(* Absolute Position der Z-Achse in mm beim ersten HC *)
	iHole_HCCounter:INT;				(* Anzahl HC Deflection *)
	iHole_HCCounterCentering:INT;		(* Anzahl HC Deflection beim Zentrieren *)
	iHole_HCCounterTorque:INT;		(* Anzahl HC Drehmoment *)
	iHole_HCCounterSpeed:INT;		(* Anzahl HC Z Geschwindigkeit *)	(* IGS *)
	diHole_CycleTime:DINT;			(* Zykluszeit in ms --> Beinhaltet Wstk Spannung, Spindeldrehung, Bearbeitung, Spindel stoppen und Wstk entspannen *)
	diHole_WorkTime:DINT;			(* Bearbeitungszeit --> Beinhaltet nur die effektive Bearbeitungszeit *)
	bHole_InfeedCounterZ:BYTE;		(* Anzahl Einfädelversuche mit der Z Achse. Wenn erste mal durchgeht dann steht eine 1, wenn erst beim zweiten Versuch dann eine 2 usw. *)
	diHoleNumber:DINT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/StationsControlling\/STATION_WORK' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRL_ONLINECHANGE :
STRUCT
(* Online Change Synch *)
	xLockChange_Z_WorkSpeedForward:BOOL:=TRUE;
	xLockChange_Z_WorkSpeedBackward:BOOL:=TRUE;
	xLockChange_S_WorkSpindleSpeed:BOOL:=TRUE;
	xLockChangeCylToolTorqueLevel:BOOL:=TRUE;
	xLockChangeCylToolDeflectionForce:BOOL:=TRUE;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/StationsControlling\/STATION_WORK' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRL_WORK :
STRUCT
	rLastOverLimitPosition:REAL:=0.0;
	iOverLimitCounter:INT:=0;
	iOverLimitCounterCentering:INT:=0;
	iOverLimitCounterTorque:INT:=0;
	iOverLimitCounterSpeed:INT:=0;				(* IGS *)
	rDiffOverLimitPosition:REAL:=0.0;
	rActualFirstContactPosition:REAL:=0.0;
	rLastFirstContactPosition:REAL:=0.0;
	bPartQuality:BYTE; 	(* 0=Hole not worked, 1=Go HC, 2=Go No HC, 3=NoGo minTime, 4=NoGo maxTime, 5=NoGo insert fail, 6=NoGo NoWP detect, 7=Working, 8=Cycle aborted, 9=No WP, 10=NoGo HC Centr., 11=WP Centered *)
	rEffCycleTime : REAL;	(* Effektive Bearbeitungszeit-->Timer startet nach dem ersten Ausschlag-->sollte kein Ausschlag eintreffen dann ist diese Zeit = 0 *)
	rCuttingSpeed:REAL;	(* Schnittgeschwindigkeit *)

(* Drehmoment Ausgabe für den Prozess in Abhängigkeit der HubAchsen Position *)
	xActiveProcess_CylToolTorqueHC:BOOL;
	xBlockOutput_CylToolTorqueHC:BOOL;

	rTorqueHC:REAL;
	rTorqueAfterHC_Min:REAL;
	rTorqueAfterHC_Max:REAL;
	xTorqueLastHC:BOOL;
	xDeflectionLastHC:BOOL;
	iHCTorquePos:INT;
	iHCDeflectionPos:INT;
	xHCSparkOut:BOOL;

(* Regler *)
	rSpeedZ_V1:REAL;						(* IGS *)
	rSpeedZ_V3:REAL;						(* IGS *)
	rTorqueZ_S1:REAL;						(* IGS *)
	rTorqueZ_S4:REAL;						(* IGS *)
	iProgressBar_Torque:INT;					(* IGS *)
	iProgressBar_ZPos:INT;					(* IGS *)
	iProgressBar_ZVel:INT;					(* IGS *)
	xTorqueAfterHC_Min_Overlimit:BOOL;		(* IGS *)
	xTorqueAfterHC_Max_Overlimit:BOOL;		(* IGS *)

	xDoNotMoveZPosition:BOOL;

	xActiveProcess:BOOL;				(* Gilt nur für das Kühlmittel *)
	xStationBlocked:BOOL;				(* Gilt für die Werkzeugspannung, als Sicherheit für den Teller *)
	iStationBlockedErrNr:INT;			(* Gilt für die Werkzeugspannung, als Sicherheit für den Teller, welcher Aktuator aktiv ist *)
	xWorkingFinished:BOOL;
	xWorkingStarted:BOOL;

	xWorkStartToolRotation:BOOL;
	xWorkStopToolRotation:BOOL;

	rMaxToolSpindleSpeed:REAL;

	xStopToolRotation:BOOL;

(* Gilt für die Kalibrierungsporzedur-->mittels diesen Flag kann mittgeteilt werden ob ToolDeflection und/oder ToolTorque kalibriert werden muss *)
	xActiveCalibrateToolDeflection:BOOL;
	xActiveCalibrateToolTorque: BOOL;	(*  *)
	rOffsetToolDeflection:REAL;
	rOffsetToolTorque:REAL;

(* Gilt für das Aufzeichnen der Rotationsdauer der Spindel *)
	tSpindelActiveRotationTime:TIME;
	iSpindelActiveRotationDay:INT;
	tSpindel2ActiveRotationTime:TIME;			(* IGS *)
	iSpindel2ActiveRotationDay:INT;			(* IGS *)
	tSpindel3ActiveRotationTime:TIME;			(* IGS *)
	iSpindel3ActiveRotationDay:INT;			(* IGS *)

(* Gilt für die Ausfunkprozedur bezüglich der Kraftmessdose für das Drehmoment *)
	xSparkOutActive:BOOL;
(* Gilt für die Erstinitialisierung der Z Achse *)
	iInitialMode_Z_Axis:INT;
	lrSaveTeachedPosition:LREAL;

(* Ausgabe für Wstk Zähler Maschine und Stationen *)
	xAddWPCounter_Machine_IO:BOOL;		(* Inkrementiere Maschinen WstkZähler für IO Wstk *)
	xAddWPCounter_Machine_NIO:BOOL;	(* Inkrementiere Maschinen WstkZähler für NIO Wstk *)
	xAddToolCounter_Machine:BOOL;		(* Inkrementieren bearbeitete Bohrungen für den WzZähler *)

	xToolInfeeded:BOOL;	(* Besagt ob das Wz eingefädelt werden konnte *)

	xWP_Analyse_ActiveCycle:BOOL;			(* Zykluszeit für zu bearbeitende Bohrung ist gestartet *)
	xWP_Analyse_ActiveWork:BOOL;			(* Bearbeitungszeit für zu bearbeitende Bohrung ist gestartet *)
	xWP_Analyse_ReadyToReadData:BOOL;	(* Gilt für das Synchronisieren der Daten für die Wstk Daten Analyse *)
	xWP_Analyse_StartAutomat:BOOL;			(* Gilt für die Aufzeichnungsdatei, um festzulegen wann der Automat für das jeweilige Talon gestartet wurde *)
	xWP_Analyse_StopAutomat:BOOL;			(* Gilt für die Aufzeichnungsdatei, um festzulegen wann der Automat für das jeweilige Talon beendet wurde *)

	xLastTryInfeed:BOOL;

(* Gilt für die Blockierung der Achsenbremse *)
	xZAxisBrakeBlocked:BOOL;
	xBlockCheckAxisBrake:BOOL;

	rProcessWork:REAL;						(* Bearbeitungsarbeit *)		(* IGS *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/StationsControlling\/STATION_WORK' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_HW_WORKSTATION :
STRUCT
	xActiveStation:BOOL;
	TCtrlWork 						:ST_CTRL_WORK;

	TAxisZ 							:ST_AXIS;			(* Achse für die Hubachse Z *)
	TAxisS 							:ST_AXIS;			(* Achse für die Werkzeugspindel *)
	TCylToolDeflection				:ST_CYLINDER;		(* Servoventil für das bestimmen der vertikalen Auslenkraft für SM oder L Spindelkopf *)
	TCylToolTorqueHC 				:ST_CYLINDER;		(* Servoventil für Drehmomentüberwachung HC für SM oder L Spindelkopf *)
	TCylToolTorqueOverload 			:ST_CYLINDER;		(* Servoventil für Drehmomentüberwachung Überlast für SM oder L Spindelkopf *)
	TSensorTorque 					:ST_CYLINDER;		(* Analoger Sensor für Drehmoment detektion *)
	TSensorTorqueOverload 			:ST_CYLINDER;		(* Digitaler Sensor für Drehmoment Überlast detektion *)										(* IGS *)
	TTorqueSensorMeasRange		:ST_CYLINDER;		(* Controlling für den Drehmomentsensor, Einstellung des Drehmomentbereiches *)				(* IGS *)
	TTorqueSensorControl				:ST_CYLINDER;		(* Controlling für den Drehmomentsensor, Überprüfung auf Funktionalität *)						(* IGS *)
	TSensorToolSpindle_L_Connect 	:ST_CYLINDER;		(* Digitaler Sensor für Spindelkopf L angeschlossen *)
	TCylBrakeReleaseZAxis 			:ST_CYLINDER;		(* Zylinder für lösen der Bremse bei der Z Achse *)
	TCylWorkpieceClamp				:ST_CYLINDER;		(* Ventil für Werkstückfixierzylinder *)
	TValveAirTable					:ST_CYLINDER;		(* Ventil für die Luft des Tisches *)
	TValveVacuumTable				:ST_CYLINDER;		(* Ventil für die Luft des Tisches *)
	TValveCleanNozzle				:ST_CYLINDER;		(* Ventil für die Reinigungsduese *)														(* BEF *)
	TAxisBubbler						:ST_DC_AXIS;		(* Rührwerk für Suspension *)															(* IGS3 *)
	TAxisFeedPump					:ST_DC_AXIS;		(* Förderpumpe für Suspension *)														(* IGS3 *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/StationsControlling' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLE_STATION :
STRUCT
	xActiveStation : BOOL;
	xActiveHardware : BOOL;
	xHardwareConfigError : BOOL;
	iFunctNr : INT :=0;
	xEnable : BOOL := FALSE;
	xSecurityCircuitOn : BOOL := FALSE;
	xSecurityCircuitOff : BOOL := FALSE;
	xExecute : BOOL := FALSE;
	xDone : BOOL := FALSE;
	xStop : BOOL := FALSE;
	xStopCycle : BOOL :=FALSE;
	xRdy : BOOL := FALSE;
	xError : BOOL := FALSE;
	diErrorNr : DINT :=0;
	xQuitError : BOOL := FALSE;
	wStatus : WORD := 0;
	xAbord : BOOL := FALSE;
	xReferenced : BOOL := FALSE;
	xResetReference : BOOL :=FALSE;
	xSetReference : BOOL :=FALSE;
	xHWAxesActive : BOOL := FALSE;
	xActiveMovement : BOOL;
	xResetHardware:BOOL;
	xResetHardwareActivateCurrent:BOOL;
	xSaveParameterToNovRAM:BOOL;
	xBlockCheckZylinder:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/StationsControlling' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_STATION :
STRUCT
(* Controlling *)
	xActive : BOOL;
	iStationNr:INT;
	sStationName : STRING(30);
(* Layer 3 *)
	TControl : ST_CTRLE_STATION;
	TCtrlOnlineChange:ST_CTRL_ONLINECHANGE;
(* Layer 2 *)
	THWWorkStation 		:ST_HW_WORKSTATION;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Terminals' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_TERMINAL_STATE :
STRUCT
	wEtherCAT_1_State:WORD;				(* 0 =No Error *)
	wEtherCAT_2_State:WORD;				(* 0 =No Error *)
	wWCMasterAxisModul1_State:WORD;		(* 8 =Operational Mode (OP) *)
	wWCMasterAxisModul2_State:WORD;		(* 8 =Operational Mode (OP) *)
	wWCEPOS_State:WORD;					(* 8 =Operational Mode (OP) *)
	wWCSMCValve:WORD;					(* 8 =Operational Mode (OP) *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/TwinSAFE' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_SAFETY_STATUS :
STRUCT
(*Status, dependent to the Safety-Program, for use in PLC*)
	iSetupMode							:INT;(*1=Mode'A', 2=Mode'B', 0=NormalBetrieb'*)

	xSetupOperateModeActive			:BOOL;

	xEnergyONNormalMode				:BOOL;

	xEnergyONSetupModeASt1			:BOOL;

	xEnergyONSetupModeBSt1			:BOOL;

	xMachineDoorClose					:BOOL;

	xMachineEmergStopActive			:BOOL;

	xSecuritySwitch						:BOOL;
	xSecurityDoorOpen					:BOOL;		(* Maschinentüre und/oder Ladetüre offen *)
	xSecurityDoorClose					:BOOL;		(* Maschinentüre und Ladetüre geschlossen *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/TwinSAFE' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_TWINSAFE_CTRLE_IN :
STRUCT
	xTwinSAFE_Group_FB_Error_1: BOOL;
	xTwinSAFE_Group_COM_Error_1: BOOL;
	xTwinSAFE_Group_OUT_Error_1: BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/TwinSAFE' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_TWINSAFE_CTRLE_OUT :
STRUCT
	xTwinSAFE_Run_1: BOOL;
	xTwinSAFE_Reset_1: BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/TwinSAFE' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_TWINSAFE_DRIVE :
STRUCT
(* Standard Sicherheitsfunktionen *)
	xSTO: BOOL;		(* Safe Torque Off *)
	xSS1: BOOL;		(* Safe Stop1 *)
	xSS2: BOOL;		(* Safe Stop2 *)
	xSOS: BOOL;		(* Safe Operating Stop *)
	xSSR: BOOL;		(* Safe Speed Range *)
	xSDIp: BOOL;		(*Safe Direction Positive *)
	xSDIn: BOOL;		(* Safe Direction Negative *)
(* Zusätzliche Sicherheitsfunktionen *)
	xSLS1: BOOL;		(* Safe Limited Speed 1 *)
	xSLS2: BOOL;		(* Safe Limited Speed 2 *)
	xSSM: BOOL;		(* Safe Speed Monitor *)
	xSMS: BOOL;		(* Safe Maximum Speed *)
	xSLP: BOOL;		(* Safe Limited Position *)
	xSCA: BOOL;		(* Safe CAM *)
	xSLI: BOOL;		(* Safe Limited Increment *)
	xSAR: BOOL;		(* Safe Acceleration Range *)
	xSMA: BOOL;		(* Safe Maximum Acceleration *)
	xError: BOOL;		(* Errorausgabe oder Error Quittierung *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/TwinSAFE' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_TWINSAFE_FB_ERROR :
STRUCT
(*Fehlermeldungen der FB's in Safety-PLC*)
	xMON_EmergencyButtonMachine		:BOOL;	(* Diskrepanzfehler  Not Aus Taster Maschine *)
	xMON_Error_MachineDoor				:BOOL;	(* Diskrepanzfehler Sicherheitstüre der Maschine *)
	xMON_KeySwitchProcObservation		:BOOL;	(* Diskrepanzfehler Schlüsselschalter für Einrichtbetrieb Prozessbeobachtung Stellung I *)
	xMON_KeySwitchWorkStation			:BOOL;	(* Diskrepanzfehler Schlüsselschalter für Einrichtbetrieb Bearbeitungsstation Stellung II *)
	xMON_EnablingSwitchActive				:BOOL;	(* Diskrepanzfehler Zustimmschalter *)
	xMON_AxesCurrentOff					:BOOL;	(* Diskrepanzfehler Antriebsperrtaste *)
	xEDM_PowSup_MasterModul			:BOOL;	(* Fehler im Rückführkreis der Leistungsschütze der Z1 Achse (400V) *)
	xEDM_PowSup_24V					:BOOL;	(* Fehler im Rückführkreis des Sicherheitsrelais für 24V Speisung *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/TwinSAFE' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_TWINSAFE_IN :
STRUCT
(* EL1904, Input *)
	IxEmergencyStopButtonCh1:BOOL;			(* Notaus Taste Kanal 1 *)
	IxEmergencyStopButtonCh2:BOOL;			(* Notaus Taste Kanal 2 *)
	IxKeySwitchProcObservationCh1:BOOL;		(* Schlüsselschalter für Einrichtbetrieb Prozessbeobachtung Kanal 1, Stellung I *)
	IxKeySwitchProcObservationCh2:BOOL;		(* Schlüsselschalter für Einrichtbetrieb Prozessbeobachtung Kanal 2, Stellung I *)
	IxKeySwitchWorkStationCh1:BOOL;			(* Schlüsselschalter für Einrichtbetrieb Bearbeitungsstation Kanal 1, Stellung II *)
	IxKeySwitchWorkStationCh2:BOOL;			(* Schlüsselschalter für Einrichtbetrieb Bearbeitungsstation Kanal 2, Stellung II *)
	IxEnablingSwitchActiveCh1:BOOL;			(* Zustimmschalter, Stellung 2-Aktiv, K1 *)
	IxEnablingSwitchActiveCh2:BOOL;			(* Zustimmschalter, Stellung 2-Aktiv, K2 *)
	IxCabinDoorCloseCh1:BOOL;				(* Kabinentüre Maschine (Sicherheitstüre) geschlossen, Kanal 1 *)
	IxCabinDoorCloseCh2:BOOL;				(* Kabinentüre Maschine (Sicherheitstüre) geschlossen, Kanal 2 *)
	IxCabinDoorOpen:BOOL;					(* Kabinentüre Maschine (Sicherheitstüre) GEöffnet *)
	IxContactorAuxContact24V:BOOL;			(* Rückführkreis des Sicherheitsrelais für 24V Speisung *)
	IxAxesCurrentOffCh1:BOOL;					(* Externe Taste füR das Ausschalten der Achsen Energieversorgung, Kanal 1 *)
	IxAxesCurrentOffCh2:BOOL;					(* Externe Taste füR das Ausschalten der Achsen Energieversorgung, Kanal 2 *)
	IxContactorAuxContactMasterModul:BOOL;	(* Rückführkreis der Leistungsschütze Z1, S (400V) *)
	IxCabinDoorClose:BOOL;					(* Kabinentüre Maschine geschlossen, Näherungsschalter (Induktiv) *)
	IxReadyToOperateMasterModul1:BOOL;		(* Betriebsbereitschaftsausgabe von Z1  Achse (BTB) *)
	IxReadyToOperateMasterModul2:BOOL;		(* Betriebsbereitschaftsausgabe von S Achse (BTB) *)	(* IGS *)
	IxRes19:BOOL;							(* Reserve *)
	IxRes20:BOOL;							(* Reserve *)
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/TwinSAFE' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_TWINSAFE_OUT :
STRUCT
(* EL2904, Output *)
	QxContactorMasterModul400VCh1:BOOL;		(* Einschalten der Leistungsschütze  Z1-, S-Achse 400V, Kanal 1 *)
	QxContactorMasterModul400VCh2:BOOL;		(* Einschalten der Leistungsschütze  Z1-, S-Achse 400V, Kanal 2 *)
	QxContactor24VCh1:BOOL;					(* Einschalten des Sicherheitsrelais für 24V Speisung, Kanal 1 *)
	QxContactor24VCh2:BOOL;					(* Einschalten des Sicherheitsrelais für 24V Speisung, Kanal 2 *)
	QxEnablingAxisSpindle_St1:BOOL;			(* Freigabe Spindel Arbeitsstation *)
	QxEnablingSwitchLed:BOOL;				(* Zustimmschalter Bereitschaftsanzeige *)
	QxRes56:BOOL;							(* Reserve *)
	QxRes57:BOOL;							(* Reserve *)
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/UPS' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLE_UPS :
STRUCT
(* input variable *)
	xDIPDisable:BOOL:=TRUE;
	iDischargeLevel : USINT:=2;
	tDelay:TIME:=T#3s;
(* output variable *)
	xPowerFailure:BOOL;
	xShutdownActive:BOOL;
	xUPSReady:BOOL;
	x24VInOK:BOOL;
	xHolding:BOOL;
	tTimeUntilShutdown:TIME;
	eUPSState : E_UPS_STATE;
	xBlockSystem_PowerFail:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_BUTTON :
STRUCT
	xInputState:BOOL;
	xLedState:BOOL;
	xResetTime:BOOL;
	tPressTime:TIME;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CONFIGPAGE :
STRUCT
	sName:STRING(32);
	wMaskBtPanelLeft:WORD;
	wMaskBtPanelRight:WORD;
	wMaskFunctionPanel:WORD;
	wMaskTouchScreenNavPanel:WORD;
	(* process mask *)
	wMaskProcBtPanelLeft:WORD;
	wMaskProcBtPanelRight:WORD;
	wMaskProcFunctionPanel:WORD;
	(* functions *)
	aiRTrigActionPanelLeft:ARRAY[1..5] OF INT:=5(0);
	aiRTrigActionPanelRight:ARRAY[1..5] OF INT:=5(0);
	aiFTrigActionPanelRight:ARRAY[1..5] OF INT:=5(0);
	aiRTrigActionFunctionPanel:ARRAY[1..12] OF INT:=12(0);
	aiRTrigActionTouchScreenNavPanel:ARRAY[1..6,1..9] OF INT;	(* 6 Task und max 9 Seiten pro Task *)
	(* start/stop button *)
	xMaskBtStart:BOOL;
	xMaskBtStop:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLEACTION :
STRUCT
(* Input *)
	xExecute:BOOL;
	xReset:BOOL;
	iFunction:INT;
	xDeleteVisuFunction:BOOL;		(* Durch setzen dieses Signals wird die aufgerufene Visu Funktion zurückgesetzt *)
	xFunctionActive:BOOL;			(* Visufunktionen, die nicht die Ressource besetzen bestimmen mittels diesem Flag dass die Funktion aktiv ist *)
(* Output *)
	xDone:BOOL;
	xNotReady:BOOL;
	xErr:BOOL;
	udiErrorID:UDINT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLEBUTTON :
STRUCT
	T_Start:ST_BUTTON;
	T_Stop:ST_BUTTON;
	xForceSetStartButton:BOOL;		(* Gilt für Prozess oder Funktionen wo die Starttaste mehrere male gedrückt werden muss *)
	xForceSetStopButton:BOOL;		(* Gilt für Prozess bei Eingabeaufforderung, wo die Schicht 4 noch nicht aktiviert wurde *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLEPROCESS :
STRUCT
(* Input *)
	xExecute:BOOL;
	xReset:BOOL;
	iFunction:INT;
(* Output *)
	xDone:BOOL;
	xErr:BOOL;
	udiErrorID:UDINT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_CTRLEVISU :
STRUCT
(* Input *)
	xActive:BOOL;
	xExecute:BOOL;
	xReset:BOOL;
	iFunction:INT;
(* Output *)
	xDone:BOOL;
	xErr:BOOL;
	udiErrorID:UDINT;
	xQvis:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_ANALOGSENSOR :
STRUCT
	rActual_Position:REAL;
	rActual_Offset:REAL;
	rSaved_Position:REAL;
	iSelectHC_Position:INT;
	rMeasureDistance:REAL;
	rScaleFactor:REAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_AXIS :
(*Struct for 'manual' axis-Setup actions from/to HMI *)
STRUCT
	iSetup_AxisSel		:INT:=1;	(*  Achsen; Auswahl 1=Z, 2 & 3=S *)
	arAxis				:ARRAY [1..gcIAxisMax] OF ST_AXIS_LIVESTATE;

	xDisableAxisSelectButton	:BOOL;	(*Betätigung des 'AxisSelect Button' sperren*)
	xJogInc_Common_Setup_Axis		:BOOL;	(*Status zum Umschalten der 'Taskbar right' für Jog oder Ink-->erfolgt über die externe Taste *)
	arTeachSelStep:ARRAY [1..gcIAxisMax] OF REAL;	(*	1=Axis Z Schrittgrösse *)
	arTeachSelVel:ARRAY [1..gcIAxisMax] OF REAL;	(*	1=Axis Z Geschwindigkeit *)
	rTeachSelStep:REAL;	(* Anzeigen der Schrittgrösse der ausgewählten Achse *)
	rTeachSelVel:REAL;	(* Anzeigen der Geschwindigkeit der ausgewählten Achse *)

	arAxisCommon				:ST_AXIS_LIVESTATE;
	rAxisSSpeedCommon:REAL;
	rAxisOSpeedCommon:REAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_BTFUNCTIONPANEL :
STRUCT
	wState:WORD;
	wActivBt:WORD;
	wNotMasktext:WORD;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_BTPARAMETERLIST :
STRUCT
	wState:WORD;		(* Anzeigen welche Liste ausgewählt ist-->Liste 1-10-->2x1=Liste 1,2x10=Liste 2,2x100=Liste 3 usw. *)
	wActivBt:WORD;		(* Button für Auswahl der Parameterliste-->Liste 1-10-->2x1=Liste 1,2x10=Liste 2,2x100=Liste 3 usw. *)
	wNotMasktext:WORD;	(* Unterdrücken des Textes und disablen des Button der jeweiligen Liste-->Liste 1-10-->2x1=Liste 1,2x10=Liste 2,2x100=Liste 3 usw.-->wenn Bit gesetzt ist, dann wird es unterdrückt *)
	aiSelectText:ARRAY [1..15] OF INT;	(* Für jede Liste kann der entsprechende Text mittels einer definierten Nummer ausgewählt werden*)
	iEditParam:INT;					(* Nummer der anzuzeigenden Parameterliste-->gleiche Nummerierung wie bei aiSelectText *)
	bParameterListEditable:BYTE;		(* 0=unterdrückt die Listen Navigierung für die Auswahl der Parameterliste die Navigierung für die einzelnen Parameter-->Bei Task wo keine Parameterliste besten!
									    1=Parameter Liste ist Editierbar
									    2=Parameter Liste ist nicht Editierbar *)
	bMessageParameter:BYTE;		(* 0=Unterdrücken der Parameter Nachricht, 1=Nur mittels Operator Level, 2=Nur mittels System Level, 3=Keine Parameterliste vorhanden *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_CONFIG :
STRUCT
	xNoTouchScreenBtPanel:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_CYLINDER :
STRUCT
	iSelCyl_Setup		:INT;	(*angewaehlte funktion in Setup Mode , kann als Index verwendet werden fuer  folgende Statusarray*)
	arStat				:ARRAY [1..8] OF ST_CYLSTAT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_FUNCTION_COMMON :
STRUCT
	iFunctionNrMicrohead:INT;	(* 	1=Grundstellungsfahrt BearbStation
									2=S Axis EIN
									3=Wz Einfädeln
									4=Bearbeitungsprozess
									5=S Axis AUS *)
(* Setup Potentiometer *)
	adiPotentiometerValue					:ARRAY [0..11] OF DINT;	(* Wert für Potentiometerstellung *)
END_STRUCT
END_TYPE


(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_INFO_PROCESS :
STRUCT
	xOnlineValueModified:BOOL;
	iProfile:INT;
	sProfileName:STRING(30);

	tActualCycleTime:TIME;
	tLastCycleTime:TIME;
	tActualEffProcTime:TIME;
	tLastEffProcTime:TIME;
	rActualFirstContactPosition:REAL;
	rLastFirstContactPosition:REAL;
	rLastOverLimitPosition:REAL;
	rDiffOverLimitPosition:REAL;
	iOverLimitCounter:INT;
	iOverLimitCounterCentering:INT;
	iOverLimitCounterTorque:INT;
	iOverLimitCounterSpeed:INT;							(* IGS *)
	rCuttingSpeed:REAL;
	bLastDetectionSignal:BYTE;	(*	1=< Wz Auslenk. Sensor >
									2=< Wz Drehmom. HC>
									3=< Wz Drehmom. v >
									4=< Wz Auslenk.+Wz Drehm.HC >
									5=< Max. BearbArbeit >	*)
	bPartQuality:BYTE; 	(* 0=Hole not worked, 1=Go HC, 2=Go No HC, 3=NoGo minTime, 4=NoGo maxTime, 5=NoGo insert fail, 6=NoGo NoWP detect, 7=Working, 8=Cycle aborted, 9=No WP, 10=NoGo HC Centr., 11=WP Centered *)

	diWPNumber:DINT;

(* Gilt für die Anzeige der geleisteten Arbeit *)
	rProcessWork:REAL;			(* Bearbeitungsarbeit *)		(* IGS *)
	rActTorque:REAL;										(* IGS *)

	xTorqueLastHC:BOOL;									(* IGS *)
	rTorqueAfterHC_Min:REAL;								(* IGS *)
	rTorqueAfterHC_Max:REAL;								(* IGS *)
	xDeflectionLastHC:BOOL;								(* IGS *)
	rTorqueHC:REAL;										(* IGS *)
	rActualCycleTime:REAL;								(* IGS *)
	rActualEffProcTime:REAL;								(* IGS *)
	iHCTorquePos:INT;									(* IGS *)
	iHCDeflectionPos:INT;									(* IGS *)
	xHCSparkOut:BOOL;									(* IGS *)

	rTorqueMaxAfterWork:REAL;			(* Prozentanzeige des maximalen Drehmoment beim zurückfahren nach der Bearbeitung *)
	rTorqueMaxAfterWorkZPos:REAL;		(* Auf welcher Z Position beim zurückfahren das maximale Drehmoment erreicht wurde *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_LAMPTEST :
STRUCT
	xButtonLampIO:BOOL;
	xButtonLampNIO:BOOL;
	xButtonOK:BOOL;
	xShowSelectIONIOButton:BOOL;
	xShowLampTestResult:BOOL;
	sTextLinesEngl:ARRAY [1..18] OF STRING(90);
	sControlMessage1Engl:STRING(90);
	sControlMessage2Engl:STRING(90);
	sTextLines:ARRAY [1..18] OF STRING(90);
	sControlMessage1:STRING(90);
	sControlMessage2:STRING(90);

	abLedControlButton:ARRAY [1..6] OF BYTE;	(*	1=StartButtonLED
													2=StopButtonLED
													3=SetupButtonLED
													4=ReleasButtonLED
													5=SETUPLED
													6=RequestOpenDoorButtonLED
											*)
	abLedStationButton:ARRAY [1..6] OF BYTE;	(*	1=Station1LED
													2=Station2LED
													3=Station3LED
													4=Station4LED
													5=Station5LED
													6=Station6LED
											*)
	abLedControlLamp:ARRAY [1..3] OF BYTE;	(*	1=ControlLampGreen
													2=ControlLampRed
													3=ControlLampYellow
											*)
	abLedSetupLamp:ARRAY [1..2] OF BYTE;	(*	1=SetupLamp1
													2=SetupLamp2
											*)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_LEVEL :
STRUCT
	iActLevel:INT;
	diPwUser:DINT;
	diPwOperator:DINT:=-1;
	diPwOperatorSaved:DINT;
	diPwSystem:DINT:=-1;
	diRandom:DINT;

	diInputOldPasword:DINT;
	diInputNewPasword:DINT;
	diInputRepeatPasword:DINT;
	xButton_OK:BOOL;
	xButton_Abord:BOOL;
	xShow_Overlay_NewPassword:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_MESSAGE :
STRUCT
	iState:INT;
	iStateBIOS:INT;
	sDynamicTextEnglish:STRING(100);
	sDynamicTextDeutsch:STRING(100);
	sDynamicTextFrancais:STRING(100);
	xShowMessageInfo:BOOL;		(* Zeilenmeldung für Informationen *)
	xShowMessageInput:BOOL;		(* Zeilenmeldung für Eingabeaufforderung *)
	xShowMessageWarning:BOOL;	(* Zeilenmeldung für Warnungen *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_MESSAGE_LIST :
STRUCT
	asMsgErrorList:ARRAY [1..20] OF STRING(100);
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_AUTOMAT :
STRUCT
(* Gilt für das Aufzeichnen der Zeit des Automatik Prozess *)
	tAutoProcessTime_St1St2:TIME;		(* hh:mm:ss *)
	iAutoProcessDay_St1St2:INT;			(* Anzahl Tage *)
	tActualActiveTime_St1:TIME;	(* hh:mm:ss *)
	iActualActiveTime_St1:INT;		(* Anzahl Tage *)


	diNumberPartWorked_St1St2:DINT;

END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_AXIS_STATE :
STRUCT
	xReferencedZAxis:BOOL;	(* TRUE= Erstinitialisierung der Z Achse wurde durchgeführt *)

	rPositionReferenceZAxis:REAL;
	rPositionReferenceZAxis_Old:REAL;
	rPositionNegLimitSwitchZAxis:REAL;
	rPositionNegLimitSwitchZAxis_Old:REAL;

	rZDetectEndSwitchSpeed:REAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_BIOS :
STRUCT
	xReferencedZAxis_St1:BOOL;	(* TRUE= Erstinitialisierung der Z Achse wurde durchgeführt *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_CONTRMOT :
STRUCT
	iCurrentReg_PGain:INT;
	iCurrentReg_IGain:INT;
	iSpeedReg_PGain:INT;
	iSpeedReg_IGain:INT;
	iPositionReg_PGain:INT;
	iPositionReg_IGain:INT;
	iPositionReg_DGain:INT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_CYLINDER :
STRUCT
	rTimeAfterSensorON:REAL;
	rTimeAfterSensorOFF:REAL;
	rTimeOutError:REAL;
	rTimeDelayON:REAL;
	rTimeDelayOFF:REAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_ONLINECHANGE :
STRUCT
	T_Data:ST_PROFILEONLINECHANGE_DATA;
	T_DataValPercentAbs:ST_PROFILEONLINECHANGE_DATA;
	T_DataValPercentRel:ST_PROFILEONLINECHANGE_DATA;
	T_Inc:ST_PROFILEONLINECHANGE_DATA;
	T_Max:ST_PROFILEONLINECHANGE_DATA;
	T_Min:ST_PROFILEONLINECHANGE_DATA;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_SPINDLEBURNIN :
STRUCT
	rTimeSpindleActive:REAL;
	rTimeSpindleInactive:REAL;
	rTimeMaxActiveFunction:REAL;
	rSpindleSpeed:REAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_SPINDLECALIBRATION :
STRUCT
	arOffsetToolDeflection:ARRAY [1..5] OF REAL;	(* 1=Aktueller Offset, 2=vorgehender Offset usw *)
	arOffsetToolTorque:ARRAY [1..5] OF REAL;	(* 1=Aktueller Offset, 2=vorgehender Offset usw *)
	rEffectiveForceToolDeflection:REAL;
	rNullValueToolDeflection:REAL;
	rEffectiveForceToolTorque:REAL;
	rNullValueToolTorque:REAL;
	iSelectCalibrationCylinder:INT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_SPINDLESYSTEM :
STRUCT
	rPistonDiameterD1:REAL;		(* the spindle diameter d1 of the ToolDeflection  *)
	rPistonDiameterD2:REAL;		(* the spindle diameter d2 of the Tooldeflection  *)
	rMaxServoAirPressure:REAL;	(* max air pressure of the servo ventil *)
	rMaxDeflectionForce:REAL;		(* calculated max. force of the wire deflection *)
	rMaxServoVoltage:REAL;		(* maximale Ausgangsspannung der Analogen Klemme damit der maximale Druck erreicht wird *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_SPINDLESYSTEM_L :
STRUCT
	rPistonDiameterD1:REAL;		(* the spindle diameter d1 of the ToolDeflection  *)
	rPistonDiameterD2:REAL;		(* the spindle diameter d2 of the Tooldeflection  *)
	rMaxServoAirPressure:REAL;	(* max air pressure of the servo ventil *)
	rMaxDeflectionForce:REAL;		(* calculated max. force of the wire deflection *)
	rMaxServoVoltage:REAL;		(* maximale Ausgangsspannung der Analogen Klemme damit der maximale Druck erreicht wird *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_STANDARDPROCESS :
STRUCT
(* Position *)
	rPositionLoad:REAL;
	rPositionStartProc:REAL;
	rPositionEndProc:REAL;
	rPositionEndMech:REAL;
	rPositionToolChange:REAL;
	iHCStartProcPosCounter:INT;
(* Infeed Tool *)
	rInfeedZAxisSpeed:REAL;
	rInfeedSpindleSpeed:REAL;
	iNumberTryInfeed:INT;
	rInfeedOffsetBackward:REAL;
	rInfeedForceDeflection:REAL;
(* Spark out *)
	rSparkOutStrokeLength:REAL;
	iSparkOutStrokeCount:INT;
	rSparkOutStrokeSpeed:REAL;
	rSparkOutForceDeflection:REAL;
	rSparkOutTorqueLevel:REAL;		(* Schwellwert für Drehmoment beim Ausfunken-->für HC *)
(* Process time *)
	rProcessMinTime:REAL;
	rProcessMaxTime:REAL;
(* Outfeed *)
	rOutfeedStrokeAxisSpeed:REAL;
	rOutfeedSpindleSpeed:REAL;
(* Neu nicht mehr als OnlineChange Parameter definiert *)
	rDeflectionSensorOffset:REAL;
(* Drehmomentüberlast *)
	rTorqueLevel_Overload:REAL;
(* Progressiv Stroke *)
	rDistProgressStroke:REAL; 			(* [mm] Vertikale Distanz, welche das Intervall zwischen den Rueckzieher definiert *) (* BEF *)
	iProgressStrokeStartTorque:INT; 	(* [%] Notwendiges Drehmoment um den ersten Rueckhub zu erzwingen und somit die progressive Hubfunktion zu starten. In Prozent bezogen auf das Hard Contact Drehmoment (WzDrehm. HC) *) (* BEF *)
(* Abblasduese *)
	iCleanNozzleMode:INT; 			(*0=Duese nicht eingeschaltet,1= fuer positive Z1 Geschwindigkeiten eingeschaltet, 2=fuer negative Z1 Geschwindigkeiten eingeschaltet, 3=fuer jegliche Geschwindigkeiten eingeschaltet *) (* BEF *)
(* Positionen *)
	rPosToolGuid_Up:REAL;			(* Position des Schlitten des oberen Führungsrohr auf der oberen Position *)
	rPosToolGuid_Down:REAL;			(* Position des Schlitten des oberen Führungsrohr auf der untere Position *)
	rDistanceToolGuide:REAL;			(* Abstand zwischen dem unteren Führungsrohr und der Lufttischplatte *)
	rDistanceToolEndPos:REAL;		(* Abstand zwischen der Luft Tischplatte und der Werkzeug End Position *)
	rLengthTool_Fixed:REAL;			(* Einspannlänge *)
	rLengthTool_Work:REAL;			(* Bearbeitungslänge *)
	rLengthToolGuide:REAL;			(* Länge des oberen Führungsrohreinsatz *)
	rLengthAirTableBoard:REAL;		(* Höhe der Lufttischplatte gemessen von der Tischplatte aus *)
	xConfigActive:BOOL;				(* TRUE=Positionen der Z Achse mittel der Konfigurationswerte, FALSE=Positionen der Z Achse mittels getachte Werte *)

	iMaxTorque:INT;																									(* IGS *)
	rSpeedZAxisForBackward:REAL;	(* Z1 Geschwindigkeit, falls diese erreicht wird das künstlich ein Rückhub erzwingt wird *)		(* IGS *)
	rWorkingSpeedOscillation:REAL;																					(* IGS2 *)
	rZ1AxisPosSwitchOAxisOff:REAL;	(* Ausschaltpunkt für die O-Achse (Schnellhub) *)										(* IGS2 *)
	xActivateCoolantProcess:BOOL;																						(* IGS2 *)
	rStrokeAxisPosSwitchCoolantOff:REAL;																				(* IGS2 *)
(* Zentrieren *)
	rCentringPosZ1Axis:REAL;					(* Z1 Achse ZentrierPosition *)																(* IGS3 *)
	rCentringPosSpeedSlowZ1Axis:REAL;		(* Z1 Achse langsame Geschwindigkeit während dem Zentrieren *)								(* IGS3-->PUM: Name geändert *)
	rCentringPosSpeedFastZ1Axis:REAL;			(* Z1 Achse schnelle Geschwindigkeit während dem Zentrieren *)								(* PUM: Neu für Zentrierprozess *)
	rCentringSpeedSAxis:REAL;					(* S Achse Drehzahl während dem Zentrieren *)												(* IGS3 *)
	rCentringSpeedOAxis:REAL;					(* O Achse Geschwindigkeit während dem Zentrieren *)										(* IGS3 *)
	rCentringBackStrokeOffsetFirstHC:REAL;		(* Z1 Achse Rückhub Offset beim ersten HC während dem Zentrieren *)							(* IGS3-->PUM: Name geändert *)
	rCentringBackStrokeOffsetAfterFirstHC:REAL;	(* Z1 Achse Rückhub Offset nach dem ersten HC während dem Zentrieren *)					(* PUM: Neu für Zentrierprozess *)
	rCentringOffsetBeforeLastHC:REAL;			(* Z1 Achse zum letzten HC minus diesen Offset schnell anfahren während dem Zentrieren *)		(* PUM: Neu für Zentrierprozess *)
	rCentringBackStrokeSpeed:REAL;			(* Z1 Achse Rückhub Geschwindigkeit während dem Zentrieren *)								(* IGS3 *)
	rCentringTimeHCActive:REAL;				(* Ab dem ersten HC bei den nächsten HC wie lange maximal gewartet werden soll wenn der neue Auslenksensor angibt bis ein Rückhub erfolgen soll *)	(* PUM: Neu für Zentrierprozess *)
	rCentringTimeHCInactive:REAL;				(* Ab dem ersten HC bei den nächsten HC wie lange der neue Auslenksensor nicht mehr angeben soll bis es wieder langsam nach vorne fährt *)			(* PUM: Neu für Zentrierprozess *)
	iCentringNumberMaxHCinWindow:INT;		(* Anzahl HC im definierten Fenster die auftreten können bis nIO während dem Zentrieren *)		(* IGS3-->PUM: Neue definition *)
	rCentringHCWindow:REAL;					(* Fenster als Überwachung beim eintreffen der HC wie oft maximal in diesem Fenster eintreffen darf bis nIO während dem Zentrieren *)					(* PUM: Neu für Zentrierprozess *)
	rCentringForceDeflection:REAL;				(* Auslenk Kraft während dem Zentrieren *)													(* IGS3 *)
	rCentringOffsetBackward:REAL;				(* bei erreichen von ZentrierPos einen Offset zurück fahren *)									(* IGS3 *)
	rCenteringDeflectionSensorOffset:REAL;		(* Offset nach welchen Z Fahrweg der HC erst angeben darf *)									(* PUM: Neu für Zentrierprozess *)
	rCentringOffsetSlowToFastZSpeed:REAL;		(* Wie lange maximal die Z Achse beim zentrieren langsam fahren soll bis es auf die schnelle Geschwindigkeit schaltet *)	(* PUM: Neu für Zentrierprozess *)
	iCentringSelectProcess:INT;					(* 1=Konventioneller Zentrier Ablauf, 2=Ablauf mit Grauzone finden *)
(* Suspenstion *)
	rSuspensionBubblerSpeed:REAL;	(* Suspension DC Motor Rührer Geschwindigkeit *)										(* IGS3 *)
	rSuspensionFeederSpeed:REAL;	(* Suspension DC Motor Pumpe Geschwindigkeit *)										(* IGS3 *)
(* Neue Parameter für das Inkrementieren der Z1 EndPosition *)
	xPositionEndProcIncOnOff:BOOL;		(* Hier kann definiert werden ob die Inkrementierung Aktiv sein soll oder nicht. Wenn Wert 0 eingestellt ist, dann ist es wie gehabt *)
	rPositionEndProcMaxInc:REAL;	(* Die Maximale EndPosition die nicht überschritten werden darf beim Inkrementieren der Z1 Position nach jeder Bearbeitung *)
	rPositionEndProInc:REAL;			(* Um wie viel nach jeder Bearbeitung die Z1 EndPosition inkrementiert werden muss *)

(* Neue Reglertype für den Bearbeitungsprozess *)
	iWorkControlType:INT;	(* 0,1=konventionell, 2=Adaptive Vorschubsteuerung mit PID, 3=konevntionell mit PD Regler *)
	(* PID Regler für adaptive Vorschubsteuerung *)
	rZ_PID_Torque:REAL;
	rZ_PID_MinSpeed:REAL;
	rZ_PID_MaxSpeed:REAL;
	rZ_PID_Kp:REAL;
	rZ_PID_Ki:REAL;
	rZ_PID_Kd:REAL;
	iZ_PID_FilterM:INT;
	(* D Regler für konventioneller Regler *)
	rZ_D_Kd:REAL;
	iZ_D_FilterM:INT;

	rOutfeedStrokeAxisSpeedSlow:REAL;		(* Neuer Parameter für das zurückfahren am Prozessende wo man eine langsame Geschwindigkeit definieren kann und nach dem abfahren des Offset mit der normalen Geschwindigkeit zurückfährt *)
	rZ1AxisPosSwitchFastVel:REAL;			(* Neuer Parameter für das zurückfahren am Prozessende nach welcher Z1 Position dann mit der schnellen Geschwindigkeit umstellen soll *)
	rZ1AxisOffsetStartRecordTorque:REAL;		(* Neuer Parameter für das zurückfahren am Prozessende nach welcher Z1 Position die Aufzeichnung für das maximale Drehmoment gestartet werden soll *)

(* Neue Parameter für das Inkrementieren der Z1 Zentrier Position *)
	xCentringEndProcIncOnOff:BOOL;		(* Hier kann definiert werden ob die Inkrementierung in der Zentrierung Aktiv sein soll oder nicht. Wenn Wert 0 eingestellt ist, dann ist es wie gehabt *)
	rCentringEndProInc:REAL;				(* Um wie viel nach jeder Zentrierung die Z1 EndPosition inkrementiert werden muss *)

(* Neue Parameter für den Regler für die Spindel S Achse und der O Achse *)
	rWorkingSpindleSpeedMinMax:REAL;	(* Spindel Regler ist Aktiv wenn dieser Wert nicht gleich Null ist *)
	rO_Ctrl_TorquePercent_OFF:REAL;	(* Schnellhub Regler --> Wenn dieser Schwellwert des Drehmomentes erreicht wird, dann wird der Schnellhub ausgeschaltet und mittels der Hilfe der Hysterese Offset wieder eingeschaltet wird *)
	rO_Ctrl_HystereseOffset:REAL;		(* Schnellhub Regler Aktiv wenn dieser Parameter nicht den Wert Null ist. Ist der Wert Positiv, dann muss das Drehmoment ansteigen damit es den Schnellhub wieder einschaltet. Wert Negativ dann muss es abklingen damit es wieder einschaltet *)

(* Neue Parameter für Abbruchkriterium für den Zylindrischen Bereich *)
	rZPositionCylindricalArea:REAL;			(* Hier bestimmt man für die Z Achse wo der Zylindrische Bereich des Werkzeuges anfängt. Wenn der Wert Null beträgt dann gilt der konventionelle Ablauf *)
	rZMinThresholdTroqueEndProcess:REAL;	(* Hier gibt man den Schwellwert an wo unterschritten werden muss wenn die Z Achse im zylindrischen Bereich ist wo dann als Prozessende gilt *)
	rZPositionCylindricalAreaStop:REAL;		(* Auf welcher Z Position im zylindrischen Bereich der Schwellwert unterschritten wurde *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_SYSTEM :
STRUCT
	xActive_ProfilLoadNormalMode:BOOL;
	xDataFileActive:BOOL;
	iMachineNumber:INT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_TEACHIN :
STRUCT
	rIncSlow:REAL;
	rIncFast:REAL;
	rVelSlow:REAL;
	rVelFast:REAL;
	rRefPosition:REAL;
	rRefSpeed:REAL;
	rPositionSpeed:REAL;
	rAcceleration:REAL;
	rDeceleration:REAL;
	rJerk:REAL;
	rDecelerationEmergency:REAL;
	rJerkEmergency:REAL;
	xResetActiveTime: BOOL;
END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_TOOLCOUNTER :
STRUCT
	diMaxNumberToolCycle:DINT;			(* Max Anz. WzZyklen *)
	diToolCycleCounter:DINT;				(* WzZyklen Zählerstand *)
	diWarningAtToolCycleCounter:DINT;		(* Warnung bei Zählerstand *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_TORQUESYSTEM :
STRUCT
	rGearRatioGearBox:REAL;					(* Übersetzungsverhältnis des Differentialgetriebe *)
	rPlanetCarrier_Radius:REAL;				(* Radius des Planetenträger *)
	rGearRatioRocker:REAL;					(* Übersetzungsverhältnis der Wippe *)
	rGearRatioSpindleMotor:REAL;				(* Übersetzungsverhältnis des Motorgetriebe *)

	rPistonTorqueHC:REAL;					(* Kolbendurchmesser für HC Drehmoment *)
	rMaxServoAirPressure_HC:REAL;			(* max air pressure of the servo ventil *)
	rMaxServoVoltage_HC:REAL;				(* maximale Ausgangsspannung der Analogen Klemme damit der maximale Druck erreicht wird *)
	rMaxTorque_HC:REAL;					(* calculated max. force of the tool torque *)

	rPistonTorqueHCOverload:REAL;			(* Kolbendurchmesser für HC Überlast Drehmoment *)
	rMaxServoAirPressure_HCOver:REAL;		(* max air pressure of the servo ventil *)
	rMaxServoVoltage_HCOver:REAL;			(* maximale Ausgangsspannung der Analogen Klemme damit der maximale Druck erreicht wird *)
	rMaxTorque_HCOver:REAL;				(* calculated max. force of the tool torque *)

(* Parameter für analoger Drehmomentsensor *)
	rTorquePosition_HC:REAL;
	rTorquePosition_HCOverload:REAL;
	rTorqueScaleFactor:REAL;
	rMeasureDistance:REAL;

	rActual_Torque:REAL;						(* Aktuelles Drehmoment der Drehmomentfeder in mNm *)			(* IGS *)
	rMaxTorque:REAL;						(* Berechnete maximales Drehmoment in mNm *)					(* IGS *)
END_STRUCT
END_TYPE



(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_TORQUESYSTEM_L :
STRUCT
	rActual_Torque:REAL;						(* Aktuelles Drehmoment der Drehmomentfeder in mNm *)			(* IGS *)
	rMaxTorque:REAL;						(* Berechnete maximales Drehmoment in mNm *)					(* IGS *)

	rMinTorqueLevel:REAL;					(* Drehmoment dass gemessen werden muss, welches den Nullpunkt oder resp. den minimale Drehmoment ergibt *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_WPCOUNTER :
STRUCT
	diWPCounter_IO_NIO:DINT;		(* WstkZähler tagesaktuell (iO+niO) *)
	diWPCounter_IO_Actual:DINT;	(* WstkZähler tagesaktuell (iO) *)
	diWPCounter_IO_Reset:DINT;	(* WstkZähler rücksetzbar (iO) *)
	diWPCounter_NIO_Actual:DINT;	(* WstkZähler tagesaktuell (niO) *)
	diWPCounter_NIO_Reset:DINT;	(* WstkZähler rücksetzbar (niO) *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARAM_Z_TGUIDE :
STRUCT
	rOffset_Z_ToolGuide:REAL;				(* Offset für die Abhängigkeit zwischen der Z Achse und dem Massstab des oberen Führungsrohr zu bestimmen *)
	rOffset_Z_ToolGuide_Old:REAL;			(* Offset für die Abhängigkeit zwischen der Z Achse und dem Massstab des oberen Führungsrohr zu bestimmen-->vorheriger Wert *)
	rDistanceTGuideToTableBoard:REAL;	(* Distanz zwischen der Platte des oberen Führungsrohr und der Tischplatte *)
	rScaleDefinedPos:REAL;					(* Definierte Position des Massstabes *)
	rToolLengthSetup:REAL;					(* Werkzeuglänge für die Einrichtung um den Offset zu bestimmen *)
	rDistanceTGuideToTableBoardLess:REAL;	(* Distanz zwischen oberen Führungsrohr und der Tischplatte *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PARTQUALITY :
STRUCT
	bPartQualityStation: BYTE;				(* 0=Hole not worked, 1=Go HC, 2=Go No HC, 3=NoGo minTime, 4=NoGo maxTime, 5=NoGo insert fail, 6=NoGo NoWP detect, 7=Working, 8=Cycle aborted, 9=No WP, 10=NoGo HC Centr., 11=WP Centered *)
	rActualFirstHCPositionStation:REAL;
	iHCCounterStation: INT;
	iHCCounterCenteringStation: INT;
	iHCCounterTorqueStation: INT;
	iHCCounterSpeedStation: INT;			(* IGS *)
	tCycleTimeStation: TIME;
	tWorkTimeStation: TIME;
	bInfeedCounterZ:BYTE;				(* Anzahl Einfädelversuche mit der Z Achse. Wenn erste mal durchgeht dann steht eine 1, wenn erst beim zweiten Versuch dann eine 2 usw. *)

	diActual_NumberHoleToWork:DINT;		(* Aktuell zu bearbeitende Bohrungsnummer *)
	sFileName:STRING(28);				(* Aktuelle Dateiname *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_PROFILE_COMMON :
STRUCT
(* State *)
	xImportProzessData:BOOL:=FALSE;
(* Array *)
	T_Id:ST_PROFILE_ID;
	T_ProfileManage:ST_PROFILE_LIST_MANAGE;
	T_ProfileList:ARRAY[1..5] OF ST_PROFILE_LIST;
	T_OnlineChange:ST_EXCHG_PARAM_ONLINECHANGE;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_SAFETY_CTRL :
STRUCT
	bStateMessageError:BYTE;
	bStateMessageInfo:BYTE;
	bStateMessageWarning:BYTE;
	bStateMessagePreWarning:BYTE;
	bStateMessageRequest:BYTE;
	xMessageActive:BOOL;		(* IGS sobald eine Overlay MessageBox aktiv ist, wird diese Variable TRUE *)
	xConfirmMsgError:BOOL;
	xConfirmMsgInfo:BOOL;
	xConfirmMsgWarning:BOOL;
	xConfirmMsgPreWarning:BOOL;
	xConfirmMsgRequest:BOOL;
	xConfirmMsgPartNumber:BOOL;
	xResetMsgPreWarning:BOOL;
	iMsgErrorLine1:INT;
	iMsgErrorLine2:INT;
	iMsgErrorLine3:INT;
	iMsgErrorLine4:INT;
	iMsgWarningLine1:INT;
	iMsgWarningLine2:INT;
	iMsgWarningLine3:INT;
	iMsgWarningLine4:INT;
	iMsgInfoLine1:INT;
	iMsgInfoLine2:INT;
	iMsgInfoLine3:INT;
	iMsgInfoLine4:INT;
	sDynMsgPreWarningLine1Engl:STRING(55);
	sDynMsgPreWarningLine2Engl:STRING(55);
	sDynMsgPreWarningLine3Engl:STRING(55);
	sDynMsgPreWarningLine4Engl:STRING(55);
	sDynMsgPreWarningLine5Engl:STRING(55);
	sDynMsgPreWarningLine1Ger:STRING(55);
	sDynMsgPreWarningLine2Ger:STRING(55);
	sDynMsgPreWarningLine3Ger:STRING(55);
	sDynMsgPreWarningLine4Ger:STRING(55);
	sDynMsgPreWarningLine5Ger:STRING(55);
	xReadNextPreWarningMessage:BOOL;
	xReadPreviousPreWarningMessage:BOOL;
	xSelect_ToolChange_St1:BOOL;
	bState_Select_St1:BYTE;	(* 1= Station 1 für Wz Wechsel Zähler zurücksetzen ausgewählt *)

	xSetForceError:BOOL;
	diSetForceErrorNr:DINT;
	xUpdateErrorList: BOOL;
	xResetErrorWarning:BOOL;
	xHideObject:BOOL;	(* Dies muss aktiv gesetzt werden sobald ein Overlay Message Aktiv ist, ansonsten kann es Probleme geben mit der Annahme der Button *)
(* Sicherheitstüre Maschine und Lader *)
	xOpenSecurityDoorMachine:BOOL;				(* Aufforderung für das Öffnen der Sicherheitstüren *)
	xCloseSecurityDoorMachine:BOOL;				(* Aufforderung für das Schliessen der Sicherheitstüren *)
(* Sicherheitssignale *)
	iSetupMode:INT;								(* Einrichtbetriebswahlschalter
													1=Einrichtbetrieb A
													2=Einrichtbetrieb B
												*)
	xSetupOperateModeActive:BOOL;				(* FALSE=NormalBetrieb, TRUE=Einrichtbetrieb *)
	bStateSafetyCtrl:BYTE;							(*
													0=< Keine Meldung >
													1=< Maschine ist am aufstarten... >
													2=< FreigabeTaste drücken >
													3=< StartTaste drücken >
													4=< Maschinen- und LadeTüre schliessen >
													5=< MaschinenTüren schliessen >
													6=< LadeTüre schliessen >
													7=< Für Positionsfahrt StartTaste drücken   >
													8=< Für Drehbewegung StartTaste drücken  >
													9=< Funktion in Ausführung >
													10=< Funktion in Ausführung...MMI ist blockiert >
													11=< Achsenposition wird überprüft...MMI ist blockiert >
													12=< Servo für Z Achsen stehen nicht bereit >
													13=< Servo für T Achse steht nicht bereit >
													14=< Servo für X Achse steht nicht bereit >
													15=< Kühlmittelpumpe Überlastschutz aktiv >
													16=< Kühlmittelpumpe nicht angeschlossen >
													17=< AntriebSperrTaste deaktivieren >
													18=< Schlüsselschalter deaktivieren >
													19=< Not Aus Taster deaktivieren >
													20=< Zustimmschalter deaktivieren >
													21=< Zustimmschalter aktivieren oder Türen schliessen >
													22=< Zylinderbewegung EIN/AUS drücken >
													23=< Ventile EIN/AUS drücken >
													24=< Zustimmschalter anschliessen >
													25=< Automat in Ausführung >
													26=< Masch.Ref/Grundstellung in Ausführung >
													27=< WstkEntladen in Ausführung >
													28=< HandBetrieb in Ausführung >
													29=< MaschinenTüreOben schliessen >
													30=< MaschinenTüreUnten schliessen >
													31=< MaschinenTüreOben und LadeTüre schliessen >
													32=< MaschinenTüreUnten und LadeTüre schliessen >
												*)
	xHideSafetyCtrlMessage:BOOL;					(* Unterdrückung der Sicherheitsmeldungen "bStateSafetyCtrl" *)
	xNormalOperate_EnergyON:BOOL;
	xSetupOperateA_EnergyON:BOOL;
	xSetupOperateB_EnergyON:BOOL;
	xDeactivateLamp:BOOL;						(* Gilt für den Lampentest, damit der Ausgang nicht mit der Logik überschrieben wird *)
	xSecurityDoorOpen:BOOL;						(* Maschinentüren und/oder Ladetüre offen *)
	bMachineDoorUpState:BYTE;					(* Zustand der Maschinentüre oben 1=Geöffnet, 2=Geschlossen, 3=Fehlverhalten *)
	bMachineDoorChannel1State:BYTE;				(* Zustand des zweikanaligen Türschalter Türe Zu für Türe oben und unten Kanal 1 1=OFF, 2=ON *)
	bMachineDoorChannel2State:BYTE;				(* Zustand des zweikanaligen Türschalter Türe Zu für Türe oben und unten Kanal 2 1=OFF, 2=ON *)
	bMachineDoorUpOpenState:BYTE;				(* Zustand des Türschalter Türe Offen für Türe oben 1=OFF, 2=ON *)
	bMachineDoorInductiveSensorState:BYTE;		(* Zustand des induktiven Sensor für Türe oben 1=OFF, 2=ON *)
	bMachineDoorGuardControlState:BYTE;			(* Zustand der Tür oben Zuhaltung 1=OFF, 2=ON *)
	iMsgInfo_ColourState:INT;						(* 0=Grün, 1=Gelb-->Gelb gilt für Prozess beendet mit mindestens einem Loch NoGo *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_SPINDLEBURNIN :
STRUCT
	rTimeActive:REAL;
	rTimeInactive:REAL;
	rTimeMaxActiveFunction:REAL;
	rSpeed_Axis_S:REAL;
	tTimeElapsed:TIME;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_STATION :
STRUCT
	xExist:BOOL;
	xActiv:BOOL;
	wState:WORD;
	iProfile:INT;
	diErrorNr:DINT;
	sProfileName:STRING(30);
	bAutomodeState:BYTE;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_STATION_COMMON :
STRUCT
(* State *)
	wState:DWORD;

	T_Param_Machine:ST_RETAIN_DATA_MACHINE;
	T_Param_StationWork:ST_RETAIN_DATA_STATIONWORK;	(* Gilt für MicroHead-  Station *)

	T_ToolCounter_St1:ST_EXCHG_PARAM_TOOLCOUNTER;			(* Braucht es wegen der Parameterliste im NormalBetrieb, da auf diese Parameter gleichzeitig zugegriffen werden muss *)
	T_WPCounter_St1:ST_EXCHG_PARAM_WPCOUNTER;				(* Braucht es wegen der Parameterliste im NormalBetrieb, da auf diese Parameter gleichzeitig zugegriffen werden muss *)

(* Page Quality *)
	T_Button_Quality_Backward:ST_EXCHG_TOUCHBUTTON;
	T_Button_Quality_Forward:ST_EXCHG_TOUCHBUTTON;
	T_Input_Quality_HoleNumber:ST_EXCHG_TOUCHINPUT;

(* Axis State *)
	bState_Axis_Z:BYTE;

(* Gilt für die Ersteinrichtung der Z Achse *)
	iZAxisFirstSetup_StepNr:INT;
	iZAxisFirstSetupStartButton_StepNr:INT;
	iZAxisFirstSetup_ShowObjectNr:INT;
	xInitial_FirstSetupZ:BOOL;		(* TRUE = Ersteinrichtung Z durchgeführt *)
	rZAxisFirstSetup_OffsetSpinToDeskTop:REAL;

	xBlockSelectAutoMode:BOOL;	(* Bei aktivem Prozess muss die Auswahl blockiert sein *)

	(* Disablen von Objekten, wenn es den SystemLevel braucht *)
	xSystemLevelActive:BOOL;

	bActiveStation_St1St2:BYTE;	(* 	0=Arbeitsstation St1St2 Automat nicht Aktiv
									1=Arbeitsstation St1St2 Automat Aktiv
									2=Arbeitsstation St1St2 Automat Fehler *)

(* Gilt für das Aufzeichnen der Rotationsdauer der Spindel *)
	tSpindelActiveRotationTime:TIME;
	iSpindelActiveRotationDay:INT;

	xOnlineValueModified_St1:BOOL;

	xToolSpindle_L_Connect:BOOL;

(* Auswahl der Zylinderkonfiguration *)
	bSelectCylinderConfig:BYTE;		(* 1=Auslenkzylinder, 2=Drehmomentzylinder *)
	bShowCylinderConfig:BYTE;		(* 1=Auslenkzylinder (SM), 2=Auslenkzylinder (L), 3=Drehmomentzylinder (SM), 4=Drehmomentzylinder (L) *)

(* Auswahl der Erst Einrichtung Z Achse *)
	bSelectZAxisProcedure:BYTE;		(* 1=Ersteinrichtung Relation Z-Achse zu oberes Führungsrohr, 2=Ersteinrichtung Z Achse *)
	xBlockSelectZAxisProcedure:BOOL;

(* Gilt für die Ersteinrichtung der Z Achse für die Relation zwischen Z Achse und oberes Führungsrohr *)
	iZAxisGuideTube_StepNr:INT;
	iZAxisGuideTubeStartButton_StepNr:INT;
	iZAxisGuideTube_ShowObjectNr:INT;

(* Bestimmung der Schwingungsqualität der Wippe der Drehmomentüberwachung *)
	rRockerQuality:REAL;
	rRockerQualityMin:REAL;
	rRockerQualityMax:REAL;
	rRockerAmplitude:REAL;
	rRockerAmplitudeMin:REAL;
	rRockerAmplitudeMax:REAL;
	rRockerPosition:REAL;
	diRockerCountHC:DINT;
	diRockerCountHCTime:DINT;

(* Konfiguration der Positionen *)
	iSelectConfigPosition:INT;
	xDisableConfigPosition:BOOL;


(* Regler *)
	rSpeedZ_V1:REAL;					(* IGS *)
	rSpeedZ_V3:REAL;					(* IGS *)
	rTorqueZ_S1:REAL;					(* IGS *)
	rTorqueZ_S4:REAL;					(* IGS *)

	iProgressBar_Torque:INT;				(* IGS *)
	iProgressBar_ZPos:INT;				(* IGS *)
	iProgressBar_ZVel:INT;				(* IGS *)

	xTorqueAfterHC_Min_Overlimit:BOOL;	(* IGS *)
	xTorqueAfterHC_Max_Overlimit: BOOL;	(* IGS *)

	rActual_Torque:REAL;			(* Aktuelles Drehmoment der Drehmomentfeder in mNm - Wechselkopf unabhängig *)	(* IGS *)
	rMaxTorque:REAL;					(* IGS *)

(* Zentrieren *)
	diCentringNumberHCinWindow:DINT;	(* Anzeigen des Zählerstandes wie oft HC in einem definierten Fenster schon eingetroffen ist *)
	xShowSelectCentringProcess:BOOL;	(* Auswahl des Zentrierprozess nur dann zeigen wenn effektiv der Zentrierprozess angewählt ist *)

	rPositionEndProcCalc:REAL;	(* Anzeige oder Eingabe für berechnete EndPosition *)
	xDisableChangeEndPos:BOOL;

	rCentringEndProcCalc:REAL;	(* Anzeige oder Eingabe für berechnete EndPosition *)
	xDisableCentringChangeEndPos:BOOL;

	bSelectShowIncValue:BYTE;	(* 0=Anzeigen der Bearb Ink Werte, 1=Anzeigen der Zentrier Ink Werte *)

	rController2_MinSpeed:REAL;

	rZPositionEndProc:REAL;

	xProcessCylindricalAreaActive:BOOL;

	xSControllerActive:BOOL;
	xOControllerActive:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_TOUCHBUTTON :
STRUCT
	xActive:BOOL;
	xDisable:BOOL;
	xHide:BOOL;
	bState:BYTE;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_TOUCHINPUT :
STRUCT
	diInput1:DINT;
	diInput2:DINT;
	diInputMin:DINT;
	diInputMax:DINT;
	xDisable:BOOL;
	xChangeColour:BOOL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_TOUCHSCREENBTPANEL :
STRUCT
	iNotMaskTextBt:INT;
	iActivBtLeft:INT;
	iStateBtLeft:INT;
	iActivBtRight:INT;
	iStateSetupLamp:INT;
	iStateButtonPage:INT;
	iSelectStationNumber:INT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_TOUCHSCREENNAVPANEL :
STRUCT
	wState:WORD;
	wNotMasktext:WORD;
	wActivBt:WORD;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_EXCHG_VISU :
STRUCT
(* Message structure *)
	T_Message:ST_EXCHG_MESSAGE;
(* Error List Structure *)
	T_MsgErrorEnglish:ST_EXCHG_MESSAGE_LIST;
	T_MsgErrorDeutsch:ST_EXCHG_MESSAGE_LIST;
(* Level structure *)
	T_Level:ST_EXCHG_LEVEL;
(* Variable *)
	iQVisActivNewPage:INT:=0;
	iLoadingStartPage:INT:=1;
	iHeaderTitlePageNumber:INT;
	bActivStation:BYTE:=0;
	bActiveSetupMode:BYTE:=0;	(* 0=AutoMode, 1=SetupMode A, 2=SetupMode B, 3=SetupMode C *)
	bMachineState:BYTE;	(* 1=Ready, no movement, 2=busy function,process or actuator active, 4=Error *)
	xKey_Enter:BOOL;
	xKey_Escape:BOOL;
	xLoadingProcessDone:BOOL;
	sSWVersion:STRING(10):='V4620698';		(* V4620698.pro *)
	sQVisVersion:STRING(10):='V462069801';	(* V4620698_01.qpr-->wird per NovRAM definiert *)
	sHWVersion:STRING(10):='V462069801';		(* V4620698_01.tsm *)
	sIPAddress:STRING(23):='xxx.xxx.xxx.xxx.xxx.xxx';
	sSubNetMask:STRING(23):='xxx.xxx.xxx.xxx.xxx.xxx';
	sGatewayAddress:STRING(23):='xxx.xxx.xxx.xxx.xxx.xxx';
	sAmsNetID:STRING(23):='xxx.xxx.xxx.xxx.xxx.xxx';
	sHostName:STRING(23):='xxxxxxxxxxxxxxxxxxxxxxx';
	xDHCPActive:BOOL:=FALSE;
	xNoRemoteControlActive:BOOL;	(* TRUE = Kein Rechner an der CX2020 angeschlossen *)
	xActiveProcessState_St1St2:BOOL;	(* Ausgabe ob Prozesszustand Aktiv ist oder nicht *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_PAGE :
STRUCT
	iIndexConfigPage:INT:=0;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_QVIS :
STRUCT
	T_PageIndex:ARRAY[0..999] OF ST_PAGE;
	T_ConfigPage:ARRAY[1..csiMaxPage] OF ST_CONFIGPAGE;
	T_CtrleVisu:ST_CTRLEVISU;
	T_PlcParam:ST_VISU_PLC_PARAM;
	T_CtrleAction:ST_CTRLEACTION;
	T_CtrleProcess:ST_CTRLEPROCESS;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_QVIS_EXCHG_PARAM :
STRUCT
	byOverride:BYTE;					(*Maschinengeschwindigkeit*)
	T_Visu:ST_EXCHG_VISU;
	T_TouchScreenBtPanel:ST_EXCHG_TOUCHSCREENBTPANEL;
	T_BtFunctionPanel:ST_EXCHG_BTFUNCTIONPANEL;
	T_BtParameterList:ST_EXCHG_BTPARAMETERLIST;
	T_TouchScreenNavPanel:ST_EXCHG_TOUCHSCREENNAVPANEL;
	T_Config:ST_EXCHG_CONFIG;
	T_TeachIn:ST_EXCHG_AXIS;
	T_Cylinder:ST_EXCHG_CYLINDER;
	T_Station1:ST_EXCHG_STATION;	(* BearbStation St1 *)
	T_StationCommon:ST_EXCHG_STATION_COMMON;
	T_FunctionCommon:ST_EXCHG_FUNCTION_COMMON;
	T_AnalogSensTorque:ST_EXCHG_ANALOGSENSOR;
	T_ProfileCommon:ST_EXCHG_PROFILE_COMMON;
	T_PartQuality:ST_EXCHG_PARTQUALITY;
	T_LampTest:ST_EXCHG_LAMPTEST;
	T_SpindleBurnIn:ST_EXCHG_SPINDLEBURNIN;
	T_SafetyCtrl:ST_EXCHG_SAFETY_CTRL;
	T_ParamBIOS:ST_EXCHG_PARAM_BIOS;
	xShutdownSystem:BOOL;
	xBIOSButton:BOOL;
	xBIOSButtonHide:BOOL;

	(* Spindelkopf Auswahl Beckhoff/Maxon *)
	xInputSelectAxisSuccesful:BOOL;								(* IGS *)
	xButtonSelect_S1:BOOL;			(* Maxon Spindel *)			(* IGS *)
	xButtonSelect_S2:BOOL;			(* Beckhoff Spindel L *)			(* IGS *)
	xButtonSelect_S3:BOOL;			(* Beckhoff Spindel M *)			(* IGS *)
	xButtonDisable:BOOL;											(* IGS *)
	xWriteSoEParameter:BOOL;									(* IGS *)
	bToolSpindleActive:BYTE;			(*	1 = Maxon Spindel
										2 = Beckhoff Spindel L
										3 = Beckhoff Spindel M *)
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_QVISCTRLE :
STRUCT
	dwInCommand:DWORD;
	dwInCount:DWORD;
	dwInQVisCtrlAddress:DWORD;
	dwInParameterAddress:DWORD;
	dwOutCount:DWORD;
	diOutStatus:DINT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_TEMP_ACTIVE_STATE :
STRUCT
	iActCyl_SetupB1_St1:INT;		(* Cyl 1, Cyl 2, Cyl 3 *)

	iActValve_SetupB1_St1:INT;		(* Valve 4, Valve 5 *)

	iActCylinderSetup_SetupB1:INT;

	iActAxis_SetupB1_St1:INT;		(* Z, S und O Achse *)

	iActiveProfile:INT;
	iPtrListProfile:INT;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_VISU_PLC_PARAM :
STRUCT
	dwSetNewPage:DWORD;
	dwActualPage:DWORD;
	dwPreviousPage:DWORD;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/VISUALISIERUNG' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE ST_VISUPAGENUMBER :
STRUCT
(* Start Page *)
	iStart_Page1:INT:=0;
(* BIOS Page *)
	iBIOS_Page1:INT:=1;
	iBIOS_Page2:INT:=2;
(* NormalOperating-->Task 1 *)
	iAutoMode_Process:INT:=10;
	iAutoMode_ProcessValue1:INT:=11;		(* IGS *)
	iAutoMode_ProcessValue2:INT:=12;		(* IGS *)
	iAutoMode_PartQuality:INT:=13;			(* alt 12 *)
(* NormalOperating-->Task 2 *)
	iAutoMode_Referencing:INT:=20;
(* NormalOperating-->Task3 *)
	iAutoMode_Profile:INT:=30;
(* NormalOperating-->Task 4 *)
	iAutoMode_ToolChange:INT:=40;
	iAutoMode_UserLevel:INT:=41;
	iAutoMode_Language:INT:=42;
(* NormalOperating-->Task 5 *)
	iAutoMode_WPCounter:INT:=50;
	iAutoMode_LampTest:INT:=51;
	iAutoMode_SafetyCheck:INT:=52;
	iAutoMode_SysInfo:INT:=53;
(* NormalOperating-->Task 6 *)
	iAutoMode_ErrorList:INT:=60;
(* NormalOperating-->Parameter *)
	iAutoMode_Parameter:INT:=70;
(* SetupOperate A-->Task 1 *)
	iHandMode_Process:INT:=110;
	iHandMode_WorkParameter:INT:=111;	(* IGS *)
	iHandMode_RegulatorPara:INT:=112;	(* IGS *)
	iHandMode_OnlineChange:INT:=113;		(* alt 111 *)
	iHandMode_ConfigPosition:INT:=114;		(* alt 112 *)
(* SetupOperate A-->Task 3 *)
	iHandMode_ProfileMngmt1:INT:=120;
(* SetupOperate A-->Task 5 *)
	iHandMode_Setup1:INT:=150;
(* SetupOperate A-->Task 6 *)
	iHandMode_ErrorList:INT:=160;
(* SetupOperate A-->Parameter *)
	iHandMode_Parameter:INT:=170;
(* SetupOperate B-->Task 1 *)
	iWorkStation_Axis1:INT:=210;
(* SetupOperate B-->Task 2 *)
	iWorkStation_Cylinder1:INT:=220;
(* SetupOperate B-->Task 3 *)
	iWorkStation_Valve1:INT:=230;
(* SetupOperate B-->Task 4 *)
	iWorkStation_Function1:INT:=240;
(* SetupOperate B-->Task 5 *)
	iWorkStation_Setup1:INT:=250;
	iWorkStation_Setup2:INT:=251;
	iWorkStation_Setup3:INT:=252;
	iWorkStation_Setup4:INT:=253;
	iWorkStation_Setup5:INT:=254;
(* SetupOperate B-->Task 6 *)
	iWorkStation_ErrorList:INT:=260;
(* SetupOperate B-->Parameter *)
	iWorkStation_Parameter:INT:=270;
(* WaitCom_Page1 *)
	iWaitCom_Page1:INT:=1001;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'Constant_Variablen' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
VAR_GLOBAL CONSTANT
(*Constant variables Axis*)
	gciAxisZ_St1				:UINT:=1;
	gciAxisS_St1				:UINT:=2;
	gciAxisMax				:UINT:=2;

	gciStationSt1				:UINT:=1;

	(* developpement *)
	(*sRootPLC:STRING(255):='C:';*)
	(* machine *)
	cssRootPLC:STRING(255):='c:\';
	cssRootUSB:STRING(255):='d:\';
	(* HDD *)
	csiMaxFileLine:INT:=2230;
	csiMaxCharPerLine:INT:=135;
	(* Axis *)
	csiMaxAxisFileObj:INT:=50;
(* Visualisation number max page *)
	csiMaxPage:INT:=60;
	(* Profile *)
	csiMaxProfile:INT:=100;
	csiMaxProfileParameter:INT:=88;		(* BEF alt: 85 *) (* PUM alt: 78 *) (* PUM alt: 75 *) (* PUM alt: 61 *) (* PUM alt: 60 *) (* PUM alt: 53 *) (* IGS3 alt: 42 *)(* IGS2 alt: 38 *)(* IGS alt 36 *)
(* Page number definition *)
	gT_PageNumber:ST_VISUPAGENUMBER;
(* Anzahl maximal Wstk für Aufzeichnung *)
	ciMaxWP:INT:=100;
(* Max Anzahl Profilparameter *)
	ciMaxProfileParameter:INT:=1000;
(* Drehrichtung des Tellers *)
	gciModuloDirection:INT:=MC_Shortest_Way;

(* Skalierungswert für S Achse *)
	grScaleSAxis_Distance_SM:REAL:=966.0;
	grScaleSAxis_Speed_SM:REAL:=650;
	grMaxSAxis_Speed_SM:REAL:=8241.758;	(* Max Motor Drehzahl *)
	grScaleSAxis_Distance_L:REAL:=966.0;
	grScaleSAxis_Speed_L:REAL:=16;


	grMaxSAxis_Speed_L:REAL:=3000.0;		(* Max Motor Drehzahl *)	(* IGS angepasst *)
	grMaxSAxis_Speed_M:REAL:=6000.0;	(* Max Motor Drehzahl *)	(* IGS *)


(* ZUM LOESCHEN *)
	grScaleSAxis_Distance:REAL:=966.0;
	grScaleSAxis_Speed:REAL:=164;
	grMaxSAxis_Speed:REAL:=10000.0;			(* Max Motor Drehzahl *)
	grMaxSAxis_SpeedAllowed:REAL:=7000.0;	(* Max Motor Drehzal die für Maschine zugelassen ist *)
END_VAR

(* @OBJECT_END := 'Constant_Variablen' *)
(* @CONNECTIONS := Constant_Variablen
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'Globale_Variablen' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
VAR_GLOBAL
	QVisCtrl :ST_QVISCTRLE;(*~	(QVis) (InOut:2)	~*)
	T_ExchgParam :ST_QVIS_EXCHG_PARAM;(*~	(QVis) (InOut:2)	~*)
	T_VisuQVis:ST_QVIS;
	TProcess : ST_PROCESS;
	TStation_Work_St1 : ST_STATION;

(* Structure layer 2 *)
	T_CtrlePanel:ST_CTRLEPANEL;
	T_HDD:ST_HDD;
	T_NovRam : ST_NOVRAM;
(* StartUp *)
	T_StartUp:ST_STARTUP;
(* UPS *)
	T_CtrleUPS : ST_CTRLE_UPS;
	TStatusUPS:ST_UPSStatus;
(* Profile, 40 records ID for each Station *)
	T_Profile:ST_PROFILE;
(* TwinSAFE *)
	T_TwinSafeCtrleIN AT %I*:ST_TWINSAFE_CTRLE_IN;
	T_TwinSafeCtrleOUT AT %Q*:ST_TWINSAFE_CTRLE_OUT;
	T_TwinSafeIn AT %I*:ST_TWINSAFE_IN;
	T_TwinSafeOut AT %I*:ST_TWINSAFE_OUT;
	T_TwinSafeFBError AT %I*:ST_TWINSAFE_FB_ERROR;
	T_TwinSafe_Ctrle_Z_Axis_St1 AT %Q* : ST_TWINSAFE_DRIVE;
	T_TwinSafe_Status_Z_Axis_St1 AT %I* : ST_TWINSAFE_DRIVE;
	T_TwinSafe_Ctrle_S2_Axis_St1 AT %Q* : ST_TWINSAFE_DRIVE;		(* IGS *)
	T_TwinSafe_Status_S2_Axis_St1 AT %I* : ST_TWINSAFE_DRIVE;		(* IGS *)
	T_TwinSafe_Ctrle_S3_Axis_St1 AT %Q* : ST_TWINSAFE_DRIVE;		(* IGS *)
	T_TwinSafe_Status_S3_Axis_St1 AT %I* : ST_TWINSAFE_DRIVE;		(* IGS *)
	gT_SafetyStatus:ST_SAFETY_STATUS;

	T_Z_St1_Ctrle:ST_AXIS_CTRLE;
(* Static Error List *)
	T_ErrorList:ST_ERROR_LIST;	(* Static define Error List *)
(* Password *)
	T_Password:ST_PASSWORD;
(* Einrichtlampe *)
	TMachineLamp : ST_CYLINDER;
(* Control Button Start/Stop *)
	T_CtrleBtStartStop:ST_CTRLEBUTTON;
(* Kollisionsüberwachung *)
	TCollisionDetection:ST_COLLISION_DETECTION;
(* Status der Beckhoffklemmen und Kopplert *)
	T_TerminalState AT %I* :ST_TERMINAL_STATE;
(* Zähler für das Löschen der Vorwarnungen *)
	giDeleteMessageNumber: INT:=0;
	gcarAxisConfig		:ARRAY[1..gcIAxisMax] OF ST_EXCHG_PARAM_TEACHIN;
	gxHardwareOFF:BOOL;	(* Für Simulationszwecke ohne Hardware *)
	gxAxisOFF:BOOL;		(* Für Simulationszwecke wenn nur der Servocontroller der Z Achse fehlt und der Rest der Hardware vorhanden ist *)

(* Freigaben der Achsenbewegung mittels dem Joystick *)
	gxEnable_Joystick_Axis_Z:BOOL;
	gxReleaseEnableSwitch:BOOL;	(* Freigabe für Bewegung der Achsen mittels dem Zustimmschalter *)
	gxResetDataAnalysis_St1:BOOL;
	gxInitialStateActivated:BOOL;	(* Merker für Grundstellungsfahrt, ob dies ausgelöst wurde oder nicht *)
	gxAxisPositionSettled:BOOL;
	gxSetSpeedInMovement:BOOL;
	gxSetupFunctionActive:BOOL;
	gxAxisAbsolutMovementActive:BOOL;
	gxHandModeActive:BOOL;
	gxBlockSetQuality:BOOL;
	gxSpindelCalibrationONOFF_St1:BOOL;

	gT_PreWarning:ST_PREWARNING;

	gxAddInfeedZ:BOOL;
	gxSetPartQuality:BOOL;

	gxWP_Analyse_ActiveWork:BOOL;
	gxWP_Analyse_ActiveInfeed:BOOL;
	gxWP_Analyse_ActiveCentering:BOOL;
	gxWP_Analyse_ResetCentCountValue:BOOL;

	gdiSavePartQuality:DINT;

	gxMachineAutomodeActive_St1St2:BOOL;

(* Process Daten Aufzeichnung *)
	T_ProcessData_St1:ST_PROCESSDATA;

	gsDriveNameProcessData: STRING:='';

	gxBlockChangeMovementVisuActiveMessage:BOOL;

	gxSpindleOverloadError:BOOL;

	garRockerMeasureValue:ARRAY [1..200] OF REAL;
	grRockerMaxValue:REAL;
	grRockerMinValue:REAL;
	grRockerQuality:REAL;
	grRockerAmplitude:REAL;
	grRockerAmplitudeMin:REAL;
	grRockerAmplitudeMax:REAL;
	grRockerQualityMin:REAL;
	grRockerQualityMax:REAL;
	gdiRockerCountHC:DINT;
	gdiRockerCountHCTime:DINT;
	grRockerPosition:REAL;

	(* Globale Z Achsen Position *)
	grZ_LoadPos:REAL;
	grZ_WorkStartPos:REAL;
	grZ_WorkEndPos:REAL;

	gudiTorqueOverloadCounterValueSt1:UDINT;		(* IGS *)

	gxCentringActive:BOOL;						(* IGS3 *)
	gxOnlyCentringActive:BOOL;					(* IGS3 *)
	gxSuspensionONOFF:BOOL;					(* IGS3 *)

	garPositionEndProcCalc:ARRAY [1..1] OF REAL;
	garCentringEndProcCalc:ARRAY [1..1] OF REAL;
	gxZAxisVelocityCtrlActive:BOOL;
	gxZFollowDistanceError:BOOL;

	gxProcessCylindricalAreaActive:BOOL;
END_VAR

(* @OBJECT_END := 'Globale_Variablen' *)
(* @CONNECTIONS := Globale_Variablen
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'HW_IN_OUT' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
VAR_GLOBAL
(*++++++++++++++++++INPUT+++++++++++++++++++++++++++++*)
(*Local Inputs Schaltschrank*)
	IiAToolTorque_St1							AT%IB0		:INT;	(* Analoger Sensor für Drehmomentüberwachung für die Werkzeug Spindel *)
	IiASpeedServoDrive							AT%IB2		:INT;	(* Geschwindigkeitseinstellung der Achse Z1 *)
	IiAToolTorque2_St1							AT%IB4		:INT;	(* Analoger Sensor für Drehmomentüberwachung für die Werkzeug Spindel *)		(* IGS *)
	IiARes83										AT%IB6		:INT;	(* Reserve *)

	IxAirSupply									AT%IX8.0	:BOOL;	(* Ueberwacht den Mindestdruck des pneu.Netzes *)
	IxCabinDoorLocked							AT%IX8.1	:BOOL;	(* Kabinentüre (Sicherheitstüre) verriegelt *)
	IxStartButton									AT%IX8.2	:BOOL;	(* Externe Starttaste *)
	IxStopButton									AT%IX8.3	:BOOL;	(* Externe Stopptaste *)
	IxReleaseButton								AT%IX8.4	:BOOL;	(* Externe Freigabetaste für Energieversorgung *)
	IxRes105										AT%IX8.5	:BOOL;	(* Reserve *)
	IxJoystick_X_Plus								AT%IX8.6	:BOOL;	(* Joystick X Plus Jog Bewegung *)
	IxJoystick_X_Minus							AT%IX8.7	:BOOL;	(* Joystick X  negativ Ink Bewegung *)
	IxJoystick_Y_Plus								AT%IX9.0	:BOOL;	(* Joystick Z1 Achsenbewegung positiv *)
	IxJoystick_Y_Minus							AT%IX9.1	:BOOL;	(* Joystick Z1 Achsenbewegung negativ *)
	IxFuse24VDC_OK								AT%IX9.2	:BOOL;	(* Sicherungen 24VDC OK *)
	IxEnablingSwitchPlusButton						AT%IX9.3	:BOOL;	(* Zustimmschalter Plus Taste *)
	IxEnablingSwitchMinusButton					AT%IX9.4	:BOOL;	(* Zustimmschalter Minus Taste *)
	IxToolDeflection_St1							AT%IX9.5	:BOOL;	(* Überwachung der Werkzeug Auslenkung für die Werkzeug Spindel *)
	IxBrakeReleaseZ1Axis_St1						AT%IX9.6	:BOOL;	(* Sensor für Bremse gelöst bei der Z1 Achse (Hubachse) *)
	IxJoystick_WorkpieceClamp_ON_St1				AT%IX9.7	:BOOL;	(* Joystick für das einschalten der Werkstückfixierung *)
	IxJoystick_AirTable_ON						AT%IX10.0	:BOOL;	(* Joystick für das einschalten der Luft des Tisches	 *)
	IxJoystick_VaccumTable_ON					AT%IX10.1	:BOOL;	(* Joystick für das einschalten des Vakuums des Tisches *)
	IxUpperToolGuide_WorkpieceClamped_St1		AT%IX10.2	:BOOL;	(* Sensor für Überwachung der Werkstückfixierung *)
	IxToolSpindle_L_Connect_St1					AT%IX10.3	:BOOL;	(* Spindelkopf L angeschlossen-->Nur als Option vorgesehen: noch nichts unternehmen *)	(* INFO brauchts nicht, wird über Visu gemacht *)
	IxCylWPUnfixAtWorkPos_St1					AT%IX10.4	:BOOL;	(* Sensor für WstkEntspannen ist auf ArbeitsPosition *)							(* IGS3 *)
	IxToolDeflection2_St1							AT%IX10.5	:BOOL;	(* Überwachung der Werkzeug Auslenkung2 für die Werkzeug Spindel *)			(* IGS3 *)
	IxSuspenstionFilled							AT%IX10.6	:BOOL;	(* Sensor für Suspension ist gefüllt *)											(* IGS3 *)
	IxRes123										AT%IX10.7	:BOOL;	(* Reserve *)
	IxRes124										AT%IX11.0	:BOOL;	(* Reserve *)
	IxRes125										AT%IX11.1	:BOOL;	(* Reserve *)
	IxRes126										AT%IX11.2	:BOOL;	(* Reserve *)
	IxRes127										AT%IX11.3	:BOOL;	(* Reserve *)
	IxRes128										AT%IX11.4	:BOOL;	(* Reserve *)
	IxRes129										AT%IX11.5	:BOOL;	(* Reserve *)
	IxRes130										AT%IX11.6	:BOOL;	(* Reserve *)
	IxRes131										AT%IX11.7	:BOOL;	(* Reserve *)

	IxTorqueOverload_St1							AT%IX12.0	:BOOL;	(* Clock-->Signal induktiver Sensor für Drehmomentüberlast *)						(* IGS *)

(*++++++++++++++++++++++++++++
	Schnittstelle PLC to Safety Program:
++++++++++++++++++++++++++++*)
	IxTwinSafeQuickStopMaster1_1					AT%IX14.0	:BOOL;	(* QuickStop Achsen Mastermodul1_1 von TwinSAFE *)
	IxTwinSafeQuickStopMaster2_1					AT%IX14.1	:BOOL;	(* QuickStop Achsen Mastermodul2_1 von TwinSAFE *)							(* IGS *)
	IxTwinSafeQuickStopMaster2_2					AT%IX14.2	:BOOL;	(* QuickStop Achsen Mastermodul2_2 von TwinSAFE *)							(* IGS *)



(*++++++++++++++++++OUTPUT+++++++++++++++++++++++++++++*)
(*Local Outputs Schaltschrank*)
	QxCtrlLampStartButton							AT%QX0.0	:BOOL;	(* Kontroll LED externe Starttaste *)
	QxCtrlLampStopButton							AT%QX0.1	:BOOL;	(* Kontroll LED externe Stopptaste *)
	QxCtrlLampReleaseButton						AT%QX0.2	:BOOL;	(* Kotroll LED externe Freigabetaste für Energieversorgung *)
	QxCtrlLampAxesCurrentOff						AT%QX0.3	:BOOL;	(* Kontroll LED externe Ausschalttaste der Achsen Energieversorgung *)
	QxRes154									AT%QX0.4	:BOOL;	(* Reserve *)
	QxSignalLampGreen							AT%QX0.5	:BOOL;	(* Grüne Signallampe *)
	QxSignalLampRed							AT%QX0.6	:BOOL;	(* Rote Signallampe *)
	QxSignalLampYellow							AT%QX0.7	:BOOL;	(* Gelbe Signallampe *)
	QxCabinDoorLock								AT%QX1.0	:BOOL;	(* Verriegelungschalter der Kabinentüre, mit Magnetkraft *)
	QxSetupModeLamp							AT%QX1.1	:BOOL;	(* Gelbe Anzeige für den Einrichtbetrieb *)
	QxReadyToOperateMasterModul1				AT%QX1.2	:BOOL;	(* Betriebsbereitschaftsausgabe an Z1 *)
	QxEnablingSwitchVibration						AT%QX1.3	:BOOL;	(* Vibration des Zustimmschalter *)
	QxReadyToOperateMasterModul2				AT%QX1.4	:BOOL;	(* Betriebsbereitschaftsausgabe an S	ReadyToOperate to S *)					(* IGS *)
	QxMeasRangeTorqueSensor_St1				AT%QX1.5	:BOOL;	(* Drehmoment Sensor Bereichsumschaltung von 0-2Nm auf 0-0.5Nm Station 1 *)		(* IGS *)
	QxControlTorqueSensor_St1					AT%QX1.6	:BOOL;	(* Drehmoment Sensor Kontrollfunktion aktivieren Station 1 *)						(* IGS *)
	QxRes165									AT%QX1.7	:BOOL;	(* Reserve *)

	QxEnableQuickStopMasterModul1				AT%QX2.0	:BOOL;	(* Mastermodul für Z1 Achse aktivieren und einleiten des Schnellstop *)
	QxEnableQuickStopMasterModul2				AT%QX2.1	:BOOL;	(* Mastermodul für S Achse aktivieren und einleiten des Schnellstop *)				(* IGS *)
	QxCoolant_St1								AT%QX2.2	:BOOL;	(* Elektromagnetisches Ventil für Kühlmittel *)									(* IGS2 *)
	QxFastStrokeOn_St1							AT%QX2.3	:BOOL;	(* Schnellhub (Frequenzumformer) Ein *)										(* IGS2 *)
	QxRes214									AT%QX2.4	:BOOL;	(* Reserve *)
	QxRes215									AT%QX2.5	:BOOL;	(* Reserve *)
	QxRes216									AT%QX2.6	:BOOL;	(* Reserve *)
	QxRes217									AT%QX2.7	:BOOL;	(* Reserve *)
	QxRes218									AT%QX3.0	:BOOL;	(* Reserve *)
	QxRes219									AT%QX3.1	:BOOL;	(* Reserve *)
	QxRes220									AT%QX3.2	:BOOL;	(* Reserve *)
	QxRes221									AT%QX3.3	:BOOL;	(* Reserve *)
	QxRes222									AT%QX3.4	:BOOL;	(* Reserve *)
	QxRes223									AT%QX3.5	:BOOL;	(* Reserve *)
	QxRes224									AT%QX3.6	:BOOL;	(* Reserve *)
	QxRes225									AT%QX3.7	:BOOL;	(* Reserve *)

	QxMachineLamp								AT%QX4.0	:BOOL;	(* Maschinenleuchte *)
	QxRes201									AT%QX4.1	:BOOL;	(* Reserve *)
	QxRes202									AT%QX4.2	:BOOL;	(* Reserve *)
	QxRes203									AT%QX4.3	:BOOL;	(* Reserve *)

	QiAToolDeflection_SM_St1						AT%QB6	:INT;	(* Servoventil für Werkzeug Auslenkung der Werkzeug Spindel SM & M *)
	QiAToolTorqueHC_SM_St1						AT%QB8	:INT;	(* Servoventil für Drehmomentüberwachung HC des Spindelkopf SM *)		(* TODO löschen *)
	QiAToolTorqueOverload_SM_St1				AT%QB10	:INT;	(* Servoventil für Werkzeug Auslenkung der Werkzeug Spindel L *)		(* ALT: Servoventil für Drehmomentüberwachung Überlast des Spindelkopf SM *)
	QiAFastStroke								AT%QB12	:INT;	(* Analog Ausgang für FU (Schnellhub) *)										(* IGS2 *)
	QiARes254									AT%QB14	:INT;	(* Reserve *)
	QiARes255									AT%QB16	:INT;	(* Reserve *)
	QiARes256									AT%QB18	:INT;	(* Reserve *)
	QiARes257									AT%QB20	:INT;	(* Reserve *)

(* External Outputs at SMC Valve Block  *)
	Qby0ValveBlock								AT%QB30	:BYTE;	(* Byte 0 for Ethercat ValveBlock, Contains all following BOOL-Vars *)
	QxCylBrakeReleaseZAxis_Open_St1				AT%QX30.0	:BOOL;	(* Ventil für Bremszylinder der Z1 Achse für Bremse lösen *)
	QxCylBrakeReleaseZAxis_Close_St1			AT%QX30.1	:BOOL;	(* Ventil für Bremszylinder der Z1 Achse für Bremse aktivieren *)
	QxCylWorkpieceClamp_St1						AT%QX30.2	:BOOL;	(* Ventil für Werkstückfixierzylinder *)
	QxRes303									AT%QX30.3	:BOOL;	(* Reserve *)
	QxAirTable									AT%QX30.4	:BOOL;	(* Ventil für die Luft des Tisches *)
	QxRes305									AT%QX30.5	:BOOL;	(* Reserve *)
	QxVacuumTable								AT%QX30.6	:BOOL;	(* Ventil für das Vakuum des Tisches *)
	QxRes307									AT%QX30.7	:BOOL;	(* Reserve *)

	Qby1ValveBlock								AT%QB31	:BYTE;	(* Byte 1 for Ethercat ValveBlock, Contains all following BOOL-Vars *)
	QxCylWPUnfix_St1							AT%QX31.0	:BOOL;	(* Ventil für ZylWstkEntspannen *)											(* IGS3 *)
	QxRes309									AT%QX31.1	:BOOL;	(* Reserve *)
	QxCylStripperClose_St1						AT%QX31.2	:BOOL;	(* Ventil für ZylAbstreiferGeschlossen *)										(* IGS3 *)
	QxCylStripperOpen_St1						AT%QX31.3	:BOOL;	(* Ventil für ZylAbstreiferOffen *)												(* IGS3 *)
	QxValveCleanNozzle							AT%QX31.4	:BOOL;	(* Ventil fuer Reinigungsduese *)												(* BEF *)
	QxRes313									AT%QX31.5	:BOOL;	(* Reserve *)
	QxRes314									AT%QX31.6	:BOOL;	(* Reserve *)
	QxRes315									AT%QX31.7	:BOOL;	(* Reserve *)

	Qby2ValveBlock								AT%QB32	:BYTE;	(* Byte 2 for Ethercat ValveBlock, Contains all following BOOL-Vars *)
	QxRes316									AT%QX32.0	:BOOL;	(* Reserve *)
	QxRes317									AT%QX32.1	:BOOL;	(* Reserve *)
	QxRes318									AT%QX32.2	:BOOL;	(* Reserve *)
	QxRes319									AT%QX32.3	:BOOL;	(* Reserve *)
	QxRes320									AT%QX32.4	:BOOL;	(* Reserve *)
	QxRes321									AT%QX32.5	:BOOL;	(* Reserve *)
	QxRes322									AT%QX32.6	:BOOL;	(* Reserve *)
	QxRes323									AT%QX32.7	:BOOL;	(* Reserve *)

(*++++++++++++++++++++++++++++
	Schnittstelle PLC to Safety Program:
++++++++++++++++++++++++++++*)
	QxTwinSafeReleaseButton						AT%QX35.0	:BOOL;	(* Output to safety prog *)
	QxTwinSafeServoDrivesRdy					AT%QX35.1	:BOOL;	(* Output to safety prog,ALL Servo-Controler: No Error *)

END_VAR

(* @OBJECT_END := 'HW_IN_OUT' *)
(* @CONNECTIONS := HW_IN_OUT
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'TwinCAT_Configuration' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
(* Generated automatically by TwinCAT - (read only) *)
VAR_CONFIG
	PRG_HW_WORK_ST1.IuiActualTorqueAxisZ_St1 AT %IB1656 : UINT;
	PRG_HW_WORK_ST1.IwInputState_Z_Axis_St1 AT %IB1658 : WORD;	(*  ~ {LinkedWith:TIID^Gerät 4 (EtherCAT)^Achse Z St1 (AX5106-0000-0210)^AT^Digital inputs, state} *)
	PRG_HW_WORK_ST1.IuiActualTorqueAxisS_St1 AT %IB1660 : UINT;
	PRG_HW_WORK_ST1.IwInputState_S1_Axis_St1 AT %IB1662 : WORD;
	PRG_HW_WORK_ST1.IwInputState_S2_Axis_St1 AT %IB1012 : WORD;	(*  ~ {LinkedWith:TIID^Gerät 4 (EtherCAT)^Antrieb S2 S3 St1 (AX5206-0000-0203)^AT 1^Digital inputs, state} *)
	PRG_HW_WORK_ST1.IwInputState_S3_Axis_St1 AT %IB1014 : WORD;	(*  ~ {LinkedWith:TIID^Gerät 4 (EtherCAT)^Antrieb S2 S3 St1 (AX5206-0000-0203)^AT 2^Digital inputs, state} *)
	PRG_HW_WORK_ST1.stZRefIn_St1 AT %IB1016 : NCTOPLC_AXLESTRUCT;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Achsen^Achse Z^Ausgänge^Achse Z_ToPlc} *)
	PRG_HW_WORK_ST1.stZRefOut_St1 AT %QB10012 : PLCTONC_AXLESTRUCT;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Achsen^Achse Z^Eingänge^Achse Z_FromPlc} *)
	PRG_HW_WORK_ST1.stZDriveState_St1 AT %IB1144 : ST_AXIS_DRIVESTATE;
	PRG_HW_WORK_ST1.stSRefIn_St1 AT %IB1148 : NCTOPLC_AXLESTRUCT;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Achsen^Achse S1^Ausgänge^Achse S1_ToPlc} *)
	PRG_HW_WORK_ST1.stSRefOut_St1 AT %QB10140 : PLCTONC_AXLESTRUCT;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Achsen^Achse S1^Eingänge^Achse S1_FromPlc} *)
	PRG_HW_WORK_ST1.stS2RefIn_St1 AT %IB1276 : NCTOPLC_AXLESTRUCT;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Achsen^Achse S2^Ausgänge^Achse 2_ToPlc} *)
	PRG_HW_WORK_ST1.stS2RefOut_St1 AT %QB10268 : PLCTONC_AXLESTRUCT;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Achsen^Achse S2^Eingänge^Achse 2_FromPlc} *)
	PRG_HW_WORK_ST1.stS3RefIn_St1 AT %IB1404 : NCTOPLC_AXLESTRUCT;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Achsen^Achse S3^Ausgänge^Achse 3_ToPlc} *)
	PRG_HW_WORK_ST1.stS3RefOut_St1 AT %QB10396 : PLCTONC_AXLESTRUCT;	(*  ~ {LinkedWith:TINC^NC-Task 1 SAF^Achsen^Achse S3^Eingänge^Achse 3_FromPlc} *)
	PRG_HW_WORK_ST1.stBubblerDataINSt1 AT %IB1648 : ST_COMM_IN_DCAXIS;
	PRG_HW_WORK_ST1.stBubblerDataOUTSt1 AT %QB10587 : ST_COMM_OUT_DCAXIS;
	PRG_HW_WORK_ST1.stFeedpumpINDataSt1 AT %IB1651 : ST_COMM_IN_DCAXIS;
	PRG_HW_WORK_ST1.stFeedpumpOUTDataSt1 AT %QB10590 : ST_COMM_OUT_DCAXIS;
	PRG_HW_WORK_ST1.IudiTorqueOverloadCounterValue_St1 AT %IB1532 : UDINT;	(*  ~ {LinkedWith:TIID^Gerät 1 (EtherCAT)^E-CAT Netzteil  (EK1200)^Zaehlerklemme 15 (EL1502)^CNT Inputs^Counter value} *)
	PRG_USB_IO_PANEL.IarxCtrlePanelButton AT %IB1536 : ARRAY [1..10] OF BOOL;
	PRG_USB_IO_PANEL.QarxCtrlePanelLed AT %QB10524 : ARRAY [1..10] OF BOOL;
	.T_TwinSafeCtrleIN AT %IB1546 : ST_TWINSAFE_CTRLE_IN;
	.T_TwinSafeCtrleOUT AT %QB10534 : ST_TWINSAFE_CTRLE_OUT;
	.T_TwinSafeIn AT %IB1549 : ST_TWINSAFE_IN;
	.T_TwinSafeOut AT %IB1569 : ST_TWINSAFE_OUT;
	.T_TwinSafeFBError AT %IB1577 : ST_TWINSAFE_FB_ERROR;
	.T_TwinSafe_Ctrle_Z_Axis_St1 AT %QB10536 : ST_TWINSAFE_DRIVE;
	.T_TwinSafe_Status_Z_Axis_St1 AT %IB1585 : ST_TWINSAFE_DRIVE;
	.T_TwinSafe_Ctrle_S2_Axis_St1 AT %QB10553 : ST_TWINSAFE_DRIVE;
	.T_TwinSafe_Status_S2_Axis_St1 AT %IB1602 : ST_TWINSAFE_DRIVE;
	.T_TwinSafe_Ctrle_S3_Axis_St1 AT %QB10570 : ST_TWINSAFE_DRIVE;
	.T_TwinSafe_Status_S3_Axis_St1 AT %IB1619 : ST_TWINSAFE_DRIVE;
	.T_TerminalState AT %IB1636 : ST_TERMINAL_STATE;
END_VAR
(* @OBJECT_END := 'TwinCAT_Configuration' *)
(* @CONNECTIONS := TwinCAT_Configuration
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'Variablen_Konfiguration' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
VAR_CONFIG
END_VAR

(* @OBJECT_END := 'Variablen_Konfiguration' *)
(* @CONNECTIONS := Variablen_Konfiguration
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)


_ALARMCONFIG
_ALARMCONFIGNEXTTEXTID : 10002
_ALARMCONFIGFORMATS : 'HH$':$'mm$':$'ss','dd$'-$'MM$'-$'yyyy'
_ALARMCLASSLIST : 1
_ALARMCLASSID : 0
_ALARMCLASSACKTYPE : 0
_ALARMCLASSNAME : 'DEFAULT'
_ALARMCLASSDESCRIPTION : ''
_ALARMCLASSBGCOLORS : 16777215,16777215,16777215
_ALARMCLASSTEXTCOLORS : 3394560,255,16711680
_ALARMCLASSBITMAPS : '','',''
_ALARMACTIONLIST : 0
(* @ALARMCLASSRESETCOLORS := '_ALARMCLASSRESETCOLORS: 33023,16777215' *)
(* @ALARMCLASSRESETBITMAP := '_ALARMCLASSRESETBITMAP: $'$'' *)
_ALARMGROUPLISTNAME : 'System'
_ALARMGROUPPATH : 'System'
_ALARMGROUPLIST : 0
_VISUALSETTINGSFLAGS : 0,0,0,0
_VISUALSETTINGSFLAGS : '','',''
_VISUALSETTINGSDYNTEXTFILECOUNT : 0

(* @ALARMCONFIGFLAGS := '_ALARMCONFIGFLAGS: 0' *)
(* @ALARMCONFIGGLOBALDB_STR := '_ALARMCONFIGGLOBALDB_STRINGS: $'$',$'$',$'$',$'$'' *)
(* @ALARMCONFIGGLOBALDB_NUM := '_ALARMCONFIGGLOBALDB_NUMBERS: 0,0' *)
_END_ALARMCONFIG


_WORKSPACE
_GLOBALVISUALSETTINGS
_VISUALSETTINGSFLAGS : 0,0,0,0
_VISUALSETTINGSFLAGS : '','',''
_VISUALSETTINGSDYNTEXTFILECOUNT : 0
_VISUALBITMAPLISTCOUNT : 0
_END_GLOBALVISUALSETTINGS
_END_WORKSPACE


LIBRARY
STANDARD.LIB 5.6.98 12:03:02
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 20
CONCAT: 0
CTD: 0
CTU: 0
CTUD: 0
DELETE: 0
F_TRIG: 0
FIND: 0
INSERT: 0
LEFT: 0
LEN: 0
MID: 0
R_TRIG: 0
REPLACE: 0
RIGHT: 0
RS: 0
SEMA: 0
SR: 0
TOF: 0
TON: 0
TP: 0
NumOfGVLs: 1
'Global Variables 0': 0
END_LIBRARY

LIBRARY
TcBase.lib 14.5.09 12:14:08
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 30
FW_AdsClearEvents: 0
FW_AdsLogDINT: 0
FW_AdsLogEvent: 0
FW_AdsLogLREAL: 0
FW_AdsLogSTR: 0
FW_AdsRdWrt: 0
FW_AdsRdWrtInd: 0
FW_AdsRdWrtRes: 0
FW_AdsRead: 0
FW_AdsReadDeviceInfo: 0
FW_AdsReadInd: 0
FW_AdsReadRes: 0
FW_AdsReadState: 0
FW_AdsWrite: 0
FW_AdsWriteControl: 0
FW_AdsWriteInd: 0
FW_AdsWriteRes: 0
FW_DRand: 0
FW_GetCpuAccount: 0
FW_GetCpuCounter: 0
FW_GetCurTaskIndex: 0
FW_GetSystemTime: 0
FW_GetVersionTcBase: 0
FW_LptSignal: 0
FW_MemCmp: 0
FW_MemCpy: 0
FW_MemMove: 0
FW_MemSet: 0
FW_PortRead: 2048
FW_PortWrite: 2048
NumOfGVLs: 0
END_LIBRARY

LIBRARY
TcBaseMath.lib 27.7.04 12:07:56
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 4
FW_Floor: 2048
FW_LrealFrac: 2048
FW_LrealModP: 2048
FW_LrealTrunc: 2048
NumOfGVLs: 0
END_LIBRARY

LIBRARY
TcCX1000System.lib 11.10.10 12:52:26
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 7
F_CX1000SetWatchdog: 2048
F_CX1000SubTimeStamp: 2048
F_GetVersionTcCX1000System: 2048
FB_CX1000Profiler: 2048
FB_CX1000SetTextDisplay: 2048
FB_CX1000SimpleUps: 2048
FB_CX1000UpsHandling: 2048
NumOfGVLs: 1
Global_Constants: 2048
END_LIBRARY

LIBRARY
TcDrive.lib 25.1.17 09:42:28
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 21
F_ConvWordToSTAX5000C1D: 2048
F_ConvWordToSTAX5000DriveStatus: 2048
F_ConvWordToSTIndraDriveCsC1D: 2048
F_ConvWordToSTIndraDriveCsDriveStatus: 2048
F_GetVersionTcDrive: 2048
FB_SoEAX5000FirmwareUpdate_ByDriveRef: 2048
FB_SoEAX5000ReadActMainVoltage_ByDriveRef: 2048
FB_SoEAX5000SetMotorCtrlWord_ByDriveRef: 2048
FB_SoEExecuteCommand_ByDriveRef: 2048
FB_SoEReadAmplifierTemperature_ByDriveRef: 2048
FB_SoEReadClassXDiag_ByDriveRef: 2048
FB_SoEReadCommandState_ByDriveRef: 2048
FB_SoEReadDcBusCurrent_ByDriveRef: 2048
FB_SoEReadDcBusVoltage_ByDriveRef: 2048
FB_SoEReadDiagMessage_ByDriveRef: 2048
FB_SoEReadDiagNumber_ByDriveRef: 2048
FB_SoEReadDiagNumberList_ByDriveRef: 2048
FB_SoEReadMotorTemperature_ByDriveRef: 2048
FB_SoEReset_ByDriveRef: 2048
FB_SoEWriteCommandControl_ByDriveRef: 2048
FB_SoEWritePassword_ByDriveRef: 2048
NumOfGVLs: 1
Global_Variables: 2048
END_LIBRARY

LIBRARY
TcEtherCAT.lib 30.11.16 19:52:18
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 82
ConvertDcTimeToPathPos: 2048
ConvertDcTimeToPos: 2048
ConvertPathPosToDcTime: 2048
ConvertPosToDcTime: 2048
DCTIME_TO_DCTIMESTRUCT: 2048
DCTIME_TO_FILETIME: 2048
DCTIME_TO_STRING: 2048
DCTIME_TO_SYSTEMTIME: 2048
DCTIMESTRUCT_TO_DCTIME: 2048
F_CheckVendorId: 2048
F_ConvBK1120CouplerStateToString: 2048
F_ConvExtTimeToDcTime: 2048
F_ConvMasterDevStateToString: 2048
F_ConvProductCodeToString: 2048
F_ConvSlaveStateToBits: 2048
F_ConvSlaveStateToString: 2048
F_ConvStateToString: 2048
F_ConvTcTimeToDcTime: 2048
F_ConvTcTimeToExtTime: 2048
F_GetActualDcTime: 2048
F_GetCurDcTaskTime: 2048
F_GetCurDcTickTime: 2048
F_GetCurExtTime: 2048
F_GetVersionTcEtherCAT: 2048
FB_EcCoESdoRead: 2048
FB_EcCoESdoReadEx: 2048
FB_EcCoESdoWrite: 2048
FB_EcCoESdoWriteEx: 2048
FB_EcDcTickTimeBaseCalc: 2048
FB_EcDcTimeCtrl: 2048
FB_EcDcTimeCtrl.A_GetDay: 2048
FB_EcDcTimeCtrl.A_GetDayOfWeek: 2048
FB_EcDcTimeCtrl.A_GetHour: 2048
FB_EcDcTimeCtrl.A_GetMicro: 2048
FB_EcDcTimeCtrl.A_GetMilli: 2048
FB_EcDcTimeCtrl.A_GetMinute: 2048
FB_EcDcTimeCtrl.A_GetMonth: 2048
FB_EcDcTimeCtrl.A_GetNano: 2048
FB_EcDcTimeCtrl.A_GetSecond: 2048
FB_EcDcTimeCtrl.A_GetYear: 2048
FB_EcExtSyncCalcTimeDiff: 2048
FB_EcExtSyncCheck: 2048
FB_EcFoeAccess: 2048
FB_EcFoeClose: 2048
FB_EcFoeLoad: 2048
FB_EcFoeOpen: 2048
FB_EcGetAllSlaveAbnormalStateChanges: 2048
FB_EcGetAllSlaveAddr: 2048
FB_EcGetAllSlaveCrcErrors: 2048
FB_EcGetAllSlavePresentStateChanges: 2048
FB_EcGetAllSlaveStates: 2048
FB_EcGetConfSlaves: 2048
FB_EcGetLastProtErrInfo: 2048
FB_EcGetMasterDevState: 2048
FB_EcGetMasterState: 2048
FB_EcGetScannedSlaves: 2048
FB_EcGetSlaveCount: 2048
FB_EcGetSlaveCrcError: 2048
FB_EcGetSlaveCrcErrorEx: 2048
FB_EcGetSlaveIdentity: 2048
FB_EcGetSlaveState: 2048
FB_EcGetSlaveTopologyInfo: 2048
FB_EcLogicalReadCmd: 2048
FB_EcLogicalWriteCmd: 2048
FB_EcMasterFrameCount: 2048
FB_EcMasterFrameStatistic: 2048
FB_EcMasterFrameStatisticClearCRC: 2048
FB_EcMasterFrameStatisticClearFrames: 2048
FB_EcMasterFrameStatisticClearTxRxErr: 2048
FB_EcPhysicalReadCmd: 2048
FB_EcPhysicalWriteCmd: 2048
FB_EcReqMasterState: 2048
FB_EcReqSlaveState: 2048
FB_EcSetMasterState: 2048
FB_EcSetSlaveState: 2048
FB_EcSoERead: 2048
FB_EcSoEWrite: 2048
FB_SoERead_ByDriveRef: 2048
FB_SoEWrite_ByDriveRef: 2048
FILETIME_TO_DCTIME: 2048
STRING_TO_DCTIME: 2048
SYSTEMTIME_TO_DCTIME: 2048
NumOfGVLs: 1
Globale_Variablen: 2048
END_LIBRARY

LIBRARY
TcIoFunctions.lib 27.1.17 17:22:22
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 99
F_ByteSwap: 2048
F_CheckForSwapBytes: 2048
F_CreateDpv1ReadReqPkg: 2048
F_CreateDpv1ReadReqPkgPNET: 2048
F_CreateDpv1WriteReqPkg: 2048
F_CreateDpv1WriteReqPkgPNET: 2048
F_GetDataString: 2048
F_GetPDTypeSize: 2048
F_GetVersionTcIoFunctions: 0
F_SplitDpv1ReadResPkg: 2048
F_SplitDpv1ReadResPkgPNET: 2048
F_SplitDpv1WriteResPkg: 2048
F_SplitDpv1WriteResPkgPNET: 2048
FB_ASI_Addressing: 0
FB_ASI_ParameterControl: 2048
FB_ASI_Parameterinterface: 0
FB_ASI_Processdata_analog: 0
FB_ASI_Processdata_digital: 0
FB_ASI_Projecting: 0
FB_ASI_ReadParameter: 0
FB_ASI_SlaveDiag: 0
FB_ASI_WriteParameter: 0
FB_ASI_WriteReadParameter: 2048
FB_AX2000_AXACT: 0
FB_AX2000_AXACT.a_MapInputs: 2048
FB_AX2000_AXACT.a_MapOutputs: 2048
FB_AX2000_AXACT.a_RW_CtrlWord: 2048
FB_AX2000_AXACT.a_RW_PZD: 2048
FB_AX2000_JogMode: 0
FB_AX2000_JogMode.a_MapInputs: 2048
FB_AX2000_JogMode.a_MapOutputs: 2048
FB_AX2000_Parameter: 0
FB_AX2000_Reference: 0
FB_AX2000_Reference.a_MapInputs: 2048
FB_AX2000_Reference.a_MapOutputs: 2048
FB_AX200X_Profibus: 0
FB_Dpv1Read: 2048
FB_Dpv1ReadPNET: 2048
FB_Dpv1Write: 2048
FB_Dpv1WritePNET: 2048
FB_FCxxxxDpv0PkwRead: 0
FB_FCxxxxDpv0PkwWrite: 0
FB_GetDPRAMInfo: 2048
FB_GetDPRAMInfoEx: 2048
FB_GetUPSStatus: 2048
FB_KL1501Config: 2048
FB_KL1501Config.A_ReadConfigTable: 2048
FB_KL1501Config.A_SetConfigTable: 2048
FB_KL27x1Config: 2048
FB_KL27x1Config.A_ReadConfigTable: 2048
FB_KL27x1Config.A_SetConfigTable: 2048
FB_KL3208Config: 2048
FB_KL3208Config.A_ReadConfigTable: 2048
FB_KL3208Config.A_SetConfigTable: 2048
FB_KL320xConfig: 2048
FB_KL320xConfig.A_ReadConfigTable: 2048
FB_KL320xConfig.A_SetConfigTable: 2048
FB_KL3228Config: 2048
FB_KL3228Config.A_ReadConfigTable: 2048
FB_KL3228Config.A_SetConfigTable: 2048
FB_NovRamReadWrite: 0
FB_NovRamReadWriteEx: 2048
FB_ReadAdsTecSysData: 2048
FB_ReadInput_analog: 2048
FB_WriteOutput_analog: 2048
IOF_CAN_Layer2Command: 0
IOF_DeviceReset: 0
IOF_GetBoxAddrByName: 0
IOF_GetBoxAddrByNameEx: 0
IOF_GetBoxCount: 0
IOF_GetBoxNameByAddr: 0
IOF_GetBoxNetId: 0
IOF_GetDeviceCount: 0
IOF_GetDeviceIDByName: 0
IOF_GetDeviceIDs: 0
IOF_GetDeviceInfoByName: 0
IOF_GetDeviceName: 0
IOF_GetDeviceNetId: 0
IOF_GetDeviceType: 0
IOF_LB_BreakLocationTest: 0
IOF_LB_ParityCheck: 0
IOF_LB_ParityCheckWithReset: 0
IOF_SER_DRIVE_Backup: 0
IOF_SER_DRIVE_BackupEx: 2048
IOF_SER_DRIVE_Reset: 0
IOF_SER_GetPhase: 0
IOF_SER_IDN_Read: 0
IOF_SER_IDN_Write: 0
IOF_SER_ResetErr: 0
IOF_SER_SaveFlash: 0
IOF_SER_SetPhase: 0
SCIT_ActivateConfiguration: 0
SCIT_AlarmStop: 0
SCIT_ConfDevErrAll: 0
SCIT_ControlActiveConfiguration: 0
SCIT_DeactivateConfiguration: 0
SCIT_GetErrorInfo: 0
SCIT_StartDataTransfer: 0
SCIT_StopDataTransfer: 0
NumOfGVLs: 1
Globale_Variablen: 0
END_LIBRARY

LIBRARY
TcMath.lib 23.9.04 15:15:30
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 7
F_GetVersionTcMath: 0
FLOOR: 2048
FRAC: 2048
LMOD: 2048
LTRUNC: 2048
MODABS: 2048
MODTURNS: 2048
NumOfGVLs: 0
END_LIBRARY

LIBRARY
TcMC.lib 27.7.15 08:51:38
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 64
F_GetIndexGroup: 2048
F_GetVersionTcMC: 2048
FB_MoveGeneric: 2048
FB_NewPosAndVeloGeneric: 2048
FB_ReadCharacteristicValues: 2048
FB_ReadWriteParameter: 2048
FB_SystemJog: 2048
MC_AbortSuperposition: 2048
MC_AbortTrigger: 2048
MC_ChangeDynParam: 2048
MC_ExtSetPointGenDisable: 2048
MC_ExtSetPointGenEnable: 2048
MC_ExtSetPointGenFeed: 2048
MC_GearIn: 0
MC_GearInDyn: 2048
MC_GearInDynCCV: 2048
MC_GearInFloat: 2048
MC_GearInMultiMaster: 2048
MC_GearOut: 0
MC_GearOutExt: 2048
MC_Home: 2048
MC_Jog: 2048
MC_Jog.ActCheckJogEnd: 2048
MC_Jog.ActJogMove: 2048
MC_MoveAbsolute: 2048
MC_MoveAbsoluteOrRestart: 2048
MC_MoveAbsoluteOrRestart.MC_MoveAbsoluteCall: 2048
MC_MoveAbsoluteOrRestart.MC_MoveAbsoluteRestartTrigger: 2048
MC_MoveAbsoluteOrRestart.MC_MoveRestartCall: 2048
MC_MoveModulo: 2048
MC_MoveModulo.MC_MoveModuloCall: 2048
MC_MoveRelative: 2048
MC_MoveSuperImposed: 2048
MC_MoveSuperImposedExt: 2048
MC_MoveVelocity: 2048
MC_NewPos: 2048
MC_NewPosAndVelo: 2048
MC_OrientedStop: 2048
MC_OverrideFilter: 2048
MC_ParametrizedStop: 2048
MC_Power: 0
MC_PowerStepper: 2048
MC_ReadActualPosition: 0
MC_ReadAxisComponents: 2048
MC_ReadAxisError: 0
MC_ReadBoolParameter: 0
MC_ReadParameter: 2048
MC_ReadParameterSet: 2048
MC_ReadStatus: 0
MC_Reset: 0
MC_SetActualPosition: 2048
MC_SetActualPositionOnTheFly: 2048
MC_SetEncoderScalingFactor: 2048
MC_SetOverride: 2048
MC_SetReferenceFlag: 2048
MC_Stop: 0
MC_TouchProbe: 2048
MC_TouchProbe.ActTouchProbeActivate: 2048
MC_TouchProbe.ActTouchProbeMonitorActivity: 2048
MC_TouchProbe.ActTouchProbeMonitorLatchValid: 2048
MC_TouchProbe.ActTouchProbeMonitorPlcEvent: 2048
MC_TouchProbe.ActTouchProbeStartupInit: 2048
MC_WriteBoolParameter: 0
MC_WriteParameter: 2048
NumOfGVLs: 1
Constants: 0
END_LIBRARY

LIBRARY
TcNC.lib 10.10.08 17:55:34
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 61
AXACT: 0
AXACTEX: 0
AXCPL: 0
AXCPLMULTITAB: 0
AXCPLTAB: 0
AXFNC: 0
AxisCamDataQueued: 2048
AxisCamScalingPending: 2048
AxisCamTableQueued: 2048
AxisControlLoopClosed: 2048
AxisDriveDeviceError: 2048
AxisExternalLatchValid: 0
AxisGetOverridePercent: 0
AxisGotNewTargetPosition: 0
AxisHasBeenStopped: 0
AxisHasExtSetPointGen: 0
AxisHasJob: 0
AxisInErrorState: 0
AxisInPositionWindow: 0
AxisInProtectedMode: 0
AxisInPTPMode: 2048
AxisIoDataIsInvalid: 2048
AxisIsAtTargetPosition: 0
AxisIsCalibrated: 0
AxisIsCalibrating: 0
AxisIsCompensating: 0
AxisIsCoupled: 0
AxisIsMoving: 0
AxisIsMovingBackwards: 0
AxisIsMovingEndless: 2048
AxisIsMovingForward: 0
AxisIsNotInTargetPosition: 0
AxisIsNotMoving: 0
AxisIsReady: 0
AxisJobPending: 2048
AxisReachedConstantVelocity: 0
AxisSetAcceptBlockedDriveSignal: 2048
AxisSetControllerEnable: 0
AxisSetFeedEnableMinus: 0
AxisSetFeedEnablePlus: 0
AxisSetOverridePercent: 0
AxisSetReferencingCamSignal: 0
AxisSoftLimitMaxExceeded: 2048
AxisSoftLimitMinExceeded: 2048
AXSCOM: 0
F_GetCompensationElementAt: 2048
F_GetLeftIndex: 2048
F_GetVersionTcNC: 0
F_IsCompensationDirection: 2048
F_LinearInterpolationCompensation: 2048
FB_AxisNewTargPosAndVelo: 0
FB_GetAxisAmsAddr: 2048
FB_PositionCompensation: 2048
FB_RegisterComKL25xx: 2048
FB_RegisterComKL25xx.ActCheckTerminalType: 2048
FB_RegisterComKL25xx.ActNcTerminalMappingIn: 2048
FB_RegisterComKL25xx.ActNcTerminalMappingOut: 2048
FB_RegisterComKL25xx.ActReadNcTerminalProcessImage: 2048
FB_RegisterComKL25xx.ActWriteNcTerminalProcessImage: 2048
FB_WritePositionCorrection: 2048
Get_TcNcUtilities_Version: 0
NumOfGVLs: 1
Global_Variables: 0
END_LIBRARY

LIBRARY
TcNcDrive.lib 19.1.10 10:33:24
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 19
F_GetVersionTcNcDrive: 2048
FB_SoEAX5000FirmwareUpdate: 2048
FB_SoEAX5000ReadActMainVoltage: 2048
FB_SoEAX5000SetMotorCtrlWord: 2048
FB_SoEExecuteCommand: 2048
FB_SoERead: 2048
FB_SoEReadAmplifierTemperature: 2048
FB_SoEReadClassXDiag: 2048
FB_SoEReadCommandState: 2048
FB_SoEReadDcBusCurrent: 2048
FB_SoEReadDcBusVoltage: 2048
FB_SoEReadDiagMessage: 2048
FB_SoEReadDiagNumber: 2048
FB_SoEReadDiagNumberList: 2048
FB_SoEReadMotorTemperature: 2048
FB_SoEReset: 2048
FB_SoEWrite: 2048
FB_SoEWriteCommandControl: 2048
FB_SoEWritePassword: 2048
NumOfGVLs: 1
Global_Variables: 2048
END_LIBRARY

LIBRARY
TcSystem.lib 7.6.16 11:01:22
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 84
ADSCLEAREVENTS: 0
ADSLOGDINT: 0
ADSLOGEVENT: 0
ADSLOGLREAL: 0
ADSLOGSTR: 0
ADSRDDEVINFO: 0
ADSRDSTATE: 0
ADSRDWRT: 0
ADSRDWRTEX: 0
ADSRDWRTIND: 0
ADSRDWRTRES: 0
ADSREAD: 0
ADSREADEX: 0
ADSREADIND: 0
ADSREADRES: 0
ADSWRITE: 0
ADSWRITEIND: 0
ADSWRITERES: 0
ADSWRTCTL: 0
AnalyzeExpression: 2048
AnalyzeExpressionCombined: 2048
AnalyzeExpressionTable: 2048
AppendErrorString: 2048
BAVERSION_TO_DWORD: 2048
CLEARBIT32: 0
CSETBIT32: 0
DRAND: 0
F_CompareFwVersion: 2048
F_CreateAmsNetId: 0
F_CreateIPv4Addr: 2048
F_GetStructMemberAlignment: 2048
F_GetVersionTcSystem: 0
F_IOPortRead: 2048
F_IOPortWrite: 2048
F_ScanAmsNetIds: 2048
F_ScanIPv4AddrIds: 2048
F_SplitPathName: 2048
F_ToASC: 2048
F_ToCHR: 2048
FB_AdsReadWriteList: 2048
FB_BaDeviceIoControl: 2048
FB_BaGenGetVersion: 2048
FB_CreateDir: 2048
FB_EOF: 0
FB_FileClose: 0
FB_FileDelete: 0
FB_FileGets: 0
FB_FileOpen: 0
FB_FilePuts: 0
FB_FileRead: 0
FB_FileRename: 0
FB_FileSeek: 0
FB_FileTell: 0
FB_FileWrite: 0
FB_PcWatchdog: 2048
FB_PcWatchdog_BAPI: 2048
FB_RemoveDir: 2048
FB_SetLedColor_BAPI: 2048
FB_SimpleAdsLogEvent: 2048
FILECLOSE: 0
FILEOPEN: 0
FILEREAD: 0
FILESEEK: 0
FILEWRITE: 0
FW_CallGenericFb: 2048
FW_CallGenericFbEx: 2048
FW_CallGenericFun: 2048
GETBIT32: 0
GETCPUACCOUNT: 0
GETCPUCOUNTER: 0
GETCURTASKINDEX: 0
GETSYSTEMTIME: 0
GETTASKTIME: 2048
LPTSIGNAL: 0
MEMCMP: 0
MEMCPY: 0
MEMMOVE: 0
MEMSET: 0
ROL32: 0
ROR32: 0
SETBIT32: 0
SFCActionControl: 0
SHL32: 0
SHR32: 0
NumOfGVLs: 1
Global_Variables: 0
END_LIBRARY

LIBRARY
TcTestAndSet.lib 23.2.09 12:50:08
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 1
TestAndSet: 2048
NumOfGVLs: 1
Global_Variables: 2048
END_LIBRARY

LIBRARY
TcUtilities.lib 3.2.16 16:08:58
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 330
ARG_TO_CSVFIELD: 2048
BCD_TO_DEC: 0
BE128_TO_HOST: 2048
BE16_TO_HOST: 2048
BE32_TO_HOST: 2048
BE64_TO_HOST: 2048
BYTE_TO_BINSTR: 2048
BYTE_TO_DECSTR: 2048
BYTE_TO_HEXSTR: 2048
BYTE_TO_LREALEX: 2048
BYTE_TO_OCTSTR: 2048
BYTEARR_TO_MAXSTRING: 2048
CSVFIELD_TO_ARG: 2048
CSVFIELD_TO_STRING: 2048
DATA_TO_HEXSTR: 2048
DCF77_TIME: 2048
DCF77_TIME_EX: 2048
DEC_TO_BCD: 0
DEG_TO_RAD: 0
DINT_TO_DECSTR: 2048
DT_TO_FILETIME: 2048
DT_TO_SYSTEMTIME: 0
DWORD_TO_BINSTR: 2048
DWORD_TO_DECSTR: 2048
DWORD_TO_HEXSTR: 2048
DWORD_TO_LREALEX: 2048
DWORD_TO_OCTSTR: 2048
F_ARGCMP: 2048
F_ARGCPY: 2048
F_ARGIsZero: 2048
F_BIGTYPE: 2048
F_BOOL: 2048
F_BYTE: 0
F_BYTE_TO_CRC16_CCITT: 2048
F_CheckSum16: 0
F_CRC16_CCITT: 0
F_CreateHashTableHnd: 2048
F_CreateLinkedListHnd: 2048
F_DATA_TO_CRC16_CCITT: 2048
F_DINT: 0
F_DWORD: 0
F_FormatArgToStr: 2048
F_GetDayOfMonthEx: 2048
F_GetDayOfWeek: 2048
F_GetDOYOfYearMonthDay: 2048
F_GetFloatRec: 2048
F_GetMaxMonthDays: 2048
F_GetMonthOfDOY: 2048
F_GetVersionTcUtilities: 0
F_GetWeekOfTheYear: 2048
F_HUGE: 2048
F_INT: 0
F_LARGE: 2048
F_LREAL: 0
F_LTrim: 2048
F_PVOID: 2048
F_REAL: 0
F_RTrim: 2048
F_SINT: 0
F_STRING: 0
F_SwapReal: 0
F_SwapRealEx: 2048
F_ToLCase: 2048
F_ToUCase: 2048
F_TranslateFileTimeBias: 2048
F_UDINT: 0
F_UHUGE: 2048
F_UINT: 0
F_ULARGE: 2048
F_USINT: 0
F_WORD: 0
F_YearIsLeapYear: 2048
FB_AddRouteEntry: 2048
FB_AmsLogger: 2048
FB_BasicPID: 0
FB_BufferedTextFileWriter: 2048
FB_BufferedTextFileWriter.A_Reset: 2048
FB_ConnectScopeServer: 2048
FB_CSVMemBufferReader: 2048
FB_CSVMemBufferWriter: 2048
FB_DbgOutputCtrl: 2048
FB_DbgOutputCtrl.A_Log: 2048
FB_DbgOutputCtrl.A_LogHex: 2048
FB_DbgOutputCtrl.A_Reset: 2048
FB_DisconnectScopeServer: 2048
FB_EnumFindFileEntry: 2048
FB_EnumFindFileList: 2048
FB_EnumRouteEntry: 2048
FB_EnumStringNumbers: 2048
FB_FileRingBuffer: 2048
FB_FileRingBuffer.A_AddTail: 2048
FB_FileRingBuffer.A_Close: 2048
FB_FileRingBuffer.A_Create: 2048
FB_FileRingBuffer.A_GetHead: 2048
FB_FileRingBuffer.A_Open: 2048
FB_FileRingBuffer.A_RemoveHead: 2048
FB_FileRingBuffer.A_Reset: 2048
FB_FileTimeToTzSpecificLocalTime: 2048
FB_FileTimeToTzSpecificLocalTime.A_Reset: 2048
FB_FormatString: 0
FB_GetAdaptersInfo: 2048
FB_GetDeviceIdentification: 2048
FB_GetDeviceIdentificationEx: 2048
FB_GetHostAddrByName: 2048
FB_GetHostName: 2048
FB_GetLocalAmsNetId: 2048
FB_GetRouterStatusInfo: 2048
FB_GetTimeZoneInformation: 2048
FB_HashTableCtrl: 2048
FB_HashTableCtrl.A_Add: 2048
FB_HashTableCtrl.A_GetFirst: 2048
FB_HashTableCtrl.A_GetIndexAtPosPtr: 2048
FB_HashTableCtrl.A_GetNext: 2048
FB_HashTableCtrl.A_Lookup: 2048
FB_HashTableCtrl.A_Remove: 2048
FB_HashTableCtrl.A_RemoveAll: 2048
FB_HashTableCtrl.A_RemoveFirst: 2048
FB_HashTableCtrl.A_Reset: 2048
FB_LinkedListCtrl: 2048
FB_LinkedListCtrl.A_AddHeadValue: 2048
FB_LinkedListCtrl.A_AddTailValue: 2048
FB_LinkedListCtrl.A_FindNext: 2048
FB_LinkedListCtrl.A_FindPrev: 2048
FB_LinkedListCtrl.A_GetHead: 2048
FB_LinkedListCtrl.A_GetIndexAtPosPtr: 2048
FB_LinkedListCtrl.A_GetNext: 2048
FB_LinkedListCtrl.A_GetPrev: 2048
FB_LinkedListCtrl.A_GetTail: 2048
FB_LinkedListCtrl.A_RemoveHeadValue: 2048
FB_LinkedListCtrl.A_RemoveTailValue: 2048
FB_LinkedListCtrl.A_RemoveValueAtPosPtr: 2048
FB_LinkedListCtrl.A_Reset: 2048
FB_LinkedListCtrl.A_SetValueAtPosPtr: 2048
FB_LocalSystemTime: 2048
FB_MemBufferMerge: 2048
FB_MemBufferSplit: 2048
FB_MemRingBuffer: 2048
FB_MemRingBuffer.A_AddTail: 2048
FB_MemRingBuffer.A_GetHead: 2048
FB_MemRingBuffer.A_RemoveHead: 2048
FB_MemRingBuffer.A_Reset: 2048
FB_MemRingBufferEx: 2048
FB_MemRingBufferEx.A_AddTail: 2048
FB_MemRingBufferEx.A_FreeHead: 2048
FB_MemRingBufferEx.A_GetFreeSize: 2048
FB_MemRingBufferEx.A_GetHead: 2048
FB_MemRingBufferEx.A_Reset: 2048
FB_MemStackBuffer: 2048
FB_MemStackBuffer.A_Pop: 2048
FB_MemStackBuffer.A_Push: 2048
FB_MemStackBuffer.A_Reset: 2048
FB_MemStackBuffer.A_Top: 2048
FB_RegQueryValue: 0
FB_RegSetValue: 0
FB_RemoveRouteEntry: 2048
FB_ResetScopeServerControl: 2048
FB_SaveScopeServerData: 2048
FB_ScopeServerControl: 2048
FB_SetTimeZoneInformation: 2048
FB_StartScopeServer: 2048
FB_StopScopeServer: 2048
FB_StringRingBuffer: 2048
FB_StringRingBuffer.A_AddTail: 2048
FB_StringRingBuffer.A_GetHead: 2048
FB_StringRingBuffer.A_RemoveHead: 2048
FB_StringRingBuffer.A_Reset: 2048
FB_SystemTimeToTzSpecificLocalTime: 2048
FB_SystemTimeToTzSpecificLocalTime.A_Reset: 2048
FB_TextFileRingBuffer: 2048
FB_TextFileRingBuffer.A_AddTail: 2048
FB_TextFileRingBuffer.A_Close: 2048
FB_TextFileRingBuffer.A_Open: 2048
FB_TextFileRingBuffer.A_Reset: 2048
FB_TranslateLocalTimeToUtcByZoneID: 2048
FB_TranslateLocalTimeToUtcByZoneID.A_Reset: 2048
FB_TranslateUtcToLocalTimeByZoneID: 2048
FB_TranslateUtcToLocalTimeByZoneID.A_Reset: 2048
FB_TzSpecificLocalTimeToFileTime: 2048
FB_TzSpecificLocalTimeToFileTime.A_Reset: 2048
FB_TzSpecificLocalTimeToSystemTime: 2048
FB_TzSpecificLocalTimeToSystemTime.A_Reset: 2048
FB_WritePersistentData: 2048
FILETIME_TO_DT: 2048
FILETIME_TO_SYSTEMTIME: 2048
FIX16_TO_LREAL: 2048
FIX16_TO_WORD: 2048
FIX16Add: 2048
FIX16Align: 2048
FIX16Div: 2048
FIX16Mul: 2048
FIX16Sub: 2048
GetRemotePCInfo: 0
GUID_TO_REGSTRING: 2048
GUID_TO_STRING: 2048
GuidsEqualByVal: 2048
HEXASCNIBBLE_TO_BYTE: 2048
HEXCHRNIBBLE_TO_BYTE: 2048
HEXSTR_TO_DATA: 2048
HOST_TO_BE128: 2048
HOST_TO_BE16: 2048
HOST_TO_BE32: 2048
HOST_TO_BE64: 2048
INT64_TO_LREAL: 2048
Int64Add64: 2048
Int64Add64Ex: 2048
Int64Cmp64: 2048
Int64Div64Ex: 2048
Int64IsZero: 2048
Int64Negate: 2048
Int64Not: 2048
Int64Sub64: 2048
IsFinite: 2048
LARGE_INTEGER: 2048
LARGE_TO_ULARGE: 2048
LREAL_TO_FIX16: 2048
LREAL_TO_FMTSTR: 2048
LREAL_TO_INT64: 2048
LREAL_TO_UINT64: 2048
MAXSTRING_TO_BYTEARR: 2048
NT_AbortShutdown: 0
NT_GetTime: 0
NT_Reboot: 0
NT_SetLocalTime: 2048
NT_SetTimeToRTCTime: 0
NT_Shutdown: 0
NT_StartProcess: 0
OTSTRUCT_TO_TIME: 0
PBOOL_TO_BOOL: 2048
PBYTE_TO_BYTE: 2048
PDATE_TO_DATE: 2048
PDINT_TO_DINT: 2048
PDT_TO_DT: 2048
PDWORD_TO_DWORD: 2048
PHUGE_TO_HUGE: 2048
PINT_TO_INT: 2048
PLARGE_TO_LARGE: 2048
PLC_ReadSymInfo: 0
PLC_ReadSymInfoByName: 0
PLC_ReadSymInfoByNameEx: 0
PLC_Reset: 0
PLC_Start: 0
PLC_Stop: 0
PLREAL_TO_LREAL: 2048
PMAXSTRING_TO_MAXSTRING: 2048
PREAL_TO_REAL: 2048
Profiler: 0
PSINT_TO_SINT: 2048
PSTRING_TO_STRING: 2048
PTIME_TO_TIME: 2048
PTOD_TO_TOD: 2048
PUDINT_TO_UDINT: 2048
PUHUGE_TO_UHUGE: 2048
PUINT64_TO_UINT64: 2048
PUINT_TO_UINT: 2048
PULARGE_TO_ULARGE: 2048
PUSINT_TO_USINT: 2048
PVOID_TO_BINSTR: 2048
PVOID_TO_DECSTR: 2048
PVOID_TO_HEXSTR: 2048
PVOID_TO_OCTSTR: 2048
PVOID_TO_STRING: 2048
PWORD_TO_WORD: 2048
RAD_TO_DEG: 0
REGSTRING_TO_GUID: 2048
ROUTETRANSPORT_TO_STRING: 2048
RTC: 2048
RTC_EX: 2048
RTC_EX2: 2048
ScopeASCIIExport: 0
ScopeExit: 2048
ScopeGetRecordLen: 0
ScopeGetState: 0
ScopeLoadFile: 0
ScopeManualTrigger: 0
ScopeSaveAs: 2048
ScopeSetOffline: 0
ScopeSetOnline: 0
ScopeSetRecordLen: 0
ScopeViewExport: 0
STRING_TO_CSVFIELD: 2048
STRING_TO_GUID: 2048
STRING_TO_PVOID: 2048
STRING_TO_SYSTEMTIME: 2048
STRING_TO_UINT64: 2048
SYSTEMTIME_TO_DT: 0
SYSTEMTIME_TO_FILETIME: 2048
SYSTEMTIME_TO_STRING: 2048
TC_Config: 2048
TC_CpuUsage: 0
TC_Restart: 0
TC_Stop: 0
TC_SysLatency: 0
TIME_TO_OTSTRUCT: 0
UDINT_TO_LREALEX: 2048
UInt32x32To64: 2048
UINT64_TO_LREAL: 2048
UINT64_TO_STRING: 2048
UInt64Add64: 2048
UInt64Add64Ex: 2048
UInt64And: 2048
UInt64Cmp64: 2048
UInt64Div16Ex: 2048
UInt64Div64: 2048
UInt64Div64Ex: 2048
UInt64isZero: 2048
UInt64Limit: 2048
UInt64Max: 2048
UInt64Min: 2048
UInt64Mod64: 2048
UInt64Mul64: 2048
UInt64Mul64Ex: 2048
UInt64Not: 2048
UInt64Or: 2048
UInt64Rol: 2048
UInt64Ror: 2048
UInt64Shl: 2048
UInt64Shr: 2048
UInt64Sub64: 2048
UInt64Xor: 2048
UINT_TO_LREALEX: 2048
ULARGE_INTEGER: 2048
ULARGE_TO_LARGE: 2048
USINT_TO_LREALEX: 2048
WORD_TO_BINSTR: 2048
WORD_TO_DECSTR: 2048
WORD_TO_FIX16: 2048
WORD_TO_HEXSTR: 2048
WORD_TO_LREALEX: 2048
WORD_TO_OCTSTR: 2048
WritePersistentData: 0
NumOfGVLs: 1
Global_Variables: 0
END_LIBRARY

PLC_CONFIGURATION
_ELEMENT 15700
_ELEMENT_END
PLC_END


RESOURCE

TASK Standard (PRIORITY := 0, INTERVAL := T#1ms);
PRG_STARTUP();
PRG_ERROR_WARNING_CTRLE();
PRG_VISU();
PRG_PROCESS();
PRG_STATION_WORK_ST1();
PRG_COLLISION_DETECTION();
PRG_VELOCITY_DETECTION();
PRG_HW_WORK_ST1();
PRG_HW_GENERAL();
{Additional_info : 1,0,0,0,1,4294967295}
END_TASK

TASK Ctrl_Panel (PRIORITY := 1, INTERVAL := T#100ms);
PRG_USB_IO_PANEL();
{Additional_info : 1,0,0,0,1,4294967295}
END_TASK

END_RESOURCE
